[src/gh:tukuaiai]: https://github.com/tukuaiai/vibe-coding-cn.git "(~ forked from: gh:EnzeD/vibe-coding.git) (MIT) (Languages: Python 57.4%, Shell 41.4%, Makefile 1.2%) 我的开发经验+提示词库=vibecoding工作站；My development experience + prompt dictionary = Vibecoding workstation；ניסיון הפיתוח שלי + מילון פרומפטים = תחנת עבודה Vibecoding；私の開発経験 + プロンプト辞書 = Vibecoding ワークステーション；나의 개발 경험 + 프롬프트 사전 = Vibecoding 워크스테이션；Mon expérience de développement + dictionnaire de prompts = station de travail Vibecoding；Meine Entwicklungserfahru /// Vibe Coding 指南 // 一个通过与 AI 结对编程，将想法变为现实的终极工作站 /// 🎲 前言 // 这是一个不断生长和自我否定的项目，当下的一切经验和能力都可能因 AI 能力的进化而失去意义，所以请时刻保持以 AI 为主的思维，不要固步自封，所有的经验都可能失效，辩证的看🙏🙏🙏 /// 核心理念: 规划就是一切。 谨慎让 AI 自主规划，否则你的代码库会变成一团无法管理的乱麻。 /// 🔑 元方法论 (Meta-Methodology) /// 该思想的核心是构建一个能够自我优化的 AI 系统。其递归本质可分解为以下步骤： /// 1. 定义核心角色： /// 1. - α-提示词 (生成器): 一个“母体”提示词，其唯一职责是生成其他提示词或技能。 /// 1. - Ω-提示词 (优化器): 另一个“母体”提示词，其唯一职责是优化其他提示词或技能。 /// 2. 描述递归的生命周期： /// 2. 1. 创生 (Bootstrap): 使用 AI 生成 α-提示词 和 Ω-提示词 的初始版本 (v1)。 /// 2. 2. 自省与进化 (Self-Correction & Evolution): 使用 Ω-提示词 (v1) 优化 α-提示词 (v1)，从而得到一个更强大的 α-提示词 (v2)。 /// 2. 3. 创造 (Generation): 使用进化后的 α-提示词 (v2) 生成所有需要的目标提示词和技能。 /// 2. 4. 循环与飞跃 (Recursive Loop): 将新生成的、更强大的产物（甚至包括新版本的 Ω-提示词）反馈给系统，再次用于优化 α-提示词，从而启动持续进化。 /// 3. 终极目标：通过此持续的递归优化循环，系统在每次迭代中实现自我超越，无限逼近预设的预期状态。 /// 🧭 方法论精要 (道·法·术) /// 1. 🧭 道 /// 1. - 凡是 AI 能做的，就不要人工做 /// 1. - 一切问题问 AI /// 1. - 目的主导：开发过程中的一切动作围绕\"目的\"展开 /// 1. - 上下文是 vibe coding 的第一性要素，垃圾进，垃圾出 /// 1. - 系统性思考，实体，链接，功能/目的，三个维度 /// 1. - 数据与函数即是编程的一切 /// 1. - 输入，处理，输出刻画整个过程 /// 1. - 多问 AI 是什么？，为什么？，怎么做？（黄金圈法则） /// 1. - 先结构，后代码，一定要规划好框架，不然后面技术债还不完 /// 1. - 奥卡姆剃刀定理，如无必要，勿增代码 /// 1. - 帕累托法则，关注重要的那20% /// 1. - 逆向思考，先明确你的需求，从需求逆向构建代码 /// 1. - 重复，多试几次，实在不行重新开个窗口， /// 1. - 专注，极致的专注可以击穿代码，一次只做一件事（神人除外） /// 2. 🧩 法 /// 2. - 一句话目标 + 非目标 /// 2. - 正交性（这个分场景） /// 2. - 能抄不写，不重复造轮子，先问 AI 有没有合适的仓库，下载下来改（glue coding全新范式） /// 2. - 一定要看官方文档，先把官方文档爬下来喂给 AI（让 AI 找工具下载到本地） /// 2. - 按职责拆模块 /// 2. - 接口先行，实现后补 /// 2. - 一次只改一个模块 /// 2. - 文档即上下文，不是事后补 /// 3. 🛠️ 术 /// 3. - 明确写清：能改什么，不能改什么 /// 3. - Debug 只给：预期 vs 实际 + 最小复现 /// 3. - 测试可交给 AI，断言人审 /// 3. - 代码一多就切会话 /// 3. - AI 犯的错误使用提示词整理为经验持久化存储，遇到问题始终无法解决，就让AI检索这个收集的问题然后寻找解决方案 /// # 🧬 胶水编程 (Glue Coding) /// ## 💡 核心理念 /// 范式转移：从「生成」到「连接」的根本性转变 /// - ❌ 不再让 AI 从零生成代码（幻觉的根源） /// - ❌ 不再重复造轮子（复杂性的根源） /// - ❌ 不再要求你理解每一行代码（门槛的根源） /// - ✅ 只复用成熟的、经过生产验证的开源项目 /// - ✅ AI 的唯一职责：理解你的意图，将模块连接起来 /// - ✅ 你的唯一职责：描述清楚「输入是什么，输出要什么」 /// ## 🏗️ 架构哲学 /// - 实体 (Entity)：成熟的开源项目、官方 SDK、久经考验的库 /// - 连接 (Link)：AI 生成的胶水代码，负责数据流转和接口适配 /// - 功能 (Function)：你描述的业务目标 /// ## 🎯 为什么这是银弹？ /// ### 1. 幻觉问题 → 彻底消失 /// AI 不再需要\"发明\"任何东西。它只需要： /// - 阅读模块 A 的文档 /// - 阅读模块 B 的文档 /// - 写出 A → B 的数据转换 /// 这是 AI 最擅长的事情，也是最不容易出错的事情。 /// ### 2. 复杂性问题 → 转嫁给社区 /// 每个模块背后都有： /// - 数千个 Issue 的讨论 /// - 数百个贡献者的智慧 /// - 数年的生产环境打磨 /// 你不是在管理复杂性，你是在站在巨人的肩膀上。 /// ### 3. 门槛问题 → 降到最低 /// 你不需要懂： /// - 底层实现原理 /// - 最佳实践细节 /// - 边界情况处理 /// 你只需要会说人话：“我要把 Telegram 的消息，经过 GPT 处理，存到 PostgreSQL” /// AI 会帮你找到最合适的轮子，然后把它们粘起来。 /// ## 📋 流程模式 /// 1. 明确目标 /// 1. - └─→ “我要实现 XXX 功能” /// 2. 寻找轮子 /// 2. - └─→ “有没有成熟的库/项目已经做过类似的事？” /// 2. - └─→ 让 AI 帮你搜索、评估、推荐 /// 3. 理解接口 /// 3. - └─→ 把官方文档喂给 AI /// 3. - └─→ AI 总结：输入是什么，输出是什么 /// 4. 描述连接 /// 4. - └─→ “A 的输出要变成 B 的输入” /// 4. - └─→ AI 生成胶水代码 /// 5. 验证运行 /// 5. - └─→ 跑通 → 完成 /// 5. - └─→ 报错 → 把错误扔给 AI，继续粘 /// ## 🎖️ 总结 /// 能抄不写，能连不造，能复用不原创。 /// 胶水编程是 Vibe Coding 的终极进化形态。 /// 它不是偷懒，而是工程智慧的最高体现—— /// 用最少的原创代码，撬动最大的生产力。 /// 这就是软件工程等待了 50 年的银弹。 /// “The best code is no code at all. The second best is glue code.”"
[src/gh:EnzeD]: https://github.com/EnzeD/vibe-coding.git "Ultimate Guide to Vibe Coding V1.2 // Vibe 编码终极指南 V1.2"
[tukuaiai.twitter]: https://twitter.com/123olp "123olp (@123olp) /// 交易猫 测算猫 预测猫 CEO gluecoding 🤖🤖🤖"

