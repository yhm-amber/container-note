[src/gh]: https://github.com/rstudio/pool.git "(MIT) (R 100.0%) Object Pooling in R // R 中的对象池 /// The goal of the pool package is to abstract away the challenges of database connection management, which is particularly relevant in interactive contexts like Shiny apps that connect to a database. // pool 包的目标是抽象化数据库连接管理的挑战，这在像 Shiny 应用这样连接到数据库的交互式环境中尤其相关。 /// Instead of creating and closing connections yourself, you create a “pool” of connections, and the pool package manages them for you. You never have to create or close connections directly: The pool knows when it should grow, shrink or keep steady. You only need to close the pool when you’re done. The pool works seamlessly with DBI and dplyr, so in most cases using the pool package is as simple replacing DBI::dbConnect() with dbPool() and adding a call to poolClose(). // 你不需要自己创建和关闭连接，而是创建一个“连接池”，pool 包会为你管理它们。你永远不需要直接创建或关闭连接：池知道何时应该增长、缩小或保持稳定。你只需要在完成时关闭池。pool 与 DBI 和 dplyr 无缝协作，因此大多数情况下使用 pool 包就像将 DBI::dbConnect() 替换为 dbPool() 并添加一个 poolClose() 的调用一样简单。 /// (The pool package is actually general enough to allow you to construct a pool of any kind of object, not just database connections, but database connections are currently its primary claim to fame.) // （pool 包实际上足够通用，允许你构建任何类型的对象池，而不仅仅是数据库连接，尽管目前数据库连接是其最显著的特色。）"
[site/ghio]: https://rstudio.github.io/pool/ "(: pool <- pool::dbPool(RSQLite::SQLite(), dbname = pool::demoDb()) ;: shiny::onStop(function () { pool::poolClose(pool) }))"
[vig:why-pool/.site]: https://rstudio.github.io/pool/articles/why-pool.html "When you’re using database from R, managing your connections is really important because you want to avoid leaking connections, leaving them open and occupying resources even when you’re not using them. Connection management is usually straightforward in scripts because you open them, use them, and close them. Connection management gets more complex in shiny apps, because apps might run for a long time (possibly days or weeks between updates) and they can used by multiple people at the same time. // 当你使用 R 数据库时，管理你的连接非常重要，因为你想要避免连接泄漏，即使在你不用它们时也保持它们打开并占用资源。在脚本中，连接管理通常很简单，因为你打开它们，使用它们，然后关闭它们。在 Shiny 应用中，连接管理变得更加复杂，因为应用可能会长时间运行（可能在更新之间持续数天或数周），并且它们可能同时被多个人使用。 /// This vignette describes two extremes for managing connections (once per app vs once per query) then shows you why pool provides a happy middle ground that is safer, more robust, and offers better overall performance. // 这个简档描述了管理连接的两个极端（每个应用一次与每个查询一次），然后展示了为什么池提供了一个更安全、更稳健且整体性能更好的中间地带。 /// ### One connection per app // 每个应用一个连接 ///: The first extreme is have one connection per app: // 第一个极端是每个应用一个连接： ///; This approach is fast, because you only ever create one connection, but has some serious drawbacks: // 这种方法很快，因为你只创建一个连接，但有一些严重的缺点： ///; - Since there is only one connection, it does not work well with multi-user apps. // 由于只有一个连接，它不适合多用户应用。 ///; - If the connection breaks at some point (maybe the database timed-out), you won’t get a new connection and you’ll have to restart the app). // 如果在某个时刻连接断开（可能是数据库超时），你将无法获得新的连接，并且不得不重新启动应用。 ///; - Even if you’re not making any queries at the moment (i.e. you leave the app running while you’re gone), you’ll have an idle connection sitting around for no reason. // 即使你当前没有进行任何查询（即你离开时让应用继续运行），也会有一个闲置的连接无意义地闲置着。 /// ### One connection per query // 每个查询一个连接 ///: Let’s now turn our attention to the other extreme: opening and closing a connection for each query: // 现在让我们将注意力转向另一个极端：为每个查询打开和关闭连接： ///; The advantages to this approach are the reverse of the disadvantages of the first approach: // 这种方法的优点与第一种方法的缺点正好相反： ///; - It can handle simultaneous requests, because these are always processed by different connections. // 它能够处理并发请求，因为这些请求总是由不同的连接来处理。 ///; - If a connection breaks, it’s no big deal because it’ll just create a new one on the next reactive computation. // 如果连接断开，这没什么大不了的，因为它会在下一次反应式计算中创建一个新的连接。 ///; - Each connection is only open for the duration of the query it makes, so there are no idle connections sitting around. // 每个连接仅在它执行的查询期间保持打开状态，因此不会有闲置的连接闲置着。 ///; - It’s moderately easy to keep track of connections (as long as you pair each connect with a dbDisconnect()). // 只要每个连接都配对一个 dbDisconnect() ，跟踪连接是相对容易的。 ///; On the other hand, it does less well on the things that the former approach excelled at: // 另一方面，它在那些前一种方法擅长的事情上表现就不那么好了： ///; - It’s slow: each time we change an input, we have a create a connection to recalculate the reactive. // 它很慢：每次我们更改输入时，都需要创建一个连接来重新计算响应式。 ///; - You need a lot more boilerplate code to connect and disconnect the connection within each reactive. // 你需要在每个 reactive 内部连接和断开连接时编写大量样板代码。 /// Pool: the best of both worlds // 泳池：两全其美 ///: Wouldn’t it be nice if you could combine the advantages of the two approaches? That’s exactly the goal of pool! 如果你能结合两种方法的优点，那该多好啊？这正是泳池的目标！ ///; A connection pool abstracts away the logic of connection management, so that, for the vast majority of cases, you never have to deal with connections directly. Since the pool knows when it needs more connections and how to open and close them, it creates them on demand and can share existing connections that have already been created. // 连接池抽象了连接管理的逻辑，因此，在绝大多数情况下，你无需直接处理连接。由于池知道何时需要更多连接以及如何打开和关闭它们，它可以根据需求创建连接，并可以共享已经创建的现有连接。 ///; The code is just as simple as the connection per app approach: all you need to do is substitute pool::dbPool() for DBI::dbConnect() and pool::poolClose() for DBI::dbDisconnect(). // 代码与每个应用一个连接的方法一样简单：你只需要用 pool::dbPool() 替换掉 DBI::dbConnect() ，用 pool::poolClose() 替换掉 DBI::dbDisconnect() 。 ///; By default, the pool will maintain one idle connection. When you make a query to the pool, it will always use that connection, unless it happens to already be busy. In that case, the pool will create another connection, use it, and then return it to the pool. If that second connection isn’t used for more then a minute (by default), the pool will disconnect it. // 默认情况下，连接池会维护一个空闲连接。当您向连接池发起查询时，它将始终使用该连接，除非该连接恰好已经繁忙。在这种情况下，连接池将创建另一个连接，使用它，然后将其返回到连接池。如果该第二个连接在一分钟（默认设置）内未被使用，连接池将断开该连接。"
[package/cran]: https://cran.r-project.org/web/packages/pool/ "(Version: 	1.0.4) (Depends: 	methods, R (≥ 3.6.0)) (Imports: 	DBI (≥ 1.2.1), later (≥ 1.0.0), R6, rlang (≥ 1.0.0)) (Suggests: 	covr, dbplyr (≥ 2.4.0), dplyr, knitr, rmarkdown, RSQLite, shiny, testthat (≥ 3.0.0), tibble) (Published: 	2024-10-07) (DOI: 	10.32614/CRAN.package.pool) (Author: 	Joe Cheng [aut], Barbara Borges [aut], Hadley Wickham [aut, cre], Posit Software, PBC [cph, fnd]) (Maintainer: 	Hadley Wickham <hadley at posit.co>) (License: 	MIT + file LICENSE) (NeedsCompilation: 	no) pool: Object Pooling // 池：对象池 /// Enables the creation of object pools, which make it less computationally expensive to fetch a new object. Currently the only supported pooled objects are 'DBI' connections. // 启用对象池的创建，这可以减少获取新对象时的计算成本。目前唯一支持的对象池是 'DBI' 连接。"
