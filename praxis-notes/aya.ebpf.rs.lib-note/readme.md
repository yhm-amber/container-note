[lib.src/gh]: https://github.com/aya-rs/aya.git "(Apache-2.0, MIT) (Languages: Rust 99.7%, Other 0.3%) Aya is an eBPF library for the Rust programming language, built with a focus on developer experience and operability. // Aya æ˜¯ä¸€ç§ç”¨äº Rust ç¼–ç¨‹è¯­è¨€çš„ eBPF åº“ï¼Œä¸“æ³¨äºå¼€å‘è€…ä½“éªŒå’Œå¯æ“ä½œæ€§ã€‚"
[linker.src/gh]: https://github.com/aya-rs/bpf-linker.git "(Apache-2.0, MIT) (Languages: Rust 99.8%, C 0.2%) Simple BPF static linker // ç®€å•çš„ BPF é™æ€é“¾æ¥å™¨ /// bpf-linker aims to simplify building modern BPF programs while still supporting older, more restrictive kernels. // bpf-linker æ—¨åœ¨ç®€åŒ–ç°ä»£ BPF ç¨‹åºçš„æ„å»ºï¼ŒåŒæ—¶ä»ç„¶æ”¯æŒè¾ƒæ—§ã€æ›´ä¸¥æ ¼çš„å†…æ ¸ã€‚ /// bpf-linker can be used to statically link multiple BPF object files together and optionally perform optimizations needed to target older kernels. It operates on LLVM bitcode, so the inputs must be bitcode files (.bc) or object files with embedded bitcode (.o), optionally stored inside ar archives (.a). // bpf-linker å¯ç”¨äºå°†å¤šä¸ª BPF å¯¹è±¡æ–‡ä»¶é™æ€é“¾æ¥åœ¨ä¸€èµ·ï¼Œå¹¶å¯é€‰æ‹©æ‰§è¡Œé’ˆå¯¹æ—§å†…æ ¸æ‰€éœ€çš„ä¼˜åŒ–ã€‚å®ƒæ“ä½œ LLVM ä½ç ï¼Œå› æ­¤è¾“å…¥å¿…é¡»æ˜¯ä½ç æ–‡ä»¶ (.bc) æˆ–åŒ…å«åµŒå…¥å¼ä½ç çš„å¯¹è±¡æ–‡ä»¶ (.o)ï¼Œè¿™äº›æ–‡ä»¶å¯ä»¥é€‰æ‹©å­˜å‚¨åœ¨ ar å½’æ¡£æ–‡ä»¶ (.a) ä¸­ã€‚"
[lib/crates]: https://crates.io/crates/aya "(: cargo add -- aya) (MIT OR Apache-2.0) (192 KiB)"
[linker/crates]: https://crates.io/crates/bpf-linker "(: cargo install -- bpf-linker) (MIT OR Apache-2.0) (52.2 KiB)"
[awesome.src/gh]: https://github.com/aya-rs/awesome-aya.git "(CC-BY-SA-4.0) (Languages: Markdown 100%) A curated list of awesome eBPF ğŸ projects using aya-rs and Rust ğŸ¦€ // ä½¿ç”¨ aya-rs å’Œ Rust ğŸ¦€ çš„ç²¾é€‰ä¼˜ç§€ eBPF ğŸ é¡¹ç›®åˆ—è¡¨"
[site]: https://aya-rs.dev "eBPF is a technology that allows running user-supplied programs inside the Linux kernel. For more info see the "What is eBPF?" documentation. /// eBPF æ˜¯ä¸€é¡¹å…è®¸åœ¨ Linux å†…æ ¸ä¸­è¿è¡Œç”¨æˆ·æä¾›çš„ç¨‹åºçš„æŠ€æœ¯ã€‚æ›´å¤šä¿¡æ¯è¯·å‚é˜…ã€Šä»€ä¹ˆæ˜¯ eBPFï¼Ÿã€‹æ–‡æ¡£ã€‚ // Aya is an eBPF library built with a focus on operability and developer experience. It does not rely on libbpf nor bcc - it's built from the ground up purely in Rust, using only the libc crate to execute syscalls. With BTF support and when linked with musl, it offers a true compile once, run everywhere solution, where a single self-contained binary can be deployed on many linux distributions and kernel versions. // Aya æ˜¯ä¸€ä¸ªä»¥å¯æ“ä½œæ€§å’Œå¼€å‘è€…ä½“éªŒä¸ºé‡ç‚¹æ„å»ºçš„ eBPF åº“ã€‚å®ƒä¸ä¾èµ–äº libbpf æˆ– bcc - å®ƒå®Œå…¨ä½¿ç”¨ Rust ä»åº•å±‚æ„å»ºï¼Œä»…ä½¿ç”¨ libc crate æ¥æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ã€‚é€šè¿‡æ”¯æŒ BTF å¹¶åœ¨ä¸ musl é“¾æ¥æ—¶ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªçœŸæ­£çš„â€œä¸€æ¬¡ç¼–è¯‘ï¼Œå¤„å¤„è¿è¡Œâ€çš„è§£å†³æ–¹æ¡ˆï¼Œå•ä¸ªè‡ªåŒ…å«çš„äºŒè¿›åˆ¶æ–‡ä»¶å¯ä»¥éƒ¨ç½²åœ¨å¤šä¸ª Linux å‘è¡Œç‰ˆå’Œå†…æ ¸ç‰ˆæœ¬ä¸Šã€‚ /// Some of the major features provided include: // æä¾›çš„ä¸€äº›ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š /// - Support for the BPF Type Format (BTF), which is transparently enabled when supported by the target kernel. This allows eBPF programs compiled against one kernel version to run on different kernel versions without the need to recompile. // å¯¹ BPF ç±»å‹æ ¼å¼ï¼ˆBTFï¼‰çš„æ”¯æŒï¼Œå½“ç›®æ ‡å†…æ ¸æ”¯æŒæ—¶å°†é€æ˜å¯ç”¨ã€‚è¿™å…è®¸é’ˆå¯¹ä¸€ä¸ªå†…æ ¸ç‰ˆæœ¬ç¼–è¯‘çš„ eBPF ç¨‹åºåœ¨ä¸åŒå†…æ ¸ç‰ˆæœ¬ä¸Šè¿è¡Œï¼Œè€Œæ— éœ€é‡æ–°ç¼–è¯‘ã€‚ /// - Support for function call relocation and global data maps, which allows eBPF programs to make function calls and use global variables and initializers. // å¯¹å‡½æ•°è°ƒç”¨é‡å®šä½å’Œå…¨å±€æ•°æ®æ˜ å°„çš„æ”¯æŒï¼Œè¿™å…è®¸ eBPF ç¨‹åºè¿›è¡Œå‡½æ•°è°ƒç”¨å¹¶ä½¿ç”¨å…¨å±€å˜é‡å’Œåˆå§‹åŒ–å™¨ã€‚ /// - Async support with both tokio and async-std. // æ”¯æŒ tokio å’Œ async-std çš„å¼‚æ­¥åŠŸèƒ½ã€‚ /// - Easy to deploy and fast to build: aya doesn't require a kernel build or compiled headers, and not even a C toolchain; a release build completes in a matter of seconds. // æ˜“äºéƒ¨ç½²ä¸”æ„å»ºå¿«é€Ÿï¼šaya ä¸éœ€è¦å†…æ ¸æ„å»ºæˆ–ç¼–è¯‘åçš„å¤´æ–‡ä»¶ï¼Œç”šè‡³ä¸éœ€è¦ C å·¥å…·é“¾ï¼›å‘å¸ƒæ„å»ºåªéœ€å‡ ç§’é’Ÿå³å¯å®Œæˆã€‚"
[book/site]: https://aya-rs.dev/book/ "This getting started guide will help you use the Rust Programming Language and Aya library to build extended Berkley Packet Filter (eBPF) programs. // è¿™ä¸ªå…¥é—¨æŒ‡å—å°†å¸®åŠ©ä½ ä½¿ç”¨ Rust ç¼–ç¨‹è¯­è¨€å’Œ Aya åº“æ¥æ„å»ºæ‰©å±• Berkeley Packet Filter (eBPF) ç¨‹åºã€‚"
[about:ebpf/ebpf.io]: https://ebpf.io/what-is-ebpf "eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in a privileged context such as the operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules. // eBPF æ˜¯ä¸€ç§é©å‘½æ€§çš„æŠ€æœ¯ï¼Œæºè‡ª Linux å†…æ ¸ï¼Œå¯ä»¥åœ¨ç‰¹æƒä¸Šä¸‹æ–‡ä¸­ï¼ˆå¦‚æ“ä½œç³»ç»Ÿå†…æ ¸ï¼‰è¿è¡Œæ²™ç›’ç¨‹åºã€‚å®ƒç”¨äºåœ¨ä¸ä¿®æ”¹å†…æ ¸æºä»£ç æˆ–åŠ è½½å†…æ ¸æ¨¡å—çš„æƒ…å†µä¸‹ï¼Œå®‰å…¨é«˜æ•ˆåœ°æ‰©å±•å†…æ ¸åŠŸèƒ½ã€‚ /// Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernelâ€™s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system. // ä»å†å²ä¸Šçœ‹ï¼Œç”±äºå†…æ ¸å…·æœ‰ç›‘ç£å’Œæ§åˆ¶æ•´ä¸ªç³»ç»Ÿçš„ç‰¹æƒèƒ½åŠ›ï¼Œæ“ä½œç³»ç»Ÿä¸€ç›´æ˜¯å®ç°å¯è§‚æµ‹æ€§ã€å®‰å…¨æ€§å’Œç½‘ç»œåŠŸèƒ½çš„ç†æƒ³åœºæ‰€ã€‚åŒæ—¶ï¼Œç”±äºæ“ä½œç³»ç»Ÿå†…æ ¸å…·æœ‰æ ¸å¿ƒä½œç”¨ï¼Œå¯¹ç¨³å®šæ€§å’Œå®‰å…¨æ€§è¦æ±‚å¾ˆé«˜ï¼Œå› æ­¤å¾ˆéš¾æ¼”è¿›ã€‚å› æ­¤ï¼Œæ“ä½œç³»ç»Ÿå±‚é¢çš„åˆ›æ–°é€Ÿåº¦é€šå¸¸ä½äºæ“ä½œç³»ç»Ÿå¤–å®ç°çš„åŠŸèƒ½ã€‚ /// eBPF changes this formula fundamentally. It allows sandboxed programs to run within the operating system, which means that application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality. // eBPF ä»æ ¹æœ¬ä¸Šæ”¹å˜äº†è¿™ä¸€å…¬å¼ã€‚å®ƒå…è®¸æ²™ç›’åŒ–ç¨‹åºåœ¨æ“ä½œç³»ç»Ÿå†…éƒ¨è¿è¡Œï¼Œè¿™æ„å‘³ç€åº”ç”¨ç¨‹åºå¼€å‘è€…å¯ä»¥åœ¨è¿è¡Œæ—¶é€šè¿‡è¿è¡Œ eBPF ç¨‹åºä¸ºæ“ä½œç³»ç»Ÿæ·»åŠ é¢å¤–åŠŸèƒ½ã€‚æ“ä½œç³»ç»Ÿéšåä¿è¯å®‰å…¨æ€§å’Œæ‰§è¡Œæ•ˆç‡ï¼Œå°±åƒå€ŸåŠ©å³æ—¶ç¼–è¯‘å™¨ï¼ˆJITï¼‰å’ŒéªŒè¯å¼•æ“åŸç”Ÿç¼–è¯‘ä¸€æ ·ã€‚è¿™å‚¬ç”Ÿäº†ä¸€æ³¢åŸºäº eBPF çš„é¡¹ç›®ï¼Œæ¶µç›–äº†å¹¿æ³›çš„åº”ç”¨åœºæ™¯ï¼ŒåŒ…æ‹¬ä¸‹ä¸€ä»£ç½‘ç»œã€å¯è§‚å¯Ÿæ€§å’Œå®‰å…¨åŠŸèƒ½ã€‚ /// Today, eBPF is used extensively to drive a wide variety of use cases: Providing high-performance networking and load-balancing in modern data centers and cloud native environments, extracting fine-grained security observability data at low overhead, helping application developers trace applications, providing insights for performance troubleshooting, preventive application and container runtime security enforcement, and much more. The possibilities are endless, and the innovation that eBPF is unlocking has only just begun. // å¦‚ä»Šï¼ŒeBPF è¢«å¹¿æ³›ç”¨äºé©±åŠ¨å„ç§åº”ç”¨åœºæ™¯ï¼šåœ¨ç°ä»£æ•°æ®ä¸­å¿ƒå’Œäº‘åŸç”Ÿç¯å¢ƒä¸­æä¾›é«˜æ€§èƒ½ç½‘ç»œå’Œè´Ÿè½½å‡è¡¡ï¼Œä»¥ä½å¼€é”€æå–ç»†ç²’åº¦å®‰å…¨å¯è§‚å¯Ÿæ€§æ•°æ®ï¼Œå¸®åŠ©åº”ç”¨ç¨‹åºå¼€å‘è€…è¿½è¸ªåº”ç”¨ç¨‹åºï¼Œä¸ºæ€§èƒ½æ•…éšœæ’é™¤æä¾›æ´å¯Ÿï¼Œé¢„é˜²åº”ç”¨ç¨‹åºå’Œå®¹å™¨è¿è¡Œæ—¶å®‰å…¨æ‰§è¡Œï¼Œä»¥åŠæ›´å¤šã€‚å¯èƒ½æ€§æ˜¯æ— é™çš„ï¼ŒeBPF æ­£åœ¨è§£é”çš„åˆ›æ–°æ‰åˆšåˆšå¼€å§‹ã€‚"
[discord]: https://discord.gg/xHW2cb2N6G
