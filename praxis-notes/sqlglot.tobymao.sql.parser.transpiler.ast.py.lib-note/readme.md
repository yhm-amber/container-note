[src/gh]: https://github.com/tobymao/sqlglot.git "(MIT) (Languages: Python 99.0%, Other 1.0%) Python SQL Parser and Transpiler // Python SQL 解析器和转换器 /// SQLGlot is a no-dependency SQL parser, transpiler, optimizer, and engine. It can be used to format SQL or translate between 31 different dialects like DuckDB, Presto / Trino, Spark / Databricks, Snowflake, and BigQuery. It aims to read a wide variety of SQL inputs and output syntactically and semantically correct SQL in the targeted dialects. // SQLGlot 是一个无依赖关系的 SQL 解析器、转换器、优化器和引擎。它可以用于格式化 SQL 或在 31 种不同的方言之间进行转换，例如 DuckDB、Presto / Trino、Spark / Databricks、Snowflake 和 BigQuery。它的目标是读取各种 SQL 输入，并以目标方言输出语法和语义正确的 SQL。 /// It is a very comprehensive generic SQL parser with a robust test suite. It is also quite performant, while being written purely in Python. // 它是一个非常全面的通用 SQL 解析器，具有强大的测试套件。它也相当高效，完全是用 Python 编写的。 /// You can easily customize the parser, analyze queries, traverse expression trees, and programmatically build SQL. // 您可以轻松地自定义解析器、分析查询、遍历表达式树，并编程方式构建 SQL。 /// SQLGlot can detect a variety of syntax errors, such as unbalanced parentheses, incorrect usage of reserved keywords, and so on. These errors are highlighted and dialect incompatibilities can warn or raise depending on configurations. // SQLGlot 可以检测各种语法错误，例如不平衡的括号、保留关键字的不正确使用等。这些错误会被高亮显示，方言不兼容性可以根据配置发出警告或引发错误。 /// FAQ // 常见问题解答 /// - I tried to parse SQL that should be valid but it failed, why did that happen? // 我尝试解析应该有效的 SQL，但它失败了，为什么会这样？ ///: Most of the time, issues like this occur because the 'source' dialect is omitted during parsing. For example, this is how to correctly parse a SQL query written in Spark SQL: parse_one(sql, dialect='spark') (alternatively: read='spark'). If no dialect is specified, parse_one will attempt to parse the query according to the “SQLGlot dialect”, which is designed to be a superset of all supported dialects. If you tried specifying the dialect and it still doesn't work, please file an issue. // 大部分时候，这类问题发生是因为解析时省略了“源”方言。例如，这是如何正确解析用 Spark SQL 编写的 SQL 查询的方法： parse_one(sql, dialect='spark') （或者： read='spark' ）。如果没有指定方言， parse_one 将尝试根据“SQLGlot 方言”解析查询，该方言设计为所有支持方言的超集。如果你尝试指定方言但仍然无法正常工作，请提交一个 issue。 /// - I tried to output SQL but it's not in the correct dialect! // 我尝试输出 SQL，但它不在正确的方言中！ ///: Like parsing, generating SQL also requires the target dialect to be specified, otherwise the SQLGlot dialect will be used by default. For example, to transpile a query from Spark SQL to DuckDB, do parse_one(sql, dialect='spark').sql(dialect='duckdb') (alternatively: transpile(sql, read='spark', write='duckdb')). // 与解析类似，生成 SQL 也需要指定目标方言，否则将默认使用 SQLGlot 方言。例如，要将 Spark SQL 查询转换为 DuckDB，请执行 parse_one(sql, dialect='spark').sql(dialect='duckdb') （或者： transpile(sql, read='spark', write='duckdb') ）。"
[lib.pip/pypi]: https://pypi.org/project/sqlglot/ "(: pip install -- sqlglot[rs] ;: # or: pip install -- sqlglot # Without Rust tokenizer (slower)) (License Expression: MIT) (Requires: Python >=3.9) (Provides-Extra: [dev], [rs]) An easily customizable SQL parser and transpiler (src: gh:tobymao/sqlglot.git) /// Easily translate from one dialect to another. For example, date/time functions vary between dialects and can be hard to deal with: // 轻松地将一种方言转换为另一种方言。例如，日期/时间函数在不同的方言中有所不同，处理起来可能很困难： /// (: sqlglot.transpile('SELECT EPOCH_MS(1618088028295)', read='duckdb', write='hive')[0] #> 'SELECT FROM_UNIXTIME(1618088028295 / POW(10, 3))')"
[site/com]: https://sqlglot.com/sqlglot.html "... /// SQLGlot is able to interpret SQL queries, where the tables are represented as Python dictionaries. The engine is not supposed to be fast, but it can be useful for unit testing and running SQL natively across Python objects. Additionally, the foundation can be easily integrated with fast compute kernels, such as Arrow and Pandas. // SQLGlot 能够解释 SQL 查询，其中表以 Python 字典的形式表示。该引擎不要求速度快，但可用于单元测试和跨 Python 对象原生运行 SQL。此外，该基础架构可以轻松与 Arrow 和 Pandas 等快速计算内核集成。"
