[intro/ghio]: https://core-quic.github.io/intro.html "Core QUIC is a research effort aiming at defining a common layer across compliant QUIC implementations, enabling them to be extended by a same plugin. // Core QUIC 是一项研究工作，旨在定义一个跨兼容 QUIC 实现的通用层，使它们能够通过同一个插件进行扩展。 /// Get Rid of the Internet Protocol Innovation Inertia // 消除互联网协议创新惰性# /// To make an analogy, this effort shares some similarities with, e.g., Software Defined Networks, in the sense that it allows offering a common programmable plane across multiple devices/implementations. However, Software Defined Networks require from the devices to offer some API (e.g., OpenFlow), which can be addressed in a fully controlled network. On the Internet, there is a very large heterogeneity in the devices, implementation and actors. For instance, a network operator could deploy a QUIC server (hence, being under his/her control), offering services to contacting clients (being typically out of control). When it comes to deploying new features in a session-based protocol, support is usually required by both participating entities. For each new protocol extension, there is some consequent effort to integrate such support to an implementation (e.g., requiring time). This effort may be voided because of the lack of support by the contacting devices. Overall, this does not incentive actors to deploy such extensions without others doing so, leading to a chicken-and-egg issue. Core QUIC provides a “Compile-Once, Run-Everywhere” approach to protocol extensions. Any compliant implementation can then have such support in a one-shot effort, even if the exact implementation is not known by the plugin developer. // 打个比方，这项工作与软件定义网络（SDN）有一些相似之处，例如，它们都允许在多个设备/实现之间提供一个通用的可编程平面。然而，软件定义网络要求设备提供一些 API（例如 OpenFlow），这可以在完全受控的网络中实现。而在互联网上，设备、实现和参与者之间存在着极大的异质性。例如，网络运营商可以部署一个 QUIC 服务器（因此处于其控制之下），向与其通信的客户端（通常不受其控制）提供服务。当需要在基于会话的协议中部署新功能时，通常需要参与双方的支持。对于每个新的协议扩展，都需要投入一定的精力将其集成到实现中（例如，需要时间）。由于缺乏通信设备的支持，这些努力可能会付诸东流。总而言之，这不利于参与者在其他参与者不这样做的情况下部署此类扩展，从而导致先有鸡还是先有蛋的问题。 Core QUIC 为协议扩展提供了一种“一次编译，到处运行”的方法。任何兼容的实现都可以一次性获得此类支持，即使插件开发者不了解具体的实现方式。 /// A single plugin can extend all Core QUIC compliant implementations, without even updating the QUIC endpoint binary. // 一个插件即可扩展所有符合 Core QUIC 标准的实现，甚至无需更新 QUIC 端点二进制文件。"
[intro.src/gh]: https://github.com/core-quic/core-quic.github.io.git "(MIT) (Languages: Jupyter Notebook 99.2%, Other 0.8%) Core QUIC // 核心 QUIC /// Enabling Dynamic, Implementation Agnostic Protocol Extensions // 实现动态、与实现无关的协议扩展"
[quinn.src/gh:core-quic]: https://github.com/core-quic/quinn.git "(Apache-2.0, MIT) (Languages: Rust 100.0%) Quinn is a pure-rust, async-compatible implementation of the IETF QUIC transport protocol. // Quinn 是 IETF QUIC 传输协议的纯 Rust 实现，并且与异步兼容。 /// Features // 特征 /// - Simultaneous client/server operation // 同时进行客户端/服务器操作 /// - Ordered and unordered stream reads for improved performance // 有序和无序流读取以提高性能 /// - Works on stable Rust, tested on Linux, macOS and Windows // 基于稳定的 Rust 版本，已在 Linux、macOS 和 Windows 上测试。 /// - Pluggable cryptography, with a standard implementation backed by rustls and ring // 可插拔密码学，其标准实现由……提供支持 沙沙声和铃声 /// - Application-layer datagrams for small, unreliable messages // 用于小型、不可靠消息的应用层数据报 /// - Future-based async API // 基于 Future 的异步 API /// - Minimum supported Rust version of 1.63.0 // 最低支持的 Rust 版本为 1.63.0 /// Overview // 概述 /// - quinn: High-level async API based on tokio, see for usage. This will be used by most developers. (Basic benchmarks are included.) // quinn： 基于 tokio 的高级异步 API，用法请参见文档。大多数开发者都会使用它。（包含基本基准测试。） /// - quinn-proto: Deterministic state machine of the protocol which performs no I/O (. web: sans-io.readthedocs.io/how-to-sans-io.html) internally and is suitable for use with custom event loops (and potentially a C or C++ API). // quinn-proto： 协议的确定性状态机，内部不执行 I/O ，适合与自定义事件循环（以及可能的 C 或 C++ API）一起使用。 /// - quinn-udp: UDP sockets with ECN information tuned for the protocol. // quinn-udp： 针对该协议优化的带有 ECN 信息的 UDP 套接字。 /// - bench: Benchmarks without any framework. // 基准测试： 不带任何框架的基准测试。 /// - fuzz: Fuzz tests. // 模糊测试： 模糊测试。"
[quinn-lib.cargo/crates]: https://crates.io/crates/quinn "(: cargo add -- quinn) (MIT OR Apache-2.0) (3.8K SLoC) (81.6 KiB) Versatile QUIC transport protocol implementation // 多功能 QUIC 传输协议实现 (src: gh:quinn-rs/quinn.git) (old-src: gh:core-quic/quinn.git)"
[quinn.guidebook/ghio]: https://quinn-rs.github.io/quinn/ "1. Networking introduction // 网络入门 ///: In this chapter, you will find a very short introduction to various networking concepts. These concepts are important to understanding when to use QUIC. // 本章将简要介绍各种网络概念。这些概念对于理解何时使用 QUIC 至关重要。 /// 2. QUIC introduction // QUIC 简介 ///: QUIC is a general-purpose network protocol built on top of UDP, and standardized by the IETF. Although QUIC is still relatively new, the protocol is used for all connections from Chrome web browsers to the Google servers. // QUIC 是一种基于 UDP 的通用网络协议，由 IETF 制定标准 。尽管 QUIC 还相对较新，但 Chrome 浏览器与 Google 服务器之间的所有连接都使用该协议。 /// 3. QUINN Introduction // 奎因简介 /// 3. 1. Certificate Configuration // 证书配置 /// 3. 2. Connection Setup // 连接设置 /// 3. 3. Data Transfer // 数据传输 /// QUIC solves a number of transport-layer and application-layer problems experienced by modern web applications. It is very similar to TCP+TLS+HTTP2, but implemented on top of UDP. Having QUIC as a self-contained protocol allows innovations which aren’t possible with existing protocols as they are hampered by legacy clients and middleboxes. /// QUIC 解决了现代 Web 应用在传输层和应用层遇到的诸多问题。它与 TCP+TLS+HTTP2 非常相似，但基于 UDP 实现。QUIC 作为一个独立的协议，能够实现现有协议因受限于传统客户端和中间件而无法实现的创新。 /// Key advantages of QUIC over TCP+TLS+HTTP2 include: // QUIC 相对于 TCP+TLS+HTTP2 的主要优势包括： /// - Improved connection establishment speed (0-rtt). // 提高了连接建立速度（0-rtt）。 /// - Improved congestion control by moving congestion control algorithms into the user space at both endpoints. // 通过将拥塞控制算法移至两端的用户空间，改进了拥塞控制。 /// - Improved bandwidth estimation in each direction to avoid congestion. // 改进了各个方向的带宽估算，以避免拥塞。 /// - Improved multiplexing without head-of-line blocking. // 改进的多路复用技术，避免队头阻塞。 /// - Contains forward error correction (FEC). // 包含前向纠错（FEC）。 /// While QUIC's intentions are originally web-oriented, it offers interesting opportunities in other areas like game networking. One thing is for sure, QUIC has many great potentials and will serve us in the future with HTTP/3. // QUIC 最初的设计目标是面向 Web，但它在游戏联网等其他领域也展现出令人瞩目的潜力。可以肯定的是，QUIC 拥有巨大的发展前景，未来将借助 HTTP/3 继续为我们提供更多服务。"
[pluginop.src/gh:core-quic]: https://github.com/core-quic/pluginop.git "(Apache-2.0, MIT) (Languages: Rust 99.9%, Shell 0.1%) PluginOp: Pluginizable Operations // PluginOp：可插件化的操作 /// One day, we will make the Internet great again. In the meantime, we struggle with engineering problems. // 总有一天，我们会让互联网重现辉煌。在此之前，我们正努力解决各种技术难题。 /// PluginOp is a crate intending to make (Rust) network implementation seamlessly pluginizable. The project consists in several sub-crates: // PluginOp 是一个旨在使（Rust）网络实现无缝插件化的 crate。该项目由多个子 crate 组成： /// - pluginop-common (. . @main/common): contains all the common structures (part of the standardized API) shared by both the plugins and the host implementation // pluginop-common ：包含插件和宿主实现共享的所有公共结构（标准化 API 的一部分）。 /// - pluginop (. . @main/lib): the main crate of this project, used by the host implementation to be pluginizable // pluginop ：本项目的主要 crate，供宿主实现插件化使用。 /// - pluginop-macro (. . @main/macro): contains macros to be used by the host implementation to pluginize its functions using one-liners // pluginop-macro ：包含宿主实现用来通过单行代码将其函数插件化的宏。 /// - pluginop-mock (. . @main/mock): a mocking host implementation used to test and benchmark the whole project // pluginop-mock ：一个用于测试和评估整个项目的模拟宿主实现 /// - pluginop-octets (. . @main/octets): a fork of the quiche's octets crate with support to raw pointer conversion // pluginop-octets ： quiche 的 octets crate 的一个分支，支持原始指针转换 /// - pluginop-rawptr (. . @main/rawptr): an abstraction over raw pointers // pluginop-rawptr ：对原始指针的抽象 /// - pluginop-wasm (. . @main/wasm): the crate offering an API to plugins // pluginop-wasm ：为插件提供 API 的 crate /// The tests folder (. . @main/tests) contains plugins for tests and benchmarks purposes. // tests 文件夹包含用于测试和基准测试的插件。 /// Supported Core Implementations // 支持的核心实现 /// - core-quic (. gh: core-quic/quiche.git): Based on quiche, main core implementation // core-quic ：基于 quiche 的主要核心实现 /// - core-quinn (. gh: core-quic/quinn.git): Based on quinn, mostly integrated in the quinn-proto crate. Does not have full support (yet), but simple frame-based plugins work. // core-quinn ：基于 quinn，大部分集成在 quinn-proto crate 中。目前尚未提供完整支持，但简单的基于框架的插件可以正常工作。"
[pluginop-lib.cargo/crates]: https://crates.io/crates/pluginop "(: cargo add -- pluginop) (MIT OR Apache-2.0) (1.6K SLoC) (15.1 KiB) A companion library to make a QUIC implementation pluginizable // 一个配套库，用于使 QUIC 实现可插件化。 (src: gh:core-quic/pluginop.git)"
[plugins.src/gh:core-quic]: https://github.com/core-quic/core-quic-plugins.git "(Languages: Rust 99.0%, Shell 1.0%) Core QUIC Plugins // 核心 QUIC 插件 /// Simple repository containing some plugins running with Core QUIC. This is a work in progress! // 这是一个包含一些与 Core QUIC 配合使用的插件的简单仓库。目前仍在开发中！ /// Implemented plugins // 已实现插件 /// All the plugins are listed in alphabetical order. // 所有插件均按字母顺序排列。 /// Functional // 功能 /// - max-data: simply rewrite processing of max-data // max-data ：简单地重写 max-data 的处理。 /// - super-frame: a dummy frame sent once per RTT // super-frame ：每个往返时间只发送一次的虚拟帧 /// - privacy-padding: force a specific sending pattern of packets having the same size // privacy-padding ：强制以特定模式发送大小相同的包。 /// - logger: Log data in a file. // logger ：将数据记录到文件中。 /// - probe-path: from the application, request sending path challenge and get delay for path response // probe-path ：来自应用程序的请求，发送路径挑战并获取路径响应的延迟 /// - bdp-frame: resume the congestion control state of a previous connection // bdp-frame ：恢复先前连接的拥塞控制状态"
[quiche.src/gh:core-quic]: https://github.com/core-quic/quiche.git "(BSD-2-Clause) (Languages: Rust 95.4%, C 4.2%, Other 0.4%) Important note // 重要提示 /// To build applications atop core-quiche, you probably want to use core-quic (. gh: core-quic/core-quic.git) instead. // 要基于 core-quiche 构建应用程序，您可能需要改用 core-quic 。"
[core-quic.src/gh]: https://github.com/core-quic/core-quic.git "(Languages: Rust 97.6%, Shell 2.4%)"

