[lib-java.src/gh]: https://github.com/json-iterator/java.git "(MIT) (Languages: Java 100.0%) jsoniter (json-iterator) is fast and flexible JSON parser available in Java and Go // jsoniter（json-iterator）是一个快速灵活的 JSON 解析器，支持 Java 和 Go 语言。"
[lib-java.mvn/mvnrepository]: https://mvnrepository.com/artifact/com.jsoniter/jsoniter "(~ pkg:maven/com.jsoniter/jsoniter@...)"
[lib-tinygo.src/gh]: https://github.com/json-iterator/tinygo.git "(MIT) (Languages: Go 100.0%) make json.Unmarshal work in tinygo // 使 json.Unmarshal 在 tinygo 中正常工作 /// The code above does not work in tinygo, due to incomplete runtime reflection support. To fix this, we use code generation instead of runtime reflection to implement json.Unmarshal // 由于 TinyGo 对运行时反射的支持不完善，上面的代码无法正常运行。为了解决这个问题，我们使用代码生成而不是运行时反射来实现 json.Unmarshal"
[lib-tinygo.go/pgd]: https://pkg.go.dev/github.com/json-iterator/tinygo "(: go get -- github.com/json-iterator/tinygo) (License: MIT) (Imports: 8) (Imported by: 0)  (src: gh:json-iterator/tinygo.git)"
[lib-go.src/gh]: https://github.com/json-iterator/go.git "(! archived on: Dec 15, 2025) (MIT) (Languages: Go 99.9% Shell 0.1%) A high-performance 100% compatible drop-in replacement of pkg.go.dev:encoding/json /// Best performance // 最佳表现 /// The default performance is already several times faster than the standard library. If you want to have absolutely best performance, you can do following things // 默认性能已经比标准库快好几倍。如果想要获得绝对最佳性能，可以执行以下操作。 /// - use jsoniter.ConfigFastest, this will marshal the float with 6 digits precision (lossy), which is significantly faster // 使用 jsoniter.ConfigFastest，这将以 6 位有效数字的精度（有损）对浮点数进行序列化，速度会显著提高。 /// - reuse the underlying Stream or Iterator instance. jsoniter.ConfigFastest.BorrowIterator or jsoniter.ConfigFastest.BorrowStream. Just remember to return them when done. // 重用底层 Stream 或 Iterator 实例。 jsoniter.ConfigFastest.BorrowIterator 或 jsoniter.ConfigFastest.BorrowStream 。只需记住在完成后返回它们即可。 /// - use jsoniter.RegisterTypeEncoder or jsoniter.RegisterTypeDecoder instead of defining MarshalJSON or UnmarshalJSON. Marshaler or Unmarshaler interface will do more copying than necessary. // 请使用 jsoniter.RegisterTypeEncoder 或 jsoniter.RegisterTypeDecoder 代替定义 MarshalJSON 或 UnmarshalJSON 或 Unmarshaler 接口会执行不必​​要的复制 Marshaler 。"
[lib-go.go/pgd]: https://pkg.go.dev/github.com/json-iterator/go "(: go get -- github.com/json-iterator/go) (License: MIT) (Imports: 20) (Imported by: 17,216)  (src: gh:json-iterator/go.git)"
[site/com]: https://jsoniter.com/ "json iterator // JSON 迭代器 /// Fastest JSON parser ever // 史上最快的 JSON 解析器 /// jsoniter (json-iterator) is fast and flexible JSON parser available in Java and Go. Good deal of the code is ported from dsljson (. gh: ngs-doo/dsl-json.git), and jsonparser (. gh: buger/jsonparser.git). // jsoniter（json-iterator）是一个快速灵活的 JSON 解析器，支持 Java 和 Go 语言。它的大部分代码都移植自 dsljson 和 jsonparser 。 /// Faster, Much Faster! // 更快，快得多！ /// Traditional JSON parsers are slow. Jsoniter Java version could be 3x times faster than jackson/gson/fastjson. If you are doing a lot of log processing or number crunching, but stuck with JSON, you definitely need to consider dsl-json or Jsoniter to save the encoding/decoding cost. Is protobuf 5x faster than JSON?, part II // 传统的 JSON 解析器速度很慢。Jsoniter 的 Java 版本速度可能是 Jackson/Gson/FastJson 的三倍 。如果您需要处理大量日志或进行大量数值计算，但又不得不使用 JSON，那么您绝对应该考虑使用 dsl-json 或 Jsoniter 来节省编码/解码的成本。protobuf 比 JSON 快 5 倍吗？ （ 第二部分） /// Jsoniter Golang version could be more than 6x times faster than standard lib (encoding/json). And the number is acheived with runtime reflection instead of go generate. // Jsoniter 的 Golang 版本速度可能比标准库（encoding/json）快 6 倍以上。而且这一速度提升是通过运行时反射而不是 go generate 实现的。 /// (: JsonStream.serialize(new int[]{1,2,3}); // from object to JSON) (: JsonIterator.deserialize(\"[1,2,3]\", int[].class); // from JSON to object, with class specified)"

