[src/gh]: https://github.com/valeriansaliou/sonic.git "(MPL-2.0) (Languages: Rust 98.4%, Other 1.6%) 🦔 Fast, lightweight & schema-less search backend. An alternative to Elasticsearch that runs on a few MBs of RAM. // 🦔 快速、轻量级且无模的搜索后端。 Elasticsearch 的替代方案，在几 MB RAM 上运行。 /// Sonic is a fast, lightweight and schema-less search backend. It ingests search texts and identifier tuples that can then be queried against in a microsecond's time. // Sonic 是一个快速、轻量级且无模式的搜索后端。它摄取搜索文本和标识符元组，然后可以在一微秒的时间内对其进行查询。 /// Sonic can be used as a simple alternative to super-heavy and full-featured search backends such as Elasticsearch in some use-cases. It is capable of normalizing natural language search queries, auto-completing a search query and providing the most relevant results for a query. Sonic is an identifier index, rather than a document index; when queried, it returns IDs that can then be used to refer to the matched documents in an external database. // 在某些用例中，Sonic 可以用作超重型、全功能搜索后端（例如 Elasticsearch）的简单替代方案。它能够规范自然语言搜索查询、自动完成搜索查询并提供与查询最相关的结果。 Sonic是标识符索引，而不是文档索引；查询时，它会返回 ID，然后可使用这些 ID 来引用外部数据库中的匹配文档。 /// A strong attention to performance and code cleanliness has been given when designing Sonic. It aims at being crash-free, super-fast and puts minimum strain on server resources (our measurements have shown that Sonic - when under load - responds to search queries in the μs range, eats ~30MB RAM and has a low CPU footprint; see our benchmarks). // 在设计 Sonic 时，我们非常注重性能和代码简洁性。它的目标是无崩溃、超快，并对服务器资源施加最小的压力（我们的测量表明，Sonic 在负载下时响应 μs 范围内的搜索查询，占用约 30MB RAM，并且 CPU 占用空间较低；请参阅我们的基准）。 /// 🇫🇷 Crafted in Nantes, France. // 🇫🇷 在法国南特制作。 /// Sonic supports a wide range of languages in its lexing system. If a language is not in this list, you will still be able to push this language to the search index, but stop-words will not be eluded, which could lead to lower-quality search results. // Sonic 的词法分析系统支持多种语言。如果某种语言不在此列表中，您仍然可以将该语言推送到搜索索引，但不会避开停用词，这可能会导致搜索结果质量较低。"

[crates]: https://crates.io/crates/sonic-server "(: cargo install -- sonic-server) (:: sonic -c /path/to/config.cfg) default cfg might be `/etc/sonic.cfg`. /// Install `build-essential`, `clang`, `libclang-dev`, `libc6-dev`, `g++` and `llvm-dev` to be able to compile the required *RocksDB* dependency."
[bin/brew]: https://formulae.brew.sh/formula/sonic "(: brew install -- sonic)"
[oci/dockerhub]: https://hub.docker.com/r/valeriansaliou/sonic "(: docker run -p 1491:1491 -v /path/to/your/sonic/config.cfg:/etc/sonic.cfg -v /path/to/your/sonic/store/:/var/lib/sonic/store/ -- valeriansaliou/sonic) In the configuration file, ensure that: // 在配置文件中（就是说容器化时候的配置文件会有点不一样），确保： /// - `channel.inet` is set to `0.0.0.0:1491` (this lets Sonic be reached from outside the container) // `channel.inet` 设置为 `0.0.0.0:1491` (这可以让 Sonic 从容器外部访问) /// - `store.kv.path` is set to `/var/lib/sonic/store/kv/` (this lets the external KV store directory be reached by Sonic) // `store.kv.path` 设置为 `/var/lib/sonic/store/kv/` (这使得 Sonic 可以访问外部 KV 存储目录 (即 `/path/to/your/sonic/store/kv/`)) /// - `store.fst.path` is set to `/var/lib/sonic/store/fst/` (this lets the external FST store directory be reached by Sonic) // `store.fst.path` 设置为 `/var/lib/sonic/store/fst/` (使 Sonic 可以访问外部 FST 存储目录) /// Sonic will be reachable from `tcp://localhost:1491`. // 然后就可以从 `tcp://localhost:1491` 访问 Sonic 了。"

[benchmark]: https://github.com/valeriansaliou/sonic#how-fast--lightweight-is-it "Sonic was built for Crisp from the start. As Crisp was growing and indexing more and more search data into a full-text search SQL database, we decided it was time to switch to a proper search backend system. When reviewing Elasticsearch (ELS) and others, we found those were full-featured heavyweight systems that did not scale well with Crisp's freemium-based cost structure. // Sonic 从一开始就是为 Crisp 打造的。随着 Crisp 的发展并将越来越多的搜索数据索引到全文搜索 SQL 数据库中，我们决定是时候切换到适当的搜索后端系统了。在审查 Elasticsearch (ELS) 和其他系统时，我们发现这些都是功能齐全的重量级系统，无法很好地适应 Crisp 基于免费增值的成本结构。 /// At the end, we decided to build our own search backend, designed to be simple and lightweight on resources. // 最后，我们决定构建自己的搜索后端，设计简单且资源轻量。 /// You can run function-level benchmarks with the command: `cargo bench --features benchmark` // 您可以使用以下命令运行函数级基准测试： `cargo bench --features benchmark` "
[test.online]: https://help.crisp.chat/ "You can test Sonic live on: Crisp Helpdesk, and get an idea of the speed and relevance of Sonic search results. You can also test search suggestions from there: start typing at least 2 characters for a word, and get suggested a full word (press the tab key to expand suggestion). Both search and suggestions are powered by Sonic. // 您可以在 Crisp Helpdesk 上实时测试 Sonic，并了解 Sonic 搜索结果的速度和相关性。您还可以从那里测试搜索建议：开始为一个单词输入至少 2 个字符，然后获得完整单词的建议（按 Tab 键展开建议）。搜索和建议均由 Sonic 提供支持。"

[auther.site]: https://valeriansaliou.name/

[blog:first-journal/auther.site]: https://journal.valeriansaliou.name/announcing-sonic-a-super-light-alternative-to-elasticsearch/ "- A GDPR-ready search system: when text is pushed to the index, Sonic splits sentences in words and then hashes each word, before they get stored and linked to a result object. Hashes cannot be traced back to their source word, you can only know which hash form a sentence together, but you cannot re-constitute the sentence with readable words. Sonic still stores non-hashed legible words in a graph for result suggestions and typo corrections, but those words are not linked together to form sentences. It means that the original text that was pushed cannot be guessed by someone hacking into your server and dumping Sonic's database. Sonic helps in designing \"privacy first\" apps. // 支持 GDPR 的搜索系统：当文本被推送到索引时，Sonic 将句子按单词拆分，然后对每个单词进行哈希处理，然后再将它们存储并链接到结果对象。哈希无法追溯到它们的源单词，你只能知道哪个哈希一起组成了一个句子，但你无法用可读的单词重新构成句子。 Sonic 仍将未散列的清晰单词存储在图表中，以提供结果建议和拼写错误更正，但这些单词不会链接在一起形成句子。这意味着侵入您的服务器并转储 Sonic 数据库的人无法猜出推送的原始文本。 Sonic 帮助设计“隐私第一”的应用程序。 /// - Reduced data dissemination: Sonic does not store nor return matched documents, it returns identifiers that refer to primary keys in another database (eg. MySQL, MongoDB, etc.). Once you get the ID results from Sonic for a search query, you need to fetch the pointed-to documents in your main database (eg. you fetch the user full name and email address from MySQL if you built a CRM search engine). Data stores synchronization is known to be hard, so you don't have to do it at all with Sonic. // 减少数据传播： Sonic 不存储也不返回匹配的文档，它返回引用另一个数据库（例如 MySQL、MongoDB 等）中主键的标识符。一旦从 Sonic 获得搜索查询的 ID 结果，您需要在主数据库中获取指向的文档（例如，如果您构建了 CRM 搜索引擎，则从 MySQL 获取用户全名和电子邮件地址）。众所周知，数据存储同步很困难，因此您根本不必使用 Sonic 来实现这一点。"


[client/rs.lib.src/gh]: https://github.com/FrontMage/sonic_client.git "(Languages: Rust 100.0%) sonic fulltext search client"
[client/ex.lib.src/gh]: https://github.com/imerkle/sonix.git "(Languages: Elixir 100.0%) An Elixir client for Sonic Search"







