[src/gh]: https://github.com/ibis-project/ibis.git "(Apache-2.0) (Languages: Python 98.4%, C++ 0.8%, Nix 0.4%, Just 0.2%, JavaScript 0.1%, Shell 0.1%) Ibis is the portable Python dataframe library: // Ibis 是可移植的 Python 数据框库： /// - Fast local dataframes (via DuckDB by default) // 快速本地数据框（默认通过 DuckDB） /// - Lazy dataframe expressions // 惰性数据框表达式 /// - Interactive mode for iterative data exploration // 交互式模式，用于迭代式数据探索 /// - Compose Python dataframe and SQL code // 组合 Python 数据框和 SQL 代码 /// - Use the same dataframe API for nearly 20 backends // 使用相同的数據框 API 支持 近 20 种后端 /// - Iterate locally and deploy remotely by changing a single line of code // 本地迭代并远程部署，只需修改一行代码 /// (: ibis.options.interactive = True ;: t = ibis.examples.penguins.fetch() # Get df from example) (: g = t.group_by('species', 'island').agg(count=t.count()).order_by('count') ;: ibis.to_sql(g) # Make expression on df and trans as sql) (: a = t.sql('SELECT species, island, count(*) AS count FROM penguins GROUP BY 1, 2') ;: b = a.order_by('count') # Mix sql and df expression) /// Most Python dataframes are tightly coupled to their execution engine. And many databases only support SQL, with no Python API. Ibis solves this problem by providing a common API for data manipulation in Python, and compiling that API into the backend’s native language. This means you can learn a single API and use it across any supported backend (execution engine). // 大多数 Python 数据框与其执行引擎紧密耦合。而且许多数据库只支持 SQL，没有 Python API。Ibis 通过为 Python 中的数据操作提供通用 API，并将该 API 编译成后端的原生语言来解决这个问题。这意味着你可以学习一个 API，并在任何支持的后端（执行引擎）上使用它。 /// Ibis broadly supports two types of backend: // Ibis 广泛支持两种后端类型： /// - SQL-generating backends // SQL 的生成后端 /// - DataFrame-generating backends // DataFrame 的生成后端 /// Ibis supports nearly 20 backends: // Ibis 支持近 20 个后端： /// - Apache DataFusion /// - Apache Druid /// - Apache Flink /// - Apache Impala /// - Apache PySpark /// - BigQuery /// - ClickHouse /// - DuckDB /// - Exasol /// - MySQL /// - Oracle /// - Polars /// - PostgreSQL /// - RisingWave /// - SQL Server /// - SQLite /// - Snowflake /// - Theseus /// - Trino"
[lib.pip/pypi]: https://pypi.org/project/ibis-framework/ "(: pip install -- ibis-framework) (License: Apache Software License (Apache-2.0)) (Requires: Python >=3.9) (Provides-Extra: [athena], [bigquery], [clickhouse], [databricks], [datafusion], [decompiler], [deltalake], [druid], [duckdb], [examples], [exasol], [flink], [geospatial], [impala], [mssql], [mysql], [oracle], [polars], [postgres], [pyspark], [risingwave], [snowflake], [sqlite], [trino], [visualization]) The portable Python dataframe library // 便携式 Python 数据帧库 (src: gh:ibis-project/ibis.git)"
[site]: https://ibis-project.org/ "Ibis // 鸢尾鸟 /// the portable Python dataframe library // 便携式 Python 数据框库 /// An open source dataframe library that works with any data system // 一个可与任何数据系统配合使用的开源数据帧库 /// - Use the same API for nearly 20 backends // 适用于近 20 种后端的相同 API /// - Fast local dataframes with embedded DuckDB (default), Polars, or DataFusion // 使用嵌入式 DuckDB（默认）、Polars 或 DataFusion 的快速本地数据帧 /// - Iterate locally and deploy remotely by changing a single line of code // 在本地迭代并在远程部署，只需修改一行代码 /// - Compose SQL and Python dataframe code, bridging the gap between data engineering and data science // 编写 SQL 和 Python 数据框代码，连接数据工程与数据科学 /// Ibis offers a familiar local dataframe experience with outstanding performance, using DuckDB by default. // Ibis 提供熟悉的本地数据框体验，并具有卓越性能，默认使用 DuckDB。 /// Use the same dataframe API for nearly 20 backends. This allows you to iterate locally and deploy remotely by changing a single line of code. For instance, develop locally with DuckDB and deploy remotely to BigQuery. Or, using any combination of backends that meet your requirements. // 使用相同的 DataFrame API 支持近 20 种后端。这允许您在本地迭代并在远程部署，只需更改一行代码。例如，使用 DuckDB 在本地开发，并将代码远程部署到 BigQuery。或者，使用任何满足您需求的后端组合。 /// Ibis works by decoupling the dataframe API from the backend execution. Most backends support a SQL dialect, which Ibis compiles its expressions into using SQLGlot. You can inspect the SQL that Ibis generates for any SQL backend. And use SQL strings directly, mixing and matching with Python dataframe code. // Ibis 通过将数据框 API 与后端执行解耦来工作。大多数后端支持 SQL 方言，Ibis 使用 SQLGlot 将其表达式编译成 SQL。您可以检查 Ibis 为任何 SQL 后端生成的 SQL。并且可以直接使用 SQL 字符串，与 Python 数据框代码混合搭配使用。"
[blog:farewell-pandas/posts/.site]: https://ibis-project.org/posts/farewell-pandas/ "TL; DR: we are deprecating the pandas and dask backends and will be removing them in version 10.0. // TL; DR：我们将弃用 pandas 和 dask 后端，并在版本 10.0 中移除它们。 /// There is no feature gap between the pandas backend and our default DuckDB backend, and DuckDB is much more performant. pandas DataFrames will still be available as format for getting data to and from Ibis, we just won’t support using pandas to execute queries. // pandas 后端与我们的默认 DuckDB 后端之间没有功能差距，而且 DuckDB 的性能要高得多。 pandas DataFrame 仍然可以作为将数据输入和输出 Ibis 的格式，但我们不再支持使用 pandas 来执行查询。 /// Most of the rationale below applies to the Dask backend since it has so much in common with pandas. Dask is a great project and people should continue to use it outside the Ibis context. // 下文中的大部分理由适用于 Dask 后端，因为它与 pandas 有很多相似之处。Dask 是一个很棒的项目，人们应该继续在 Ibis 环境之外使用它。 /// - Deferred vs Eager // 延迟与即时 ///: pandas is inherently an eager engine – every time you hit Enter you are computing an intermediate result. Ibis uses a deferred execution model, similar to what nearly all SQL backends use, that enables query planning and optimization passes. // pandas 本质上是一个即时引擎——每次你按下 Enter 键时，你都在计算一个中间结果。Ibis 使用延迟执行模型，类似于几乎所有 SQL 后端使用的模型，这能够实现查询规划和优化过程。 ///; Trying to make a pandas interface that behaves in a deferred way is hard. // 试图创建一个具有延迟行为的 pandas 界面很困难。 ///; One of the unfortunate effects of this mismatch is that, unlike our other backends, the pandas backend is often much slower than just using pandas directly. // 这种不匹配的不幸影响之一是，与我们的其他后端不同， pandas 后端通常比直接使用 pandas 慢得多。 ///; And to provide this suboptimal experience, we have a few thousand lines of code that are only used in the pandas backend. // 为了提供这种次优体验，我们有一段几千行代码，这些代码仅在 pandas 后端使用。 /// - NaN vs NULL // NaN 与 NULL ///: The choice was made a long time ago to accept using NaN as the marker for missing values in pandas. This is because NumPy has a notion of NaN, but a Python None would lead to an object-dtype and poor performance. // 很久以前就决定在 pandas 中使用 NaN 作为缺失值的标记。这是因为 NumPy 有 NaN 的概念，但 Python 的 None 会导致 object -dtype 并影响性能。 ///; Practicality beats purity, but this is a horrible decision to have to make. Ibis doesn’t have to make it with any other backend, because NULL indicates a missing value, and NaN is Not a Number. // 实用性胜于纯粹，但这不得不做出一个可怕的决定。Ibis 不需要在其他后端做出这样的决定，因为 NULL 表示缺失值，NaN 表示不是一个数字。 ///; Those are fundamentally different ideas and it is an ongoing headache for Ibis to try to pretend that they aren’t. // 这些是根本不同的概念，Ibis 试图假装它们不是这样，一直是一个持续的困扰。 /// - Misleading new users // 误导新用户 ///: People reach for what is familiar. When you try Ibis for the first time, we’re asking you to both a) try Ibis and b) pick a backend. We have defaults to try to help with this, but it can be confusing at first. // 人们倾向于选择熟悉的事物。当你第一次尝试使用 Ibis 时，我们希望你既能尝试 Ibis，又能选择一个后端。我们提供了默认选项来帮助完成这一过程，但一开始可能会感到困惑。 ///; We have many reports from new users that “Ibis is slow”. What this almost always means is that they tried the pandas backend (because they know pandas) and they are having a less-than-great time. // 我们收到了很多新用户报告称“Ibis 运行缓慢”。这几乎总是意味着他们尝试了 pandas 后端（因为他们知道 pandas ），并且体验不太好。 ///; If they tried DuckDB or Polars, instead, they would have a much easier time getting things going. // 如果他们尝试使用 DuckDB 或 Polars，事情就会容易得多。 /// - Feature parity // 功能对等 ///: This is the one of the strongest reasons to drop the pandas backend – it is redundant. The DuckDB backend can seamlessly query pandas DataFrames, supports several flavors of UDF, and can read and write parquet, CSV, JSON, and other formats. // 这是放弃 pandas 后端的一个强有力的原因——它是冗余的。DuckDB 后端可以无缝查询 pandas DataFrames，支持多种 UDF，并且可以读写 parquet、CSV、JSON 以及其他格式。 ///; There is a reason DuckDB is our default backend: it’s easy to install, it runs locally, it’s blazing fast, and it interacts well with the Python ecosystem. Those are all the reasons we added pandas as a backend in the first place, but with the added benefit of blazing-fast results, and no type-system headaches. // 有一个原因让 DuckDB 成为我们的默认后端：它易于安装，可以在本地运行，运行速度极快，并且与 Python 生态系统兼容良好。这些就是我们最初添加 pandas 作为后端的原因，而且它还具备极快的运行速度和无需处理类型系统问题的额外优势。"
