[src/gh]: https://github.com/python-trio/trio.git "(Apache-2.0, MIT) (Languages: Python 99.7%, Other 0.3%) Trio – a friendly Python library for async concurrency and I/O // Trio – 一个用于异步并发和 I/O 的友好 Python 库 /// The Trio project aims to produce a production-quality, permissively licensed, async/await-native I/O library for Python. Like all async libraries, its main purpose is to help you write programs that do multiple things at the same time with parallelized I/O. A web spider that wants to fetch lots of pages in parallel, a web server that needs to juggle lots of downloads and websocket connections simultaneously, a process supervisor monitoring multiple subprocesses... that sort of thing. Compared to other libraries, Trio attempts to distinguish itself with an obsessive focus on usability and correctness. Concurrency is complicated; we try to make it easy to get things right. // Trio 项目旨在为 Python 生产一个允许许可的、原生支持 async/await 的 I/O 库。与其他所有异步库一样，其主要目的是帮助你编写能够同时做很多事情的并行化 I/O 程序。例如，一个想要并行获取大量页面的网络爬虫，一个需要同时处理大量下载和 WebSocket 连接的网络服务器，一个监控多个子进程的过程管理器等等。与其他库相比，Trio 试图通过对可用性和正确性的极致关注来区分自己。并发很复杂；我们努力让正确性变得容易。 /// Trio was built from the ground up to take advantage of the latest Python features, and draws inspiration from many sources, in particular Dave Beazley's Curio. The resulting design is radically simpler than older competitors like asyncio and Twisted, yet just as capable. Trio is the Python I/O library I always wanted; I find it makes building I/O-oriented programs easier, less error-prone, and just plain more fun. Perhaps you'll find the same. // Trio 是从底层构建的，以利用最新的 Python 功能，并从许多来源汲取灵感，特别是 Dave Beazley 的 Curio。最终的设计比旧的竞争对手如 asyncio 和 Twisted 简单得多，但同样强大。Trio 是我一直想要的 Python I/O 库；我发现它使构建 I/O 程序变得更容易、更不容易出错，而且纯粹更有趣。也许你也会发现同样的。 /// Trio is a mature and well-tested project: the overall design is solid, and the existing features are fully documented and widely used in production. While we occasionally make minor interface adjustments, breaking changes are rare. We encourage you to use Trio with confidence, but if you rely on long-term API stability, consider subscribing to issue #1 for advance notice of any compatibility updates. // Trio 是一个成熟且经过充分测试的项目：整体设计稳固，现有功能均有完整文档，并在生产环境中广泛使用。虽然我们偶尔会进行一些小的接口调整，但破坏性变更很少。我们鼓励您自信地使用 Trio，但如果您依赖长期 API 稳定性，请考虑订阅 issue #1 以获取任何兼容性更新的提前通知。 /// (: import trio ;: async def async_double(x): return 2 * x ;: trio.run(async_double, 3)  # returns 6) /// “Async” is short for “asynchronous”; we’ll sometimes refer to regular functions like regular_double as “synchronous functions”, to distinguish them from async functions. // “Async” 是 “asynchronous” 的缩写；有时我们会将像 regular_double 这样的普通函数称为 “同步函数”，以区别于异步函数。 /// From a user’s point of view, there are two differences between an async function and a regular function: // 从用户的角度来看，异步函数与普通函数之间有两个主要区别： /// 1. To call an async function, you have to use the await keyword. So instead of writing regular_double(3), you write await async_double(3). // 要调用一个异步函数，你必须使用 await 关键字。所以，你不用写 regular_double(3) ，而是写 await async_double(3) 。 /// 2. You can’t use the await keyword inside the body of a regular function. If you try it, you’ll get a syntax error: // 你不能在普通函数的体内使用 await 关键字。如果你尝试这样做，你会得到一个语法错误： /// (: def print_double(x): print(await async_double(x)) # <-- SyntaxError here) /// But inside an async function, await is allowed: // 但在异步函数体内， await 是被允许的： /// (: async def print_double(x): print(await async_double(x)) # <-- OK!)"
[docs/rtd]: https://trio.readthedocs.io "Now, let’s think about the consequences here: if you need await to call an async function, and only async functions can use await… // 现在，让我们思考一下这里的后果：如果你需要 await 来调用一个异步函数，而只有异步函数可以使用 await …… /// So, if a **sync** function and it wants to call a **async** function, it can’t do that directly. // 所以，若一个 **同步** 函数想要调用一个 **异步** 函数，它不能直接这样做。 /// So in summary: As a user, the entire advantage of async functions over regular functions is that async functions have a superpower: they can call other async functions. // 总而言之：作为用户，异步函数相对于普通函数的全部优势在于异步函数拥有超能力：它们可以调用其他异步函数。 /// This immediately raises two questions: how, and why? Specifically: // 这立刻引出了两个问题：如何，以及为何？具体来说： /// When your Python program starts up, it’s running regular old sync code. So there’s a chicken-and-the-egg problem: once we’re running an async function we can call other async functions, but how do we call that first async function? // 当你的 Python 程序启动时，它正在运行常规的同步代码。因此存在一个鸡生蛋还是蛋生鸡的问题：一旦我们运行了异步函数，就可以调用其他异步函数，但我们如何调用第一个异步函数？ /// And, if the only reason to write an async function is that it can call other async functions, why on earth would we ever use them in the first place? I mean, as superpowers go this seems a bit pointless. Wouldn’t it be simpler to just… not use any async functions at all? // 而且，如果编写异步函数的唯一原因是因为它可以调用其他异步函数，我们究竟为什么要使用它们呢？我的意思是，作为超能力来说，这似乎有点没意义。难道我们不是应该简单地……完全不用任何异步函数吗？ /// This is where an async library like Trio comes in. // 这就是像 Trio 这样的异步库发挥作用的地方。 /// (: import trio ;: async def async_double(x): return 2 * x ;: trio.run(async_double, 3)  # returns 6) /// “Async” is short for “asynchronous”; we’ll sometimes refer to regular functions like regular_double as “synchronous functions”, to distinguish them from async functions. // “Async” 是 “asynchronous” 的缩写；有时我们会将像 regular_double 这样的普通函数称为 “同步函数”，以区别于异步函数。 /// From a user’s point of view, there are two differences between an async function and a regular function: // 从用户的角度来看，异步函数与普通函数之间有两个主要区别： /// 1. To call an async function, you have to use the await keyword. So instead of writing regular_double(3), you write await async_double(3). // 要调用一个异步函数，你必须使用 await 关键字。所以，你不用写 regular_double(3) ，而是写 await async_double(3) 。 /// 2. You can’t use the await keyword inside the body of a regular function. If you try it, you’ll get a syntax error: // 你不能在普通函数的体内使用 await 关键字。如果你尝试这样做，你会得到一个语法错误： /// (: def print_double(x): print(await async_double(x)) # <-- SyntaxError here) /// But inside an async function, await is allowed: // 但在异步函数体内， await 是被允许的： /// (: async def print_double(x): print(await async_double(x)) # <-- OK!)"
[lib.pip/pypi]: https://pypi.org/project/trio/ "(: pip install -- trio) (License Expression: MIT OR Apache-2.0) (Requires: Python >=3.10) A friendly Python library for async concurrency and I/O // 一个友好的 Python 库，用于异步并发和 I/O (src: gh:python-trio/trio.git)"

