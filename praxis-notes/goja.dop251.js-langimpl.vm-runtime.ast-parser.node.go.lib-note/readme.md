[es-vm.src/gh]: https://github.com/dop251/goja.git "(MIT) (Languages: Go 99.8%, Other 0.2%) ECMAScript/JavaScript engine in pure Go // 纯 Go 编写的 ECMAScript/JavaScript 引擎 /// Goja is an implementation of ECMAScript 5.1 in pure Go with emphasis on standard compliance and performance. // Goja 是用纯 Go 实现的 ECMAScript 5.1，注重标准兼容性和性能。 /// Features // 特性 /// - Full ECMAScript 5.1 support (including regex and strict mode). // 完整的 ECMAScript 5.1 支持（包括正则表达式和严格模式）。 /// - Passes nearly all tc39 tests for the features implemented so far. The goal is to pass all of them. See .tc39_test262_checkout.sh for the latest working commit id. // 通过了目前已实现的几乎所有 tc39 测试。目标是全部通过。参见 .tc39_test262_checkout.sh 获取最新的有效提交 ID。 /// - Capable of running Babel, Typescript compiler and pretty much anything written in ES5. // 可以运行 Babel、TypeScript 编译器以及几乎所有用 ES5 编写的代码。 /// - Sourcemaps. // Sourcemaps。 /// - Most of ES6 functionality, still work in progress, see https://github.com/dop251/goja/milestone/1?closed=1 // ES6 的大部分功能仍然在开发中 /// ### How fast is it? // 它有多快？ /// Although it's faster than many scripting language implementations in Go I have seen (for example it's 6-7 times faster than otto on average) it is not a replacement for V8 or SpiderMonkey or any other general-purpose JavaScript engine. You can find some benchmarks here (. gh:.#issues/2). // 尽管它比我所见过的许多 Go 脚本语言实现都要快（例如，平均速度比 otto 快 6-7 倍），但它并不能取代 V8、SpiderMonkey 或任何其他通用 JavaScript 引擎。你可以在这里找到一些基准测试。 /// ### Why would I want to use it over a V8 wrapper? // 为什么我想用它而不是 V8 包装器？ /// It greatly depends on your usage scenario. If most of the work is done in javascript (for example crypto or any other heavy calculations) you are definitely better off with V8. // 这很大程度上取决于你的使用场景。如果大部分工作是在 javascript 中完成的（例如加密或任何其他复杂的计算），你绝对更适合使用 V8。 /// If you need a scripting language that drives an engine written in Go so that you need to make frequent calls between Go and javascript passing complex data structures then the cgo overhead may outweigh the benefits of having a faster javascript engine. // 如果你需要一个用 Go 编写的脚本语言引擎，并且需要在 Go 和 javascript 之间频繁调用以传递复杂的数据结构，那么 cgo 的开销可能会超过拥有一个更快的 javascript 引擎所带来的好处。 /// Because it's written in pure Go there are no cgo dependencies, it's very easy to build and it should run on any platform supported by Go. // 因为它是用纯 Go 编写的，所以没有 cgo 依赖，构建非常简单，应该可以在 Go 支持的任何平台上运行。 /// It gives you a much better control over execution environment so can be useful for research. // 它为您提供对执行环境的更好控制，因此对研究很有用。 /// ### Is it goroutine-safe? // 它是 goroutine 安全的吗？ /// No. An instance of goja.Runtime can only be used by a single goroutine at a time. You can create as many instances of Runtime as you like but it's not possible to pass object values between runtimes. // 不是的。goja.Runtime 的一个实例在同一时间只能被一个 goroutine 使用。你可以创建任意数量的 Runtime 实例，但无法在不同的 runtime 之间传递对象值。 /// ### Where is setTimeout()/setInterval()? // setTimeout() 和 setInterval() 在哪里？ /// setTimeout() and setInterval() are common functions to provide concurrent execution in ECMAScript environments, but the two functions are not part of the ECMAScript standard. Browsers and NodeJS just happen to provide similar, but not identical, functions. The hosting application need to control the environment for concurrent execution, e.g. an event loop, and supply the functionality to script code. // setTimeout() 和 setInterval() 是在 ECMAScript 环境中提供并发执行的常见函数，但这两个函数并不是 ECMAScript 标准的一部分。浏览器和 NodeJS 只是恰好提供了相似但不完全相同的函数。宿主应用程序需要控制并发执行的环境，例如事件循环，并向脚本代码提供相应的功能。 /// There is a separate project (. gh: dop251/goja_nodejs.git) aimed at providing some NodeJS functionality, and it includes an event loop. // 有一个独立的项目旨在提供一些 NodeJS 功能，并且它包含一个事件循环。"
[es-vm-lib.go/pgd]: https://pkg.go.dev/github.com/dop251/goja "(: go get -- github.com/dop251/goja) (License: MIT) (Imports: 36) (Imported by: 3,781)  (src: gh:dop251/goja.git)"
[njs-collection.src/gh]: https://github.com/dop251/goja_nodejs.git '(MIT) (Languages: Go 98.3%, JavaScript 1.7%) Nodejs compatibility library for Goja // Goja 的 Nodejs 兼容库 /// This is a collection of Goja modules that provide nodejs compatibility. // 这是一个提供 nodejs 兼容性的 Goja 模块集合。 /// (: import ("github.com/dop251/goja" "github.com/dop251/goja_nodejs/require") ;: registry := new(require.Registry) // this can be shared by multiple runtimes ;: runtime := goja.New() ;: req := registry.Enable(runtime) ;: runtime.RunString(` var m = require("./m.js"); m.test(); `) ;: m, err := req.Require("./m.js") ;: _, _ = m, err)'
[njs-collection-lib.go/pgd]: https://pkg.go.dev/github.com/dop251/goja_nodejs "(: go get -- github.com/dop251/goja_nodejs) (License: MIT)  (src: gh:dop251/goja_nodejs.git)"
[knows_by]: https://github.com/coder/guts.git "How it works // 工作原理 /// guts first parses a set of golang packages. The Go AST is traversed to find all the types defined in the packages. // guts 首先解析一组 golang 包。遍历 Go 抽象语法树（AST）以找到包中定义的所有类型。 /// These types are placed into a simple AST that directly maps to the typescript AST. // 这些类型被放置到一个简单的 AST 中，该 AST 直接映射到 TypeScript 的 AST。 /// Using goja (. gh: dop251/goja.git), these types are then serialized to typescript using the typescript compiler API. // 使用 goja，这些类型随后通过 TypeScript 编译器 API 序列化为 TypeScript。"

