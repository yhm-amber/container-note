[src/gh]: https://github.com/lichuan/erlang-vs-golang.git "(MIT) (Languages: Go 50.1%, Erlang 49.9%) Scheduler Fairness and Real-Time Performance: Golang vs Erlang // 调度公平性和实时性能：Golang 与 Erlang /// This repository contains a comparative analysis of the scheduling fairness and real-time performance between Golang and Erlang. The tests demonstrate that Golang's goroutine scheduler performs poorly - it's crude, unfair, and lacks good real-time characteristics. In contrast, Erlang's scheduler proves significantly superior in both fairness and real-time performance! // 该存储库包含了对 Golang 和 Erlang 之间调度公平性和实时性能的比较分析。测试表明，Golang 的协程调度器表现不佳——它粗糙、不公平，且缺乏良好的实时特性。相比之下，Erlang 的调度器在公平性和实时性能方面都显著优越！ /// The essence of scheduler evaluation lies in testing whether concurrent processes/goroutines receive fair treatment even when some routines are consuming substantial CPU resources. Other routines should enjoy equal execution opportunities rather than being forced into delay or blocking. // 调度器评估的本质在于测试并发进程/协程是否即使在某些协程消耗大量 CPU 资源时也能获得公平对待。其他协程应该享有平等的执行机会，而不是被迫延迟或阻塞。 /// We designed two identical functions (work1 and work2) in both languages, then launched multiple resource-intensive routines (work_busy) to compete for system resources. // 我们在两种语言中都设计了两个相同的函数（ work1 和 work2 ），然后启动了多个资源密集型协程（ work_busy ）来竞争系统资源。 /// While Golang (as a static language) naturally delivers higher performance, we adjusted the number of work_busy routines appropriately for each language to ensure: // 尽管 Go 语言（作为一种静态语言）自然能提供更高的性能，我们适当调整了每种语言的 work_busy 协程数量以确保： /// - Both implementations maintain similar execution rates (approximately 60-80 executions per second) // 两种实现都保持了相似的执行速率（大约每秒 60-80 次执行） /// - work1 and work2 achieve roughly the same execution counts within the same timeframe // work1 和 work2 在相同时间内实现了大致相同的执行次数 /// - The comparison focuses specifically on scheduler behavior rather than raw language performance // 这项比较特别关注调度器的行为，而不是原始语言性能 /// After running approximately 10,000 iterations: // 运行大约 10,000 次后： /// - Golang results: work1 and work2 showed a difference of over 100 executions // Golang 结果： work1 和 work2 显示执行次数差异超过 100 次 /// - Erlang results: work1 and work2 differed by only 1 execution - an astonishing result! // Erlang 结果： work1 和 work2 仅相差 1 次执行 - 这是一个惊人的结果！"
