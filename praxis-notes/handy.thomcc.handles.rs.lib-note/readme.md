[src/gh]: https://github.com/thomcc/handy.git "(Apache-2.0, MIT) (Languages: Rust 100.0%) Rust handle library // Rust 句柄库 /// handy: handles and handle maps. // handy : 处理句柄和处理映射。 /// handy provides handles and handle maps for rust code. This is a fairly useful data structure for rust code, since it can help you work around borrow checker issues. // handy 为 Rust 代码提供处理句柄和处理映射。这对于 Rust 代码来说是一种相当有用的数据结构，因为它可以帮助你绕过借用检查器的问题。 /// Essentially, Handle and HandleMap are a more robust version of the pattern where instead of storing a reference to a &T directly, you instead store a usize which indicates where it is in some Vec. I claim they're more robust because: // 本质上， Handle 和 HandleMap 是一种更健壮的模式版本，它不是直接存储对 &T 的引用，而是存储一个 usize ，该句柄指示其在某个 Vec 中的位置。我声称它们更健壮，因为： /// - They can detect if you try to use a handle in a map other than the one that provided it. // 它们可以检测你是否尝试在提供该句柄的映射之外使用一个句柄。 /// - If you remove an item from the HandleMap, the handle map won't let you use the stale handle to get whatever value happens to be in that slot at the time. // 如果你从 HandleMap 中移除一个项，handle map 将不会让你使用过期的 handle 来获取该槽位在此时此刻可能存在的任何值。 /// Similar crates // 类似的 crate ///: There are a whole bunch. // 有很多。 /// - slotmap: Same idea as this, but it requires T: Copy (there's a way around this but it's a pain IMO). Has a system for defining handles for use in specific maps, but can't detect if you use a key from one map in another, if the maps are the same type. It also has a bunch of other maps for different performance cases but honestly the limitation of T: Copy has prevented me from digging too deeply. // slotmap : 与这个想法相同，但它需要 T: Copy （虽然有一个解决方法，但在我看来很麻烦）。它有一个用于在特定映射中定义 handle 的系统，但无法检测如果你从同一类型的多个映射中使用一个映射的键，这是否正确。它还有许多其他用于不同性能情况的映射，但说实话， T: Copy 的限制阻止了我深入研究。 /// - slab: Also the same idea but you might not realize it from the docs. It can't detect use with the wrong map or use after the item is removed and another occupies the same spot. // slab : 同样的思路，但可能从文档中无法意识到。它无法检测到使用错误的映射或在使用项目被移除后，另一个项目占据了相同位置的情况。 /// - ffi_support's HandleMap: I wrote this one. It's very similar, but with some different tradeoffs, and essentially different code. Also, this library doesn't bring in as many heavyweight dependencies, has more features, and isn't focused on use inside the FFI. // ffi_support 的 HandleMap : 我写的这个。它非常相似，但有一些不同的权衡，本质上代码也不同。此外，这个库没有引入那么多重量级的依赖项，功能更多，并且不专注于在 FFI 内部使用。 /// - Unlike any of them, we're usable in no_std situations (we do link with extern crate alloc, of course). // 与其他任何都不一样，我们可以在 no_std 情况下使用（当然，我们确实链接了 extern crate alloc ）。 /// License // 许可证 ///: TLDR: MIT / Apache2 like every other Rust library. // TLDR：与其他所有 Rust 库一样，采用 MIT / Apache2 许可。 /// This code shares common legacy with the Handle/HandleMap types from https://crates.io/crates/ffi-support (After all, I wrote that library too). I also stole the test code more or less directly from that crate. Because of that, this library has the exact same license, down to the copyright assignment to Mozilla. // 这段代码与 https://crates.io/crates/ffi-support 中的 Handle/HandleMap 类型有共同的遗留关系（毕竟，我也写了那个库）。我还几乎直接从那个 crate 中复制了测试代码。由于这个原因，这个库具有完全相同的许可证，甚至包括版权转让给 Mozilla 的条款。 /// In practice that doesn't matter, since who cares, they're both MIT / Apache2, but I figured I should write it down somewhere. // 实际上这并不重要，因为谁在乎呢，它们都是 MIT / Apache2，但我认为应该把这事写下来。"
[lib.cargo/crates]: https://crates.io/crates/handy "(: cargo add -- handy) (Apache-2.0 OR MIT) (1,369 SLoC) (21.6 KiB)"
