<!DOCTYPE html> <html lang=en><!--
 Page saved with SingleFile 
 url: https://smunix.github.io/dev.stephendiehl.com/hask/ 
 saved date: Mon Apr 17 2023 16:11:02 GMT+0800 (中国标准时间)
--><meta charset=utf-8><style data-title=hcfy>hcfy-result{--hcfy-result-main-color:#cf77ff}.__hcfy-result-comparison__{border-left:3px solid var(--hcfy-result-main-color,#008b45);padding-left:6px}.__hcfy-result-comparison-block__{padding:6px 0 6px 12px}.__hcfy-result-comparison-inline__{margin-left:.4em}</style><title>What I Wish I Knew When Learning Haskell 2.3 ( Stephen Diehl ) ~ 学习 Haskell 2.3 时我希望知道的事（Stephen Diehl）</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content><link rel=canonical href=https://smunix.github.io/dev.stephendiehl.com/hask/><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><body itemscope itemtype=http://schema.org/TechArticle>Providence Salumu
 
 
 
 
 
 
 
 
 <style>div.sourceCode{overflow-x:auto}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode{margin:0;padding:0;vertical-align:baseline;border:0}table.sourceCode{width:100%;line-height:100%}td.lineNumbers{text-align:right;padding-right:4px;padding-left:4px;color:#aaa;border-right:1px solid #aaa}td.sourceCode{padding-left:5px}code>span.kw{color:#007020;font-weight:bold}code>span.dt{color:#902000}code>span.dv{color:#40a070}code>span.bn{color:#40a070}code>span.fl{color:#40a070}code>span.ch{color:#4070a0}code>span.st{color:#4070a0}code>span.co{color:#60a0b0;font-style:italic}code>span.ot{color:#007020}code>span.al{color:red;font-weight:bold}code>span.fu{color:#06287e}code>span.er{color:red;font-weight:bold}code>span.wa{color:#60a0b0;font-weight:bold;font-style:italic}code>span.cn{color:#800}code>span.sc{color:#4070a0}code>span.vs{color:#4070a0}code>span.ss{color:#b68}code>span.im{}code>span.va{color:#19177c}code>span.cf{color:#007020;font-weight:bold}code>span.op{color:#666}code>span.bu{}code>span.ex{}code>span.pp{color:#bc7a00}code>span.at{color:#7d9029}code>span.do{color:#ba2121;font-style:italic}code>span.an{color:#60a0b0;font-weight:bold;font-style:italic}code>span.cv{color:#60a0b0;font-weight:bold;font-style:italic}code>span.in{color:#60a0b0;font-weight:bold;font-style:italic}<hcfy-result style="display: none;"><\/hcfy-result></style>
 
 <style>html,body{margin:0;padding:0;height:100%}body{font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-size:15px;font-style:normal;font-weight:400;line-height:1.5;color:#333;-webkit-font-feature-settings:"kern","liga";-moz-font-feature-settings:"kern","liga";font-feature-settings:"kern","liga"}h1,h2,h3,h4,h5{font-weight:bold;line-height:1.1;margin:1em 0 .5em}h1{padding:1em 0;margin:0;text-align:center;font-size:250%}h2{font-size:175%;padding:.5em 0;margin:0}h3{font-size:150%}h4{font-size:125%}pre.sourceCode{padding:10px 20px;margin:0}code{color:inherit;background-color:inherit}pre code{font-family:"Source Code Pro",monospace;font-size:13px}img{max-width:100%;height:auto}hr{border:0px;border-bottom:1px solid #eee;margin:50px 0}.document-title{text-transform:uppercase;font-size:200%;text-align:center;padding-bottom:0}.document-version{font-size:150%;color:#666;text-align:center;margin-top:0}.author{color:#006;font-weight:bold;text-align:center}img{margin:0 auto}#sidebar-wrapper{overflow-x:hidden}a:link{color:#4070a0;text-decoration:none}a:hover{text-decoration:underline}a:active{color:#205080}p a{text-decoration:underline}li code,p code,table code{border:0;margin:0;padding:0 3px;-moz-border-radius:0px;border-radius:0px;background:#eee}table{width:100%;background:#fff;border:0;border-collapse:collapse;margin:20px 0}th,td{padding:5px 10px;text-align:left;vertical-align:top;border:1px solid #ddd}tr:nth-child(even) td{background:#f7f7f7}.overflow-table{width:100%;margin:20px 0;overflow-x:auto;border-left:1px solid #ddd;border-right:1px solid #ddd}.overflow-table table{margin:0}.overflow-table tr td:first-child,.overflow-table tr th:first-child{border-left:0}.overflow-table tr td:last-child,.overflow-table tr th:last-child{border-right:0}.overflow-table>p{display:none}.center{text-align:center}.bigger img{width:120%;height:120%}.annotation{font-size:10pt}.annotation pre{display:block;margin:0;padding:7px 10px;overflow-x:auto}.annotation.span2{margin-left:0px !important;margin-top:18px !important}.annotation pre code{border:0;padding:0;background:transparent}blockquote{border-left:5px solid #ccc;margin:0;padding:1px 0 1px 1em}.sections blockquote p{font-family:Menlo,Consolas,Monaco,monospace;font-size:12px;line-height:16px;color:#999;margin:10px 0 0;white-space:pre-wrap}ul.sections{list-style:none;padding:0 0 5px 0;margin:0}code.sourceCode{padding:0;background:inherit}ul.sections>li>div{-moz-box-sizing:border-box;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-khtml-box-sizing:border-box;box-sizing:border-box}.alert{padding:5px 15px;margin-bottom:15px;bakground:#eee}.alert a{color:inherit}.alert-success{color:#468847;background-color:#dff0d8;border-color:#d6e9c6}.alert-danger{color:#b94a48;background-color:#f2dede;border-color:#eed3d7}</style>
 <style>/*!
 * Start Bootstrap - Simple Sidebar HTML Template (http://startbootstrap.com)
 * Code licensed under the Apache License v2.0.
 * For details, see http://www.apache.org/licenses/LICENSE-2.0.
 */#sidebar-wrapper{position:fixed;top:0;left:0;bottom:0;height:100%;width:250px;overflow-y:auto;overflow-x:hidden;background:#f7f7f7;border-right:1px solid #eee;-webkit-overflow-scrolling:touch}#sidebar-wrapper .logo{display:block;margin:10px 0 0;text-align:center}#sidebar-wrapper .logo img{width:160px}#toggle-sidebar{display:none}.sidebar-nav{margin:0;padding:0;font-size:13px}.sidebar-nav li{}.sidebar-nav li a{display:block;text-decoration:none;color:inherit}.sidebar-nav li a:hover{text-decoration:underline}.sidebar-nav li a:active,.sidebar-nav li a:focus{}.sidebar-nav ul{list-style-type:circle;padding:10px 10px 10px 20px}.sidebar-nav>ul{list-style-type:none;padding-left:10px}.sidebar-nav>ul>li>a{font-weight:bold}#main-wrapper{position:fixed;top:0;right:0;left:250px;bottom:0;height:100%;overflow-y:auto;-webkit-overflow-scrolling:touch}#main{padding:20px;max-width:800px}@media screen and (max-width:800px){#sidebar-wrapper{z-index:10;width:100%;height:50px;right:0;border-right:0;border-bottom:1px solid #eee}#sidebar-wrapper .sidebar-nav{display:none;position:absolute;bottom:0;left:0;right:0;top:50px;height:100%;border-top:1px solid #eee;overflow-y:auto;font-size:15px}#sidebar-wrapper .sidebar-nav a{display:inline-block}#sidebar-wrapper.expanded{height:100%}#sidebar-wrapper.expanded .sidebar-nav{display:block}#sidebar-wrapper .logo{display:inline-block;width:50px;height:50px;margin:0 10px}#sidebar-wrapper .logo img{height:50px;line-height:50px;vertical-align:middle}#toggle-sidebar{display:inline-block;float:right;line-height:30px;height:50px;border:0;background:0;padding:10px;font-size:15px}#sidebar-wrapper #toggle-sidebar:before{content:"Show"}#sidebar-wrapper.expanded #toggle-sidebar:before{content:"Close"}#main-wrapper{top:50px;left:0}}</style>
 
 
 
 <div id=sidebar-wrapper>
 <a href=https://smunix.github.io/dev.stephendiehl.com/hask/index.html class=logo>
 <img src=data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNDgxLjg4OTdwdCIgaGVpZ2h0PSIzNDAuMTU3NHB0IiB2aWV3Qm94PSIwIDAgNDgxLjg4OTcgMzQwLjE1NzQiIHZlcnNpb249IjEuMSI+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAxIj4KICA8cGF0aCBkPSJNIDAgMzQwLjE1NjI1IEwgNDgxLjg5MDYyNSAzNDAuMTU2MjUgTCA0ODEuODkwNjI1IDAgTCAwIDAgTCAwIDM0MC4xNTYyNSBaIE0gMCAzNDAuMTU2MjUgIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPGcgaWQ9InN1cmZhY2UwIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAxKSIgY2xpcC1ydWxlPSJub256ZXJvIj4KPHBhdGggc3R5bGU9IiBzdHJva2U6bm9uZTtmaWxsLXJ1bGU6IG5vbnplcm87IGZpbGw6IHJnYig2OSw1OSw5Nyk7IGZpbGwtb3BhY2l0eTogMTsiIGQ9Ik0gMCAzNDAuMTU2MjUgTCAxMTMuMzg2NzE5IDE3MC4wNzgxMjUgTCAwIDAgTCA4NS4wMzkwNjIgMCBMIDE5OC40MjU3ODEgMTcwLjA3ODEyNSBMIDg1LjAzOTA2MiAzNDAuMTU2MjUgTCAwIDM0MC4xNTYyNSBaIE0gMCAzNDAuMTU2MjUgIi8+CjxwYXRoIHN0eWxlPSIgc3Ryb2tlOm5vbmU7ZmlsbC1ydWxlOiBub256ZXJvOyBmaWxsOiByZ2IoOTUsODIsMTM0KTsgZmlsbC1vcGFjaXR5OiAxOyIgZD0iTSAxMTMuMzg2NzE5IDM0MC4xNTYyNSBMIDIyNi43NzM0MzggMTcwLjA3ODEyNSBMIDExMy4zODY3MTkgMCBMIDE5OC40MjU3ODEgMCBMIDQyNS4xOTUzMTIgMzQwLjE1NjI1IEwgMzQwLjE1NjI1IDM0MC4xNTYyNSBMIDI2OS4yOTI5NjkgMjMzLjg1OTM3NSBMIDE5OC40MjU3ODEgMzQwLjE1NjI1IEwgMTEzLjM4NjcxOSAzNDAuMTU2MjUgWiBNIDExMy4zODY3MTkgMzQwLjE1NjI1ICIvPgo8cGF0aCBzdHlsZT0iIHN0cm9rZTpub25lO2ZpbGwtcnVsZTogbm9uemVybzsgZmlsbDogcmdiKDE0Miw4MCwxMzgpOyBmaWxsLW9wYWNpdHk6IDE7IiBkPSJNIDM4Ny40MDIzNDQgMjQwLjk0NTMxMiBMIDM0OS42MDkzNzUgMTg0LjI1MzkwNiBMIDQ4MS44OTA2MjUgMTg0LjI1IEwgNDgxLjg5MDYyNSAyNDAuOTQ1MzEyIEwgMzg3LjQwMjM0NCAyNDAuOTQ1MzEyIFogTSAzODcuNDAyMzQ0IDI0MC45NDUzMTIgIi8+CjxwYXRoIHN0eWxlPSIgc3Ryb2tlOm5vbmU7ZmlsbC1ydWxlOiBub256ZXJvOyBmaWxsOiByZ2IoMTQyLDgwLDEzOCk7IGZpbGwtb3BhY2l0eTogMTsiIGQ9Ik0gMzMwLjcxMDkzOCAxNTUuOTA2MjUgTCAyOTIuOTE0MDYyIDk5LjIxNDg0NCBMIDQ4MS44OTA2MjUgOTkuMjEwOTM4IEwgNDgxLjg5MDYyNSAxNTUuOTA2MjUgTCAzMzAuNzEwOTM4IDE1NS45MDYyNSBaIE0gMzMwLjcxMDkzOCAxNTUuOTA2MjUgIi8+CjwvZz4KPC9nPgo8L3N2Zz4K alt="Haskell Logo" data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/haskell_logo.svg>
 </a>
 <button id=toggle-sidebar>
 Menu
 <hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>菜单</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></button>
 <ul class=sidebar-nav>
<ul>
<li><a href=#basics>Basics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#cabal>Cabal<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>阴谋</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#stack>Stack<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>堆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#flags>Flags<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>旗帜</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#hackage>Hackage<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>骇客</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#ghci>GHCi<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GHCi</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#editor-integration><font>Editor Integration</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>编辑器集成</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#bottoms>Bottoms<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>下装</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#exhaustiveness>Exhaustiveness<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>详尽无遗</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#debugger>Debugger<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>调试器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#stack-traces>Stack Traces<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>堆栈跟踪</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#trace>Trace<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>痕迹</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#type-holes>Type Holes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型孔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#deferred-type-errors><font>Deferred Type Errors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>延迟类型错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#ghcid>ghcid<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ghcid</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#haddock>Haddock<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>黑线鳕</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#monads>Monads<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#eightfold-path-to-monad-satori><font>Eightfold Path to Monad Satori</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通向单悟的八正道</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monadic-myths>Monadic Myths<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>一元神话</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monadic-methods>Monadic Methods<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子方法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#laws>Laws<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>法律</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#do-notation>Do Notation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>做符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#maybe>Maybe<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>或许</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#list>List<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#io>IO<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>输入输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#whats-the-point><font>What's the point?</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重点是什么？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#reader-monad>Reader Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>读者单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#writer-monad>Writer Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>作家莫纳德</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#state-monad>State Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>状态单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monad-tutorials>Monad Tutorials<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#monad-transformers><font>Monad Transformers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#mtl-transformers><font>mtl / transformers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>mtl/变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#transformers><font>Transformers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#basics-1><font>Basics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#readert><font>ReaderT</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>读者T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#newtype-deriving><font>Newtype Deriving</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>新型派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#efficiency><font>Efficiency</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>效率</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monad-morphisms><font>Monad Morphisms</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子态射</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#language-extensions><font>Language Extensions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#the-benign><font>The Benign</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>良性的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#the-dangerous><font>The Dangerous</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>危险的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#type-inference><font>Type Inference</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型推断</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monomorphism-restriction><font>Monomorphism Restriction</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#extended-defaulting><font>Extended Defaulting</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>延长违约</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#safe-haskell><font>Safe Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#partial-type-signatures><font>Partial Type Signatures</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>部分类型签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#recursive-do><font>Recursive Do</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>递归做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#applicative-do><font>Applicative Do</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>应用做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#pattern-guards><font>Pattern Guards</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模式守卫</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#viewpatterns><font>ViewPatterns</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>查看模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#tuplesections><font>TupleSections</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>元组部分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#multiwayif><font>MultiWayIf</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MultiWayIf</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#emptycase><font>EmptyCase</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>空箱子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#lambdacase><font>LambdaCase</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Lambda案例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#numdecimals><font>NumDecimals</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>小数位数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#packageimports><font>PackageImports</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>包裹进口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#recordwildcards><font>RecordWildCards</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>记录万能牌</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#namedfieldpuns><font>NamedFieldPuns</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>命名字段双关语</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#patternsynonyms><font>PatternSynonyms</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模式同义词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#derivetraversable><font>DeriveTraversable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>导出Traversable</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#derivefoldable><font>DeriveFoldable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Derive可折叠</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#derivefunctor><font>DeriveFunctor</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>派生函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#derivegeneric><font>DeriveGeneric</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>派生泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#deriveanyclass><font>DeriveAnyClass</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>派生类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#staticpointers><font>StaticPointers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>静态指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#duplicaterecordfields><font>DuplicateRecordFields</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重复记录字段</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#overloadedlabels><font>OverloadedLabels</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#cpp><font>Cpp</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Cpp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#historical-extensions><font>Historical Extensions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>历史延伸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#type-classes>Type Classes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#minimal-annotations><font>Minimal Annotations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>最少的注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#flexibleinstances>FlexibleInstances<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>弹性实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#flexiblecontexts>FlexibleContexts<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>灵活上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#overlappinginstances><font>OverlappingInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重叠实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#incoherentinstances><font>IncoherentInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>不相干实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#typesynonyminstances><font>TypeSynonymInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>TypeSynonymInstances</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#laziness>Laziness<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>懒惰</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#strictness>Strictness<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#seq-and-whnf><font>Seq and WHNF</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序列和 WHNF</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#strictness-annotations><font>Strictness Annotations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#strict-haskell>Strict Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格的 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#deepseq>Deepseq<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>深度测序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#irrefutable-patterns><font>Irrefutable Patterns</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>无可辩驳的模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#prelude>Prelude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序幕</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#what-to-avoid><font>What to Avoid?</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>要避免什么？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#what-should-be-in-base><font>What Should be in Base</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基地应该有什么</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#custom-preludes>Custom Preludes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>定制前奏曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#protolude>Protolude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#partial-functions>Partial Functions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>偏函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#safe>Safe<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#boolean-blindness>Boolean Blindness<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>布尔盲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#foldable-traversable><font>Foldable / Traversable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可折叠/可穿越</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#corecursion>Corecursion<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>核心游说</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#split>split<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>分裂</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monad-loops>monad-loops<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子循环</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#foundation>Foundation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基础</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#strings>Strings<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#string>String<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>细绳</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#import-conventions><font>Import Conventions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>导入约定</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#text>Text<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#text.builder>Text.Builder<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>文本生成器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#bytestring>ByteString<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#utf8-string>utf8-string<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>utf8 字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#base64-bytestring>base64-bytestring<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>base64字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#printf>Printf<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>打印</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#overloaded-lists>Overloaded Lists<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#string-conversions><font>String Conversions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字符串转换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#applicatives>Applicatives<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>应用程序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#alternative>Alternative<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>选择</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#arrows>Arrows<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>箭头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#bifunctors>Bifunctors<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>双函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#polyvariadic-functions><font>Polyvariadic Functions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多元函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#error-handling>Error Handling<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>错误处理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#control.exception>Control.Exception<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>控制异常</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#exceptions>Exceptions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>例外情况</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#exceptt>ExceptT<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>除了T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#spoon>spoon<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>勺子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#safe-exceptions>safe-exceptions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全异常</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#advanced-monads>Advanced Monads<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高级单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#function-monad>Function Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>函数单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#rws-monad>RWS Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>RWS Monad</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#cont>Cont<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>续</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monadplus>MonadPlus<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MonadPlus</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monadfix>MonadFix<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MonadFix</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#st-monad>ST Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>圣莫纳德</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#free-monads>Free Monads<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>免费单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#indexed-monads>Indexed Monads<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>索引单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#lifted-base>lifted-base<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>提升基地</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#quantification>Quantification<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#universal-quantification><font>Universal Quantification</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#free-theorems>Free theorems<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自由定理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#type-systems>Type Systems<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型系统</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#rank-n-types>Rank-N Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>N 阶类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#existential-quantification><font>Existential Quantification</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>存在量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#impredicative-types><font>Impredicative Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>指示类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#scoped-type-variables><font>Scoped Type Variables</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>作用域类型变量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#gadts>GADTs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#gadts-1>GADTs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#kind-signatures>Kind Signatures<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>亲切签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#void>Void<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>空白</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#phantom-types>Phantom Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>幻影类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#typelevel-operations><font>Typelevel Operations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级操作</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#interpreters>Interpreters<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>口译员</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#hoas>HOAS<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>HOAS</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#phoas>PHOAS<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>恐惧症</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#final-interpreters><font>Final Interpreters</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>最终口译员</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#finally-tagless>Finally Tagless<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>终于无标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#datatypes>Datatypes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#f-algebras>F-Algebras<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>F代数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#recursion-schemes>recursion-schemes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>递归方案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#data-types-%C3%A0-la-carte><font>Data types à la carte</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据类型按菜单点菜</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#hint-and-mueval><font>Hint and Mueval</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>提示和穆瓦尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#testing>Testing<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>测试</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#quickcheck>QuickCheck<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>快速检查</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#smallcheck>SmallCheck<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>小支票</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#quickspec>QuickSpec<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>快速规格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#criterion>Criterion<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>标准</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#tasty>Tasty<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#silently>silently<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>默默</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#type-families>Type Families<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#multiparam-typeclasses><font>MultiParam Typeclasses</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#type-families-1>Type Families<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#injectivity>Injectivity<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>内射性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#roles>Roles<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>角色</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monotraversable>Monotraversable<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可单行</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#nonempty>NonEmpty<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>非空</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#overloaded-lists-1>Overloaded Lists<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#manual-proofs>Manual Proofs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>人工校样</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#constraint-kinds>Constraint Kinds<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>约束种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#typefamilydependencies><font>TypeFamilyDependencies</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型FamilyDependencies</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#promotion>Promotion<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>晋升</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#higher-kinded-types><font>Higher Kinded Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高等类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#kind-polymorphism>Kind Polymorphism<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>种类多态性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#data-kinds>Data Kinds<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#size-indexed-vectors><font>Size-Indexed Vectors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>大小索引载体</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#typelevel-numbers>Typelevel Numbers<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级数字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#typelevel-strings>Typelevel Strings<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#custom-errors>Custom Errors<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自定义错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#type-equality>Type Equality<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型相等</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#proxies>Proxies<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#promoted-syntax>Promoted Syntax<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>提升语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#singleton-types>Singleton Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单例类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#closed-type-families><font>Closed Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>封闭式家庭</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#kind-indexed-type-families><font>Kind Indexed Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>种类索引类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#promoted-symbols>Promoted Symbols<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>推广符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#hlists>HLists<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>H列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#typelevel-dictionaries><font>Typelevel Dictionaries</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级词典</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#advanced-proofs>Advanced Proofs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高级证明</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#liquid-haskell>Liquid Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Liquid Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#generics>Generics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#typeable>Typeable<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可打字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#dynamic>Dynamic<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>动态的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#data>Data<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#syb>Syb<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>赛博</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#generic>Generic<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#generic-deriving>Generic Deriving<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#generics-sop>generics-sop<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>仿制药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#uniplate>Uniplate<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单板</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#mathematics>Mathematics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数学</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#numeric-tower>Numeric Tower<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数字塔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#integer>Integer<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#complex>Complex<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>复杂的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#scientific>Scientific<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>科学的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#statistics>Statistics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>统计数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#constructive-reals><font>Constructive Reals</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>构造实数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#sat-solvers>SAT Solvers<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>SAT 求解器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#smt-solvers>SMT Solvers<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>SMT求解器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#z3>Z3<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Z3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#data-structures>Data Structures<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据结构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#map>Map<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>地图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#tree>Tree<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>树</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#set>Set<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>放</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#vector>Vector<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#mutable-vectors>Mutable Vectors<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可变向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#unordered-containers><font>Unordered-Containers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>无序容器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#hashtables>Hashtables<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哈希表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#graphs>Graphs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#graph-theory>Graph Theory<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图论</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#dlist>DList<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#sequence>Sequence<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>顺序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#ffi>FFI<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#pure-functions>Pure Functions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>纯函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#storable-arrays>Storable Arrays<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可存储数组</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#function-pointers>Function Pointers<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>函数指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#concurrency>Concurrency<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>并发</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#sparks>Sparks<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>火花</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#threadscope>Threadscope<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>线程范围</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#strategies>Strategies<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>攻略</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#stm>STM<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>STM</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#monad-par>Monad Par<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单价单价</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#async>async<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>异步</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#graphics>Graphics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图形</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#diagrams>Diagrams<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#parsing>Parsing<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#parsec>Parsec<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>秒差距</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#custom-lexer>Custom Lexer<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自定义词法分析器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#simple-parsing>Simple Parsing<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>简单解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#generic-parsing>Generic Parsing<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#attoparsec>Attoparsec<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>阿托秒差距</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#optparse-applicative><font>Optparse Applicative</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Optparse 应用程序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#happy-alex><font>Happy &amp; Alex</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>快乐 &amp; 亚历克斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#configurator>Configurator<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>配置器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#streaming>Streaming<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>串流</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#lazy-io>Lazy IO<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>惰性输入输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#pipes>Pipes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>管道</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#safe-pipes>Safe Pipes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全管道</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#conduits>Conduits<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>导管</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#cryptography>Cryptography<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>密码学</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#cryptonite>cryptonite<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>隐晶石</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#entropy>entropy<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>熵</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#memory>memory<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>记忆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#crypto-pubkey>crypto-pubkey<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>加密公钥</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#crypto-api>crypto-api<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>加密API</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#x509>x509<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>x509</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#ed25519>ed25519<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ed25519</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#compression>Compression<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>压缩</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#lz4>lz4<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>lz4</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#zlib>zlib<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>zlib</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#data-formats>Data Formats<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据格式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#json>JSON<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>JSON</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#yaml>Yaml<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>山药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#csv>CSV<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>CSV文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#network-web-programming><font>Network &amp; Web Programming</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>网络与网络编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#http><font>HTTP</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>HTTP</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#blaze><font>Blaze</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>火焰</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#warp><font>Warp</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>经</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#scotty><font>Scotty</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>斯科蒂</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#servant><font>Servant</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>仆人</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#hastache><font>Hastache</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>黑芝麻</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#databases>Databases<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据库</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#postgres>Postgres<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Postgres</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#redis>Redis<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>雷迪斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#acid-state>Acid State<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>酸性状态</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#ghc>GHC<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>全球健康中心</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#block-diagram>Block Diagram<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>框图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#core>Core<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>核</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#inliner>Inliner<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>内胆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#dictionaries>Dictionaries<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>词典</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#specialization>Specialization<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>专业化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#static-compilation><font>Static Compilation</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>静态编译</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#unboxed-types>Unboxed Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未装箱类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#iost>IO/ST<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>输入/输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#ghc-heap-view>ghc-heap-view<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ghc 堆视图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#stg>STG<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>STG</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#workerwrapper>Worker/Wrapper<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>工人/包装</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#z-encoding>Z-Encoding<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Z编码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#cmm>Cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>厘米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#optimization-hacks><font>Optimization Hacks</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>优化技巧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#interface-files>Interface Files<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>接口文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#profiling>Profiling<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>剖析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#ekg>EKG<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>心电图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#rts-profiling>RTS Profiling<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>RTS 分析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#languages>Languages<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#unbound>unbound<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未绑定</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#unbound-generics>unbound-generics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未绑定泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#llvm-general>llvm-general<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>llvm-通用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#pretty>pretty<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>漂亮的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#wl-pprint-text>wl-pprint-text<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>wl-pprint-文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#pretty-show>pretty-show<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>漂亮秀</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#haskeline>Haskeline<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哈士奇林</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#repline>Repline<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>回复</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#template-haskell>Template Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#perils-of-metaprogramming><font>Perils of Metaprogramming</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>元编程的危险</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#quasiquotation>Quasiquotation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>准报价</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#language-c-quote>language-c-quote<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言-c-引用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#template-haskell-1>Template Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#antiquotation>Antiquotation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>反报价</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#templated-type-families><font>Templated Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板化类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#templated-type-classes><font>Templated Type Classes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板化类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#multiline-strings>Multiline Strings<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多行字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#git-embed>git-embed<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>git 嵌入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#categories>Categories<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#algebraic-relations><font>Algebraic Relations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代数关系</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#categories-1>Categories<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#isomorphisms>Isomorphisms<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>同构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#duality>Duality<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>二元性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#functors>Functors<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#natural-transformations><font>Natural Transformations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自然变换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#adjunctions>Adjunctions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>附属词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#yoneda-lemma>Yoneda Lemma<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>米田引理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#kleisli-category>Kleisli Category<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>克莱斯利类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#resources>Resources<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>资源</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#other-languages>Other Languages<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>其他语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a><ul>
<li><a href=#haskell>Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#ocaml>OCaml<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>OCaml</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#standard-ml>Standard ML<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>标准机器学习</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#agda>Agda<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>阿格达</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#coq>Coq<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>辅酶Q</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#idris>Idris<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>伊德里斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#rust>Rust<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>锈</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#purescript>Purescript<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>纯文字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#elm>Elm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>榆树</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#python>Python<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Python</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#r>R<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>R</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#julia>Julia<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>茱莉亚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#erlang>Erlang<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>二郎</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#elixer>Elixer<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>长生不老药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#java>Java<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>爪哇</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#clojure>Clojure<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Clojure 语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#swift>Swift<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>迅速</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#scheme>Scheme<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>方案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#racket>Racket<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>球拍</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#c>C#<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>C＃</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#f>F#<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>F＃</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#c-1>C++<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>C++</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#go>Go<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>去</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#scala>Scala<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>斯卡拉</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#javascript>Javascript<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Javascript</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#kotlin>Kotlin<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>科特林</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#php>PHP<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>PHP</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#perl>Perl<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Perl</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=#lua>Lua<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Lua</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul></li>
<li><a href=#code>Code<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
 </ul>
 </div>
 <div id=main-wrapper>
 <div id=main>
 <h1 class=document-title itemprop=name><font>
 What I Wish I Knew When Learning Haskell
 </font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>学习 HASKELL 时我希望知道的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
 <p itemprop=version class=document-version><font>
 Version
 </font><span class=version>2.3</span><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>版本 2.3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result>
 </p>
<hr>
<p><font>% Stephen Diehl % March 2016</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>% Stephen Diehl % 2016 年 3 月</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Stephen Diehl (</font><a class=author href=https://twitter.com/smdiehl><span class=citation>@smdiehl</span></a><font> )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>斯蒂芬·迪尔 (@smdiehl)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>This is the fourth draft of this document.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是本文件的第四稿。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong><a href=https://smunix.github.io/dev.stephendiehl.com/hask/tutorial.pdf>PDF Version<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>PDF版本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></strong></p>
<h4 id=license><font>License</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>执照</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>This code and text are dedicated to the public domain. You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此代码和文本专用于公共领域。您可以复制、修改、分发和执行作品，甚至可以用于商业目的，所有这些都无需征得许可。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>You may copy and paste any code here verbatim into your codebase, wiki, blog, book or Haskell musical production as you see fit. The Markdown and Haskell source is </font><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src>available on Github</a><font>. Pull requests are always accepted for changes and additional content. This is a living document.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>您可以将此处的任何代码逐字复制并粘贴到您认为合适的代码库、wiki、博客、书籍或 Haskell 音乐作品中。 Github 上提供了 Markdown 和 Haskell 源代码。始终接受更改和附加内容的拉取请求。这是一份活文件。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=changelog><font>Changelog</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>变更日志</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><strong>2.4</strong></p>
<p><strong>2.3</strong></p>
<ul>
<li><font>Stack</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>堆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Stackage</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>堆叠</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>ghcid</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghcid</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Nix (Removed)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尼克斯（已移除）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Aeson (Updated)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>永生 (更新)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Language Extensions (Updated)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语言扩展（更新）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Type Holes (Updated)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型孔（更新）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Partial Type Signatures</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>部分类型签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Pattern Synonyms (Updated)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模式同义词（更新）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Unboxed Types ( Updated )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未装箱类型（更新）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Vim Integration ( Updated )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Vim 集成（更新）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Emacs Integration ( Updated )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Emacs 集成（更新）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Strict Language Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格的语言扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Injective Type Families</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>内射类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Custom Type Errors</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自定义类型错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Language Comparisons</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语言比较</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Recursive Do</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>递归做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Applicative Do</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>应用做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>LiquidHaskell</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>LiquidHaskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Cpp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cpp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Minimal Pragma</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最小语用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Typeclass Extensions</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>ExtendedDefaultRules</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>扩展默认规则</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>mmorph</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>变形</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>integer-gmp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>整数gmp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Static Pointers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>静态指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>spoon</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>勺子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>monad-control</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子控制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>monad-base</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子基础</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>postgresql-simple</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>postgresql-简单</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>hedis</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>赫迪斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>happy/alex</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>快乐/亚历克斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>configurator</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>配置器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>string-conv</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字符串转换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>resource-pool</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>资源池</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>resourcet</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>资源</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>optparse-applicative</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>optparse-applicative</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>hastache</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>胡须</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>silently</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默默</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Mulitiline Strings</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>多行字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>git-embed</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>git 嵌入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Coercible</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>强制的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>-fdefer-type-errors</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fdefer 类型错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><strong>2.2</strong></p>
<p><font>Sections that have had been added or seen large changes:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>已添加或看到较大更改的部分：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Irrefutable Patterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>无可辩驳的模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Hackage</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>骇客</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Exhaustiveness</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>详尽无遗</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Stacktraces</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>堆栈跟踪</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Laziness</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>懒惰</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Skolem Capture</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>斯科林捕获</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Foreign Function Pointers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外部函数指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Attoparsec Parser</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>阿托秒解析器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Inline Cmm</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>内联三坐标</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>PrimMonad</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>PrimMonad</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Specialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专业化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>unbound-generics</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未绑定泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Editor Integration</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>编辑器集成</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>EKG</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>心电图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Nix</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尼克斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Haddock</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>黑线鳕</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Corecursion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>核心游说</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Category</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Arrows</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>箭头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Bifunctors</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>ExceptT</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>除了T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>hint / mueval</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>提示/mueval</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Roles</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>角色</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Higher Kinds</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>高等种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Kind Polymorphism</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>种类多态性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Numeric Tower</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数字塔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>SAT Solvers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SAT 求解器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Graph</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>图形</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Sparks</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>火花</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Threadscope</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>线程范围</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Generic Parsers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通用解析器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>GHC Block Diagram</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 框图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>GHC Debug Flags</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 调试标志</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Core</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>核</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Inliner</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>内胆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Unboxed Types</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未装箱类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Runtime Memory Representation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>运行时内存表示</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>ghc-heapview</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghc-heapview</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>STG</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>STG</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Worker/Wrapper</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>工人/包装</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Z-Encoding</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z编码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Cmm</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Runtime Optimizations</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>运行时优化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>RTS Profiling</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>RTS 分析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Algebraic Relations</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>代数关系</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<hr>
<h1 id=basics><font>Basics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=cabal><font>Cabal</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>阴谋</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-success">
<p><font>Historically Cabal had a component known as </font><code>cabal-install</code><font> that has largely been replaced by </font><a href=#stack>Stack</a><font>. The following use of Cabal sandboxes is left for historical reasons and can often be replaced by modern tools.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从历史上看，Cabal 有一个称为 cabal-install 的组件，它在很大程度上已被 Stack 取代。以下使用 Cabal 沙箱是由于历史原因而留下的，通常可以用现代工具代替。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><a href=https://www.haskell.org/cabal/>Cabal</a><font> is the build system for Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cabal 是 Haskell 的构建系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example, to install the </font><a href=http://hackage.haskell.org/package/parsec>parsec</a><font> package to your system from </font><a href=#hackage>Hackage</a><font>, the upstream source of Haskell packages, invoke the </font><code>install</code><font> command:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，要将 parsec 包从 Haskell 包的上游源 Hackage 安装到您的系统，请调用安装命令：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> install parsec           <span class=co># latest version</span>
$ <span class=kw>cabal</span> install parsec==3.1.5    <span class=co># exact version</span></code></pre></div>
<p><font>The usual build invocation for Haskell packages is the following:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 包的通常构建调用如下：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> get parsec    <span class=co># fetch source</span>
$ <span class=kw>cd</span> parsec-3.1.5

$ <span class=kw>cabal</span> configure
$ <span class=kw>cabal</span> build
$ <span class=kw>cabal</span> install</code></pre></div>
<p><font>To update the package index from Hackage, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要从 Hackage 更新包索引，请运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> update</code></pre></div>
<p><font>To start a new Haskell project, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要开始一个新的 Haskell 项目，运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> init
$ <span class=kw>cabal</span> configure</code></pre></div>
<p><font>A </font><code>.cabal</code><font> file will be created with the configuration options for our new project.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将使用我们新项目的配置选项创建一个 .cabal 文件。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The latest feature of </font><code>cabal</code><font> is the addition of </font><a href=http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html>Sandboxes</a><font>, ( in cabal &gt; 1.18 ) which are self contained environments of Haskell packages separate from the global package index stored in the </font><code>./.cabal-sandbox</code><font> of our project's root. To create a new </font><code>sandbox</code><font> for our </font><code>cabal</code><font> project, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>cabal 的最新特性是添加了沙盒（在 cabal &gt; 1.18 中），它们是 Haskell 包的自包含环境，与存储在我们项目根目录的 ./.cabal-sandbox 中的全局包索引分开。要为我们的 cabal 项目创建一个新的沙箱，请运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> sandbox init</code></pre></div>
<p><font>Additionally, the </font><code>sandbox</code><font> can be torn down:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此外，可以拆除沙箱：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> sandbox delete</code></pre></div>
<p><font>When in the working directory of a project with a </font><code>sandbox</code><font> that has a configuration already set up, invoking </font><code>cabal</code><font> commands alters the behaviour of cabal itself. For instance, the </font><code>cabal install</code><font> command will alter only the install to the local package index, not the global configuration.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当在具有已设置配置的沙箱的项目的工作目录中时，调用 cabal 命令会改变 cabal 本身的行为。例如，cabal install 命令只会改变安装到本地包索引，而不是全局配置。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To install the dependencies from the </font><code>.cabal</code><font> file into the newly created </font><code>sandbox</code><font>, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要将 .cabal 文件中的依赖项安装到新创建的沙箱中，请运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> install --only-dependencies</code></pre></div>
<p><font>Dependencies can also be built in parallel by passing </font><code>-j&lt;n&gt;</code><font> where </font><code>n</code><font> is the number of concurrent builds.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>依赖项也可以通过传递 -j&lt;n&gt; 来并行构建，其中 n 是并发构建的数量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> install -j4 --only-dependencies</code></pre></div>
<p><font>Let's look at an example </font><code>.cabal</code><font> file. There are two main entry points that any package may provide: a </font><code>library</code><font> and an </font><code>executable</code><font>. Multiple executables can be defined, but only one library. In addition, there is a special form of executable entry point </font><code>Test-Suite</code><font>, which defines an interface for invoking unit tests from </font><code>cabal</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>让我们看一个示例 .cabal 文件。任何包都可能提供两个主要入口点：库和可执行文件。可以定义多个可执行文件，但只能定义一个库。此外，还有一种特殊形式的可执行入口点Test-Suite，它定义了一个从cabal调用单元测试的接口。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For a library, the </font><code>exposed-modules</code><font> field in the </font><code>.cabal</code><font> file indicates which modules within the package structure will be publicly visible when the package is installed. These modules are the user-facing APIs that we wish to expose to downstream consumers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于库，.cabal 文件中的 exposed-modules 字段指示包结构中的哪些模块在安装包时将公开可见。这些模块是我们希望向下游消费者公开的面向用户的 API。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For an executable, the </font><code>main-is</code><font> field indicates the module that exports the </font><code>main</code><font> function running the executable logic of the application. Every module in the package must be listed in one of </font><code>other-modules</code><font>, </font><code>exposed-modules</code><font> or </font><code>main-is</code><font> fields.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于可执行文件，main-is 字段指示导出运行应用程序可执行逻辑的主要功能的模块。包中的每个模块都必须列在 other-modules、exposed-modules 或 main-is 字段之一中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>name</span>:               mylibrary
<span class=kw>version</span>:            0.1
<span class=kw>cabal-version</span>:      <span class=kw>&gt;</span>= 1.10
<span class=kw>author</span>:             Paul Atreides
<span class=kw>license</span>:            MIT
<span class=kw>license-file</span>:       LICENSE
<span class=kw>synopsis</span>:           The code must flow.
<span class=kw>category</span>:           Math
<span class=kw>tested-with</span>:        GHC
<span class=kw>build-type</span>:         Simple

<span class=kw>library</span>
    <span class=kw>exposed-modules</span>:
      <span class=kw>Library.ExampleModule1</span>
      <span class=kw>Library.ExampleModule2</span>

    <span class=kw>build-depends</span>:
      <span class=kw>base</span> <span class=kw>&gt;</span>= 4 <span class=kw>&amp;&amp;</span> <span class=kw>&lt;</span> <span class=kw>5</span>

    <span class=kw>default-language</span>: Haskell2010

    <span class=kw>ghc-options</span>: -O2 -Wall -fwarn-tabs

<span class=kw>executable</span> <span class=st>"example"</span>
    <span class=kw>build-depends</span>:
        <span class=kw>base</span> <span class=kw>&gt;</span>= 4 <span class=kw>&amp;&amp;</span> <span class=kw>&lt;</span> <span class=kw>5</span>,
        <span class=kw>mylibrary</span> == 0.1
    <span class=kw>default-language</span>: Haskell2010
    <span class=kw>main-is</span>: Main.hs

<span class=kw>Test-Suite</span> test
  <span class=kw>type</span>: exitcode-stdio-1.0
  <span class=kw>main-is</span>: Test.hs
  <span class=kw>default-language</span>: Haskell2010
  <span class=kw>build-depends</span>:
      <span class=kw>base</span> <span class=kw>&gt;</span>= 4 <span class=kw>&amp;&amp;</span> <span class=kw>&lt;</span> <span class=kw>5</span>,
      <span class=kw>mylibrary</span> == 0.1</code></pre></div>
<p><font>To run an "executable" for a project under the </font><code>cabal</code> <code>sandbox</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 cabal 沙箱下为项目运行“可执行文件”：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> run
$ <span class=kw>cabal</span> run <span class=kw>&lt;</span>name<span class=kw>&gt;</span> <span class=co># when there are several executables in a project</span></code></pre></div>
<p><font>To load the "library" into a </font><a href=#ghci>GHCi</a><font> shell under </font><code>cabal</code> <code>sandbox</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将“库”加载到 cabal 沙箱下的 GHCi shell 中：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> repl
$ <span class=kw>cabal</span> repl <span class=kw>&lt;</span>name<span class=kw>&gt;</span></code></pre></div>
<p><font>The </font><code>&lt;name&gt;</code><font> metavariable is either one of the executable or library declarations in the </font><code>.cabal</code><font> file and can optionally be disambiguated by the prefix </font><code>exe:&lt;name&gt;</code><font> or </font><code>lib:&lt;name&gt;</code><font> respectively.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>&lt;name&gt; 元变量是 .cabal 文件中的可执行文件或库声明之一，可以选择分别通过前缀 exe:&lt;name&gt; 或 lib:&lt;name&gt; 来消除歧义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To build the package locally into the </font><code>./dist/build</code><font> folder, execute the </font><code>build</code><font> command:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要在本地将包构建到 ./dist/build 文件夹中，请执行构建命令：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> build</code></pre></div>
<p><font>To run the tests, our package must itself be reconfigured with the </font><code>--enable-tests</code><font> and the </font><code>build-depends</code><font> options. The </font><code>Test-Suite</code><font> must be installed manually, if not already present.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要运行测试，我们的包本身必须使用 --enable-tests 和 build-depends 选项重新配置。如果测试套件不存在，则必须手动安装。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> install --only-dependencies --enable-tests
$ <span class=kw>cabal</span> configure --enable-tests
$ <span class=kw>cabal</span> test
$ <span class=kw>cabal</span> test <span class=kw>&lt;</span>name<span class=kw>&gt;</span></code></pre></div>
<p><font>Moreover, arbitrary shell commands can be invoked with the </font><a href=https://www.haskell.org/ghc/>GHC</a><font> environmental variables set up for the </font><code>sandbox</code><font>. Quite common is to invoke a new shell with this command such that the </font><code>ghc</code><font> and </font><code>ghci</code><font> commands use the </font><code>sandbox</code><font>. ( They don't by default, which is a common source of frustration. ).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此外，可以使用为沙箱设置的 GHC 环境变量调用任意 shell 命令。很常见的是用这个命令调用一个新的 shell，这样 ghc 和 ghci 命令就可以使用沙箱。 （默认情况下他们不这样做，这是令人沮丧的常见原因。）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> exec
$ <span class=kw>cabal</span> exec sh <span class=co># launch a shell with GHC sandbox path set.</span></code></pre></div>
<p><font>The </font><a href=#haddock>haddock</a><font> documentation can be generated for the local project by executing the </font><code>haddock</code><font> command. The documentation will be built to the </font><code>./dist</code><font> folder.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以通过执行 haddock 命令为本地项目生成黑线鳕文档。文档将构建到 ./dist 文件夹中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> haddock</code></pre></div>
<p><font>When we're finally ready to upload to Hackage ( presuming we have a Hackage account set up ), then we can build the tarball and upload with the following commands:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当我们最终准备好上传到 Hackage 时（假设我们已经设置了 Hackage 帐户），然后我们可以构建 tarball 并使用以下命令上传：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> sdist
$ <span class=kw>cabal</span> upload dist/mylibrary-0.1.tar.gz</code></pre></div>
<p><font>Sometimes you'd also like to add a library from a local project into a </font><code>sandbox</code><font>. In this case, run the </font><code>add-source</code><font> command to bring the library into the </font><code>sandbox</code><font> from a local directory:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有时您还想将本地项目中的库添加到沙箱中。在这种情况下，运行 add-source 命令将库从本地目录引入沙箱：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> sandbox add-source /path/to/project</code></pre></div>
<p><font>The current state of a </font><code>sandbox</code><font> can be frozen with all current package constraints enumerated:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以使用枚举的所有当前包约束来冻结沙箱的当前状态：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>cabal</span> freeze</code></pre></div>
<p><font>This will create a file </font><code>cabal.config</code><font> with the constraint set.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这将创建一个带有约束集的文件 cabal.config。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">constraints<span class=fu>:</span> mtl <span class=fu>==</span><span class=fl>2.2</span><span class=fu>.</span><span class=dv>1</span>,
             text <span class=fu>==</span><span class=fl>1.1</span><span class=fu>.</span><span class=fl>1.3</span>,
             transformers <span class=fu>==</span><span class=fl>0.4</span><span class=fu>.</span><span class=fl>1.0</span></code></pre></div>
<p><font>Using the </font><code>cabal repl</code><font> and </font><code>cabal run</code><font> commands is preferable, but sometimes we'd like to manually perform their equivalents at the shell. Several useful aliases rely on shell directory expansion to find the package database in the current working directory and launch GHC with the appropriate flags:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最好使用 cabal repl 和 cabal run 命令，但有时我们希望在 shell 中手动执行它们的等效命令。几个有用的别名依赖于 shell 目录扩展来在当前工作目录中找到包数据库并使用适当的标志启动 GHC：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>alias</span> ghc-sandbox=<span class=st>"ghc -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"</span>
<span class=kw>alias</span> ghci-sandbox=<span class=st>"ghci -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"</span>
<span class=kw>alias</span> runhaskell-sandbox=<span class=st>"runhaskell -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"</span></code></pre></div>
<p><font>There is also a zsh script to show the sandbox status of the current working directory in our shell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>还有一个 zsh 脚本可以在我们的 shell 中显示当前工作目录的沙箱状态：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>function</span><span class=fu> cabal_sandbox_info()</span> <span class=kw>{</span>
    <span class=ot>cabal_files=(</span>*.cabal(N<span class=ot>)</span>)
    <span class=kw>if [</span> <span class=ot>$#</span>cabal_files <span class=ot>-gt</span> 0<span class=kw> ]</span>; <span class=kw>then</span>
        <span class=kw>if [</span> <span class=ot>-f</span> cabal.sandbox.config<span class=kw> ]</span>; <span class=kw>then</span>
            <span class=kw>echo</span> <span class=st>"%{</span><span class=ot>$fg[green]</span><span class=st>%}sandboxed%{</span><span class=ot>$reset_color</span><span class=st>%}"</span>
        <span class=kw>else</span>
            <span class=kw>echo</span> <span class=st>"%{</span><span class=ot>$fg[red]</span><span class=st>%}not sandboxed%{</span><span class=ot>$reset_color</span><span class=st>%}"</span>
        <span class=kw>fi</span>
    <span class=kw>fi</span>
<span class=kw>}</span>

<span class=ot>RPROMPT=</span><span class=st>"</span><span class=dt>\$</span><span class=st>(cabal_sandbox_info) </span><span class=ot>$RPROMPT</span><span class=st>"</span></code></pre></div>
<p><font>The </font><code>cabal</code><font> configuration is stored in </font><code>$HOME/.cabal/config</code><font> and contains various options including credential information for Hackage upload. One addition to configuration is to completely disallow the installation of packages outside of sandboxes to prevent accidental collisions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>cabal 配置存储在 $HOME/.cabal/config 中，包含各种选项，包括用于 Hackage 上传的凭证信息。配置的一项补充是完全禁止在沙箱外安装包，以防止意外碰撞。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode perl"><code class="sourceCode perl">-- Don<span class=kw>'</span><span class=st>t allow global install of packages.</span>
<span class=st>require-sandbox: True</span></code></pre></div>
<p><font>A library can also be compiled with runtime profiling information enabled. More on this is discussed in the section on </font><a href=#concurrency>Concurrency</a><font> and </font><a href=#profiling>Profiling</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>还可以在启用运行时分析信息的情况下编译库。有关更多信息，请参阅并发和分析部分。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode perl"><code class="sourceCode perl">library-profiling: True</code></pre></div>
<p><font>Another common flag to enable is </font><code>documentation</code><font> which forces the local build of Haddock documentation, which can be useful for offline reference. On a Linux filesystem these are built to the </font><code>/usr/share/doc/ghc-doc/html/libraries/</code><font> directory.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>另一个要启用的常见标志是强制在本地构建 Haddock 文档的文档，这对于离线参考很有用。在 Linux 文件系统上，这些被构建到 /usr/share/doc/ghc-doc/html/libraries/ 目录。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode perl"><code class="sourceCode perl">documentation: True</code></pre></div>
<p><font>If GHC is currently installed, the documentation for the Prelude and Base libraries should be available at this local link:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果当前安装了 GHC，Prelude 和 Base 库的文档应该可以在这个本地链接中找到：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><a href=file:///usr/share/doc/ghc-doc/html/libraries/index.html>/usr/share/doc/ghc-doc/html/libraries/index.html<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>/usr/share/doc/ghc-doc/html/libraries/index.html</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html>An Introduction to Cabal Sandboxes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Cabal 沙盒简介</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://www.vex.net/~trebla/haskell/sicp.xhtml>Storage and Identification of Cabalized Packages<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Cabalized包的存储和标识</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=stack><font>Stack</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>堆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><a href=http://docs.haskellstack.org/en/stable/README/>Stack</a><font> is a new approach to Haskell package structure that emerged in 2015. Instead of using a rolling build like </font><code>cabal-install</code><font>, </font><code>stack</code><font> breaks up sets of packages into release blocks that guarantee internal compatibility between sets of packages. The package solver for </font><code>stack</code><font> uses a different, more robust strategy for resolving dependencies than </font><code>cabal-install</code><font> has historically used.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Stack 是 2015 年出现的一种新的 Haskell 包结构方法。Stack 不是使用像 cabal-install 这样的滚动构建，而是将包集分解为发布块，以保证包集之间的内部兼容性。堆栈的包求解器使用一种不同的、比 cabal-install 历史上使用的更健壮的策略来解决依赖关系。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class="alert alert-success">
<p><font>Contrary to much misinformation, </font><strong>Stack does not replace <a href=#cabal>Cabal</a> as the build system</strong><font> and </font><a href=http://docs.haskellstack.org/en/stable/faq/#what-is-the-relationship-between-stack-and-cabal>uses it under the hood</a><font>. Stack simply streamlines integration with third-party packages and the resolution of their dependencies.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与许多错误信息相反，Stack 并没有取代 Cabal 作为构建系统，而是在底层使用它。 Stack 只是简化了与第三方包的集成以及它们的依赖关系的解析。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h4 id=install><font>Install</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安装</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>To install </font><code>stack</code><font> on Ubuntu Linux, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要在 Ubuntu Linux 上安装堆栈，请运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442                             <span class=co># get fp complete key</span>
<span class=kw>echo</span> <span class=st>'deb http://download.fpcomplete.com/ubuntu trusty main'</span><span class=kw>|sudo</span> tee /etc/apt/sources.list.d/fpco.list    <span class=co># add appropriate source repo</span>
<span class=kw>sudo</span> apt-get update <span class=kw>&amp;&amp;</span> <span class=kw>sudo</span> apt-get install stack -y</code></pre></div>
<p><font>For other operating systems, see </font><a href=http://docs.haskellstack.org/en/stable/install_and_upgrade/>the official install directions</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于其他操作系统，请参阅官方安装说明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=usage><font>Usage</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>用法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Once </font><code>stack</code><font> is installed, it is possible to setup a build environment on top of your existing project's </font><code>cabal</code><font> file by running:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安装堆栈后，可以通过运行以下命令在现有项目的 cabal 文件之上设置构建环境：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>stack</span> init</code></pre></div>
<p><font>An example </font><code>stack.yaml</code><font> file for </font><a href=https://www.haskell.org/ghc>GHC</a><font> 7.10.3 would look like:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 7.10.3 的示例 stack.yaml 文件如下所示：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>resolver</span>: lts-6.4
<span class=kw>flags</span>: <span class=dt>{}</span>
<span class=kw>extra-package-dbs</span>: []
<span class=kw>packages</span>: []
<span class=kw>extra-deps</span>: []</code></pre></div>
<p><font>Most of the common libraries used in everyday development are already in the </font><a href=https://www.stackage.org/>Stackage</a><font> repository. The </font><code>extra-deps</code><font> field can be used to add </font><a href=http://hackage.haskell.org/>Hackage</a><font> dependencies that are not in the Stackage repository. They are specified by the package and the version key. For instance, the </font><code>zenc</code><font> package could be added to the </font><code>stack</code><font> build:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>大多数日常开发中使用的常用库都已经在 Stackage 存储库中。 extra-deps 字段可用于添加不在 Stackage 存储库中的 Hackage 依赖项。它们由包和版本密钥指定。例如，可以将 zenc 包添加到堆栈构建中：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<pre><code>extra-deps:
- zenc-0.1.1</code></pre>
<p><font>The </font><code>stack</code><font> command can be used to install packages and executables into either the current build environment or the global environment. For example, the following command installs the executable for </font><code>hlint</code><font>, </font><a href=https://github.com/ndmitchell/hlint>a popular linting tool for Haskell</a><font>, and places it in the PATH:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>stack 命令可用于将包和可执行文件安装到当前构建环境或全局环境中。例如，以下命令安装 hlint 的可执行文件，这是一种流行的 Haskell linting 工具，并将其放在 PATH 中：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>stack</span> install hlint</code></pre></div>
<p><font>To check the set of dependencies, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要检查依赖项集，请运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>stack</span> list-dependencies</code></pre></div>
<p><font>Just as with </font><code>cabal</code><font>, the build and debug process can be orchestrated using </font><code>stack</code><font> commands:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就像 cabal 一样，构建和调试过程可以使用堆栈命令来编排：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>stack</span> build                 <span class=co># Build a cabal target</span>
$ <span class=kw>stack</span> repl                  <span class=co># Launch ghci</span>
$ <span class=kw>stack</span> ghc                   <span class=co># Invoke the standalone compiler in stack environment</span>
$ <span class=kw>stack</span> exec bash             <span class=co># Execute a shell command with the stack GHC environment variables</span>
$ <span class=kw>stack</span> build --file-watch    <span class=co># Build on every filesystem change</span></code></pre></div>
<p><font>To visualize the dependency graph, use the dot command piped first into graphviz, then piped again into your favorite image viewer:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要可视化依赖关系图，请使用首先通过管道传输到 graphviz 的 dot 命令，然后再次通过管道传输到您最喜欢的图像查看器：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>stack</span> dot --external <span class=kw>|</span> <span class=kw>dot</span> -Tpng <span class=kw>|</span> <span class=kw>feh</span> -</code></pre></div>
<h2 id=flags><font>Flags</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>旗帜</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Enabling </font><a href=https://www.haskell.org/ghc>GHC</a> <a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html>compiler flags</a><font> grants the user more control in detecting common code errors. The most frequently used flags are:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用 GHC 编译器标志可让用户在检测常见代码错误方面拥有更多控制权。最常用的标志是：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Flag</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>旗帜</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Description</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>-fwarn-tabs</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-tabs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Emit warnings of tabs instead of spaces in the source code</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>发出制表符警告而不是源代码中的空格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fwarn-unused-imports</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-未使用的进口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn about libraries imported without being used</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>警告有关导入但未使用的库</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>-fwarn-name-shadowing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-name-shadowing</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn on duplicate names in nested bindings</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>警告嵌套绑定中的重复名称</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fwarn-incomplete-uni-patterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-不完整的单向模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Emit warnings for incomplete patterns in lambdas or pattern bindings</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>针对 lambda 或模式绑定中的不完整模式发出警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>-fwarn-incomplete-patterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-不完整的模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn on non-exhaustive patterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对非详尽模式发出警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fwarn-overlapping-patterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-重叠模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn on pattern matching branches that overlap</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对重叠的模式匹配分支发出警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>-fwarn-incomplete-record-updates</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-不完整的记录更新</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn when records are not instantiated with all fields</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未使用所有字段实例化记录时发出警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fdefer-type-errors</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fdefer 类型错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Turn type errors into warnings</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将类型错误转化为警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>-fwarn-missing-signatures</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-缺少签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn about toplevel missing type signatures</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>关于顶层缺少类型签名的警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fwarn-monomorphism-restriction</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn when the monomorphism restriction is applied implicitly</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>隐式应用单态限制时发出警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>-fwarn-orphans</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fwarn-孤儿</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Warn on orphan typeclass instances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对孤立类型类实例发出警告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fforce-recomp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fforce-recomp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Force recompilation regardless of timestamp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>无论时间戳如何都强制重新编译</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>-fno-code</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fno代码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Omit code generation, just parse and typecheck</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>省略代码生成，仅解析和类型检查</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>-fobject-code</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-fobject 代码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Generate object code</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生成目标代码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Like most compilers, GHC takes the </font><code>-Wall</code><font> flag to enable all warnings. However, a few of the enabled warnings are highly verbose. For example, </font><code>-fwarn-unused-do-bind</code><font> and </font><code>-fwarn-unused-matches</code><font> typically would not correspond to errors or failures.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与大多数编译器一样，GHC 使用 -Wall 标志来启用所有警告。但是，一些启用的警告非常冗长。例如，-fwarn-unused-do-bind 和 -fwarn-unused-matches 通常不会对应于错误或失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Any of these flags can be added to the </font><code>ghc-options</code><font> section of a project's </font><code>.cabal</code><font> file. For example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些标志中的任何一个都可以添加到项目的 .cabal 文件的 ghc-options 部分。例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode perl"><code class="sourceCode perl">library mylib

  ghc-options:
    -fwarn-tabs
    -fwarn-unused-imports
    -fwarn-missing-signatures
    -fwarn-name-shadowing
    -fwarn-incomplete-patterns</code></pre></div>
<p><font>The flags described above are simply the most useful. See the </font><a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html>official reference</a><font> for the complete set of GHC's supported flags.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>上面描述的标志是最有用的。请参阅官方参考以获取完整的 GHC 支持标志集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For information on debugging GHC internals, see the </font><a href=#block-diagram>commentary</a><font> on GHC internals.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有关调试 GHC 内部的信息，请参阅 GHC 内部的评论。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=hackage><font>Hackage</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>骇客</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><a href=http://hackage.haskell.org/>Hackage</a><font> is the upstream source of </font><a href=https://smunix.github.io/dev.stephendiehl.com/hask/://www.fsf.org/about/what-is-free-software>Free</a><font> and/or </font><a href=https://opensource.org/>Open Source</a><font> Haskell packages. With Haskell's continuing evolution, Hackage has become many things to developers, but there seem to be two dominant philosophies of uploaded libraries.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Hackage 是免费和/或开源 Haskell 包的上游来源。随着 Haskell 的不断发展，Hackage 已成为开发人员的许多东西，但似乎有两种关于上传库的主导哲学。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Reusable Code / Building Blocks<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可重用代码/构建块</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>In the first philosophy, libraries exist as reliable, community-supported building blocks for constructing higher level functionality on top of a common, stable edifice. In development communities where this method is the dominant philosophy, the author(s) of libraries have written them as a means of packaging up their understanding of a problem domain so that others can build on their understanding and expertise.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在第一种理念中，图书馆作为可靠的、社区支持的构建块存在，用于在公共、稳定的大厦之上构建更高级别的功能。在以这种方法为主导理念的开发社区中，库的作者编写它们作为打包他们对问题领域的理解的一种方式，以便其他人可以建立在他们的理解和专业知识的基础上。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>A Staging Area / Request for Comments<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>暂存区/征求意见</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>In contrast to the previous method of packaging, a common philosophy in the Haskell community is that Hackage is a place to upload experimental libraries as a means of getting community feedback and making the code publicly available. Library author(s) often rationalize putting these kind of libraries up undocumented, often without indication of what the library actually does, by simply stating that they intend to tear the code down and rewrite it later. This approach unfortunately means a lot of Hackage namespace has become polluted with dead-end, bit-rotting code. Sometimes packages are also uploaded purely for internal use within an organisation, to accompany a paper, or just to integrate with the </font><code>cabal</code><font> build system. These packages are often left undocumented as well.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与之前的打包方式相比，Haskell 社区的一个普遍理念是，Hackage 是一个上传实验库的地方，作为获得社区反馈和公开代码的一种方式。库的作者经常合理化将这些类型的库放在未记录的地方，通常没有说明库实际做了什么，只是简单地声明他们打算拆除代码并在以后重写。不幸的是，这种方法意味着很多 Hackage 命名空间已经被死胡同、比特腐烂的代码污染了。有时，上传包也纯粹供组织内部使用、随论文一起使用，或者只是为了与 cabal 构建系统集成。这些包通常也没有记录。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For developers coming to Haskell from other language ecosystems that favor the former philsophy (e.g., Python, Javascript, Ruby), seeing </font><em>thousands of libraries without the slightest hint of documentation or description of purpose</em><font> can be unnerving. It is an open question whether the current cultural state of Hackage is sustainable in light of these philsophical differences.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于从支持前哲学的其他语言生态系统（例如 Python、Javascript、Ruby）来到 Haskell 的开发人员来说，看到成千上万的库没有丝毫的文档提示或目的描述可能会令人不安。鉴于这些哲学差异，目前的 Hackage 文化状态是否可持续是一个悬而未决的问题。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Needless to say, there is a lot of very low-quality Haskell code and documentation out there today, so being conservative in library assessment is a necessary skill. That said, there are also quite a few phenomenal libraries on Hackage that are highly curated by many people.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不用说，今天有很多非常低质量的 Haskell 代码和文档，因此在库评估中保持保守是一项必要的技能。也就是说，Hackage 上也有不少非凡的库，它们受到许多人的精心策划。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>As a general rule, if the Haddock documentation for the library does not have a </font><strong>minimal worked example</strong><font>, it is usually safe to assume that it is an RFC-style library and probably should be avoided in production-grade code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作为一般规则，如果该库的 Haddock 文档没有最小的工作示例，通常可以安全地假设它是一个 RFC 样式的库，并且可能应该避免在生产级代码中使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Similarly, if the library </font><strong>predates the <a href=http://hackage.haskell.org/package/text>text</a> library</strong><font> (released circa 2007), it probably should be avoided in production code. The way we write Haskell has changed drastically since the early days.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>同样，如果该库早于文本库（大约 2007 年发布），则可能应该在生产代码中避免使用它。自早期以来，我们编写 Haskell 的方式发生了翻天覆地的变化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=ghci><font>GHCi</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GHCi</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><a href=https://wiki.haskell.org/GHC/GHCi>GHCi</a><font> is the interactive shell for the </font><a href=https://www.haskell.org/GHC>GHC</a><font> compiler. GHCi is where we will spend most of our time in every day development.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHCi 是 GHC 编译器的交互式 shell。 GHCi 是我们在日常开发中花费大部分时间的地方。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Command</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>命令</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Shortcut</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>捷径</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Action</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>行动</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>:reload<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：重新加载</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:r<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:r</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Code reload</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>代码重载</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>:type<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:t<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:t</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Type inspection</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>型式检验</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>:kind<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:k<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:k</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Kind inspection</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>实物检验</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>:info<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：信息</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:i<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：我</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Information</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>信息</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>:print<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：打印</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:p<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:p</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Print the expression</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>打印表达式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>:edit<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：编辑</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:e<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:e</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Load file in system editor</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在系统编辑器中加载文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>:load<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：加载</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:l<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:l</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Set the active Main module in the REPL</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 REPL 中设置活动主模块</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>:add<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：添加</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:ad<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：广告</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Load a file into the REPL namespace</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将文件加载到 REPL 命名空间</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>:browse<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：浏览</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:bro<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>：兄弟</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Browse all available symbols in the REPL namespace</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>浏览 REPL 命名空间中的所有可用符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>The introspection commands are an essential part of debugging and interacting with Haskell code:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自省命令是调试和与 Haskell 代码交互的重要部分：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span><span class=kw>type</span> <span class=dv>3</span>
<span class=dv>3</span><span class=ot> ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>kind <span class=dt>Either</span>
<span class=dt>Either</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>info <span class=dt>Functor</span>
<span class=kw>class</span> <span class=dt>Functor</span> f <span class=kw>where</span>
<span class=ot>  fmap ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b
<span class=ot>  (&lt;$) ::</span> a <span class=ot>-&gt;</span> f b <span class=ot>-&gt;</span> f a
        <span class=co>-- Defined in `GHC.Base'</span>
  <span class=fu>...</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>i (<span class=fu>:</span>)
<span class=kw>data</span> [] a <span class=fu>=</span> <span class=fu>...</span> <span class=fu>|</span> a <span class=fu>:</span> [a]       <span class=co>-- Defined in `GHC.Types'</span>
<span class=kw>infixr</span> <span class=dv>5</span> <span class=fu>:</span></code></pre></div>
<p><font>Querying the current state of the global environment in the shell is also possible. For example, to view module-level bindings and types in GHCi, run:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>查询 shell 中全局环境的当前状态也是可能的。例如，要查看 GHCi 中的模块级绑定和类型，请运行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>browse
λ<span class=fu>:</span> <span class=fu>:</span>show bindings</code></pre></div>
<p><font>Examining module-level imports, execute:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>检查模块级导入，执行：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>show imports
<span class=kw>import </span><span class=dt>Prelude</span> <span class=co>-- implicit</span>
<span class=kw>import </span><span class=dt>Data.Eq</span>
<span class=kw>import </span><span class=dt>Control.Monad</span></code></pre></div>
<p><font>To see compiler-level flags and pragmas, use:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要查看编​​译器级别的标志和编译指示，请使用：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>set
options currently set<span class=fu>:</span> none<span class=fu>.</span>
base language is<span class=fu>:</span> <span class=dt>Haskell2010</span>
with the following modifiers<span class=fu>:</span>
  <span class=fu>-</span><span class=dt>XNoDatatypeContexts</span>
  <span class=fu>-</span><span class=dt>XNondecreasingIndentation</span>
<span class=dt>GHCi</span><span class=fu>-</span>specific dynamic flag settings<span class=fu>:</span>
other dynamic, non<span class=fu>-</span>language, flag settings<span class=fu>:</span>
  <span class=fu>-</span>fimplicit<span class=fu>-</span>import<span class=fu>-</span>qualified
warning settings<span class=fu>:</span>

λ<span class=fu>:</span> <span class=fu>:</span>showi language
base language is<span class=fu>:</span> <span class=dt>Haskell2010</span>
with the following modifiers<span class=fu>:</span>
  <span class=fu>-</span><span class=dt>XNoDatatypeContexts</span>
  <span class=fu>-</span><span class=dt>XNondecreasingIndentation</span>
  <span class=fu>-</span><span class=dt>XExtendedDefaultRules</span></code></pre></div>
<p><font>Language extensions and compiler pragmas can be set at the prompt. See the </font><a href=#flags>Flag Reference</a><font> for the vast collection of compiler flag options.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以在提示符下设置语言扩展和编译器编译指示。有关编译器标志选项的大量集合，请参阅标志参考。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Several commands for the interactive shell have shortcuts:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>交互式 shell 的几个命令有快捷方式：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>+t<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>+t</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Show types of evaluated expressions</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>显示评估表达式的类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>+s<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>+s</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Show timing and memory usage</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>显示时间和内存使用情况</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>+m<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>+米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Enable multi-line expression delimited by </font><code>:{</code><font> and </font><code>:}</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用由 :{ 和 :} 分隔的多行表达式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>set <span class=fu>+</span>t
λ<span class=fu>:</span> []
[]
<span class=ot>it ::</span> [a]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>set <span class=fu>+</span>s
λ<span class=fu>:</span> foldr (<span class=fu>+</span>) <span class=dv>0</span> [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>]
<span class=dv>325</span>
<span class=ot>it ::</span> <span class=dt>Prelude.Integer</span>
(<span class=fl>0.02</span> secs, <span class=dv>4900952</span> bytes)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>{
λ<span class=fu>:|</span> <span class=kw>let</span> foo <span class=fu>=</span> <span class=kw>do</span>
λ<span class=fu>:|</span>           putStrLn <span class=st>"hello ghci"</span>
λ<span class=fu>:|</span> <span class=fu>:</span>}
λ<span class=fu>:</span> foo
<span class=st>"hello ghci"</span></code></pre></div>
<p><font>The configuration for the GHCi shell can be customized globally by defining a </font><code>ghci.conf</code><font> in </font><code>$HOME/.ghc/</code><font> or in the current working directory as </font><code>./.ghci.conf</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHCi shell 的配置可以通过在 $HOME/.ghc/ 中定义 ghci.conf 或在当前工作目录中定义为 ./.ghci.conf 来全局定制。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example, we can add a command to use the </font><a href=https://www.haskell.org/hoogle/>Hoogle</a><font> type search from within GHCi. First, install </font><code>hoogle</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们可以添加一个命令以在 GHCi 中使用 Hoogle 类型搜索。首先，安装hoogle：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>cabal</span> install hoogle</code></pre></div>
<p><font>Then, we can enable the search functionality by adding a command to our </font><code>ghci.conf</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>然后，我们可以通过向我们的 ghci.conf 添加命令来启用搜索功能：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/01-basics/ghci.conf><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>:</span>set prompt <span class=st>"λ: "</span>

<span class=fu>:</span>def hlint const <span class=fu>.</span> return <span class=fu>$</span> <span class=st>":! hlint \"src\""</span>
<span class=fu>:</span>def hoogle \s <span class=ot>-&gt;</span> return <span class=fu>$</span> <span class=st>":! hoogle --count=15 \""</span> <span class=fu>++</span> s <span class=fu>++</span> <span class=st>"\""</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>hoogle (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b
<span class=dt>Data.Traversable</span><span class=ot> fmapDefault ::</span> <span class=dt>Traversable</span> t <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> t b
<span class=dt>Prelude</span><span class=ot> fmap ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b</code></pre></div>
<p><font>For reasons of sexiness, it is desirable to set your GHC prompt to a </font><code>λ</code><font> or a </font><code>λΠ</code><font>. Only if you're into that lifestyle, though.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>出于性感的原因，最好将 GHC 提示符设置为 λ 或 λΠ。不过，只有当你喜欢那种生活方式时。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>:</span>set prompt <span class=st>"λ: "</span>
<span class=fu>:</span>set prompt <span class=st>"ΠΣ: "</span></code></pre></div>
<h4 id=ghci-performance><font>GHCi Performance</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GHCi 性能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>For large projects, GHCi with the default flags can use quite a bit of memory and take a long time to compile. To speed compilation by keeping artificats for compiled modules around, we can enable object code compilation instead of bytecode.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于大型项目，使用默认标志的 GHCi 会占用大量内存并需要很长时间才能编译。为了通过保留已编译模块的技巧来加速编译，我们可以启用目标代码编译而不是字节码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>:</span>set <span class=fu>-</span>fobject<span class=fu>-</span>code</code></pre></div>
<p><font>Enabling object code compliation may complicate type inference, since type information provided to the shell can sometimes be less informative than source-loaded code. This under specificity can result in breakage with some langauge extensions. In that case, you can temporarily reenable bytecode compilation on a per module basis with the </font><code>-fbyte-code</code><font> flag.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用目标代码编译可能会使类型推断复杂化，因为提供给 shell 的类型信息有时可能不如加载源代码的信息丰富。这种特异性不足会导致某些语言扩展的破坏。在这种情况下，您可以使用 -fbyte-code 标志在每个模块的基础上临时重新启用字节码编译。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>:</span>set <span class=fu>-</span>fbyte<span class=fu>-</span>code
<span class=fu>:</span>load MyModule.hs</code></pre></div>
<p><font>If you all you need is to typecheck your code in the interactive shell, then disabling code generation entirely makes reloading code almost instantaneous:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果您只需要在交互式 shell 中对代码进行类型检查，那么完全禁用代码生成会使重新加载代码几乎是即时的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>:</span>set <span class=fu>-</span>fno<span class=fu>-</span>code</code></pre></div>
<h2 id=editor-integration><font>Editor Integration</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>编辑器集成</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell has a variety of editor tools that can be used to provide interactive development feedback and functionality such as querying types of subexpressions, linting, type checking, and code completion.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 有多种编辑器工具，可用于提供交互式开发反馈和功能，例如查询子表达式的类型、linting、类型检查和代码完成。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Several prepackaged setups exist to expedite the process of setting up many of the programmer editors for Haskell development. In particular, using </font><code>ghc-mod</code><font> can remarkably improve programmer efficiency and productivity because </font><a href=http://www.mew.org/~kazu/proj/ghc-mod/en/>the project</a><font> attempts to implement features common to modern IDEs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在一些预先打包的设置来加快为 Haskell 开发设置许多程序员编辑器的过程。特别是，使用 ghc-mod 可以显着提高程序员的效率和生产力，因为该项目试图实现现代 IDE 共有的功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Vim<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>维姆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<ul>
<li><a href=https://github.com/begriffs/haskell-vim-now>haskell-vim-now<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>haskell-vim-现在</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://smunix.github.io/www.stephendiehl.com/posts/vim_2016.html>Vim and Haskell in 2016<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>2016 年的 Vim 和 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<p><strong>Emacs<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Emacs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<ul>
<li><a href=https://github.com/chrisdone/emacs-haskell-config>Chris Done's Emacs Config<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Chris Done 的 Emacs 配置</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html>Haskell Development From Emacs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>从 Emacs 开发 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/chrisdone/structured-haskell-mode>Structured Haskell Mode<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>结构化 Haskell 模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<p><strong>Atom<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>原子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<ul>
<li><a href=https://atom.io/packages/language-haskell>language-haskell plugin<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言-haskell 插件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://atom.io/packages/ide-haskell>ide-haskell plugin<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ide-haskell 插件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=bottoms><font>Bottoms</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>下装</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The bottom is a singular value that inhabits every type. When this value is evaluated, the semantics of Haskell no longer yield a meaningful value. In other words, further operations on the value cannot be defined in Haskell. A bottom value is usually written as the symbol </font><a href=https://smunix.github.io/en.wikipedia.org/wiki/Up_tack.html>⊥</a><font>, ( i.e. the compiler flipping you off ). Several ways exist to express bottoms in Haskell code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>底部是存在于每种类型中的奇异值。当评估这个值时，Haskell 的语义不再产生有意义的值。换句话说，无法在 Haskell 中定义对值的进一步操作。底部值通常写为符号 ⊥，（即编译器让你失望）。在 Haskell 代码中有几种表达底部的方法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For instance, </font><code>undefined</code><font> is an easily called example of a bottom value. This function has type </font><code>a</code><font> but lacks any type constraints in its type signature. Thus, </font><code>undefined</code><font> is able to stand in for any type in a function body, allowing type checking to succeed, even if the function is incomplete or lacking a definition entirely. The </font><code>undefined</code><font> function is extremely practical for debugging or to accommodate writing incomplete programs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，undefined 是一个很容易调用的底值示例。此函数具有类型 a 但在其类型签名中缺少任何类型约束。因此，undefined 能够代表函数体中的任何类型，允许类型检查成功，即使函数不完整或完全缺少定义。 undefined 函数对于调试或编写不完整的程序非常实用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">undefined<span class=ot> ::</span> a


<span class=ot>mean ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>Vector</span> a <span class=ot>-&gt;</span> a
mean nums <span class=fu>=</span> (total <span class=fu>/</span> count) <span class=kw>where</span>            <span class=co>-- Partially defined function</span>
              total <span class=fu>=</span> undefined
              count <span class=fu>=</span> undefined

<span class=ot>addThreeNums ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
addThreeNums n m j <span class=fu>=</span> undefined               <span class=co>-- No function body declared at all</span>

<span class=ot>f ::</span> a <span class=ot>-&gt;</span> <span class=dt>Complicated</span> <span class=dt>Type</span>
f <span class=fu>=</span> undefined                                <span class=co>-- Write tomorrow, typecheck today!</span>
                                             <span class=co>-- Arbitrarily complicated types</span>
                                             <span class=co>-- welcome!</span></code></pre></div>
<p><font>Another example of a bottom value comes from the evaluation of the </font><code>error</code><font> function, which takes a </font><code>String</code><font> and returns something that can be of any type. This property is quite similar to </font><code>undefined</code><font>, which also can also stand in for any type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>底部值的另一个例子来自错误函数的计算，它接受一个字符串并返回可以是任何类型的东西。此属性与 undefined 非常相似，它也可以代表任何类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Calling </font><code>error</code><font> in a function causes the compiler to throw an exception, halt the program, and print the specified error message. In the </font><code>divByY</code><font> function below, passing the function </font><code>0</code><font> as the divisor results in this function results in such an exception.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在函数中调用错误会导致编译器抛出异常、暂停程序并打印指定的错误消息。在下面的 divByY 函数中，将函数 0 作为除数传递给这个函数会导致这样的异常。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">error<span class=ot> ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> a                       <span class=co>-- Takes an error message of type</span>
                                           <span class=co>-- String and returns whatever type</span>
                                           <span class=co>-- is needed</span></code></pre></div>
<div class=sourceCode include=src/01-basics/errors.hs><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class=co>-- Annotated code that features use of the error function.</span>

<span class=ot>divByY::</span> (<span class=dt>Num</span> a, <span class=dt>Eq</span> a, <span class=dt>Fractional</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
divByY _ <span class=dv>0</span> <span class=fu>=</span> error <span class=st>"Divide by zero error"</span>      <span class=co>-- Dividing by 0 causes an error</span>
divByY dividend divisor <span class=fu>=</span> dividend <span class=fu>/</span> divisor   <span class=co>-- Handles defined division</span>
</code></pre></div>
<p><font>A third type way to express a bottom is with an infinitely looping term:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第三种表示底部的方法是使用无限循环项：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> a
f <span class=fu>=</span> <span class=kw>let</span> x <span class=fu>=</span> x <span class=kw>in</span> x</code></pre></div>
<p><font>Examples of actual Haskell code that use this looping syntax live in the source code of the </font><a href=https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html>GHC.Prim</a><font> module. These bottoms exist because the operations </font><a href=https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/primitives.html>cannot be defined in native Haskell</a><font>. Such operations are baked into the compiler at a very low level. However, this module exists so that </font><a href=#haddock>Haddock</a><font> can generate documentation for these primitive operations, while the looping syntax serves as a placeholder for the actual implementation of the primops.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用这种循环语法的实际 Haskell 代码示例位于 GHC.Prim 模块的源代码中。这些底部的存在是因为无​​法在本机 Haskell 中定义这些操作。此类操作在非常低的级别上嵌入到编译器中。然而，这个模块的存在是为了让 Haddock 可以为这些原始操作生成文档，而循环语法则作为 primops 实际实现的占位符。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Perhaps the most common introduction to bottoms is writing a partial function that does not have </font><a href=#exhaustiveness>exhaustive</a><font> pattern matching defined. For example, the following code has non-exhaustive pattern matching because the </font><code>case</code><font> expression, lacks a definition of what to do with a </font><code>B</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也许最常见的底部介绍是编写一个没有定义详尽模式匹配的部分函数。例如，以下代码具有非详尽的模式匹配，因为 case 表达式缺少如何处理 B 的定义：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>F</span> <span class=fu>=</span> <span class=dt>A</span> <span class=fu>|</span> <span class=dt>B</span>
<span class=kw>case</span> x <span class=kw>of</span>
  <span class=dt>A</span> <span class=ot>-&gt;</span> ()</code></pre></div>
<p><font>The code snippet above is translated into the following </font><a href=#code>GHC Core</a><font> output. The compiler inserts an exception to account for the non-exhaustive patterns:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>上面的代码片段被翻译成下面的 GHC Core 输出。编译器插入一个异常来说明非详尽模式：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>case</span> x <span class=kw>of</span> _ {
  <span class=dt>A</span> <span class=ot>-&gt;</span> ();
  <span class=dt>B</span> <span class=ot>-&gt;</span> patError <span class=st>"&lt;interactive&gt;:3:11-31|case"</span>
}</code></pre></div>
<p><font>GHC can be made more vocal about incomplete patterns using the </font><code>-fwarn-incomplete-patterns</code><font> and </font><code>-fwarn-incomplete-uni-patterns</code><font> flags.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 -fwarn-incomplete-patterns 和 -fwarn-incomplete-uni-patterns 标志可以使 GHC 对不完整的模式更加直言不讳。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>A similar situation can arise with records. Although constructing a record with missing fields is rarely useful, it is still possible.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>记录也会出现类似的情况。虽然构造一个缺少字段的记录很少有用，但它仍然是可能的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Foo</span> <span class=fu>=</span> <span class=dt>Foo</span> {<span class=ot> example1 ::</span> <span class=dt>Int</span> }
f <span class=fu>=</span> <span class=dt>Foo</span> {}     <span class=co>-- Record defined with a missing field</span></code></pre></div>
<p><font>When the developer omits a field's definition, the compiler inserts an exception in the GHC Core representation:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当开发人员省略字段的定义时，编译器会在 GHC 核心表示中插入一个异常：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Foo</span> (recConError <span class=st>"&lt;interactive&gt;:4:9-12|a"</span>)</code></pre></div>
<p><font>Fortunately, GHC will warn us by default about missing record fields.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>幸运的是，GHC 默认会警告我们缺少记录字段。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Bottoms are used extensively throughout </font><a href=#prelude>the Prelude</a><font>, although this fact may not be immediately apparent. The reasons for including bottoms are either practical or historical.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在整个 Prelude 中广泛使用了底部，尽管这一事实可能不会立即显现出来。包括底部的原因是实际的或历史的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The canonical example is the </font><code>head</code><font> function which has type </font><code>[a] -&gt; a</code><font>. This function could not be well-typed without the bottom.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>典型的例子是 head 函数，其类型为 [a] -&gt; a。没有底部，这个功能就无法打好。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/01-basics/bottoms.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>GHC.Err</span>
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (head, (!!), undefined)

<span class=co>-- degenerate functions</span>

undefined<span class=ot> ::</span> a
undefined <span class=fu>=</span>  error <span class=st>"Prelude.undefined"</span>

head<span class=ot> ::</span> [a] <span class=ot>-&gt;</span> a
head (x<span class=fu>:</span>_) <span class=fu>=</span>  x
head []    <span class=fu>=</span>  error <span class=st>"Prelude.head: empty list"</span>

<span class=ot>(!!) ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a
xs     <span class=fu>!!</span> n <span class=fu>|</span> n <span class=fu>&lt;</span> <span class=dv>0</span> <span class=fu>=</span>  error <span class=st>"Prelude.!!: negative index"</span>
[]     <span class=fu>!!</span> _         <span class=fu>=</span>  error <span class=st>"Prelude.!!: index too large"</span>
(x<span class=fu>:</span>_)  <span class=fu>!!</span> <span class=dv>0</span>         <span class=fu>=</span>  x
(_<span class=fu>:</span>xs) <span class=fu>!!</span> n         <span class=fu>=</span>  xs <span class=fu>!!</span> (n<span class=fu>-</span><span class=dv>1</span>)</code></pre></div>
<p><font>It is rare to see these partial functions thrown around carelessly in production code because they cause the program to halt. The preferred method for handling exceptions is to combine the use of safe variants provided in </font><code>Data.Maybe</code><font> with the usual fold functions </font><code>maybe</code><font> and </font><code>either</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>很少看到这些部分函数在生产代码中不小心抛出，因为它们会导致程序停止。处理异常的首选方法是结合使用 Data.Maybe 中提供的安全变体与通常的折叠函数 maybe 和 either。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Another method is to use pattern matching, as shown in </font><code>listToMaybe</code><font>, a safer version of </font><code>head</code><font> described below:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>另一种方法是使用模式匹配，如 listToMaybe 所示，这是一种更安全的 head 版本，如下所述：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>listToMaybe ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
listToMaybe []     <span class=fu>=</span>  <span class=dt>Nothing</span>    <span class=co>-- An empty list returns Nothing</span>
listToMaybe (a<span class=fu>:</span>_)  <span class=fu>=</span>  <span class=dt>Just</span> a     <span class=co>-- A non-empty list returns the first element</span>
                                 <span class=co>-- wrapped in the Just context.</span></code></pre></div>
<p><font>Invoking a bottom defined in terms of </font><code>error</code><font> typically will not generate any position information. However, </font><code>assert</code><font>, which is used to provide assertions, can be short-circuited to generate position information in the place of either </font><code>undefined</code><font> or </font><code>error</code><font> calls.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>调用根据错误定义的底部通常不会生成任何位置信息。但是，用于提供断言的 assert 可以短路以生成位置信息，以代替未定义或错误调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/01-basics/fail.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>GHC.Base</span>

<span class=ot>foo ::</span> a
foo <span class=fu>=</span> undefined
<span class=co>-- *** Exception: Prelude.undefined</span>

<span class=ot>bar ::</span> a
bar <span class=fu>=</span> assert <span class=dt>False</span> undefined
<span class=co>-- *** Exception: src/fail.hs:8:7-12: Assertion failed</span></code></pre></div>
<p><font>See: </font><a href=https://wiki.haskell.org/Avoiding_partial_functions>Avoiding Partial Functions</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：避免偏函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=exhaustiveness><font>Exhaustiveness</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>详尽无遗</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Pattern matching in Haskell allows for the possibility of non-exhaustive patterns. For example, passing Nothing to </font><code>unsafe</code><font> will cause the program to crash at runtime. However, this function is an otherwise valid, type-checked program.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中的模式匹配允许非穷举模式的可能性。例如，将 Nothing 传递给 unsafe 将导致程序在运行时崩溃。但是，此函数在其他方面是有效的、经过类型检查的程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>unsafe ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>Maybe</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
unsafe (<span class=dt>Just</span> x) <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> x <span class=fu>+</span> <span class=dv>1</span></code></pre></div>
<p><font>Since </font><code>unsafe</code><font> takes a </font><code>Maybe a</code><font> value as its argument, two possible values are valid input: </font><code>Nothing</code><font> and </font><code>Just a</code><font>. Since the case of a </font><code>Nothing</code><font> was not defined in </font><code>unsafe</code><font>, we say that the pattern matching within that function is </font><em>non-exhaustive</em><font>. In other words, the function does not implement appropriate handling of all valid inputs. Instead of yielding a value, such a function will halt from an incomplete match.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>由于 unsafe 将 Maybe a 值作为其参数，因此两个可能的值是有效输入：Nothing 和 Just a。由于在 unsafe 中没有定义 Nothing 的情况，我们说该函数内的模式匹配是非穷尽的。换句话说，该函数没有实现对所有有效输入的适当处理。这样的函数不会产生一个值，而是会因不完整的匹配而停止。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Partial functions from non-exhaustivity are a controversial subject, and frequent use of non-exhaustive patterns is considered a dangerous code smell. However, the complete removal of non-exhaustive patterns from the language would itself be too restrictive and forbid too many valid programs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自非穷举的部分函数是一个有争议的话题，频繁使用非穷举模式被认为是一种危险的代码味道。然而，从语言中完全删除非穷举模式本身就限制太多，并且会禁止太多有效程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Several flags exist that we can pass to the compiler to warn us about such patterns or forbid them entirely either locally or globally.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在几个标志，我们可以将它们传递给编译器，以警告我们此类模式或在本地或全局完全禁止它们。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> ghc <span class=fu>-</span>c <span class=fu>-</span><span class=dt>Wall</span> <span class=fu>-</span><span class=dt>Werror</span> A.hs
A.hs<span class=fu>:</span><span class=dv>3</span><span class=fu>:</span><span class=dv>1</span><span class=fu>:</span>
    <span class=dt>Warning</span><span class=fu>:</span> <span class=dt>Pattern</span> match(es) are non<span class=fu>-</span>exhaustive
             <span class=dt>In</span> an equation for <span class=ot>`unsafe': Patterns not matched: Nothing</span></code></pre></div>
<p><font>The </font><code>-Wall</code><font> or </font><code>-fwarn-incomplete-patterns</code><font> flag can also be added on a per-module basis by using the </font><code>OPTIONS_GHC</code> <a href=https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/pragmas.html>pragma</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-Wall 或 -fwarn-incomplete-patterns 标志也可以通过使用 OPTIONS_GHC pragma 在每个模块的基础上添加。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# OPTIONS_GHC -Wall #-}</span>
<span class=ot>{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}</span></code></pre></div>
<p><font>A more subtle case of non-exhaustivity is the use of implicit pattern matching with a single </font><em>uni-pattern</em><font> in a lambda expression. In a manner similar to the </font><code>unsafe</code><font> function above, a uni-pattern cannot handle all types of valid input. For instance, the function </font><code>boom</code><font> will fail when given a Nothing, even though the type of the lambda expression's argument is a </font><code>Maybe a</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>非详尽性的一个更微妙的例子是在 lambda 表达式中使用隐式模式匹配和单个单一模式。以类似于上述不安全函数的方式，单一模式无法处理所有类型的有效输入。例如，即使 lambda 表达式的参数类型是 Maybe a，函数 boom 也会在给定 Nothing 时失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">boom <span class=fu>=</span> \(<span class=dt>Just</span> a) <span class=ot>-&gt;</span> something</code></pre></div>
<p><font>Non-exhaustivity arising from uni-patterns in lambda expressions occurs frequently in </font><code>let</code><font> or </font><code>do</code><font>-blocks after desugaring, because such code is translated into lambda expressions similar to </font><code>boom</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>由 lambda 表达式中的 uni-patterns 引起的非穷尽性经常出现在脱糖后的 let 或 do 块中，因为这样的代码被翻译成类似于 boom 的 lambda 表达式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">boom2 <span class=fu>=</span> <span class=kw>let</span>
  <span class=dt>Just</span> a <span class=fu>=</span> something

boom3 <span class=fu>=</span> <span class=kw>do</span>
  <span class=dt>Just</span> a <span class=ot>&lt;-</span> something</code></pre></div>
<p><font>GHC can warn about these cases of non-exhaustivity with the </font><code>-fwarn-incomplete-uni-patterns</code><font> flag.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 可以使用 -fwarn-incomplete-uni-patterns 标志警告这些非详尽情况。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Grossly speaking, any non-trivial program will use some measure of partial functions. It is simply a fact. Thus, there exist obligations for the programmer than cannot be manifest in the Haskell type system.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>粗略地说，任何重要的程序都会使用部分函数的某种度量。这只是一个事实。因此，对于程序员来说，存在一些无法在 Haskell 类型系统中体现的义务。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=debugger><font>Debugger</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>调试器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Since </font><a href=#ghci>GHCi</a><font> version 6.8.1, a built-in </font><a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html>debugger</a><font> has been available, although its use is somewhat rare. Debugging uncaught exceptions from bottoms or asynchronous exceptions is in similar style to debugging segfaults with gdb.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 GHCi 版本 6.8.1 开始，一个内置的调试器已经可用，尽管它的使用有些罕见。从底部调试未捕获的异常或异步异常与使用 gdb 调试段错误的风格类似。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>set <span class=fu>-</span>fbreak<span class=fu>-</span>on<span class=fu>-</span>exception       <span class=co>-- Sets option for evaluation to stop on exception</span>
λ<span class=fu>:</span> <span class=fu>:</span>break <span class=dv>2</span> <span class=dv>15</span>                     <span class=co>-- Sets a break point at line 2, column 15</span>
λ<span class=fu>:</span> <span class=fu>:</span>trace main                     <span class=co>-- Run a function to generate a sequence of evaluation steps</span>
λ<span class=fu>:</span> <span class=fu>:</span>hist                           <span class=co>-- Step backwards from a breakpoint through previous steps of evaluation</span>
λ<span class=fu>:</span> <span class=fu>:</span>back                           <span class=co>-- Step backwards a single step at a time through the history</span>
λ<span class=fu>:</span> <span class=fu>:</span>forward                        <span class=co>-- Step forward a single step at a time through the history</span></code></pre></div>
<h2 id=stack-traces><font>Stack Traces</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>堆栈跟踪</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>With </font><a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html>runtime profiling enabled</a><font>, </font><a href=https://www.haskell.org/ghc/>GHC</a><font> can also print a stack trace when a diverging bottom term (error, undefined) is hit. This action, though, requires a special flag and profiling to be enabled, both of which are disabled by default. So, for example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用运行时分析后，GHC 还可以在遇到不同的底部术语（错误，未定义）时打印堆栈跟踪。不过，此操作需要启用特殊标志和分析，默认情况下两者都是禁用的。所以，例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/01-basics/stacktrace.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Exception</span>

f x <span class=fu>=</span> g x

g x <span class=fu>=</span> error (show x)

main <span class=fu>=</span> try (evaluate (f ()))<span class=ot> ::</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>SomeException</span> ())</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> ghc <span class=fu>-</span><span class=dt>O0</span> <span class=fu>-</span>rtsopts<span class=fu>=</span>all <span class=fu>-</span>prof <span class=fu>-</span>auto<span class=fu>-</span>all <span class=co>--make stacktrace.hs</span>
<span class=fu>./</span>stacktrace <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span>xc</code></pre></div>
<p><font>And indeed, the runtime tells us that the exception occurred in the function </font><code>g</code><font> and enumerates the call stack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>事实上，运行时告诉我们异常发生在函数 g 中并枚举了调用堆栈。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>***</span> <span class=dt>Exception</span> (reporting due to <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span>xc)<span class=fu>:</span> (<span class=dt>THUNK_2_0</span>), stack trace<span class=fu>:</span>
  Main.g,
  called from Main.f,
  called from Main.main,
  called from <span class=dt>Main.CAF</span>
  <span class=fu>--&gt;</span> evaluated by<span class=fu>:</span> Main.main,
  called from <span class=dt>Main.CAF</span></code></pre></div>
<p><font>It is best to run this code without optimizations applied </font><code>-O0</code><font> so as to preserve the original call stack as represented in the source. With optimizations applied, GHC will rearrange the program in rather drastic ways, resulting in what may be an entirely different call stack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最好在不应用优化的情况下运行此代码 -O0 以便保留源代码中表示的原始调用堆栈。应用优化后，GHC 将以相当激烈的方式重新安排程序，从而导致可能完全不同的调用堆栈。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#idp13041968>xc flag<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>xc标志</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=trace><font>Trace</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>痕迹</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Since Haskell is a </font><a href=https://smunix.github.io/dev.stephendiehl.com/fun/000_introduction.html#functional-languages>pure language</a><font>, it has the unique property that most code is introspectable on its own. As such, using </font><a href=https://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output>printf</a><font> to display the state of the program at critical times throughout execution is often unnecessary because we can simply open </font><a href=#ghci>GHCi</a><font> and test the function. Nevertheless, Haskell does come with an unsafe </font><code>trace</code><font> function which can be used to perform arbitrary print statements outside of the IO monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>由于 Haskell 是一门纯语言，它具有大多数代码都可以自省的独特属性。因此，在整个执行过程中的关键时刻使用 printf 来显示程序状态通常是不必要的，因为我们可以简单地打开 GHCi 并测试功能。然而，Haskell 确实带有一个不安全的跟踪函数，可用于在 IO monad 之外执行任意打印语句。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/01-basics/trace.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Debug.Trace</span>

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> trace <span class=st>"impure print"</span> <span class=dv>1</span>

<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> traceShow <span class=st>"tracing"</span> <span class=dv>2</span>

<span class=ot>example3 ::</span> [<span class=dt>Int</span>]
example3 <span class=fu>=</span> [trace <span class=st>"will not be called"</span> <span class=dv>3</span>]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print example1
  print example2
  print <span class=fu>$</span> length example3
<span class=co>-- impure print</span>
<span class=co>-- 1</span>
<span class=co>-- "tracing"</span>
<span class=co>-- 2</span>
<span class=co>-- 1</span></code></pre></div>
<div class="alert alert-danger">
<p><font>Trace uses </font><code>unsafePerformIO</code><font> under the hood and should </font><strong>not</strong><font> be used in stable code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Trace 在后台使用 unsafePerformIO，不应在稳定代码中使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>In addition to the </font><code>trace</code><font> function, several monadic </font><code>trace</code><font> variants are quite common.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>除了 trace 函数之外，一些 monadic trace 变体也很常见。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Text.Printf</span>
<span class=kw>import </span><span class=dt>Debug.Trace</span>

<span class=ot>traceM ::</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> m ()
traceM string <span class=fu>=</span> trace string <span class=fu>$</span> return ()

<span class=ot>traceShowM ::</span> (<span class=dt>Show</span> a, <span class=dt>Monad</span> m) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> m ()
traceShowM <span class=fu>=</span> traceM <span class=fu>.</span> show

<span class=ot>tracePrintfM ::</span> (<span class=dt>Monad</span> m, <span class=dt>PrintfArg</span> a) <span class=ot>=&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> m ()
tracePrintfM s <span class=fu>=</span> traceM <span class=fu>.</span> printf s</code></pre></div>
<h2 id=type-holes><font>Type Holes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型孔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Since the release of GHC 7.8, </font><em>typed holes</em><font> allow for debugging incomplete programs. By placing an underscore on any value on the right hand-side of a declaration, </font><a href=https://www.haskell.org/ghc/>GHC</a><font> will throw an error during type-checking. Such an error reflects what type the value in the position of the type hole could be in order for the program to type-check successfully.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自 GHC 7.8 发布以来，类型化漏洞允许调试不完整的程序。通过在声明右侧的任何值上放置下划线，GHC 将在类型检查期间抛出错误。这样的错误反映了类型孔位置的值可能是什么类型，以便程序能够成功进行类型检查。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Functor</span> [] <span class=kw>where</span>
  fmap f (x<span class=fu>:</span>xs) <span class=fu>=</span> f x <span class=fu>:</span> fmap f _</code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">[<span class=kw>1</span> of 1] Compiling Main             ( src/typedhole.hs, interpreted )

<span class=kw>src</span>/typedhole.hs:<span class=kw>7</span>:32:
    <span class=kw>Found</span> hole ‘_’ with type: [a]
    <span class=kw>Where</span>: ‘a’ is a rigid type variable bound by
               <span class=kw>the</span> type signature for fmap :: (a -<span class=kw>&gt;</span> b) <span class=kw>-&gt;</span> [a] -<span class=kw>&gt;</span> [b]
               <span class=kw>at</span> src/typedhole.hs:7:3
    <span class=kw>Relevant</span> bindings include
      <span class=kw>xs</span> :: [a] (bound at src/typedhole.hs:7:13)
      <span class=kw>x</span> :: a (bound at src/typedhole.hs:7:11)
      <span class=kw>f</span> :: a -<span class=kw>&gt;</span> b (bound at src/typedhole.hs:7:8)
      <span class=kw>fmap</span> :: (a -<span class=kw>&gt;</span> b) <span class=kw>-&gt;</span> [a] -<span class=kw>&gt;</span> [b] (bound at src/typedhole.hs:7:3)
    <span class=kw>In</span> the second argument of ‘fmap’, namely ‘_’
    <span class=kw>In</span> the second argument of ‘(:)’, <span class=kw>namely</span> ‘fmap f _’
    <span class=kw>In</span> the expression: f x : fmap f _
<span class=kw>Failed</span>, modules loaded: none.</code></pre></div>
<p><font>GHC has rightly suggested that the expression needed to finish the program is </font><code>xs :: [a]</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 正确地建议完成程序所需的表达式是 xs :: [a]。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=deferred-type-errors><font>Deferred Type Errors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>延迟类型错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Since the release of version 7.8, </font><a href=https://www.haskell.org/ghc/>GHC</a><font> supports the option of treating type errors as runtime errors. With this option enabled, programs will run, but they will fail when a mistyped expression is evaluated. This feature is enabled with the </font><code>-fdefer-type-errors</code><font> flag in three ways: at the module level, when compiled from the command line, or inside of a </font><a href=#ghci>GHCi</a><font> interactive session.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自 7.8 版本发布以来，GHC 支持将类型错误视为运行时错误的选项。启用此选项后，程序将运行，但在评估输入错误的表达式时它们将失败。此功能通过三种方式使用 -fdefer-type-errors 标志启用：在模块级别、从命令行编译时或在 GHCi 交互式会话内部。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For instance, the program below will compile:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，下面的程序将编译：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/01-basics/defer.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# OPTIONS_GHC -fdefer-type-errors #-}</span> <span class=co>-- Enable deferred type</span>
                                        <span class=co>-- errors at module level</span>

<span class=ot>x ::</span> ()
x <span class=fu>=</span> print <span class=dv>3</span>

<span class=ot>y ::</span> <span class=dt>Char</span>
y <span class=fu>=</span> <span class=dv>0</span>

<span class=ot>z ::</span> <span class=dt>Int</span>
z <span class=fu>=</span> <span class=dv>0</span> <span class=fu>+</span> <span class=st>"foo"</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print x</code></pre></div>
<p><font>However, when a pathological term is evaluated at runtime, we'll see a message like:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>但是，当在运行时评估病理术语时，我们会看到如下消息：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>defer</span>: defer.hs:4:5:
    <span class=kw>Couldn</span><span class=st>'t match expected type ‘()’ with actual type ‘IO ()’</span>
<span class=st>    In the expression: print 3</span>
<span class=st>    In an equation for ‘x’: x = print 3</span>
<span class=st>(deferred type error)</span></code></pre></div>
<p><font>This error tells us that while </font><code>x</code><font> has a declared type of </font><code>()</code><font>, the body of the function </font><code>print 3</code><font> has a type of </font><code>IO ()</code><font>. However, if the term is never evaluated, GHC will not throw an exception.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这个错误告诉我们，虽然 x 的声明类型为 ()，但函数 print 3 的主体的类型为 IO ()。但是，如果该术语从未被评估，GHC 将不会抛出异常。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=ghcid><font>ghcid</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ghcid</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><a href=https://github.com/ndmitchell/ghcid>ghcid</a><font> is a lightweight IDE hook that allows continuous feedback whenever code is updated. It can be run from the command line in the root of the </font><code>cabal</code><font> project directory by specifying a command to run (e.g. </font><code>ghci</code><font>, </font><code>cabal repl</code><font>, or </font><code>stack repl</code><font>).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghcid 是一个轻量级的 IDE 钩子，它允许在代码更新时持续反馈。它可以通过指定要运行的命令（例如 ghci、cabal repl 或 stack repl）从 cabal 项目目录根目录中的命令行运行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>ghcid</span> --command=<span class=st>"cabal repl"</span>   <span class=co># Run cabal repl under ghcid</span>
<span class=kw>ghcid</span> --command=<span class=st>"stack repl"</span>   <span class=co># Run stack repl under ghcid</span>
<span class=kw>ghcid</span> --command=<span class=st>"ghci baz.hs"</span>  <span class=co># Open baz.hs under ghcid</span></code></pre></div>
<p><font>When a Haskell module is loaded into </font><code>ghcid</code><font>, the code is evaluated in order to provide the user with any errors or warnings that would happen at compile time. When the developer edits and saves code loaded into </font><code>ghcid</code><font>, the program automatically reloads and evaluates the code for errors and warnings.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当 Haskell 模块加载到 ghcid 中时，代码会被评估，以便为用户提供编译时可能发生的任何错误或警告。当开发人员编辑并保存加载到 ghcid 中的代码时，程序会自动重新加载代码并评估错误和警告。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=haddock><font>Haddock</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>黑线鳕</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><a href=haskel://www.haskell.org/haddock/#Overview>Haddock</a><font> is the automatic documentation generation tool for Haskell source code. It integrates with the usual </font><code>cabal</code><font> toolchain. In this section, we will explore how to document code so that Haddock can generate documentation successfully.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haddock 是 Haskell 源代码的自动文档生成工具。它与通常的 cabal 工具链集成。在本节中，我们将探讨如何对代码进行文档化，以便 Haddock 能够成功生成文档。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Several frequent comment patterns are used to document code for Haddock. The first of these methods uses </font><code>-- |</code><font> to delineate the beginning of a comment:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>几种常见的注释模式用于记录 Haddock 的代码。这些方法中的第一个使用 -- |描述评论的开头：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Documentation for f</span>
<span class=ot>f ::</span> a <span class=ot>-&gt;</span> a
f <span class=fu>=</span> <span class=fu>...</span></code></pre></div>
<p><font>Multiline comments are also possible:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>多行评论也是可能的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Multiline documentation for the function</span>
<span class=co>-- f with multiple arguments.</span>
fmap<span class=ot> ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span>
     <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b)  <span class=co>-- ^ function</span>
     <span class=ot>-&gt;</span> f a       <span class=co>-- ^ input</span>
     <span class=ot>-&gt;</span> f b       <span class=co>-- ^ output</span></code></pre></div>
<p><code>-- ^</code><font> is also used to comment Constructors or Record fields:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-- ^ 还用于注释构造函数或记录字段：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>T</span> a b
  <span class=fu>=</span> <span class=dt>A</span> a <span class=co>-- ^ Documentation for A</span>
  <span class=fu>|</span> <span class=dt>B</span> b <span class=co>-- ^ Documentation for B</span>

<span class=kw>data</span> <span class=dt>R</span> a b <span class=fu>=</span> <span class=dt>R</span>
  {<span class=ot> f1 ::</span> a <span class=co>-- ^ Documentation for the field f1</span>
  ,<span class=ot> f2 ::</span> b <span class=co>-- ^ Documentation for the field f2</span>
  }</code></pre></div>
<p><font>Elements within a module (i.e. value, types, classes) can be hyperlinked by enclosing the identifier in single quotes:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模块中的元素（即值、类型、类）可以通过将标识符括在单引号中来进行超链接：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>T</span> a b
  <span class=fu>=</span> <span class=dt>A</span> a <span class=co>-- ^ Documentation for 'A'</span>
  <span class=fu>|</span> <span class=dt>B</span> b <span class=co>-- ^ Documentation for 'B'</span></code></pre></div>
<p><font>Modules themselves can be referenced by enclosing them in double quotes:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模块本身可以通过用双引号括起来来引用：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Here we use the "Data.Text" library and import</span>
<span class=co>-- the 'Data.Text.pack' function.</span></code></pre></div>
<p><code>haddock</code><font> also allows the user to include blocks of code within the generated documentation. Two methods of demarcating the code blocks exist in </font><code>haddock</code><font>. For example, enclosing a code snippet in </font><code>@</code><font> symbols marks it as a code block:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>haddock 还允许用户在生成的文档中包含代码块。黑线鳕中存在两种划分代码块的方法。例如，将代码片段括在 @ 符号中将其标记为代码块：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | An example of a code block.</span>
<span class=fu>--</span>
<span class=co>-- @</span>
<span class=co>--    f x = f (f x)</span>
<span class=co>-- @</span></code></pre></div>
<p><font>Similarly, it's possible to use bird tracks (</font><code>&gt;</code><font>) in a comment line to set off a code block. This usage is very similar to </font><a href=https://wiki.haskell.org/Literate_programming#Bird_Style>Bird style Literate Haskell</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>同样，可以在注释行中使用鸟迹 (&gt;) 来引出代码块。这种用法与 Bird 风格的 Literate Haskell 非常相似。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | A similar code block example that uses bird tracks (i.e. '&gt;')</span>
<span class=co>-- &gt; f x = f (f x)</span></code></pre></div>
<p><font>Snippets of interactive shell sessions can also be included in </font><code>haddock</code><font> documentation. In order to denote the beginning of code intended to be run in a REPL, the </font><code>&gt;&gt;&gt;</code><font> symbol is used:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>交互式 shell 会话的片段也可以包含在黑线鳕文档中。为了表示要在 REPL 中运行的代码的开头，使用了 &gt;&gt;&gt; 符号：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Example of an interactive shell session embedded within documentation</span>
<span class=fu>--</span>
<span class=co>-- &gt;&gt;&gt; factorial 5</span>
<span class=co>-- 120</span></code></pre></div>
<p><font>Headers for specific blocks can be added by prefacing the comment in the module block with a </font><code>*</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以通过在模块块中的注释前加上 * 来添加特定块的标题：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Foo</span> (
  <span class=co>-- * My Header</span>
  example1,
  example2
)</code></pre></div>
<p><font>Sections can also be delineated by </font><code>$</code><font> blocks that pertain to references in the body of the module:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>部分也可以由与模块主体中的引用相关的 $ 块描述：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Foo</span> (
  <span class=co>-- $section1</span>
  example1,
  example2
)

<span class=co>-- $section1</span>
<span class=co>-- Here is the documentation section that describes the symbols</span>
<span class=co>-- 'example1' and 'example2'.</span></code></pre></div>
<p><font>Links can be added with the following syntax:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以使用以下语法添加链接：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>&lt;</span>url text<span class=fu>&gt;</span></code></pre></div>
<p><font>Images can also be included, so long as the path is either absolute or relative to the directory in which </font><code>haddock</code><font> is run.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也可以包含图像，只要路径是绝对路径或相对于黑线鳕运行目录的路径即可。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>&lt;&lt;</span>diagram<span class=fu>.</span>png title<span class=fu>&gt;&gt;</span></code></pre></div>
<p><code>haddock</code><font> options can also be specified with pragmas in the source, either at the module or project level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>黑线鳕选项也可以在源代码中使用 pragmas 指定，无论是在模块还是项目级别。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# OPTIONS_HADDOCK show-extensions, ignore-exports #-}</span></code></pre></div>
<table>
<thead>
<tr class=header>
<th align=left><font>Option</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>选项</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Description</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>ignore-exports</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>忽略出口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Ignores the export list and includes all signatures in scope.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>忽略导出列表并包括范围内的所有签名。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>not-home</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不在家</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Module will not be considered in the root documentation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>根文档中不会考虑模块。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>show-extensions</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>显示扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Annotates the documentation with the language extensions used.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用所使用的语言扩展注释文档。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>hide</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>隐藏</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Forces the module to be hidden from Haddock.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>强制模块对 Haddock 隐藏。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>prune</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>修剪</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Omits definitions with no annotations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>省略没有注释的定义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<hr>
<h1 id=monads><font>Monads</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=eightfold-path-to-monad-satori><font>Eightfold Path to Monad Satori</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通向单悟的八正道</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Much ink has been spilled waxing lyrical about the supposed mystique of monads. Instead, I suggest a path to enlightenment:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>关于所谓的单子的神秘性，大量的墨水被泼洒了。相反，我建议一条启蒙之路：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ol style=list-style-type:decimal>
<li><font>Don't read the monad tutorials.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不要阅读 monad 教程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>No really, don't read the monad tutorials.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不，真的，不要阅读 monad 教程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Learn about </font><a href=https://smunix.github.io/book.realworldhaskell.org/read/types-and-functions.html>Haskell types</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>了解 Haskell 类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Learn what a typeclass is.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>了解什么是类型类。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Read the </font><a href=http://wiki.haskell.org/Typeclassopedia>Typeclassopedia</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>阅读 Typeclassopedia。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Read the monad definitions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>阅读 monad 定义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Use monads in real code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在实际代码中使用 monad。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Don't write monad-analogy tutorials.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不要编写 monad 类比教程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ol>
<p><font>In other words, the only path to understanding monads is to read the fine source, fire up GHC, and write some code. Analogies and metaphors will not lead to understanding.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>换句话说，理解 monad 的唯一途径是阅读优秀的源代码、启动 GHC 并编写一些代码。类比和隐喻不会导致理解。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=monadic-myths><font>Monadic Myths</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>一元神话</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The following are all </font><strong>false</strong><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>以下都是假的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Monads are impure.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子是不纯的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are about effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是关于效果的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are about state.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是关于状态的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are about imperative sequencing.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是关于命令式排序的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are about IO.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是关于 IO 的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are dependent on laziness.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 依赖于惰性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are a "back-door" in the language to perform side-effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是语言中执行副作用的“后门”。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are an embedded imperative language inside Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是 Haskell 中的一种嵌入式命令式语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads require knowing abstract mathematics.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子需要了解抽象数学。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Monads are unique to Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 是 Haskell 独有的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>See: </font><a href=http://wiki.haskell.org/What_a_Monad_is_not>What a Monad Is Not</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Monad 不是什么</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=monadic-methods><font>Monadic Methods</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子方法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Monads are not complicated. They are implemented as a typeclass with two methods, </font><code>return</code><font> and </font><code>(&gt;&gt;=)</code><font> (pronounced "bind"). In order to implement a Monad instance, these two functions must be defined in accordance with the arity described in the typeclass definition:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 并不复杂。它们被实现为具有两个方法的类型类，return 和 (&gt;&gt;=)（发音为“bind”）。为了实现一个 Monad 实例，这两个函数必须按照类型类定义中描述的元数来定义：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Monad</span> m <span class=kw>where</span>
<span class=ot>  return ::</span> a <span class=ot>-&gt;</span> m a                    <span class=co>-- N.B. 'm' refers to a type constructor</span>
                                        <span class=co>-- (e.g., Maybe, Either, etc.) that</span>
                                        <span class=co>-- implements the Monad typeclass</span>

<span class=ot>  (&gt;&gt;=)  ::</span> m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m b</code></pre></div>
<p><font>The first type signature in the Monad class definition is for </font><code>return</code><font>. Any preconceptions one might have for the word "return" should be discarded: It has an entirely different meaning in the context of Haskell and acts very differently than in languages like C, Python, or Java. Instead of being the final arbiter of what value a function produces, </font><code>return</code><font> in Haskell injects a value of type </font><code>a</code><font> into a monadic context (e.g., Maybe, Either, etc.), which is denoted as </font><code>m a</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 类定义中的第一个类型签名用于返回。人们对“return”这个词的任何先入之见都应该被抛弃：它在 Haskell 的上下文中具有完全不同的含义，并且与 C、Python 或 Java 等语言中的行为非常不同。在 Haskell 中，return 不是函数产生什么值的最终仲裁者，而是将类型 a 的值注入到单子上下文（例如，Maybe、Either 等）中，表示为 m a。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The other function essential to implementing a Monad instance is </font><code>(&gt;&gt;=)</code><font>. This infix takes two arguments. On its left side is a value with type </font><code>m a</code><font>, while on the right side is a function with type </font><code>(a -&gt; m b)</code><font>. The bind operation results in a final value of type </font><code>m b</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>实现 Monad 实例所必需的另一个函数是 (&gt;&gt;=)。这个中缀有两个参数。在它的左边是一个类型为 m a 的值，而在右边是一个类型为 (a -&gt; m b) 的函数。绑定操作导致类型为 m b 的最终值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>A third, auxiliary function (</font><code>(&gt;&gt;)</code><font>) is defined in terms of the bind operation that discards its argument.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第三个辅助函数 ((&gt;&gt;)) 是根据丢弃其参数的绑定操作定义的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>(&gt;&gt;) ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> m b <span class=ot>-&gt;</span> m b
m <span class=fu>&gt;&gt;</span> k <span class=fu>=</span> m <span class=fu>&gt;&gt;=</span> \_ <span class=ot>-&gt;</span> k</code></pre></div>
<p><font>This definition says that (&gt;&gt;) has a left and right argument which are monadic with types </font><code>m a</code><font> and </font><code>m b</code><font> respectively, while the infix returns a value of type </font><code>m b</code><font>. The actual implementation of (&gt;&gt;) says that when </font><code>m</code><font> is passed to </font><code>(&gt;&gt;)</code><font> with </font><code>k</code><font> on the right, the value </font><code>k</code><font> will always be returned.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这个定义说 (&gt;&gt;) 有一个左参数和右参数，它们分别是类型 m a 和 m b 的单子，而中缀返回类型 m b 的值。 (&gt;&gt;) 的实际实现是说，当 m 传递给右边有 k 的 (&gt;&gt;) 时，将始终返回值 k。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=laws><font>Laws</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>法律</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>In addition to specific implementations of </font><code>(&gt;&gt;=)</code><font> and </font><code>return</code><font>, all monad instances must satisfy three laws.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>除了 (&gt;&gt;=) 和 return 的具体实现之外，所有的 monad 实例都必须满足三个定律。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Law 1<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 1</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>The first law says that when </font><code>return a</code><font> is passed through a </font><code>(&gt;&gt;=)</code><font> into a function </font><code>f</code><font>, this expression is exactly equivalent to </font><code>f a</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第一定律说当return a通过a(&gt;&gt;=)进入函数f时，这个表达式正好等价于f a。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">return a <span class=fu>&gt;&gt;=</span> f ≡ f a    <span class=co>-- N.B. 'a' refers to a value, not a type</span></code></pre></div>
<p><font>In discussing the next two laws, we'll refer to a value </font><code>m</code><font>. This notation is shorthand for value wrapped in a monadic context. Such a value has type </font><code>m a</code><font>, and could be represented more concretely by values like </font><code>Nothing</code><font>, </font><code>Just x</code><font>, or </font><code>Right x</code><font>. It is important to note that some of these concrete instantiations of the value </font><code>m</code><font> have multiple components. In discussing the second and third monad laws, we'll see some examples of how this plays out.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在讨论接下来的两个定律时，我们将引用一个值 m。此表示法是包装在单子上下文中的值的简写。这样的值的类型为 m a，可以更具体地表示为 Nothing、Just x 或 Right x 等值。重要的是要注意，值 m 的这些具体实例中的一些具有多个组件。在讨论第二和第三单子定律时，我们将看到一些例子来说明这是如何发生的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Law 2<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 2</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>The second law states that a monadic value </font><code>m</code><font> passed through </font><code>(&gt;&gt;=)</code><font> into </font><code>return</code><font> is exactly equivalent to itself. In other words, using bind to pass a monadic value to </font><code>return</code><font> does not change the initial value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第二定律指出，通过 (&gt;&gt;=) 传递到 return 的一元值 m 完全等同于其自身。换句话说，使用 bind 传递一个 monadic 值返回并不会改变初始值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class=fu>&gt;&gt;=</span> return ≡ m        <span class=co>-- 'm' here refers to a value that has type 'm a'</span></code></pre></div>
<p><font>A more explicit way to write the second Monad law exists. In this following example code, the first expression shows how the second law applies to values represented by </font><a href=https://wiki.haskell.org/Constructor#Type_constructor>non-nullary</a><font> type constructors. The second snippet shows how a value represented by a nullary type constructor works within the context of the second law.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在编写第二 Monad 定律的更明确的方法。在下面的示例代码中，第一个表达式显示了第二定律如何应用于由非空类型​​构造函数表示的值。第二个片段显示了空类型构造函数表示的值如何在第二定律的上下文中工作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class=dt>SomeMonad</span> val) <span class=fu>&gt;&gt;=</span> return ≡ <span class=dt>SomeMonad</span> val  <span class=co>-- 'SomeMonad val' has type 'm a' just</span>
                                            <span class=co>-- like 'm' from the first example of the</span>
                                            <span class=co>-- second law</span>

<span class=dt>NullaryMonadType</span> <span class=fu>&gt;&gt;=</span> return ≡ <span class=dt>NullaryMonadType</span></code></pre></div>
<p><strong>Law 3<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>While the first two laws are relatively clear, the third law may be more difficult to understand. This law states that when a monadic value </font><code>m</code><font> is passed through </font><code>(&gt;&gt;=)</code><font> to the function </font><code>f</code><font> and then the result of that expression is passed to </font><code>&gt;&gt;= g</code><font>, the entire expression is exactly equivalent to passing </font><code>m</code><font> to a lambda expression that takes one parameter </font><code>x</code><font> and outputs the function </font><code>f</code><font> applied to </font><code>x</code><font>. By the definition of bind, </font><code>f x</code> <em>must</em><font> return a value wrapped in the same Monad. Because of this property, the resultant value of that expression can be passed through </font><code>(&gt;&gt;=)</code><font> to the function </font><code>g</code><font>, which also returns a monadic value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>前两个定律比较清楚，第三个定律可能比较难理解。该定律指出，当一个单子值 m 通过 (&gt;&gt;=) 传递给函数 f，然后该表达式的结果传递给 &gt;&gt;= g 时，整个表达式完全等同于将 m 传递给一个 lambda 表达式接受一个参数 x 并输出应用于 x 的函数 f。根据 bind 的定义，f x 必须返回一个包装在同一个 Monad 中的值。由于这个属性，该表达式的结果值可以通过 (&gt;&gt;=) 传递给函数 g，该函数也返回一个单子值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class=fu>&gt;&gt;=</span> f) <span class=fu>&gt;&gt;=</span> g ≡ m <span class=fu>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span> f x <span class=fu>&gt;&gt;=</span> g)  <span class=co>-- Like in the last law, 'm' has</span>
                                           <span class=co>-- has type 'm a'. The functions 'f'</span>
                                           <span class=co>-- and 'g' have types '(a -&gt; m b)'</span>
                                           <span class=co>-- and '(b -&gt; m c)' respectively</span></code></pre></div>
<p><font>Again, it is possible to write this law with more explicit code. Like in the explicit examples for law 2, </font><code>m</code><font> has been replaced by </font><code>SomeMonad val</code><font> in order to be very clear that there can be multiple components to a monadic value. Although little has changed in the code, it is easier to see what value--namely, </font><code>val</code><font>--corresponds to the </font><code>x</code><font> in the lambda expression. After </font><code>SomeMonad val</code><font> is passed through </font><code>(&gt;&gt;=)</code><font> to </font><code>f</code><font>, the function </font><code>f</code><font> operates on </font><code>val</code><font> and returns a result still wrapped in the </font><code>SomeMonad</code><font> type constructor. We can call this new value </font><code>SomeMonad newVal</code><font>. Since it is still wrapped in the monadic context, </font><code>SomeMonad newVal</code><font> can thus be passed through the bind operation into the function </font><code>g</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>同样，可以用更明确的代码编写此法则。与法则 2 的显式示例一样，m 已被替换为 SomeMonad val 以便非常清楚地表明单子值可以有多个组件。尽管代码几乎没有变化，但更容易看出什么值（即 val）对应于 lambda 表达式中的 x。在 SomeMonad val 通过 (&gt;&gt;=) 传递给 f 之后，函数 f 对 val 进行操作并返回一个结果，该结果仍然包装在 SomeMonad 类型构造函数中。我们可以将这个新值称为 SomeMonad newVal。由于它仍然包裹在 monadic 上下文中，因此 SomeMonad newVal 可以通过绑定操作传递到函数 g 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">((<span class=dt>SomeMonad</span> val) <span class=fu>&gt;&gt;=</span> f) <span class=fu>&gt;&gt;=</span> g ≡ (<span class=dt>SomeMonad</span> val) <span class=fu>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span> f x <span class=fu>&gt;&gt;=</span> g)</code></pre></div>
<p><font>See: </font><a href=http://wiki.haskell.org/Monad_laws>Monad Laws</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：Monad 法则</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=do-notation><font>Do Notation</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>做符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Monadic syntax in Haskell is written in a sugared form, known as </font><code>do</code><font> notation. The advantages of this special syntax are that it is easier to write and is entirely equivalent to just applications of the monad operations. The desugaring is defined recursively by the rules:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中的 Monadic 语法是以糖化形式编写的，称为 do 表示法。这种特殊语法的优点是它更容易编写并且完全等同于 monad 操作的应用程序。脱糖由规则递归定义：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>do</span> { a <span class=ot>&lt;-</span> f ; m } ≡ f <span class=fu>&gt;&gt;=</span> \a <span class=ot>-&gt;</span> <span class=kw>do</span> { m }  <span class=co>-- bind 'f' to a, proceed to desugar</span>
                                          <span class=co>-- 'm'</span>

<span class=kw>do</span> { f ; m } ≡ f <span class=fu>&gt;&gt;</span> <span class=kw>do</span> { m }              <span class=co>-- evaluate 'f', then proceed to</span>
                                          <span class=co>-- desugar  m</span>

<span class=kw>do</span> { m } ≡ m</code></pre></div>
<p><font>Thus, through the application of the desugaring rules, the following expressions are equivalent:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，通过应用脱糖规则，以下表达式是等价的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>do</span>
  a <span class=ot>&lt;-</span> f                               <span class=co>-- f, g, and h are bound to the names a,</span>
  b <span class=ot>&lt;-</span> g                               <span class=co>-- b, and c. These names are then passed</span>
  c <span class=ot>&lt;-</span> h                               <span class=co>-- to 'return' to ensure that all values</span>
  return (a, b, c)                     <span class=co>-- are wrapped in the appropriate monadic</span>
                                       <span class=co>-- context</span>

<span class=kw>do</span> {                                   <span class=co>-- N.B. '{}'  and ';' characters are</span>
  a <span class=ot>&lt;-</span> f;                              <span class=co>--  rarely used in do-notation</span>
  b <span class=ot>&lt;-</span> g;
  c <span class=ot>&lt;-</span> h;
  return (a, b, c)
  }

f <span class=fu>&gt;&gt;=</span> \a <span class=ot>-&gt;</span>
  g <span class=fu>&gt;&gt;=</span> \b <span class=ot>-&gt;</span>
    h <span class=fu>&gt;&gt;=</span> \c <span class=ot>-&gt;</span>
      return (a, b, c)</code></pre></div>
<p><font>If one were to write the bind operator as an uncurried function ( this is not how Haskell uses it ) the same desugaring might look something like the following chain of nested binds with lambdas.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果将绑定运算符编写为非柯里化函数（这不是 Haskell 使用它的方式），则相同的脱糖可能类似于以下带有 lambda 的嵌套绑定链。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">bindMonad(f, lambda a<span class=fu>:</span>
  bindMonad(g, lambda b<span class=fu>:</span>
    bindMonad(h, lambda c<span class=fu>:</span>
      returnMonad (a,b,c))))</code></pre></div>
<p><font>In the do-notation, the </font><a href=#laws>monad laws</a><font> from above are equivalently written:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 do-notation 中，上面的 monad 法则等价地写成：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Law 1<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 1</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class=kw>do</span> y <span class=ot>&lt;-</span> return x
     f y

<span class=fu>=</span> <span class=kw>do</span> f x</code></pre></div>
<p><strong>Law 2<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 2</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class=kw>do</span> x <span class=ot>&lt;-</span> m
     return x

<span class=fu>=</span> <span class=kw>do</span> m</code></pre></div>
<p><strong>Law 3<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class=kw>do</span> b <span class=ot>&lt;-</span> <span class=kw>do</span> a <span class=ot>&lt;-</span> m
             f a
     g b

<span class=fu>=</span> <span class=kw>do</span> a <span class=ot>&lt;-</span> m
     b <span class=ot>&lt;-</span> f a
     g b

<span class=fu>=</span> <span class=kw>do</span> a <span class=ot>&lt;-</span> m
     <span class=kw>do</span> b <span class=ot>&lt;-</span> f a
        g b</code></pre></div>
<p><font>See: </font><a href=http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14>Haskell 2010: Do Expressions</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Haskell 2010：做表达式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=maybe><font>Maybe</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>或许</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><em>Maybe</em><font> monad is the simplest first example of a monad instance. The Maybe monad models computations which fail to yield a value at any point during computation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Maybe monad 是 monad 实例的最简单的第一个例子。 Maybe monad 对在计算过程中的任何时候都无法产生值的计算进行建模。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The Maybe type has two value constructors. The first, </font><code>Just</code><font>, is a unary constructor representing a successful computation, while the second, </font><code>Nothing</code><font>, is a nullary constructor that represents failure.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Maybe 类型有两个值构造函数。第一个 Just 是表示成功计算的一元构造函数，而第二个 Nothing 是表示失败的空构造函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Maybe</span> a <span class=fu>=</span> <span class=dt>Just</span> a <span class=fu>|</span> <span class=dt>Nothing</span></code></pre></div>
<p><font>The monad instance describes the implementation of </font><code>(&gt;&gt;=)</code><font> for </font><code>Maybe</code><font> by pattern matching on the possible inputs that could be passed to the bind operation (i.e., </font><code>Nothing</code><font> or </font><code>Just x</code><font>). The instance declaration also provides an implementation of </font><code>return</code><font>, which in this case is simply </font><code>Just</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>monad 实例通过对可能传递给绑定操作的可能输入（即 Nothing 或 Just x）进行模式匹配来描述 Maybe 的 (&gt;&gt;=) 的实现。实例声明还提供了 return 的实现，在本例中就是 Just。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Monad</span> <span class=dt>Maybe</span> <span class=kw>where</span>
  (<span class=dt>Just</span> x) <span class=fu>&gt;&gt;=</span> k <span class=fu>=</span> k x            <span class=co>-- 'k' is a function with type  (a -&gt; Maybe a)</span>
  <span class=dt>Nothing</span>  <span class=fu>&gt;&gt;=</span> k <span class=fu>=</span> <span class=dt>Nothing</span>

  return <span class=fu>=</span> <span class=dt>Just</span>                   <span class=co>-- Just's type signature is (a -&gt; Maybe a), in</span>
                                  <span class=co>-- other words, extremely similar to the</span>
                                  <span class=co>-- type of 'return' in the typeclass</span>
                                  <span class=co>-- declaration above.</span></code></pre></div>
<p><font>The following code shows some simple operations to do within the Maybe monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>以下代码显示了在 Maybe monad 中执行的一些简单操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In the first example, The value </font><code>Just 3</code><font> is passed via </font><code>(&gt;&gt;=)</code><font> to the lambda function </font><code>\x -&gt; return (x + 1)</code><font>. </font><code>x</code><font> refers to the </font><code>Int</code><font> portion of </font><code>Just 3</code><font>, and we can use </font><code>x</code><font> in the second half of the lambda expression, where </font><code>return (x + 1)</code><font> evaluates to </font><code>Just 4</code><font>, indicating a successful computation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在第一个示例中，值 Just 3 通过 (&gt;&gt;=) 传递给 lambda 函数 \x -&gt; return (x + 1)。 x 指的是 Just 3 的 Int 部分，我们可以在 lambda 表达式的后半部分使用 x，其中 return (x + 1) 计算结果为 Just 4，表示计算成功。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class=dt>Just</span> <span class=dv>3</span>) <span class=fu>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span> return (x <span class=fu>+</span> <span class=dv>1</span>))
<span class=co>-- Just 4</span></code></pre></div>
<p><font>In the second example, the value </font><code>Nothing</code><font> is passed via </font><code>(&gt;&gt;=)</code><font> to the same lambda function as in the previous example. However, according to the </font><code>Maybe</code><font> Monad instance, whenever </font><code>Nothing</code><font> is bound to a function, the expression's result will be </font><code>Nothing</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在第二个示例中，值 Nothing 通过 (&gt;&gt;=) 传递给与上一个示例相同的 lambda 函数。但是，根据 Maybe Monad 实例，只要 Nothing 绑定到函数，表达式的结果将是 Nothing。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Nothing</span> <span class=fu>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span> return (x <span class=fu>+</span> <span class=dv>1</span>))
<span class=co>-- Nothing</span></code></pre></div>
<p><font>In the next example, </font><code>return</code><font> is applied to </font><code>4</code><font> and returns </font><code>Just 4</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在下一个示例中，return 应用于 4 并返回 Just 4。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">return <span class=dv>4</span><span class=ot> ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
<span class=co>-- Just 4</span></code></pre></div>
<p><font>The next code examples show the use of </font><code>do</code><font> notation within the Maybe monad to do addition that might fail. Desugared examples are provided as well.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>下一个代码示例显示了在 Maybe monad 中使用 do 表示法来执行可能会失败的加法。还提供了脱糖示例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/02-monads/maybe.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>example1 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> <span class=dt>Just</span> <span class=dv>3</span>                <span class=co>-- Bind 3 to name a</span>
  b <span class=ot>&lt;-</span> <span class=dt>Just</span> <span class=dv>4</span>                <span class=co>-- Bind 4 to name b</span>
  return <span class=fu>$</span> a <span class=fu>+</span> b             <span class=co>-- Evaluate (a + b), then use 'return' to ensure</span>
                             <span class=co>-- the result is in the Maybe monad in order to</span>
                             <span class=co>-- satisfy the type signature</span>
<span class=co>-- Just 7</span>

<span class=ot>desugared1 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
desugared1 <span class=fu>=</span> <span class=dt>Just</span> <span class=dv>3</span> <span class=fu>&gt;&gt;=</span> \a <span class=ot>-&gt;</span>    <span class=co>-- This example is the desugared</span>
               <span class=dt>Just</span> <span class=dv>4</span> <span class=fu>&gt;&gt;=</span> \b <span class=ot>-&gt;</span>  <span class=co>-- equivalent to example1</span>
                 return <span class=fu>$</span> a <span class=fu>+</span> b
<span class=co>-- Just 7</span>

<span class=ot>example2 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> <span class=dt>Just</span> <span class=dv>3</span>                <span class=co>-- Bind 3 to name a</span>
  b <span class=ot>&lt;-</span> <span class=dt>Nothing</span>               <span class=co>-- Bind Nothing to name b</span>
  return <span class=fu>$</span> a <span class=fu>+</span> b
<span class=co>-- Nothing                   -- This result might be somewhat surprising, since</span>
                             <span class=co>-- addition within the Maybe monad can actually</span>
                             <span class=co>-- return 'Nothing'. This result occurs because one</span>
                             <span class=co>-- of the values, Nothing, indicates computational</span>
                             <span class=co>-- failure. Since the computation failed at one</span>
                             <span class=co>-- step within the process, the whole computation</span>
                             <span class=co>-- fails, leaving us with 'Nothing' as the final</span>
                             <span class=co>-- result.</span>

<span class=ot>desugared2 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
desugared2 <span class=fu>=</span> <span class=dt>Just</span> <span class=dv>3</span> <span class=fu>&gt;&gt;=</span> \a <span class=ot>-&gt;</span>     <span class=co>-- This example is the desugared</span>
               <span class=dt>Nothing</span> <span class=fu>&gt;&gt;=</span> \b <span class=ot>-&gt;</span>  <span class=co>-- equivalent to example2</span>
                 return <span class=fu>$</span> a <span class=fu>+</span> b
<span class=co>-- Nothing</span></code></pre></div>
<h2 id=list><font>List</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><em>List</em><font> monad is the second simplest example of a monad instance. As always, this monad implements both </font><code>(&gt;&gt;=)</code><font> and </font><code>return</code><font>. The definition of bind says that when the list </font><code>m</code><font> is bound to a function </font><code>f</code><font>, the result is a concatenation of </font><code>map f</code><font> over the list </font><code>m</code><font>. The </font><code>return</code><font> method simply takes a single value </font><code>x</code><font> and injects into a singleton list </font><code>[x]</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>List monad 是 monad 实例的第二个最简单的例子。一如既往，这个 monad 实现了 (&gt;&gt;=) 和 return。 bind 的定义表明，当列表 m 绑定到函数 f 时，结果是映射 f 在列表 m 上的串联。 return 方法只接受一个值 x 并注入到一个单例列表 [x] 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Monad</span> [] <span class=kw>where</span>
  m <span class=fu>&gt;&gt;=</span> f   <span class=fu>=</span>  concat (map f m)          <span class=co>-- 'm' is a list</span>
  return x  <span class=fu>=</span>  [x]</code></pre></div>
<p><font>In order to demonstrate the </font><code>List</code><font> monad's methods, we will define two functions: </font><code>m</code><font> and </font><code>f</code><font>. </font><code>m</code><font> is a simple list, while </font><code>f</code><font> is a function that takes a single </font><code>Int</code><font> and returns a two element list </font><code>[1, 0]</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了演示 List monad 的方法，我们将定义两个函数：m 和 f。 m 是一个简单列表，而 f 是一个接受单个 Int 并返回两个元素列表 [1, 0] 的函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>m ::</span> [<span class=dt>Int</span>]
m <span class=fu>=</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>]

<span class=ot>f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> [<span class=dt>Int</span>]
f <span class=fu>=</span> \x <span class=ot>-&gt;</span> [<span class=dv>1</span>,<span class=dv>0</span>]               <span class=co>-- 'f' always returns [1, 0]</span></code></pre></div>
<p><font>The evaluation proceeds as follows:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>评估过程如下：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class=fu>&gt;&gt;=</span> f
<span class=fu>==&gt;</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>] <span class=fu>&gt;&gt;=</span> \x <span class=ot>-&gt;</span> [<span class=dv>1</span>,<span class=dv>0</span>]
<span class=fu>==&gt;</span> concat (map (\x <span class=ot>-&gt;</span> [<span class=dv>1</span>,<span class=dv>0</span>]) [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>])
<span class=fu>==&gt;</span> concat ([[<span class=dv>1</span>,<span class=dv>0</span>],[<span class=dv>1</span>,<span class=dv>0</span>],[<span class=dv>1</span>,<span class=dv>0</span>],[<span class=dv>1</span>,<span class=dv>0</span>]])
<span class=fu>==&gt;</span> [<span class=dv>1</span>,<span class=dv>0</span>,<span class=dv>1</span>,<span class=dv>0</span>,<span class=dv>1</span>,<span class=dv>0</span>,<span class=dv>1</span>,<span class=dv>0</span>]</code></pre></div>
<p><font>The list comprehension syntax in Haskell can be implemented in terms of the list monad. List comprehensions can be considered syntactic sugar for more obviously monadic implementations. Examples </font><code>a</code><font> and </font><code>b</code><font> illustrate these use cases.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中的列表理解语法可以根据列表 monad 来实现。列表理解可以被认为是更明显的单子实​​现的语法糖。示例 a 和 b 说明了这些用例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The first example (</font><code>a</code><font>) illustrates how to write a list comprehension. Although the syntax looks strange at first, there are elements of it that may look familiar. For instance, the use of </font><code>&lt;-</code><font> is just like bind in a </font><code>do</code><font> notation: It binds an element of a list to a name. However, one major difference is apparent: </font><code>a</code><font> seems to lack a call to </font><code>return</code><font>. Not to worry, though, the </font><code>[]</code><font> fills this role. This syntax can be easily desugared by the compiler to an explicit invocation of </font><code>return</code><font>. Furthermore, it serves to remind the user that the computation takes place in the List monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第一个示例 (a) 说明了如何编写列表理解。尽管语法乍一看很奇怪，但其中的某些元素可能看起来很熟悉。例如，&lt;- 的使用就像 do 符号中的 bind 一样：它将列表的元素绑定到名称。但是，一个主要区别是显而易见的：a 似乎缺少返回的调用。不过不用担心，[] 扮演了这个角色。编译器可以轻松地将此语法脱糖为显式调用 return。此外，它用于提醒用户计算发生在 List monad 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=fu>=</span> [
      f x y <span class=fu>|</span>        <span class=co>-- Corresponds to 'f x y' in example b</span>
      x <span class=ot>&lt;-</span> xs,
      y <span class=ot>&lt;-</span> ys,
      x <span class=fu>==</span> y         <span class=co>-- Corresponds to 'guard $ x == y' in example b</span>
    ]</code></pre></div>
<p><font>The second example (</font><code>b</code><font>) shows the list comprehension above rewritten with </font><code>do</code><font> notation:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第二个示例 (b) 显示了上面用 do 符号重写的列表理解：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Identical to `a`</span>
b <span class=fu>=</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> xs
  y <span class=ot>&lt;-</span> ys
  guard <span class=fu>$</span> x <span class=fu>==</span> y     <span class=co>-- Corresponds to 'x == y' in example a</span>
  return <span class=fu>$</span> f x y     <span class=co>-- Corresponds to the '[]' and 'f x y' in example a</span></code></pre></div>
<p><font>The final examples are further illustrations of the List monad. The functions below each return a list of 3-tuples which contain the possible combinations of the three lists that get bound the names </font><code>a</code><font>, </font><code>b</code><font>, and </font><code>c</code><font>. N.B.: Only values in the list bound to </font><code>a</code><font> can be used in </font><code>a</code><font> position of the tuple; the same fact holds true for the lists bound to </font><code>b</code><font> and </font><code>c</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最后的例子是 List monad 的进一步说明。下面的每个函数都返回一个三元组列表，其中包含绑定名称 a、b 和 c 的三个列表的可能组合。注意：只有绑定到 a 的列表中的值才能用于元组的位置；同样的事实也适用于绑定到 b 和 c 的列表。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/02-monads/list.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>example ::</span> [(<span class=dt>Int</span>, <span class=dt>Int</span>, <span class=dt>Int</span>)]
example <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> [<span class=dv>1</span>,<span class=dv>2</span>]
  b <span class=ot>&lt;-</span> [<span class=dv>10</span>,<span class=dv>20</span>]
  c <span class=ot>&lt;-</span> [<span class=dv>100</span>,<span class=dv>200</span>]
  return (a,b,c)
<span class=co>-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span>

<span class=ot>desugared ::</span> [(<span class=dt>Int</span>, <span class=dt>Int</span>, <span class=dt>Int</span>)]
desugared <span class=fu>=</span> [<span class=dv>1</span>, <span class=dv>2</span>] <span class=fu>&gt;&gt;=</span> \a <span class=ot>-&gt;</span>
              [<span class=dv>10</span>, <span class=dv>20</span>] <span class=fu>&gt;&gt;=</span> \b <span class=ot>-&gt;</span>
                [<span class=dv>100</span>, <span class=dv>200</span>] <span class=fu>&gt;&gt;=</span> \c <span class=ot>-&gt;</span>
                  return (a, b, c)
<span class=co>-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></code></pre></div>
<h2 id=io><font>IO</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>输入输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Perhaps the most (in)famous example in Haskell of a type that forms a monad is </font><code>IO</code><font>. A value of type </font><code>IO a</code><font> is a computation which, when performed, does some I/O before returning a value of type </font><code>a</code><font>. These computations are called </font><a href=https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions>actions</a><font>. IO actions executed in </font><code>main</code><font> are the means by which a program can operate on or access information in the external world. IO actions allow the program to do many things, including, but not limited to:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也许 Haskell 中最著名（最不知名）的构成 monad 类型的例子是 IO。 IO a 类型的值是一种计算，执行时​​会在返回 a 类型的值之前执行一些 I/O。这些计算称为动作。在 main 中执行的 IO 操作是程序可以操作或访问外部世界信息的手段。 IO 动作允许程序做很多事情，包括但不限于：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Print a </font><code>String</code><font> to the terminal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>打印一个字符串到终端</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Read and parse input from the terminal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从终端读取和解析输入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Read from or write to a file on the system</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读取或写入系统上的文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Establish an </font><code>ssh</code><font> connection to a remote computer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与远程计算机建立 ssh 连接</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Take input from a radio antenna for singal processing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从无线电天线获取输入以进行信号处理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>Conceptualizing I/O as a monad enables the developer to access information outside the program, but operate on the data with pure functions. The following examples will show how we can use IO actions and IO values to receive input from stdin and print to stdout.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将 I/O 概念化为 monad 使开发人员能够访问程序外部的信息，但使用纯函数对数据进行操作。以下示例将展示我们如何使用 IO 操作和 IO 值从标准输入接收输入并打印到标准输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Perhaps the most immediately useful function for doing I/O in Haskell is </font><code>putStrLn</code><font>. This function takes a </font><code>String</code><font> and returns an </font><code>IO ()</code><font>. Calling it from </font><code>main</code><font> will result in the </font><code>String</code><font> being printed to stdout followed by a newline character.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也许在 Haskell 中执行 I/O 最直接有用的函数是 putStrLn。该函数接受一个字符串并返回一个 IO()。从 main 调用它会导致 String 被打印到 stdout，后跟一个换行符。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn<span class=ot> ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</code></pre></div>
<p><font>Here is some code that prints a couple of lines to the terminal. The first invocation of </font><code>putStrLn</code><font> is executed, causing the </font><code>String</code><font> to be printed to stdout. The result is bound to a lambda expression that discards its argument, and then the next </font><code>putStrLn</code><font> is executed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一些代码，可以将几行打印到终端。执行 putStrLn 的第一次调用，导致将字符串打印到标准输出。结果绑定到丢弃其参数的 lambda 表达式，然后执行下一个 putStrLn。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> putStrLn <span class=st>"Vesihiisi sihisi hississäään."</span> <span class=fu>&gt;&gt;=</span>
         \_ <span class=ot>-&gt;</span> putStrLn <span class=st>"Or in English: 'The water devil was hissing</span>
<span class=st>                         in her elevator'."</span>

<span class=co>-- Sugared code, written with do notation</span>
<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span> putStrLn <span class=st>"Vesihiisi sihisi hississäään."</span>
          putStrLn <span class=st>"Or in English: 'The water devil was hissing in her</span>
<span class=st>                    elevator'."</span></code></pre></div>
<p><font>Another useful function is </font><code>getLine</code><font> which has type </font><code>IO String</code><font>. This function gets a line of input from stdin. The developer can then bind this line to a name in order to operate on the value within the program.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>另一个有用的函数是 getLine，它的类型是 IO String。此函数从标准输入获取一行输入。然后开发人员可以将此行绑定到一个名称，以便在程序中对值进行操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">getLine<span class=ot> ::</span> <span class=dt>IO</span> <span class=dt>String</span></code></pre></div>
<p><font>The code below demonstrates a simple combination of these two functions as well as desugaring </font><code>IO</code><font> code. First, </font><code>putStrLn</code><font> prints a </font><code>String</code><font> to stdout to ask the user to supply their name, with the result being bound to a lambda that discards it argument. Then, </font><code>getLine</code><font> is executed, supplying a prompt to the user for entering their name. Next, the resultant </font><code>IO String</code><font> is bound to </font><code>name</code><font> and passed to </font><code>putStrLn</code><font>. Finally, the program prints the name to the terminal.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>下面的代码演示了这两个函数的简单组合以及脱糖 IO 代码。首先，putStrLn 将一个 String 打印到 stdout 以要求用户提供他们的名字，结果被绑定到一个丢弃它参数的 lambda。然后，执行 getLine，提示用户输入他们的名字。接下来，将生成的 IO String 绑定到 name 并传递给 putStrLn。最后，程序将名称打印到终端。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span> putStrLn <span class=st>"What is your name: "</span>
          name <span class=ot>&lt;-</span> getLine
          putStrLn name</code></pre></div>
<p><font>The next code block is the desugared equivalent of the previous example; however, the uses of </font><code>(&gt;&gt;=)</code><font> are made explict.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>下一个代码块是上一个示例的脱糖等价物；但是，(&gt;&gt;=) 的用法是明确的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> putStrLn <span class=st>"What is your name:"</span> <span class=fu>&gt;&gt;=</span>
       \_    <span class=ot>-&gt;</span> getLine <span class=fu>&gt;&gt;=</span>
       \name <span class=ot>-&gt;</span> putStrLn name</code></pre></div>
<p><font>Our final example executes in the same way as the previous two examples. This example, though, uses the special </font><code>(&gt;&gt;)</code> <a href=#monadic-methods>operator</a><font> to take the place of binding a result to the lamda that discards its argument.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们最后一个示例的执行方式与前两个示例相同。不过，此示例使用特殊 (&gt;&gt;) 运算符来代替将结果绑定到丢弃其参数的 lamda。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> putStrLn <span class=st>"What is your name: "</span> <span class=fu>&gt;&gt;</span> (getLine <span class=fu>&gt;&gt;=</span> (\name <span class=ot>-&gt;</span> putStrLn name))</code></pre></div>
<p><font>See: </font><a href=http://www.haskell.org/onlinereport/haskell2010/haskellch7.html>Haskell 2010: Basic/Input Output</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Haskell 2010：基本/输入输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=whats-the-point><font>What's the point?</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重点是什么？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Although it is difficult, if not impossible, to touch, see, or otherwise physically interact with a monad, this construct has some very interesting implications for programmers. For instance, consider the non-intuitive fact that we now have a uniform interface for talking about three very different, but foundational ideas for programming: </font><em>Failure</em><font>, </font><em>Collections</em><font> and </font><em>Effects</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尽管触摸、查看或以其他方式与 monad 进行物理交互是很困难的，如果不是不可能的话，但这种构造对程序员来说具有一些非常有趣的含义。例如，考虑一个非直观的事实，即我们现在有一个统一的界面来讨论三个非常不同但基本的编程思想：失败、集合和效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Let's write down a new function called </font><code>sequence</code><font> which folds a function </font><code>mcons</code><font> over a list of monadic computations. We can think of </font><code>mcons</code><font> as analogous to the list constructor (i.e. </font><code>(a : b : [])</code><font>) except it pulls the two list elements out of two monadic values (</font><code>p</code><font>,</font><code>q</code><font>) by means of bind. The bound values are then joined with the list constructor </font><code>:</code><font>, before finally being rewrapped in the appropriate monadic context with </font><code>return</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>让我们写下一个名为 sequence 的新函数，它将函数 mcons 折叠在一元计算列表上。我们可以将 mcons 视为类似于列表构造函数（即 (a : b : [])），只是它通过绑定将两个列表元素从两个单子值 (p,q) 中提取出来。绑定值然后与列表构造函数 : 连接，最后通过 return 在适当的 monadic 上下文中重新包装。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class=ot> ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> [m a] <span class=ot>-&gt;</span> m [a]
sequence <span class=fu>=</span> foldr mcons (return [])

<span class=ot>mcons ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m t <span class=ot>-&gt;</span> m [t] <span class=ot>-&gt;</span> m [t]
mcons p q <span class=fu>=</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> p          <span class=co>-- 'x' refers to a singleton value</span>
  y <span class=ot>&lt;-</span> q          <span class=co>-- 'y' refers to a list. Because of this fact, 'x' can be</span>
  return (x<span class=fu>:</span>y)    <span class=co>--  prepended to it</span></code></pre></div>
<p><font>What does this function mean in terms of each of the monads discussed above?</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就上面讨论的每个 monad 而言，这个函数意味着什么？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Maybe<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或许</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>Sequencing a list of values within the </font><code>Maybe</code> <a href=#maybe>context</a><font> allows us to collect the results of a series of computations which can possibly fail. However, </font><code>sequence</code><font> yields the aggregated values only if each computation succeeds. In other words, if even one of the </font><code>Maybe</code><font> values in the initial list passed to </font><code>sequence</code><font>is a </font><code>Nothing</code><font>, the result of </font><code>sequence</code><font> will also be </font><code>Nothing</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Maybe 上下文中对值列表进行排序允许我们收集一系列可能失败的计算结果。但是，仅当每次计算成功时，序列才会产生聚合值。换句话说，即使传递给序列的初始列表中的一个 Maybe 值是 Nothing，序列的结果也将是 Nothing。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class=ot> ::</span> [<span class=dt>Maybe</span> a] <span class=ot>-&gt;</span> <span class=dt>Maybe</span> [a]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence [<span class=dt>Just</span> <span class=dv>3</span>, <span class=dt>Just</span> <span class=dv>4</span>]
<span class=co>-- Just [3,4]</span>

sequence [<span class=dt>Just</span> <span class=dv>3</span>, <span class=dt>Just</span> <span class=dv>4</span>, <span class=dt>Nothing</span>]     <span class=co>-- Since one of the results is Nothing,</span>
<span class=co>-- Nothing                             -- the whole computation fails</span></code></pre></div>
<p><strong>List<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>The bind operation for the </font><a href=#list>list monad</a><font> forms the pairwise list of elements from the two operands. Thus, folding the binds contained in </font><code>mcons</code><font> over a list of lists with </font><code>sequence</code><font> implements the general Cartesian product for an arbitrary number of lists.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>列表 monad 的绑定操作形成来自两个操作数的元素的成对列表。因此，将 mcons 中包含的绑定折叠到具有序列的列表列表上，实现了任意数量列表的一般笛卡尔积。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class=ot> ::</span> [[a]] <span class=ot>-&gt;</span> [[a]]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence [[<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>],[<span class=dv>10</span>,<span class=dv>20</span>,<span class=dv>30</span>]]
<span class=co>-- [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]</span></code></pre></div>
<p><strong>IO<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>输入输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>Applying </font><code>sequence</code><font> within the </font><a href=#io>IO context</a><font> results in still a different result. The function takes a list of IO actions, performs them sequentially, and then returns the list of resulting values in the order sequenced.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 IO 上下文中应用序列会产生不同的结果。该函数采用 IO 操作列表，按顺序执行它们，然后按顺序返回结果值列表。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class=ot> ::</span> [<span class=dt>IO</span> a] <span class=ot>-&gt;</span> <span class=dt>IO</span> [a]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence [getLine, getLine, getLine]
<span class=co>-- a                                  -- a, b, and 9 are the inputs given by the</span>
<span class=co>-- b                                  -- user at the prompt</span>
<span class=co>-- 9</span>
<span class=co>-- ["a", "b", "9"]                    -- All inputs are returned in a list as</span>
                                      <span class=co>-- an IO [String].</span></code></pre></div>
<p><font>So there we have it, three fundamental concepts of computation that are normally defined independently of each other actually all share this similar structure. This unifying pattern can be abstracted out and reused to build higher abstractions that work for all current and future implementations. If you want a motivating reason for understanding monads, this is it! These insights are the essence of what I wish I knew about monads looking back.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以我们有了它，通常相互独立定义的三个基本计算概念实际上都共享这个相似的结构。这种统一的模式可以被抽象出来并重新使用，以构建适用于所有当前和未来实现的更高抽象。如果你想要一个理解 monad 的激励理由，就是这个！这些见解是我希望我回顾过去时了解的关于 monad 的精髓。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#g:4>Control.Monad</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Control.Monad</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=reader-monad><font>Reader Monad</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>读者单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The reader monad lets us access shared immutable state within a monadic context.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>reader monad 允许我们在 monadic 上下文中访问共享的不可变状态。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>ask ::</span> <span class=dt>Reader</span> r r
<span class=ot>asks ::</span> (r <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>Reader</span> r a
<span class=ot>local ::</span> (r <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> <span class=dt>Reader</span> r a <span class=ot>-&gt;</span> <span class=dt>Reader</span> r a
<span class=ot>runReader ::</span> <span class=dt>Reader</span> r a <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> a</code></pre></div>
<div class=sourceCode include=src/02-monads/reader.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.Reader</span>

<span class=kw>data</span> <span class=dt>MyContext</span> <span class=fu>=</span> <span class=dt>MyContext</span>
  {<span class=ot> foo ::</span> <span class=dt>String</span>
  ,<span class=ot> bar ::</span> <span class=dt>Int</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=ot>computation ::</span> <span class=dt>Reader</span> <span class=dt>MyContext</span> (<span class=dt>Maybe</span> <span class=dt>String</span>)
computation <span class=fu>=</span> <span class=kw>do</span>
  n <span class=ot>&lt;-</span> asks bar
  x <span class=ot>&lt;-</span> asks foo
  <span class=kw>if</span> n <span class=fu>&gt;</span> <span class=dv>0</span>
    <span class=kw>then</span> return (<span class=dt>Just</span> x)
    <span class=kw>else</span> return <span class=dt>Nothing</span>

<span class=ot>ex1 ::</span> <span class=dt>Maybe</span> <span class=dt>String</span>
ex1 <span class=fu>=</span> runReader computation <span class=fu>$</span> <span class=dt>MyContext</span> <span class=st>"hello"</span> <span class=dv>1</span>

<span class=ot>ex2 ::</span> <span class=dt>Maybe</span> <span class=dt>String</span>
ex2 <span class=fu>=</span> runReader computation <span class=fu>$</span> <span class=dt>MyContext</span> <span class=st>"haskell"</span> <span class=dv>0</span></code></pre></div>
<p><font>A simple implementation of the Reader monad:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Reader monad 的简单实现：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/02-monads/reader_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Reader</span> r a <span class=fu>=</span> <span class=dt>Reader</span> {<span class=ot> runReader ::</span> r <span class=ot>-&gt;</span> a }

<span class=kw>instance</span> <span class=dt>Monad</span> (<span class=dt>Reader</span> r) <span class=kw>where</span>
  return a <span class=fu>=</span> <span class=dt>Reader</span> <span class=fu>$</span> \_ <span class=ot>-&gt;</span> a
  m <span class=fu>&gt;&gt;=</span> k  <span class=fu>=</span> <span class=dt>Reader</span> <span class=fu>$</span> \r <span class=ot>-&gt;</span> runReader (k (runReader m r)) r

<span class=ot>ask ::</span> <span class=dt>Reader</span> a a
ask <span class=fu>=</span> <span class=dt>Reader</span> id

<span class=ot>asks ::</span> (r <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>Reader</span> r a
asks f <span class=fu>=</span> <span class=dt>Reader</span> f

<span class=ot>local ::</span> (r <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> <span class=dt>Reader</span> r a <span class=ot>-&gt;</span> <span class=dt>Reader</span> r a
local f m <span class=fu>=</span> <span class=dt>Reader</span> <span class=fu>$</span> runReader m <span class=fu>.</span> f</code></pre></div>
<h2 id=writer-monad><font>Writer Monad</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>作家莫纳德</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The writer monad lets us emit a lazy stream of values from within a monadic context.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>writer monad 允许我们从 monadic 上下文中发出一个惰性的值流。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>tell ::</span> w <span class=ot>-&gt;</span> <span class=dt>Writer</span> w ()
<span class=ot>execWriter ::</span> <span class=dt>Writer</span> w a <span class=ot>-&gt;</span> w
<span class=ot>runWriter ::</span> <span class=dt>Writer</span> w a <span class=ot>-&gt;</span> (a, w)</code></pre></div>
<div class=sourceCode include=src/02-monads/writer.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.Writer</span>

<span class=kw>type</span> <span class=dt>MyWriter</span> <span class=fu>=</span> <span class=dt>Writer</span> [<span class=dt>Int</span>] <span class=dt>String</span>

<span class=ot>example ::</span> <span class=dt>MyWriter</span>
example  <span class=fu>=</span> <span class=kw>do</span>
  tell [<span class=dv>1</span><span class=fu>..</span><span class=dv>3</span>]
  tell [<span class=dv>3</span><span class=fu>..</span><span class=dv>5</span>]
  return <span class=st>"foo"</span>

<span class=ot>output ::</span> (<span class=dt>String</span>, [<span class=dt>Int</span>])
output <span class=fu>=</span> runWriter example
<span class=co>-- ("foo", [1, 2, 3, 3, 4, 5])</span></code></pre></div>
<p><font>A simple implementation of the Writer monad:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Writer monad 的简单实现：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/02-monads/writer_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Monoid</span>

<span class=kw>newtype</span> <span class=dt>Writer</span> w a <span class=fu>=</span> <span class=dt>Writer</span> {<span class=ot> runWriter ::</span> (a, w) }

<span class=kw>instance</span> <span class=dt>Monoid</span> w <span class=ot>=&gt;</span> <span class=dt>Monad</span> (<span class=dt>Writer</span> w) <span class=kw>where</span>
  return a <span class=fu>=</span> <span class=dt>Writer</span> (a, mempty)
  m <span class=fu>&gt;&gt;=</span> k  <span class=fu>=</span> <span class=dt>Writer</span> <span class=fu>$</span> <span class=kw>let</span>
      (a, w)  <span class=fu>=</span> runWriter m
      (b, w') <span class=fu>=</span> runWriter (k a)
      <span class=kw>in</span> (b, w <span class=ot>`mappend`</span> w')

<span class=ot>execWriter ::</span> <span class=dt>Writer</span> w a <span class=ot>-&gt;</span> w
execWriter m <span class=fu>=</span> snd (runWriter m)

<span class=ot>tell ::</span> w <span class=ot>-&gt;</span> <span class=dt>Writer</span> w ()
tell w <span class=fu>=</span> <span class=dt>Writer</span> ((), w)</code></pre></div>
<p><font>This implementation is lazy, so some care must be taken that one actually wants to only generate a stream of thunks. Most often the lazy writer is not suitable for use, instead implement the equivalent structure by embedding some monomial object inside a StateT monad, or using the strict version.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此实现是惰性的，因此必须注意实际只想生成一个 thunk 流。大多数情况下，懒惰的编写器不适合使用，而是通过在 StateT monad 中嵌入一些单项式对象或使用严格版本来实现等效结构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.Writer.Strict</span></code></pre></div>
<h2 id=state-monad><font>State Monad</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>状态单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The state monad allows functions within a stateful monadic context to access and modify shared state.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>state monad 允许有状态 monadic 上下文中的函数访问和修改共享状态。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runState  ::</span> <span class=dt>State</span> s a <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> (a, s)
<span class=ot>evalState ::</span> <span class=dt>State</span> s a <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> a
<span class=ot>execState ::</span> <span class=dt>State</span> s a <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> s</code></pre></div>
<div class=sourceCode include=src/02-monads/state.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.State</span>

<span class=ot>test ::</span> <span class=dt>State</span> <span class=dt>Int</span> <span class=dt>Int</span>
test <span class=fu>=</span> <span class=kw>do</span>
  put <span class=dv>3</span>
  modify (<span class=fu>+</span><span class=dv>1</span>)
  get

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> print <span class=fu>$</span> execState test <span class=dv>0</span></code></pre></div>
<p><font>The state monad is often mistakenly described as being impure, but it is in fact entirely pure and the same effect could be achieved by explicitly passing state. A simple implementation of the State monad takes only a few lines:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>状态 monad 经常被错误地描述为不纯的，但实际上它是完全纯的，并且可以通过显式传递状态来实现相同的效果。 State monad 的简单实现只需要几行代码：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/02-monads/state_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>State</span> s a <span class=fu>=</span> <span class=dt>State</span> {<span class=ot> runState ::</span> s <span class=ot>-&gt;</span> (a,s) }

<span class=kw>instance</span> <span class=dt>Monad</span> (<span class=dt>State</span> s) <span class=kw>where</span>
  return a <span class=fu>=</span> <span class=dt>State</span> <span class=fu>$</span> \s <span class=ot>-&gt;</span> (a, s)

  <span class=dt>State</span> act <span class=fu>&gt;&gt;=</span> k <span class=fu>=</span> <span class=dt>State</span> <span class=fu>$</span> \s <span class=ot>-&gt;</span>
    <span class=kw>let</span> (a, s') <span class=fu>=</span> act s
    <span class=kw>in</span> runState (k a) s'

<span class=ot>get ::</span> <span class=dt>State</span> s s
get <span class=fu>=</span> <span class=dt>State</span> <span class=fu>$</span> \s <span class=ot>-&gt;</span> (s, s)

<span class=ot>put ::</span> s <span class=ot>-&gt;</span> <span class=dt>State</span> s ()
put s <span class=fu>=</span> <span class=dt>State</span> <span class=fu>$</span> \_ <span class=ot>-&gt;</span> ((), s)

<span class=ot>modify ::</span> (s <span class=ot>-&gt;</span> s) <span class=ot>-&gt;</span> <span class=dt>State</span> s ()
modify f <span class=fu>=</span> get <span class=fu>&gt;&gt;=</span> \x <span class=ot>-&gt;</span> put (f x)

<span class=ot>evalState ::</span> <span class=dt>State</span> s a <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> a
evalState act <span class=fu>=</span> fst <span class=fu>.</span> runState act

<span class=ot>execState ::</span> <span class=dt>State</span> s a <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> s
execState act <span class=fu>=</span> snd <span class=fu>.</span> runState act</code></pre></div>
<h2 id=monad-tutorials><font>Monad Tutorials</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>So many monad tutorials have been written that it begs the question: what makes monads so difficult when first learning Haskell? I hypothesize there are three aspects to why this is so:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>已经编写了如此多的 monad 教程，以至于它回避了一个问题：是什么让 monad 在第一次学习 Haskell 时如此困难？我假设有三个方面来解释为什么会这样：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ol style=list-style-type:decimal>
<li><em>There are several levels on indirection with desugaring.<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>脱糖的间接性有几个层次。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></em></li>
</ol>
<p><font>A lot of the Haskell we write is radically rearranged and transformed into an entirely new form under the hood.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们编写的很多 Haskell 都经过了彻底的重新排列，并在底层转变为一种全新的形式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Most monad tutorials will not manually expand out the do-sugar. This leaves the beginner thinking that monads are a way of dropping into a pseudo-imperative language inside of code and further fuels that misconception that specific instances like IO are monads in their full generality.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>大多数 monad 教程不会手动扩展 do-sugar。这让初学者认为 monad 是一种在代码内部使用伪命令式语言的方式，并进一步助长了这种误解，即像 IO 这样的特定实例是完全通用的 monad。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class=fu>=</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> getLine
  putStrLn x
  return ()</code></pre></div>
<p><font>Being able to manually desugar is crucial to understanding.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>能够手动脱糖对于理解至关重要。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class=fu>=</span>
  getLine <span class=fu>&gt;&gt;=</span> \x <span class=ot>-&gt;</span>
    putStrLn x <span class=fu>&gt;&gt;=</span> \_ <span class=ot>-&gt;</span>
      return ()</code></pre></div>
<ol start=2 style=list-style-type:decimal>
<li><em>Asymmetric binary infix operators for higher order functions are not common in other languages.<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>高阶函数的非对称二进制中缀运算符在其他语言中并不常见。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></em></li>
</ol>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>(&gt;&gt;=) ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m b</code></pre></div>
<p><font>On the left hand side of the operator we have an </font><code>m a</code><font> and on the right we have </font><code>a -&gt; m b</code><font>. Although some languages do have infix operators that are themselves higher order functions, it is still a rather rare occurrence.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在运算符的左侧，我们有一个 m a，在右侧，我们有一个 -&gt; m b。尽管某些语言确实有本身就是高阶函数的中缀运算符，但这种情况仍然很少见。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>So with a function desugared, it can be confusing that </font><code>(&gt;&gt;=)</code><font> operator is in fact building up a much larger function by composing functions together.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，在函数脱糖的情况下， (&gt;&gt;=) 运算符实际上是通过将函数组合在一起来构建一个更大的函数，这可能会让人感到困惑。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class=fu>=</span>
  getLine <span class=fu>&gt;&gt;=</span> \x <span class=ot>-&gt;</span>
    putStrLn <span class=fu>&gt;&gt;=</span> \_ <span class=ot>-&gt;</span>
      return ()</code></pre></div>
<p><font>Written in prefix form, it becomes a little bit more digestible.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>以前缀形式编写，它变得更容易理解一点。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class=fu>=</span>
  (<span class=fu>&gt;&gt;=</span>) getLine (\x <span class=ot>-&gt;</span>
    (<span class=fu>&gt;&gt;=</span>) putStrLn (\_ <span class=ot>-&gt;</span>
          return ()
    )
  )</code></pre></div>
<p><font>Perhaps even removing the operator entirely might be more intuitive coming from other languages.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>甚至完全删除运算符可能来自其他语言会更直观。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class=fu>=</span> bind getLine (\x <span class=ot>-&gt;</span> bind putStrLn (\_ <span class=ot>-&gt;</span> return ()))
  <span class=kw>where</span>
    bind x y <span class=fu>=</span> x <span class=fu>&gt;&gt;=</span> y</code></pre></div>
<ol start=3 style=list-style-type:decimal>
<li><em>Ad-hoc polymorphism is not commonplace in other languages.<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Ad-hoc 多态性在其他语言中并不常见。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></em></li>
</ol>
<p><font>Haskell's implementation of overloading can be unintuitive if one is not familiar with type inference. It is abstracted away from the user, but the </font><code>(&gt;&gt;=)</code><font> or </font><code>bind</code><font> function is really a function of 3 arguments with the extra typeclass dictionary argument (</font><code>$dMonad</code><font>) implicitly threaded around.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果不熟悉类型推断，Haskell 的重载实现可能不直观。它是从用户那里抽象出来的，但是 (&gt;&gt;=) 或 bind 函数实际上是一个具有 3 个参数的函数，带有额外的类型类字典参数 ($dMonad) 隐式线程化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class=fu>$</span>dMonad <span class=fu>=</span> bind <span class=fu>$</span>dMonad getLine (\x <span class=ot>-&gt;</span> bind <span class=fu>$</span>dMonad putStrLn (\_ <span class=ot>-&gt;</span> return <span class=fu>$</span>dMonad ()))</code></pre></div>
<p><font>Except in the case where the parameter of the monad class is unified ( through inference ) with a concrete class instance, in which case the instance dictionary (</font><code>$dMonadIO</code><font>) is instead spliced throughout.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>除了 monad 类的参数与具体类实例统一（通过推理）的情况外，在这种情况下，实例字典（$dMonadIO）被拼接在整个过程中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> bind <span class=fu>$</span>dMonadIO getLine (\x <span class=ot>-&gt;</span> bind <span class=fu>$</span>dMonadIO putStrLn (\_ <span class=ot>-&gt;</span> return <span class=fu>$</span>dMonadIO ()))</code></pre></div>
<p><font>Now, all of these transformations are trivial once we understand them, they're just typically not discussed. In my opinion the fundamental fallacy of monad tutorials is not that intuition for monads is hard to convey ( nor are metaphors required! ), but that novices often come to monads with an incomplete understanding of points (1), (2), and (3) and then trip on the simple fact that monads are the first example of a Haskell construct that is the confluence of all three.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在，一旦我们理解了所有这些转换都是微不足道的，它们通常不会被讨论。在我看来，monad 教程的根本谬误不是 monad 的直觉很难传达（也不需要隐喻！），而是新手在接触 monad 时常常对 (1)、(2) 和 ( 3) 然后基于一个简单的事实，即 monad 是 Haskell 构造的第一个示例，它是所有三者的汇合点。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/>Monad Tutorial Fallacy</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Monad 教程谬误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<hr>
<h1 id=monad-transformers><font>Monad Transformers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=mtl-transformers><font>mtl / transformers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>mtl/变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>So, the descriptions of Monads in the previous chapter are a bit of a white lie. Modern Haskell monad libraries typically use a more general form of these, written in terms of monad transformers which allow us to compose monads together to form composite monads. The monads mentioned previously are subsumed by the special case of the transformer form composed with the Identity monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以，上一章对Monads的描述有点善意的谎言。现代 Haskell monad 库通常使用这些更通用的形式，根据 monad 转换器编写，它允许我们将 monad 组合在一起以形成复合 monad。前面提到的 monad 包含在由 Identity monad 组成的 transformer 形式的特例中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Monad</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Transformer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>变压器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Type</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Transformed Type</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>变形型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Maybe</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或许</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>MaybeT</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也许T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><code>Maybe a<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也许一个</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>m (Maybe a)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>米（也许是）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><font>Reader</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读者</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>ReaderT</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读者T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><code>r -&gt; a<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>r -&gt; 一个</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>r -&gt; m a<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>r -&gt; 米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><font>Writer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作家</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>WriterT</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作家T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><code>(a,w)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(a,w)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>m (a,w)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>米（一，瓦）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><font>State</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>状态</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>StateT</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>状态T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><code>s -&gt; (a,s)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>s -&gt; (a,s)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>s -&gt; m (a,s)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>s -&gt; m (a,s)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
</tbody>
</table>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>State</span>  s <span class=fu>=</span> <span class=dt>StateT</span>  s <span class=dt>Identity</span>
<span class=kw>type</span> <span class=dt>Writer</span> w <span class=fu>=</span> <span class=dt>WriterT</span> w <span class=dt>Identity</span>
<span class=kw>type</span> <span class=dt>Reader</span> r <span class=fu>=</span> <span class=dt>ReaderT</span> r <span class=dt>Identity</span>

<span class=kw>instance</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>MonadState</span> s (<span class=dt>StateT</span> s m)
<span class=kw>instance</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>MonadReader</span> r (<span class=dt>ReaderT</span> r m)
<span class=kw>instance</span> (<span class=dt>Monoid</span> w, <span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>MonadWriter</span> w (<span class=dt>WriterT</span> w m)</code></pre></div>
<p><font>In terms of generality the mtl library is the most common general interface for these monads, which itself depends on the transformers library which generalizes the "basic" monads described above into transformers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就通用性而言，mtl 库是这些 monad 最常见的通用接口，它本身依赖于将上述“基本”monad 概括为转换器的 transformers 库。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=transformers><font>Transformers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>At their core monad transformers allow us to nest monadic computations in a stack with an interface to exchange values between the levels, called </font><code>lift</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在它们的核心，monad transformers 允许我们将 monadic 计算嵌套在一个堆栈中，并带有一个接口来在级别之间交换值，称为 lift。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>lift ::</span> (<span class=dt>Monad</span> m, <span class=dt>MonadTrans</span> t) <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> t m a
<span class=ot>liftIO ::</span> <span class=dt>MonadIO</span> m <span class=ot>=&gt;</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> m a</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>MonadTrans</span> t <span class=kw>where</span>
<span class=ot>    lift ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> t m a

<span class=kw>class</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>MonadIO</span> m <span class=kw>where</span>
<span class=ot>    liftIO ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> m a

<span class=kw>instance</span> <span class=dt>MonadIO</span> <span class=dt>IO</span> <span class=kw>where</span>
    liftIO <span class=fu>=</span> id</code></pre></div>
<p><font>Just as the base monad class has laws, monad transformers also have several laws:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>正如基本 monad 类有规律一样，monad 转换器也有几个规律：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Law #1<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 #1</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">lift <span class=fu>.</span> return <span class=fu>=</span> return</code></pre></div>
<p><strong>Law #2<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 #2</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">lift (m <span class=fu>&gt;&gt;=</span> f) <span class=fu>=</span> lift m <span class=fu>&gt;&gt;=</span> (lift <span class=fu>.</span> f)</code></pre></div>
<p><font>Or equivalently:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者等价地：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Law #1<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则#1</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">  lift (return x)

<span class=fu>=</span> return x</code></pre></div>
<p><strong>Law #2<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>法则 #2</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class=kw>do</span> x <span class=ot>&lt;-</span> lift m
     lift (f x)

<span class=fu>=</span> lift <span class=fu>$</span> <span class=kw>do</span> x <span class=ot>&lt;-</span> m
            f x</code></pre></div>
<p><font>It's useful to remember that transformers compose </font><em>outside-in</em><font> but are </font><em>unrolled inside out</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>记住变压器由外向内组合但由内向外展开是很有用的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://catamorph.de/publications/2004-10-01-monad-transformers.html>Monad Transformers: Step-By-Step</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Monad 变形金刚：循序渐进</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=basics-1><font>Basics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The most basic use requires us to use the T-variants for each of the monad transformers in the outer layers and to explicitly </font><code>lift</code><font> and </font><code>return</code><font> values between the layers. Monads have kind </font><code>(* -&gt; *)</code><font>, so monad transformers which take monads to monads have </font><code>((* -&gt; *) -&gt; * -&gt; *)</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最基本的用途要求我们为外层中的每个 monad 转换器使用 T 变体，并在层之间显式提升和返回值。 Monad 有种类 (* -&gt; *)，所以将 monad 转换为 monad 的 monad 转换器有 ((* -&gt; *) -&gt; * -&gt; *)：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Monad</span> (<span class=ot>m ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>)
<span class=dt>MonadTrans</span> (<span class=ot>t ::</span> (<span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>)</code></pre></div>
<p><font>So, for example, if we wanted to form a composite computation using both the Reader and Maybe monads we can now put the Maybe inside of a </font><code>ReaderT</code><font> to form </font><code>ReaderT t Maybe a</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，例如，如果我们想使用 Reader 和 Maybe monad 形成复合计算，我们现在可以将 Maybe 放在 ReaderT 中以形成 ReaderT t Maybe a。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/03-monad-transformers/transformer.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.Reader</span>

<span class=kw>type</span> <span class=dt>Env</span> <span class=fu>=</span> [(<span class=dt>String</span>, <span class=dt>Int</span>)]
<span class=kw>type</span> <span class=dt>Eval</span> a <span class=fu>=</span> <span class=dt>ReaderT</span> <span class=dt>Env</span> <span class=dt>Maybe</span> a

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Val</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>Add</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Var</span> <span class=dt>String</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=ot>eval ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Eval</span> <span class=dt>Int</span>
eval ex <span class=fu>=</span> <span class=kw>case</span> ex <span class=kw>of</span>

  <span class=dt>Val</span> n <span class=ot>-&gt;</span> return n

  <span class=dt>Add</span> x y <span class=ot>-&gt;</span> <span class=kw>do</span>
    a <span class=ot>&lt;-</span> eval x
    b <span class=ot>&lt;-</span> eval y
    return (a<span class=fu>+</span>b)

  <span class=dt>Var</span> x <span class=ot>-&gt;</span> <span class=kw>do</span>
    env <span class=ot>&lt;-</span> ask
    val <span class=ot>&lt;-</span> lift (lookup x env)
    return val

<span class=ot>env ::</span> <span class=dt>Env</span>
env <span class=fu>=</span> [(<span class=st>"x"</span>, <span class=dv>2</span>), (<span class=st>"y"</span>, <span class=dv>5</span>)]

<span class=ot>ex1 ::</span> <span class=dt>Eval</span> <span class=dt>Int</span>
ex1 <span class=fu>=</span> eval (<span class=dt>Add</span> (<span class=dt>Val</span> <span class=dv>2</span>) (<span class=dt>Add</span> (<span class=dt>Val</span> <span class=dv>1</span>) (<span class=dt>Var</span> <span class=st>"x"</span>)))

example1,<span class=ot> example2 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> runReaderT ex1 env
example2 <span class=fu>=</span> runReaderT ex1 []</code></pre></div>
<p><font>The fundamental limitation of this approach is that we find ourselves </font><code>lift.lift.lift</code><font>ing and </font><code>return.return.return</code><font>ing a lot.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这种方法的根本限制是我们发现自己 lift.lift.lifting 和 return.return.returning 很多。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=readert><font>ReaderT</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>读者T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>For example, there exist three possible forms of the Reader monad. The first is the Haskell 98 version that no longer exists, but is useful for understanding the underlying ideas. The other two are the </font><em>transformers</em><font> and </font><em>mtl</em><font> variants.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，Reader monad 存在三种可能的形式。第一个是不再存在的 Haskell 98 版本，但对于理解底层思想很有用。另外两个是 transformers 和 mtl 变体。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><em>Reader<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读者</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></em></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Reader</span> r a <span class=fu>=</span> <span class=dt>Reader</span> {<span class=ot> runReader ::</span> r <span class=ot>-&gt;</span> a }

<span class=kw>instance</span> <span class=dt>MonadReader</span> r (<span class=dt>Reader</span> r) <span class=kw>where</span>
  ask       <span class=fu>=</span> <span class=dt>Reader</span> id
  local f m <span class=fu>=</span> <span class=dt>Reader</span> (runReader m <span class=fu>.</span> f)</code></pre></div>
<p><em>ReaderT<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读者T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></em></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>ReaderT</span> r m a <span class=fu>=</span> <span class=dt>ReaderT</span> {<span class=ot> runReaderT ::</span> r <span class=ot>-&gt;</span> m a }

<span class=kw>instance</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>Monad</span> (<span class=dt>ReaderT</span> r m) <span class=kw>where</span>
  return a <span class=fu>=</span> <span class=dt>ReaderT</span> <span class=fu>$</span> \_ <span class=ot>-&gt;</span> return a
  m <span class=fu>&gt;&gt;=</span> k  <span class=fu>=</span> <span class=dt>ReaderT</span> <span class=fu>$</span> \r <span class=ot>-&gt;</span> <span class=kw>do</span>
      a <span class=ot>&lt;-</span> runReaderT m r
      runReaderT (k a) r

<span class=kw>instance</span> <span class=dt>MonadTrans</span> (<span class=dt>ReaderT</span> r) <span class=kw>where</span>
    lift m <span class=fu>=</span> <span class=dt>ReaderT</span> <span class=fu>$</span> \_ <span class=ot>-&gt;</span> m</code></pre></div>
<p><em>MonadReader<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子阅读器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></em></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>MonadReader</span> r m <span class=fu>|</span> m <span class=ot>-&gt;</span> r <span class=kw>where</span>
<span class=ot>  ask   ::</span> m r
<span class=ot>  local ::</span> (r <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> m a <span class=ot>-&gt;</span> m a

<span class=kw>instance</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>MonadReader</span> r (<span class=dt>ReaderT</span> r m) <span class=kw>where</span>
  ask       <span class=fu>=</span> <span class=dt>ReaderT</span> return
  local f m <span class=fu>=</span> <span class=dt>ReaderT</span> <span class=fu>$</span> \r <span class=ot>-&gt;</span> runReaderT m (f r)</code></pre></div>
<p><font>So, hypothetically the three variants of ask would be:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，假设 ask 的三种变体是：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>ask ::</span> <span class=dt>Reader</span> r r
<span class=ot>ask ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>ReaderT</span> r m r
<span class=ot>ask ::</span> <span class=dt>MonadReader</span> r m <span class=ot>=&gt;</span> m r</code></pre></div>
<p><font>In practice only the last one is used in modern Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>实际上，只有最后一个在现代 Haskell 中使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=newtype-deriving><font>Newtype Deriving</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>新型派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Newtypes let us reference a data type with a single constructor as a new distinct type, with no runtime overhead from boxing, unlike an algebraic datatype with a single constructor. Newtype wrappers around strings and numeric types can often drastically reduce accidental errors.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>新类型让我们将具有单个构造函数的数据类型引用为新的不同类型，与具有单个构造函数的代数数据类型不同，没有来自装箱的运行时开销。围绕字符串和数字类型的新类型包装器通常可以大大减少意外错误。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Consider the case of using a newtype to distinguish between two different text blobs with different semantics. Both have the same runtime representation as a text object, but are distinguished statically, so that plaintext can not be accidentally interchanged with encrypted text.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑使用新类型来区分具有不同语义的两个不同文本块的情况。两者都具有与文本对象相同的运行时表示，但静态区分，因此明文不会意外地与加密文本互换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Plaintext</span> <span class=fu>=</span> <span class=dt>Plaintext</span> <span class=dt>Text</span>
<span class=kw>newtype</span> <span class=dt>Crytpotext</span> <span class=fu>=</span> <span class=dt>Cryptotext</span> <span class=dt>Text</span>

<span class=ot>encrypt ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Plaintext</span> <span class=ot>-&gt;</span> <span class=dt>Cryptotext</span>
<span class=ot>decrypt ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Cryptotext</span> <span class=ot>-&gt;</span> <span class=dt>Plaintext</span></code></pre></div>
<p><font>The other common use case is using newtypes to derive logic for deriving custom monad transformers in our business logic. Using </font><code>-XGeneralizedNewtypeDeriving</code><font> we can recover the functionality of instances of the underlying types composed in our transformer stack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>另一个常见用例是使用新类型来派生逻辑，以在我们的业务逻辑中派生自定义 monad 转换器。使用 -XGeneralizedNewtypeDeriving 我们可以恢复在我们的转换器堆栈中组成的基础类型实例的功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/03-monad-transformers/newtype.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class=kw>newtype</span> <span class=dt>Velocity</span> <span class=fu>=</span> <span class=dt>Velocity</span> {<span class=ot> unVelocity ::</span> <span class=dt>Double</span> }
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Ord</span>)

<span class=ot>v ::</span> <span class=dt>Velocity</span>
v <span class=fu>=</span> <span class=dt>Velocity</span> <span class=fl>2.718</span>

<span class=ot>x ::</span> <span class=dt>Double</span>
x <span class=fu>=</span> <span class=fl>2.718</span>

<span class=co>-- Type error is caught at compile time even though</span>
<span class=co>-- they are the same value at runtime!</span>
err <span class=fu>=</span> v <span class=fu>+</span> x

<span class=kw>newtype</span> <span class=dt>Quantity</span> v a <span class=fu>=</span> <span class=dt>Quantity</span> a
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Ord</span>, <span class=dt>Num</span>, <span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>Haskeller</span>
<span class=kw>type</span> <span class=dt>Haskellers</span> <span class=fu>=</span> <span class=dt>Quantity</span> <span class=dt>Haskeller</span> <span class=dt>Int</span>

a <span class=fu>=</span> <span class=dt>Quantity</span> <span class=dv>2</span><span class=ot> ::</span> <span class=dt>Haskellers</span>
b <span class=fu>=</span> <span class=dt>Quantity</span> <span class=dv>6</span><span class=ot> ::</span> <span class=dt>Haskellers</span>

<span class=ot>totalHaskellers ::</span> <span class=dt>Haskellers</span>
totalHaskellers <span class=fu>=</span> a <span class=fu>+</span> b</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Couldn't</span> match <span class=kw>type</span> <span class=ot>`Double' with `</span><span class=dt>Velocity'</span>
<span class=dt>Expected</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Velocity</span>
  <span class=dt>Actual</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Double</span>
<span class=dt>In</span> the second argument <span class=kw>of</span> <span class=ot>`(+)', namely `</span>x'
<span class=dt>In</span> the expression<span class=fu>:</span> v <span class=fu>+</span> x</code></pre></div>
<p><font>Using newtype deriving with the mtl library typeclasses we can produce flattened transformer types that don't require explicit lifting in the transform stack. For example, here is a little stack machine involving the Reader, Writer and State monads.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 mtl 库类型类的新类型派生，我们可以生成不需要在转换堆栈中显式提升的扁平转换器类型。例如，这是一个涉及 Reader、Writer 和 State monad 的小型堆栈机器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/03-monad-transformers/newtype_deriving.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class=kw>import </span><span class=dt>Control.Monad.Reader</span>
<span class=kw>import </span><span class=dt>Control.Monad.Writer</span>
<span class=kw>import </span><span class=dt>Control.Monad.State</span>

<span class=kw>type</span> <span class=dt>Stack</span>   <span class=fu>=</span> [<span class=dt>Int</span>]
<span class=kw>type</span> <span class=dt>Output</span>  <span class=fu>=</span> [<span class=dt>Int</span>]
<span class=kw>type</span> <span class=dt>Program</span> <span class=fu>=</span> [<span class=dt>Instr</span>]

<span class=kw>type</span> <span class=dt>VM</span> a <span class=fu>=</span> <span class=dt>ReaderT</span> <span class=dt>Program</span> (<span class=dt>WriterT</span> <span class=dt>Output</span> (<span class=dt>State</span> <span class=dt>Stack</span>)) a

<span class=kw>newtype</span> <span class=dt>Comp</span> a <span class=fu>=</span> <span class=dt>Comp</span> {<span class=ot> unComp ::</span> <span class=dt>VM</span> a }
  <span class=kw>deriving</span> (<span class=dt>Monad</span>, <span class=dt>MonadReader</span> <span class=dt>Program</span>, <span class=dt>MonadWriter</span> <span class=dt>Output</span>, <span class=dt>MonadState</span> <span class=dt>Stack</span>)

<span class=kw>data</span> <span class=dt>Instr</span> <span class=fu>=</span> <span class=dt>Push</span> <span class=dt>Int</span> <span class=fu>|</span> <span class=dt>Pop</span> <span class=fu>|</span> <span class=dt>Puts</span>

<span class=ot>evalInstr ::</span> <span class=dt>Instr</span> <span class=ot>-&gt;</span> <span class=dt>Comp</span> ()
evalInstr instr <span class=fu>=</span> <span class=kw>case</span> instr <span class=kw>of</span>
  <span class=dt>Pop</span>    <span class=ot>-&gt;</span> modify tail
  <span class=dt>Push</span> n <span class=ot>-&gt;</span> modify (n<span class=fu>:</span>)
  <span class=dt>Puts</span>   <span class=ot>-&gt;</span> <span class=kw>do</span>
    tos <span class=ot>&lt;-</span> gets head
    tell [tos]

<span class=ot>eval ::</span> <span class=dt>Comp</span> ()
eval <span class=fu>=</span> <span class=kw>do</span>
  instr <span class=ot>&lt;-</span> ask
  <span class=kw>case</span> instr <span class=kw>of</span>
    []     <span class=ot>-&gt;</span> return ()
    (i<span class=fu>:</span>is) <span class=ot>-&gt;</span> evalInstr i <span class=fu>&gt;&gt;</span> local (const is) eval

<span class=ot>execVM ::</span> <span class=dt>Program</span> <span class=ot>-&gt;</span> <span class=dt>Output</span>
execVM <span class=fu>=</span> flip evalState [] <span class=fu>.</span> execWriterT <span class=fu>.</span> runReaderT (unComp eval)

<span class=ot>program ::</span> <span class=dt>Program</span>
program <span class=fu>=</span> [
     <span class=dt>Push</span> <span class=dv>42</span>,
     <span class=dt>Push</span> <span class=dv>27</span>,
     <span class=dt>Puts</span>,
     <span class=dt>Pop</span>,
     <span class=dt>Puts</span>,
     <span class=dt>Pop</span>
  ]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> mapM_ print <span class=fu>$</span> execVM program</code></pre></div>
<p><font>Pattern matching on a newtype constructor compiles into nothing. For example the</font><code>extractB</code><font> function does not scrutinize the </font><code>MkB</code><font> constructor like the </font><code>extractA</code><font> does, because </font><code>MkB</code><font> does not exist at runtime, it is purely a compile-time construct.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>新类型构造函数上的模式匹配编译成空。例如，extractB 函数不像 extractA 那样仔细检查 MkB 构造函数，因为 MkB 在运行时不存在，它纯粹是编译时构造。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>A</span> <span class=fu>=</span> <span class=dt>MkA</span> <span class=dt>Int</span>
<span class=kw>newtype</span> <span class=dt>B</span> <span class=fu>=</span> <span class=dt>MkB</span> <span class=dt>Int</span>

<span class=ot>extractA ::</span> <span class=dt>A</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
extractA (<span class=dt>MkA</span> x) <span class=fu>=</span> x

<span class=ot>extractB ::</span> <span class=dt>B</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
extractB (<span class=dt>MkB</span> x) <span class=fu>=</span> x</code></pre></div>
<h2 id=efficiency><font>Efficiency</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>效率</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The second monad transformer law guarantees that sequencing consecutive lift operations is semantically equivalent to lifting the results into the outer monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第二个 monad 变换器法则保证对连续的提升操作进行排序在语义上等同于将结果提升到外部 monad 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>do</span> x <span class=ot>&lt;-</span> lift m  <span class=fu>==</span>  lift <span class=fu>$</span> <span class=kw>do</span> x <span class=ot>&lt;-</span> m
   lift (f x)                 f x</code></pre></div>
<p><font>Although they are guaranteed to yield the same result, the operation of lifting the results between the monad levels is not without cost and crops up frequently when working with the monad traversal and looping functions. For example, all three of the functions on the left below are less efficient than the right hand side which performs the bind in the base monad instead of lifting on each iteration.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尽管它们保证产生相同的结果，但在 monad 级别之间提升结果的操作并非没有成本，并且在使用 monad 遍历和循环功能时经常出现。例如，下面左侧的所有三个函数的效率都低于右侧，后者在基础 monad 中执行绑定而不是在每次迭代时提升。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Less Efficient      More Efficient</span>
forever (lift m)    <span class=fu>==</span> lift (forever m)
mapM_ (lift <span class=fu>.</span> f) xs <span class=fu>==</span> lift (mapM_ f xs)
forM_ xs (lift <span class=fu>.</span> f) <span class=fu>==</span> lift (forM_ xs f)</code></pre></div>
<h2 id=monad-morphisms><font>Monad Morphisms</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子态射</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The base monad transformer package provides a </font><code>MonadTrans</code><font> class for lifting to another monad:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>基础 monad 转换器包提供了一个 MonadTrans 类，用于提升到另一个 monad：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>lift ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> t m a</code></pre></div>
<p><font>But often times we need to work with and manipulate our monad transformer stack to either produce new transformers, modify existing ones or extend an upstream library with new layers. The </font><code>mmorph</code><font> library provides the capacity to compose monad morphism transformation directly on transformer stacks. The equivalent of type transformer type-level map is the </font><code>hoist</code><font> function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>但很多时候我们需要使用和操纵我们的 monad 转换器堆栈来生成新的转换器、修改现有转换器或使用新层扩展上游库。 mmorph 库提供了直接在转换器堆栈上组合 monad 态射转换的能力。相当于 type transformer type-level map 的是 hoist 函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>hoist ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> (forall a<span class=fu>.</span> m a <span class=ot>-&gt;</span> n a) <span class=ot>-&gt;</span> t m b <span class=ot>-&gt;</span> t n b</code></pre></div>
<p><font>Hoist takes a </font><em>monad morphism</em><font> (a mapping from a </font><code>m a</code><font> to a </font><code>n a</code><font>) and applies in on the inner value monad of a transformer stack, transforming the value under the outer layer.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Hoist 采用 monad 态射（从 m a 到 n a 的映射）并将 in 应用于转换器堆栈的内部值 monad，转换外层下的值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The monad morphism </font><code>generalize</code><font> takes an Identity monad into any another monad </font><code>m</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>monad morphism generalize 将一个 Identity monad 转化为任何另一个 monad m。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>generalize ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Identity</span> a <span class=ot>-&gt;</span> m a</code></pre></div>
<p><font>For example, it generalizes </font><code>State s a</code><font> (which is </font><code>StateT s Identity a</code><font>) to </font><code>StateT s m a</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，它将 State s a（即 StateT s Identity a）泛化为 StateT s m a。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>So we can generalize an existing transformer to lift an IO layer onto it.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以我们可以泛化一个现有的转换器，将一个 IO 层提升到它上面。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/mmorph.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.State</span>
<span class=kw>import </span><span class=dt>Control.Monad.Morph</span>

<span class=kw>type</span> <span class=dt>Eval</span> a <span class=fu>=</span> <span class=dt>State</span> [<span class=dt>Int</span>] a

<span class=ot>runEval ::</span> [<span class=dt>Int</span>] <span class=ot>-&gt;</span> <span class=dt>Eval</span> a <span class=ot>-&gt;</span> a
runEval <span class=fu>=</span> flip evalState

<span class=ot>pop ::</span> <span class=dt>Eval</span> <span class=dt>Int</span>
pop <span class=fu>=</span> <span class=kw>do</span>
  top <span class=ot>&lt;-</span> gets head
  modify tail
  return top

<span class=ot>push ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Eval</span> ()
push x <span class=fu>=</span> modify (x<span class=fu>:</span>)

<span class=ot>ev1 ::</span> <span class=dt>Eval</span> <span class=dt>Int</span>
ev1 <span class=fu>=</span> <span class=kw>do</span>
  push <span class=dv>3</span>
  push <span class=dv>4</span>
  pop
  pop

<span class=ot>ev2  ::</span> <span class=dt>StateT</span> [<span class=dt>Int</span>] <span class=dt>IO</span> ()
ev2 <span class=fu>=</span> <span class=kw>do</span>
  result <span class=ot>&lt;-</span> hoist generalize ev1
  liftIO <span class=fu>$</span> putStrLn <span class=fu>$</span> <span class=st>"Result: "</span> <span class=fu>++</span> show result</code></pre></div>
<p><font>See: </font><a href=https://hackage.haskell.org/package/mmorph>mmorph</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：mmorph</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<hr>
<h1 id=language-extensions><font>Language Extensions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>It's important to distinguish between different categories of language extensions </font><em>general</em><font> and </font><em>specialized</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>区分通用和专用语言扩展的不同类别很重要。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The inherent problem with classifying the extensions into the general and specialized categories is that it's a subjective classification. Haskellers who do type system research will have a very different interpretation of Haskell than people who do web programming. As such this is a conservative assessment, as an arbitrary baseline let's consider </font><code>FlexibleInstances</code><font> and </font><code>OverloadedStrings</code><font> "everyday" while </font><code>GADTs</code><font> and </font><code>TypeFamilies</code><font> are "specialized".</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将扩展分为一般类别和专用类别的内在问题是它是一种主观分类。从事类型系统研究的 Haskellers 对 Haskell 的理解与从事网络编程的人截然不同。因此，这是一个保守的评估，作为一个任意基线，让我们“每天”考虑 FlexibleInstances 和 OverloadedStrings，而 GADT 和 TypeFamilies 是“专门的”。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Key<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>钥匙</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<ul>
<li><em>Benign</em><font> implies both that importing the extension won't change the semantics of the module if not used and that enabling it makes it no easier to shoot yourself in the foot.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>良性意味着导入扩展不会改变模块的语义（如果不使用的话），并且启用它不会更容易搬起石头砸自己的脚。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><em>Historical</em><font> implies that one shouldn't use this extension, it's in GHC purely for backwards compatibility. Sometimes these are dangerous to enable.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>历史意味着不应该使用这个扩展，它在 GHC 中纯粹是为了向后兼容。有时启用这些是危险的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><em>Steals syntax</em><font> means that enabling this extension means that certain code valid in vanilla Haskell will no longer be accepted. For example, </font><code>f $(a)</code><font> is the same as </font><code>f $ (a)</code><font> in Haskell98, but </font><code>TemplateHaskell</code><font> will interpret </font><code>$(a)</code><font> as a splice.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Steals syntax 意味着启用此扩展意味着某些在 vanilla Haskell 中有效的代码将不再被接受。例如，f $(a)​​ 与 Haskell98 中的 f $ (a) 相同，但 TemplateHaskell 会将 $(a)​​ 解释为拼接。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><extensions></extensions></p>
<table class=table-striped>
 <tbody><tr class=striped-header>
 <td></td>
 <td><font>Benign</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>良性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Historical</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>历史的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Steals Syntax</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>窃取语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Use</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Use</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>GHC Reference</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Reference</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 </tr>
 <tr>
 <td><font>AllowAmbiguousTypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>允许歧义类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#ambiguity>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td></td>
 </tr>
 <tr>
 <td><font>Arrows</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>箭头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/arrow-notation.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#arrows>Arrows<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>箭头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>AutoDeriveTypeable</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>AutoDeriveTypeable</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#auto-derive-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>BangPatterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>爆炸图案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Strictness Annotation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/bang-patterns.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#strictness-annotations>Strictness Annotations<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ApplicativeDo</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>应用做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-capi>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#applicative-do>Applicative Do<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>应用做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>CApiFFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>卡皮菲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-capi>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ConstrainedClassMethods</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>约束类方法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#class-method-types>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ConstraintKinds</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>约束种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/constraint-kind.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#constraint-kinds>Constraint Kinds<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>约束种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>CPP</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>CPP</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Preprocessor</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>预处理器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/options-phases.html#c-pre-processor>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#cpp>Cpp<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Cpp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DataKinds</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/promotion.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#data-kinds>Data Kinds<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DatatypeContexts</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据类型上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>Deprecated</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弃用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deprecated</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弃用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#datatype-contexts>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DefaultSignatures</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Generic Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>泛型编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#class-default-signatures>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#generic>Generic<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveAnyClass</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>派生类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#derive-any-class>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveDataTypeable</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可派生数据类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#typeable>Typeable<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可打字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveFoldable</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Derive可折叠</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#foldable-traversable>Foldable / Traversable<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可折叠/可穿越</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveFunctor</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>派生函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveGeneric</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>派生泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#generic>Generic<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveLift</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>派生升降机</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#template-haskell>Template Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DeriveTraversable</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>导出Traversable</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DisambiguateRecordFields</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>消除记录字段的歧义</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#disambiguate-fields>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DuplicateRecordFields</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重复记录字段</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#disambiguate-fields>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#duplicaterecordfields>DuplicateRecordFields<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重复记录字段</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>DoRec</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>DoRec</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#recursive-do-notation>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#recursive-do>Recursive Do<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>递归做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>EmptyCase</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空箱子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#empty-case>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#emptycase>EmptyCase<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>空箱子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>EmptyDataDecls</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空数据声明</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#nullary-types>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#void>Void<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>空白</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ExistentialQuantification</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#existential-quantification>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#existential-quantification>Existential Quantification<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>存在量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ExplicitForAll</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>显式的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#explicit-foralls>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#universal-quantification>Universal Quantification<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ExplicitNamespaces</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>显式命名空间</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#explicit-namespaces>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ExtendedDefaultRules</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>扩展默认规则</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/interactive-evaluation.html#extended-default-rules>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>FlexibleContexts</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>灵活上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#flexible-contexts>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#flexiblecontexts>Flexible Contexts<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>灵活的上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>FlexibleInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弹性实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-rules>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#flexibleinstances>Flexible Instances<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>弹性实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ForeignFunctionInterface</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外部函数接口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#ffi>FFI<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>FunctionalDependencies</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能依赖</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#functional-dependencies>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#multiparam-typeclasses>Multiparam Typeclasses<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>GADTs</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#gadt>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#gadts>GADTs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>GADTSyntax</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GADTS语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#gadt-style>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#gadts>GADTs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>GeneralizedNewtypeDeriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>广义新类型推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#newtype-deriving>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#newtype-deriving>Newtype Deriving<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>新型派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>GHCForeignImportPrim</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHCForeignImportPrim</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-prim>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#cmm>Cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>厘米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ImplicitParams</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>隐式参数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#implicit-parameters>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ImpredicativeTypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>指示类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#impredicative-polymorphism>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#impredicative-types>Impredicative Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>指示类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>IncoherentInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不相干实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-overlap>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#incoherentinstances>Incoherent Instances<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>不连贯的实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>InstanceSigs</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>实例签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-sigs>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>InterruptibleFFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可中断FFI</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-interruptible>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#ffi>FFI<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>KindSignatures</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>友善签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#kinding>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#kind-signatures>Kind Signatures<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>亲切签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>LambdaCase</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Lambda案例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#lambda-case>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#lambdacase>Lambda Case<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>拉姆达案例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>LiberalTypeSynonyms</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自由类型同义词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#type-synonyms>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>MagicHash</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>魔法哈希</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>GHC Internals</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 内部结构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#magic-hash>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#unboxed-types>Unboxed Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未装箱类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>MonadComprehensions</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 理解</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#monad-comprehensions>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>MonoLocalBinds</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>MonoLocalBinds</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#mono-local-binds>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>MonoPatBinds</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>MonoPat绑定</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/monomorphism.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>MultiParamTypeClasses</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#multi-param-type-classes>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#multiparam-typeclasses>Multiparam Typeclasses<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>MultiWayIf</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>MultiWayIf</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#multi-way-if>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#multiwayif>MultiWawyIf<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MultiWawyIf</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NamedFieldPuns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>命名字段双关语</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#record-puns>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#namedfieldpuns>Named Field Puns<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>命名字段双关语</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NegativeLiterals</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>负文字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#negative-literals>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NoImplicitPrelude</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>没有隐含的前奏</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Import Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>导入消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#rebindable-syntax>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#custom-prelude>Custom Prelude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自定义序曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NoMonomorphismRestriction</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>无单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#monomorphism>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#monomorphism-restriction>Monomorphism Restriction<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NPlusKPatterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>NPlusK模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deprecated</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弃用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deprecated</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弃用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#n-k-patterns>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NullaryTypeClasses</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#nullary-type-classes>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#multiparam-typeclasses>Multiparam Typeclasses<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>NumDecimals</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>小数位数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#num-decimals>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#numdecimals>NumDecimals<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>小数位数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>OverlappingInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重叠实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-overlap>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#overlappinginstances>Overlapping Instances<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重叠实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>OverloadedLabels</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重载标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=#>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#overloadedlabels>Overloaded Labels<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>超载标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>OverloadedRecordFields</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重载记录字段</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=#>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#overloadedlabels>Overloaded Labels<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>超载标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>OverloadedLists</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重载列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#overloaded-lists>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#overloaded-lists>Overloaded Lists<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>OverloadedStrings</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重载字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#overloaded-strings>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#string>Overloaded Strings<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载的字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PackageImports</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>包裹进口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Import Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>导入消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#package-imports>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#package-imports>Package Imports<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>包导入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ParallelArrays</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>平行阵列</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Data Parallel Haskell</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据并行 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/lang-parallel.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ParallelListComp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>并行列表组件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#parallel-list-comprehensions>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PartialTypeSignatures</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>部分类型签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Interactive Typing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>交互式打字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/partial-type-signatures.html>Ref
 <hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#partial-type-signatures>Partial Type Signatures<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>部分类型签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PatternGuards</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>图案守卫</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#pattern-guards>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#pattern-guards>Pattern Guards<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模式守卫</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PatternSynonyms</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模式同义词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#pattern-synonyms>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#patternsynonyms>Pattern Synonyms<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模式同义词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PolyKinds</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>PolyKinds</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/kind-polymorphism.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#kind-polymorphism>Kind Polymorphism<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>种类多态性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PolymorphicComponents</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>多态组件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Deprecated</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弃用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>PostfixOperators</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>后缀运算符</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#postfix-operators>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>QuasiQuotes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>准行情</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Metaprogramming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>元编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/template-haskell.html#th-quasiquotation>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#quasiquotation>QuasiQuotation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>准报价单</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>Rank2Types</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rank2类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Historical Artifact</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>历史文物</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#rank-n-types>Rank N Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>等级 N 类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>RankNTypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>RankN类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#rank-n-types>Rank N Types<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>等级 N 类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>RebindableSyntax</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可重新绑定的语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Metaprogramming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>元编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#rebindable-syntax>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#indexed-monads>Indexed Monads<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>索引单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>RecordWildCards</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>记录万能牌</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#record-wildcards>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#recordwildcards>Record Wildcards<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>记录通配符</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>RecursiveDo</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>递归做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#recursive-do-notation>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#monadfix>MonadFix<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MonadFix</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>RelaxedPolyRec</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>轻松的 PolyRec</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#typing-binds>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>RoleAnnotations</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>角色注解</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Type Disambiguation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型消歧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/roles.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#roles>Roles<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>角色</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>Safe</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安全的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Security Auditing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安全审计</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#safe-haskell>Safe Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>SafeImports</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安全进口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Security Auditing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安全审计</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#safe-haskell>Safe Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ScopedTypeVariables</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作用域类型变量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#scoped-type-variables>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#scoped-type-variables>Scoped Type Variables<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>作用域类型变量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>StandaloneDeriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>独立派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#stand-alone-deriving>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>StaticPointers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>静态指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Distributed Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>分布式编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#stand-alone-deriving>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>Strict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Strictness Annotations</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html#ghc-flag--XStrict>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#strict-haskell>Strict Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格的 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>StrictData</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Strictness Annotations</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html#ghc-flag--XStrict>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#strict-haskell>Strict Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格的 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TemplateHaskell</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模板Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Metaprogramming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>元编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/template-haskell.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#template-haskell>Template Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TraditionalRecordSyntax</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>传统记录句法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Historical Artifact</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>历史文物</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#traditional-record-syntax>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#historical-extensions>Historical Extensions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>历史延伸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TransformListComp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>转换列表组件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#generalised-list-comprehensions>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>Trustworthy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>值得信赖</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Security Auditing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安全审计</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#safe-haskell>Safe Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TupleSections</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>元组部分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#tuple-sections>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#tuplesections>Tuple Sections<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>元组部分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TypeApplications</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型应用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-families.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TypeFamilies</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型家庭</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-families.html>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#type-families>Type Families<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TypeHoles</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型孔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Interactive Typing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>交互式打字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/typed-holes.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#type-holes>Type Holes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型孔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TypeInType</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>打字打字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=#>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TypeOperators</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型运算符</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#type-operators>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#manual-proofs>Manual Proofs<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>人工校样</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>TypeSynonymInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>TypeSynonymInstances</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typeclass Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#flexible-instance-head>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#typesynonyminstances>Type Synonym Instances<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型同义词实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>UnboxedTuples</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未装箱元组</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/primitives.html#unboxed-tuples>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>UndecidableInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不可判定实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Typelevel Programming</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#undecidable-instances>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#multiparam-typeclasses>Multiparam Typeclasses<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>UnicodeSyntax</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Unicode语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#unicode-syntax>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>UnliftedFFITypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未提升的 FFI 类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>FFI</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/primitives.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#cmm>Cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>厘米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>Unsafe</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不安全</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td></td>
 <td></td>
 <td><font>Specialized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专门</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Security Auditing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>安全审计</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html>Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#safe-haskell>Safe Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
 <tr>
 <td><font>ViewPatterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>查看模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td></td>
 <td><font>✓</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>✓</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>General</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一般的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><font>Syntax Extension</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>语法扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
 <td><a href=http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#view-patterns>
 Ref<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 <td><a href=#viewpatterns>View Patterns<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>查看模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></td>
 </tr>
</table>
<p><font>See: </font><a href=http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/flag-reference.html#idp14615552>GHC Extension Reference</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：GHC 扩展参考</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=the-benign><font>The Benign</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>良性的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>It's not obvious which extensions are the most common but it's fairly safe to say that these extensions are benign and are safely used extensively:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哪些扩展是最常见的并不明显，但可以肯定地说这些扩展是良性的并且被广泛安全地使用：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>OverloadedStrings</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重载字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>FlexibleContexts</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>灵活上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>FlexibleInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>弹性实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>GeneralizedNewtypeDeriving</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>广义新类型推导</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>TypeSynonymInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>TypeSynonymInstances</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>MultiParamTypeClasses</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>FunctionalDependencies</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能依赖</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>NoMonomorphismRestriction</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>无单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>GADTs</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>BangPatterns</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>爆炸图案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>DeriveGeneric</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>派生泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>ScopedTypeVariables</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作用域类型变量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<h2 id=the-dangerous><font>The Dangerous</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>危险的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>GHC's typechecker sometimes just casually tells us to enable language extensions when it can't solve certain problems. These include:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 的类型检查器有时只是在无法解决某些问题时随便告诉我们启用语言扩展。这些包括：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>DatatypeContexts</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据类型上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>OverlappingInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重叠实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>IncoherentInstances</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不相干实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>ImpredicativeTypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>指示类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>AllowAmbigiousTypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>允许模糊类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>These almost always indicate a design flaw and shouldn't be turned on to remedy the error at hand, as much as GHC might suggest otherwise!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些几乎总是表明设计缺陷，不应该打开来纠正手头的错误，正如 GHC 可能建议的那样！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=type-inference><font>Type Inference</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型推断</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Inference in Haskell is usually precise, although there are several boundary cases where inference is difficult or impossible to infer a principal type of an expression. There a two common cases:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中的推理通常是精确的，尽管有几种边界情况，在这些情况下推理很难或不可能推断出表达式的主要类型。有两种常见情况：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=mutually-recursive-binding-groups><font>Mutually Recursive Binding Groups</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>相互递归绑定组</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f x <span class=fu>=</span> const x g
g y <span class=fu>=</span> f <span class=ch>'A'</span></code></pre></div>
<p><font>The inferred type signatures are correct in their usage, but don't represent the most general signatures. When GHC analyzes the module it analyzes the dependencies of expressions on each other, groups them together, and applies substitutions from unification across mutually defined groups. As such the inferred types may not be the most general types possible, and an explicit signature may be desired.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推断出的类型签名在使用上是正确的，但并不代表最通用的签名。当 GHC 分析模块时，它会分析表达式之间的依赖关系，将它们组合在一起，并在相互定义的组之间应用来自统一的替换。因此，推断的类型可能不是最通用的类​​型，并且可能需要显式签名。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Inferred types</span>
<span class=ot>f ::</span> <span class=dt>Char</span> <span class=ot>-&gt;</span> <span class=dt>Char</span>
<span class=ot>g ::</span> t <span class=ot>-&gt;</span> <span class=dt>Char</span>

<span class=co>-- Most general types</span>
<span class=ot>f ::</span> a <span class=ot>-&gt;</span> a
<span class=ot>g ::</span> a <span class=ot>-&gt;</span> <span class=dt>Char</span></code></pre></div>
<h4 id=polymorphic-recursion><font>Polymorphic recursion</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多态递归</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Tree</span> a <span class=fu>=</span> <span class=dt>Leaf</span> <span class=fu>|</span> <span class=dt>Bin</span> a (<span class=dt>Tree</span> (a, a))

size <span class=dt>Leaf</span> <span class=fu>=</span> <span class=dv>0</span>
size (<span class=dt>Bin</span> _ t) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> <span class=dv>2</span> <span class=fu>*</span> size t</code></pre></div>
<p><font>The problem with this expression is because the inferred type variable </font><code>a</code><font> in </font><code>size</code><font> spans two possible types (</font><code>a</code><font> and </font><code>(a,a)</code><font>), the recursion is polymorphic. These two types won't pass the occurs-check of the typechecker and it yields an incorrect inferred type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这个表达式的问题是因为推断出的类型变量 a 在大小上跨越了两种可能的类型（a 和 (a,a)），递归是多态的。这两种类型不会通过类型检查器的发生检查，并且会产生不正确的推断类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class=dt>Occurs</span> check<span class=fu>:</span> cannot construct the infinite <span class=kw>type</span><span class=fu>:</span> t0 <span class=fu>=</span> (t0, t0)
    <span class=dt>Expected</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Tree</span> t0
      <span class=dt>Actual</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Tree</span> (t0, t0)
    <span class=dt>In</span> the first argument <span class=kw>of</span> <span class=ot>`size', namely `</span>t'
    <span class=dt>In</span> the second argument <span class=kw>of</span> <span class=ot>`(*)', namely `</span>size t'
    <span class=dt>In</span> the second argument <span class=kw>of</span> <span class=ot>`(+)', namely `</span><span class=dv>2</span> <span class=fu>*</span> size t'</code></pre></div>
<p><font>Simply adding an explicit type signature corrects this. Type inference using polymorphic recursion is undecidable in the general case.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>只需添加显式类型签名即可纠正此问题。在一般情况下，使用多态递归的类型推断是不可判定的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>size ::</span> <span class=dt>Tree</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>
size <span class=dt>Leaf</span> <span class=fu>=</span> <span class=dv>0</span>
size (<span class=dt>Bin</span> _ t) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> <span class=dv>2</span> <span class=fu>*</span> size t</code></pre></div>
<p><font>See: </font><a href=https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5>Static Semantics of Function and Pattern Bindings</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：函数和模式绑定的静态语义</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=monomorphism-restriction><font>Monomorphism Restriction</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The most common edge case of the inference is known as the dreaded </font><em>monomorphism restriction</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>推理中最常见的边缘情况被称为可怕的单态限制。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>When the toplevel declarations of a module are generalized the monomorphism restricts that toplevel values (i.e. expressions not under a lambda ) whose type contains the subclass of the </font><code>Num</code><font> type from the Prelude are not generalized and instead are instantiated with a monotype tried sequentially from the list specified by the </font><code>default</code><font> which is normally </font><code>Integer</code><font>, then </font><code>Double</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当模块的顶层声明被泛化时，单态性限制其类型包含 Prelude 中 Num 类型的子类的顶层值（即不在 lambda 下的表达式）不被泛化，而是用从列表中按顺序尝试的单型实例化默认情况下通常是 Integer，然后是 Double。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/monomorphism.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Double is inferred by type inferencer.</span>
<span class=ot>example1 ::</span> <span class=dt>Double</span>
example1 <span class=fu>=</span> <span class=fl>3.14</span>

<span class=co>-- In the presense of a lambda, a different type is inferred!</span>
<span class=ot>example2 ::</span> <span class=dt>Fractional</span> a <span class=ot>=&gt;</span> t <span class=ot>-&gt;</span> a
example2 _ <span class=fu>=</span> <span class=fl>3.14</span>

default (<span class=dt>Integer</span>, <span class=dt>Double</span>)</code></pre></div>
<p><font>As of GHC 7.8, the monomorphism restriction is switched off by default in GHCi.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 GHC 7.8 开始，单态性限制在 GHCi 中默认关闭。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> set <span class=fu>+</span>t

λ<span class=fu>:</span> <span class=dv>3</span>
<span class=dv>3</span>
<span class=ot>it ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a

λ<span class=fu>:</span> default (<span class=dt>Double</span>)

λ<span class=fu>:</span> <span class=dv>3</span>
<span class=fl>3.0</span>
<span class=ot>it ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a</code></pre></div>
<h2 id=extended-defaulting><font>Extended Defaulting</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>延长违约</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell normally applies several defaulting rules for ambigious literals in the absence of an explicit type signature. When an ambiguous literal is typechecked if at least one of its typeclass constraints is numeric and all of its classes are standard library classes, the module's default list is consulted, and the first type from the list that will satisfy the context of the type variable is instantiated. So for instance given the following default rules.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在没有显式类型签名的情况下，Haskell 通常会为不明确的文字应用一些默认规则。当一个有歧义的文字被类型检查时，如果它的至少一个类型类约束是数字的，并且它的所有类都是标准库类，模块的默认列表将被查询，并且列表中满足类型变量上下文的第一个类型是实例化。因此，例如给出以下默认规则。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">default (<span class=dt>C1</span> a,<span class=fu>...</span>,<span class=dt>Cn</span> a)</code></pre></div>
<p><font>The following set of heuristics is used to determine what to instnatiate the ambiguous type variable to.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>以下一组启发式方法用于确定将不明确类型变量实例化到什么。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ol style=list-style-type:decimal>
<li><font>The type variable a appears in no other constraints</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型变量 a 没有出现在其他约束中</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>All the classes Ci are standard.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所有类别 Ci 都是标准的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>At least one of the classes Ci is numeric.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Ci 类中至少有一个是数字类。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ol>
<p><font>The default default is (Integer, Double)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认默认为 (Integer, Double)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>This is normally fine, but sometimes we'd like more granular control over defaulting. The </font><code>-XExtendedDefaultRules</code><font> loosens the restriction that we're constrained with working on Numerical typeclasses and the constraint that we can only work with standard library classes. If we'd like to have our string literals (using -XOverlodaedStrings) automatically default to the more efficient </font><code>Text</code><font> implementation instead of </font><code>String</code><font> we can twiddle the flag and GHC will perform the right substitution without the need for an explicit annotation on every string literal.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这通常很好，但有时我们希望对默认设置进行更精细的控制。 -XExtendedDefaultRules 放宽了我们只能使用数字类型类的限制以及我们只能使用标准库类的限制。如果我们想让我们的字符串文字（使用 -XOverlodaedStrings）自动默认为更高效的 Text 实现而不是 String，我们可以旋转标志，GHC 将执行正确的替换，而不需要对每个字符串文字进行显式注释。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE ExtendedDefaultRules #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>

default (<span class=dt>T.Text</span>)

example <span class=fu>=</span> <span class=st>"foo"</span></code></pre></div>
<p><font>For code typed at the GHCi prompt, the </font><code>-XExtendedDefaultRules</code><font> flag is always on, and cannot be switched off.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于在 GHCi 提示符下键入的代码，-XExtendedDefaultRules 标志始终打开，无法关闭。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=#monomorphism-restriction>Monomorphism Restriction</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：单态限制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=safe-haskell><font>Safe Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>As everyone eventually finds out there are several functions within the implementation of GHC ( not the Haskell language ) that can be used to subvert the type-system, they are marked with the prefix </font><code>unsafe</code><font>. These functions exist only for when one can manually prove the soundness of an expression but can't express this property in the type-system or externalities to Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当每个人最终发现在 GHC（不是 Haskell 语言）的实现中有几个函数可以用来破坏类型系统时，它们被标记为前缀不安全。这些函数仅在可以手动证明表达式的可靠性但无法在类型系统或 Haskell 的外部性中表达此属性时才存在。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>unsafeCoerce ::</span> a <span class=ot>-&gt;</span> b
<span class=ot>unsafePerformIO ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> a</code></pre></div>
<div class="alert alert-danger">
<p><font>Using these functions to subvert the Haskell typesystem will cause all measure of undefined behavior with unimaginable pain and suffering, and are </font><span style=font-weight:bold>strongly discouraged</span><font>. When initially starting out with Haskell there are no legitimate reason to use these functions at all, period.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用这些函数来颠覆 Haskell 类型系统将导致所有测量未定义的行为，带来难以想象的痛苦和折磨，强烈建议不要使用。当最初开始使用 Haskell 时，根本没有合理的理由使用这些函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>The Safe Haskell language extensions allow us to restrict the use of unsafe language features using </font><code>-XSafe</code><font> which restricts the import of modules which are themselves marked as Safe. It also forbids the use of certain language extensions (</font><code>-XTemplateHaskell</code><font>) which can be used to produce unsafe code. The primary use case of these extensions is security auditing.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Safe Haskell 语言扩展允许我们使用 -XSafe 来限制不安全语言特性的使用，它限制了本身被标记为安全的模块的导入。它还禁止使用某些可用于生成不安全代码的语言扩展 (-XTemplateHaskell)。这些扩展的主要用例是安全审计。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE Safe #-}</span>
<span class=ot>{-# LANGUAGE Trustworthy #-}</span></code></pre></div>
<div class=sourceCode include=src/04-extensions/safe.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE Safe #-}</span>

<span class=kw>import </span><span class=dt>Unsafe.Coerce</span>
<span class=kw>import </span><span class=dt>System.IO.Unsafe</span>

<span class=ot>bad1 ::</span> <span class=dt>String</span>
bad1 <span class=fu>=</span> unsafePerformIO getLine

<span class=ot>bad2 ::</span> a
bad2 <span class=fu>=</span> unsafeCoerce <span class=fl>3.14</span> ()</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Unsafe.Coerce</span><span class=fu>:</span> <span class=dt>Can't</span> be safely imported<span class=fu>!</span>
<span class=dt>The</span> <span class=kw>module</span> itself isn't safe<span class=fu>.</span></code></pre></div>
<p><font>See: </font><a href=https://smunix.github.io/ghc.haskell.org/trac/ghc/wiki/SafeHaskell.html>Safe Haskell</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Safe Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=partial-type-signatures><font>Partial Type Signatures</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>部分类型签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The same hole technique can be applied at the toplevel for signatures:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以在签名的顶层应用相同的孔技术：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>const' ::</span> _
const' x y <span class=fu>=</span> x</code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">[<span class=kw>1</span> of 1] Compiling Main             ( src/typedhole.hs, interpreted )

<span class=kw>typedhole.hs</span>:3:11:
    <span class=kw>Found</span> hole ‘_’ with type: t1 -<span class=kw>&gt;</span> t -<span class=kw>&gt;</span> t1
    <span class=kw>Where</span>: ‘t’ is a rigid type variable bound by
               <span class=kw>the</span> inferred type of const<span class=st>' :: t1 -&gt; t -&gt; t1 at foo.hs:4:1</span>
<span class=st>           ‘t1’ is a rigid type variable bound by</span>
<span class=st>                the inferred type of const'</span> :: t1 -<span class=kw>&gt;</span> t -<span class=kw>&gt;</span> t1 at foo.hs:4:1
    <span class=kw>To</span> use the inferred type, enable PartialTypeSignatures
    <span class=kw>In</span> the type signature for ‘const<span class=st>'’: _</span>
<span class=st>Failed, modules loaded: none.</span></code></pre></div>
<p><font>Pattern wildcards can also be given explicit names so that GHC will use when reporting the inferred type in the resulting message.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>也可以为模式通配符指定显式名称，以便 GHC 在报告结果消息中的推断类型时使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>foo ::</span> _a <span class=ot>-&gt;</span> _a
foo _ <span class=fu>=</span> <span class=dt>False</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>typedhole.hs</span>:6:9:
    <span class=kw>Couldn</span><span class=st>'t match expected type ‘_a’ with actual type ‘Bool’</span>
<span class=st>      ‘_a’ is a rigid type variable bound by</span>
<span class=st>           the type signature for foo :: _a -&gt; _a at foo.hs:5:8</span>
<span class=st>    Relevant bindings include foo :: _a -&gt; _a (bound at foo.hs:6:1)</span>
<span class=st>    In the expression: False</span>
<span class=st>    In an equation for ‘foo’: foo _ = False</span>
<span class=st>Failed, modules loaded: none.</span></code></pre></div>
<p><font>The same wildcards can be used in type contexts to dump out inferred type class constraints:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以在类型上下文中使用相同的通配符来转储推断出的类型类约束：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>succ' ::</span> _ <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
succ' x <span class=fu>=</span> x <span class=fu>+</span> <span class=dv>1</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>typedhole.hs</span>:3:10:
    <span class=kw>Found</span> hole ‘_’ with inferred constraints: (Num a)
    <span class=kw>To</span> use the inferred type, enable PartialTypeSignatures
    <span class=kw>In</span> the type signature for ‘succ<span class=st>'’: _ =&gt; a -&gt; a</span>
<span class=st>Failed, modules loaded: none.</span></code></pre></div>
<p><font>When the flag </font><code>-XPartialTypeSignatures</code><font> is passed to GHC and the inferred type is unambiguous, GHC will let us leave the holes in place and the compilation will proceed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当标志 -XPartialTypeSignatures 被传递给 GHC 并且推断的类型是明确的时，GHC 会让我们留下漏洞并继续编译。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>typedhole.hs</span>:3:10: Warning:
    <span class=kw>Found</span> hole ‘_’ with type: w_
    <span class=kw>Where</span>: ‘w_’ is a rigid type variable bound by
                <span class=kw>the</span> inferred type of succ<span class=st>' :: w_ -&gt; w_1 -&gt; w_ at foo.hs:4:1</span>
<span class=st>    In the type signature for ‘succ'</span>’: _ -<span class=kw>&gt;</span> _ -<span class=kw>&gt;</span> _</code></pre></div>
<h2 id=recursive-do><font>Recursive Do</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>递归做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Recursive do notation allows to use to self-reference expressions on both sides of a monadic bind. For instance the following uses lazy evaluation to generate a infinite list. This is sometimes used for instantiating cyclic datatypes inside of a monadic context that need to hold a reference to themselves.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>递归 do 表示法允许在单子绑定的两侧使用自引用表达式。例如，以下使用惰性评估来生成无限列表。这有时用于在需要保存对自身的引用的单子上下文中实例化循环数据类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RecursiveDo #-}</span>

<span class=ot>justOnes ::</span> <span class=dt>Maybe</span> [<span class=dt>Int</span>]
justOnes <span class=fu>=</span> <span class=kw>do</span>
  rec xs <span class=ot>&lt;-</span> <span class=dt>Just</span> (<span class=dv>1</span><span class=fu>:</span>xs)
  return (map negate xs)</code></pre></div>
<p><font>See: </font><a href=https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-recursive-do-notation>Recursive Do Notation</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：递归 Do 表示法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=applicative-do><font>Applicative Do</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>应用做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>By default GHC desugars do-notation to use implicit invocations of bind and return.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认情况下，GHC 去除 do-notation 以使用隐式调用 bind 和 return。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>test ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m (a, b, c)
test <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> f
  b <span class=ot>&lt;-</span> g
  c <span class=ot>&lt;-</span> h
  return (a, b, c)</code></pre></div>
<p><font>Desugars into:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>脱糖成：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>test ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m (a, b, c)
test <span class=fu>=</span>
f <span class=fu>&gt;&gt;=</span> \a <span class=ot>-&gt;</span>
  g <span class=fu>&gt;&gt;=</span> \b <span class=ot>-&gt;</span>
    h <span class=fu>&gt;&gt;=</span> \c <span class=ot>-&gt;</span>
      return (a, b, c)</code></pre></div>
<p><font>With </font><code>ApplicativeDo</code><font> this instead desugars into use of applicative combinators and a laxer Applicative constraint.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 ApplicativeDo 时，这会减少对应用组合器和更宽松的应用约束的使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>test ::</span> <span class=dt>Applicative</span> m <span class=ot>=&gt;</span> m (a, b, c)
test <span class=fu>=</span> (,,) <span class=fu>&lt;$&gt;</span> f <span class=fu>&lt;*&gt;</span> g <span class=fu>&lt;*&gt;</span> h</code></pre></div>
<h2 id=pattern-guards><font>Pattern Guards</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模式守卫</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Pattern guards are an extension to the pattern matching syntax. Given a </font><code>&lt;-</code><font> pattern qualifier, the right hand side is evaluated and matched against the pattern on the left. If the match fails then the whole guard fails and the next equation is tried. If it succeeds, then the appropriate binding takes place, and the next qualifier is matched, in the augmented environment.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模式守卫是模式匹配语法的扩展。给定一个 &lt;- 模式限定符，右侧将被评估并与左侧的模式匹配。如果比赛失败，则整个守卫失败并尝试下一个等式。如果成功，则进行适当的绑定，并在增强环境中匹配下一个限定符。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PatternGuards #-}</span>

combine env x y
   <span class=fu>|</span> <span class=dt>Just</span> a <span class=ot>&lt;-</span> lookup x env
   , <span class=dt>Just</span> b <span class=ot>&lt;-</span> lookup y env
   <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> a <span class=fu>+</span> b

   <span class=fu>|</span> otherwise <span class=fu>=</span> <span class=dt>Nothing</span></code></pre></div>
<h2 id=viewpatterns><font>ViewPatterns</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>查看模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>View patterns are like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of algebraic data types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>视图模式就像可以嵌套在其他模式中的模式守卫。它们是针对代数数据类型的值进行模式匹配的便捷方式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/views.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ViewPatterns #-}</span>
<span class=ot>{-# LANGUAGE NoMonomorphismRestriction #-}</span>

<span class=kw>import </span><span class=dt>Safe</span>

<span class=ot>lookupDefault ::</span> <span class=dt>Eq</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> [(a,b)] <span class=ot>-&gt;</span> b
lookupDefault k _ (lookup k <span class=ot>-&gt;</span> <span class=dt>Just</span> s) <span class=fu>=</span> s
lookupDefault _ d _ <span class=fu>=</span> d

<span class=ot>headTup ::</span> (a, [t]) <span class=ot>-&gt;</span> [t]
headTup (headMay <span class=fu>.</span> snd <span class=ot>-&gt;</span> <span class=dt>Just</span> n) <span class=fu>=</span> [n]
headTup _ <span class=fu>=</span> []

<span class=ot>headNil ::</span> [a] <span class=ot>-&gt;</span> [a]
headNil (headMay <span class=ot>-&gt;</span> <span class=dt>Just</span> x) <span class=fu>=</span> [x]
headNil _ <span class=fu>=</span> []</code></pre></div>
<h2 id=tuplesections><font>TupleSections</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>元组部分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TupleSections #-}</span>

<span class=ot>first ::</span> a <span class=ot>-&gt;</span> (a, <span class=dt>Bool</span>)
first <span class=fu>=</span> (,<span class=dt>True</span>)

<span class=ot>second ::</span> a <span class=ot>-&gt;</span> (<span class=dt>Bool</span>, a)
second <span class=fu>=</span> (<span class=dt>True</span>,)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> t <span class=ot>-&gt;</span> t1 <span class=ot>-&gt;</span> t2 <span class=ot>-&gt;</span> t3 <span class=ot>-&gt;</span> (t, (), t1, (), (), t2, t3)
f <span class=fu>=</span> (,(),,(),(),,)</code></pre></div>
<h2 id=multiwayif><font>MultiWayIf</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MultiWayIf</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiWayIf #-}</span>

<span class=ot>bmiTell ::</span> <span class=dt>Float</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
bmiTell bmi <span class=fu>=</span> <span class=kw>if</span>
  <span class=fu>|</span> bmi <span class=fu>&lt;=</span> <span class=fl>18.5</span> <span class=ot>-&gt;</span> <span class=st>"You're underweight."</span>
  <span class=fu>|</span> bmi <span class=fu>&lt;=</span> <span class=fl>25.0</span> <span class=ot>-&gt;</span> <span class=st>"You're average weight."</span>
  <span class=fu>|</span> bmi <span class=fu>&lt;=</span> <span class=fl>30.0</span> <span class=ot>-&gt;</span> <span class=st>"You're overewight."</span>
  <span class=fu>|</span> otherwise   <span class=ot>-&gt;</span> <span class=st>"You're a whale."</span></code></pre></div>
<h2 id=emptycase><font>EmptyCase</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>空箱子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>GHC normally requires at least one pattern branch in case statement this restriction can be relaxed with -XEmptyCase. The case statement then immediately yields a </font><code>Non-exhaustive patterns in case</code><font> if evaluated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 通常在 case 语句中至少需要一个模式分支，这一限制可以通过 -XEmptyCase 放宽。 case 语句然后立即产生非穷举模式以防万一被评估。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<pre><code>test = case of</code></pre>
<h2 id=lambdacase><font>LambdaCase</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Lambda案例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>For case statements, LambdaCase allows the elimination of redundant free variables introduced purely for the case of pattern matching on.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于 case 语句，LambdaCase 允许消除纯粹为 case 模式匹配而引入的冗余自由变量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">\<span class=kw>case</span>
  p1 <span class=ot>-&gt;</span> <span class=dv>32</span>
  p2 <span class=ot>-&gt;</span> <span class=dv>32</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">\temp <span class=ot>-&gt;</span> <span class=kw>case</span> temp <span class=kw>of</span>
  p1 <span class=ot>-&gt;</span> <span class=dv>32</span>
  p2 <span class=ot>-&gt;</span> <span class=dv>32</span></code></pre></div>
<div class=sourceCode include=src/04-extensions/lambdacase.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE LambdaCase #-}</span>

<span class=kw>data</span> <span class=dt>Exp</span> a
  <span class=fu>=</span> <span class=dt>Lam</span> a (<span class=dt>Exp</span> a)
  <span class=fu>|</span> <span class=dt>Var</span> a
  <span class=fu>|</span> <span class=dt>App</span> (<span class=dt>Exp</span> a) (<span class=dt>Exp</span> a)

<span class=ot>example ::</span> <span class=dt>Exp</span> a <span class=ot>-&gt;</span> a
example <span class=fu>=</span> \<span class=kw>case</span>
  <span class=dt>Lam</span> a b <span class=ot>-&gt;</span> a
  <span class=dt>Var</span> a   <span class=ot>-&gt;</span> a
  <span class=dt>App</span> a b <span class=ot>-&gt;</span> example a</code></pre></div>
<h2 id=numdecimals><font>NumDecimals</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>小数位数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>NumDecimals allows the use of exponential notation for integral literals that are not necessarily floats. Without it, any use of expontial notation induces a Fractional class constraint.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>NumDecimals 允许对不一定是浮点数的整数文字使用指数表示法。没有它，任何指数表示法的使用都会导致 Fractional 类约束。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>googol ::</span> <span class=dt>Fractional</span> a <span class=ot>=&gt;</span> a
googol <span class=fu>=</span> 1e100</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE NumDecimals #-}</span>
<span class=ot>googol ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a
googol <span class=fu>=</span> 1e100</code></pre></div>
<h2 id=packageimports><font>PackageImports</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>包裹进口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Package imports allows us to disambiguate hierarchical package names by their respective package key. This is useful in the case where you have to imported packages that expose the same module. In practice most of the common libraries have taken care to avoid conflicts in the namespace and this is not usually a problem in most modern Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>包导入允许我们通过各自的包键来消除分层包名称的歧义。这在您必须导入公开相同模块的包的情况下很有用。在实践中，大多数公共库都注意避免命名空间中的冲突，这在大多数现代 Haskell 中通常不是问题。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example we could explicitly ask GHC to resolve that </font><code>Control.Monad.Error</code><font> package be drawn from the </font><code>mtl</code><font> library.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们可以明确要求 GHC 解析从 mtl 库中提取的 Control.Monad.Error 包。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> "mtl" <span class=dt>Control.Monad.Error</span> <span class=kw>as</span> <span class=dt>Error</span>
<span class=kw>import qualified</span> "mtl" <span class=dt>Control.Monad.State</span> <span class=kw>as</span> <span class=dt>State</span>
<span class=kw>import qualified</span> "mtl" <span class=dt>Control.Monad.Reader</span> <span class=kw>as</span> <span class=dt>Reader</span></code></pre></div>
<h2 id=recordwildcards><font>RecordWildCards</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>记录万能牌</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Record wild cards allow us to expand out the names of a record as variables scoped as the labels of the record implicitly. The extension can be used to extract variables names into a scope or to assign to variables in a record drawing, aligning the record's labels with the variables in scope for the assignment. The syntax introduced is the </font><code>{..}</code><font> pattern selector.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>记录通配符允许我们将记录的名称扩展为变量，隐式地定义为记录的标签。该扩展可用于将变量名称提取到范围内或分配给记录绘图中的变量，将记录的标签与分配范围内的变量对齐。引入的语法是 {..} 模式选择器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/wildcards_update.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RecordWildCards #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>

<span class=kw>data</span>  <span class=dt>Example</span> <span class=fu>=</span> <span class=dt>Example</span>
  {<span class=ot> e1 ::</span> <span class=dt>Int</span>
  ,<span class=ot> e2 ::</span> <span class=dt>Text</span>
  ,<span class=ot> e3 ::</span> <span class=dt>Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=co>-- Extracting from a record using wildcards.</span>
<span class=ot>scope ::</span> <span class=dt>Example</span> <span class=ot>-&gt;</span> (<span class=dt>Int</span>, <span class=dt>Text</span>, <span class=dt>Text</span>)
scope <span class=dt>Example</span> {<span class=fu>..</span>} <span class=fu>=</span> (e1, e2, e3)

<span class=co>-- Assign to a record using wildcards.</span>
<span class=ot>assign ::</span> <span class=dt>Example</span>
assign <span class=fu>=</span> <span class=dt>Example</span> {<span class=fu>..</span>}
  <span class=kw>where</span>
    (e1, e2, e3) <span class=fu>=</span> (<span class=dv>1</span>, <span class=st>"Kirk"</span>, <span class=st>"Picard"</span>)</code></pre></div>
<h2 id=namedfieldpuns><font>NamedFieldPuns</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>命名字段双关语</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Provides alternative syntax for accessing record fields in a pattern match.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>提供用于访问模式匹配中的记录字段的替代语法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>D</span> <span class=fu>=</span> <span class=dt>D</span> {<span class=ot>a ::</span> <span class=dt>Int</span>,<span class=ot> b ::</span> <span class=dt>Int</span>}

<span class=ot>f ::</span> <span class=dt>D</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
f <span class=dt>D</span> {a, b} <span class=fu>=</span> a <span class=fu>-</span> b

<span class=co>-- Order doesn't matter</span>
<span class=ot>g ::</span> <span class=dt>D</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
g <span class=dt>D</span> {b, a} <span class=fu>=</span> a <span class=fu>-</span> b</code></pre></div>
<h2 id=patternsynonyms><font>PatternSynonyms</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模式同义词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Suppose we were writing a typechecker, it would be very common to include a distinct </font><code>TArr</code><font> term to ease the telescoping of function signatures, this is what GHC does in its Core language. Even though technically it could be written in terms of more basic application of the </font><code>(-&gt;)</code><font> constructor.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>假设我们正在编写一个类型检查器，包含一个不同的 TArr 术语以简化函数签名的伸缩是很常见的，这就是 GHC 在其核心语言中所做的。尽管从技术上讲，它可以根据 (-&gt;) 构造函数的更基本应用来编写。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Type</span>
  <span class=fu>=</span> <span class=dt>TVar</span> <span class=dt>TVar</span>
  <span class=fu>|</span> <span class=dt>TCon</span> <span class=dt>TyCon</span>
  <span class=fu>|</span> <span class=dt>TApp</span> <span class=dt>Type</span> <span class=dt>Type</span>
  <span class=fu>|</span> <span class=dt>TArr</span> <span class=dt>Type</span> <span class=dt>Type</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Eq</span>, <span class=dt>Ord</span>)</code></pre></div>
<p><font>With pattern synonyms we can eliminate the extraneous constructor without losing the convenience of pattern matching on arrow types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用模式同义词，我们可以消除无关的构造函数，而不会失去箭头类型模式匹配的便利性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PatternSynonyms #-}</span>

pattern <span class=dt>TArr</span> t1 t2 <span class=fu>=</span> <span class=dt>TApp</span> (<span class=dt>TApp</span> (<span class=dt>TCon</span> <span class=st>"(-&gt;)"</span>) t1) t2</code></pre></div>
<p><font>So now we can write an eliminator and constructor for arrow type very naturally.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以现在我们可以很自然地为箭头类型编写一个消除器和构造器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/patterns.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PatternSynonyms #-}</span>

<span class=kw>import </span><span class=dt>Data.List</span> (foldl1')

<span class=kw>type</span> <span class=dt>Name</span>  <span class=fu>=</span> <span class=dt>String</span>
<span class=kw>type</span> <span class=dt>TVar</span>  <span class=fu>=</span> <span class=dt>String</span>
<span class=kw>type</span> <span class=dt>TyCon</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Type</span>
  <span class=fu>=</span> <span class=dt>TVar</span> <span class=dt>TVar</span>
  <span class=fu>|</span> <span class=dt>TCon</span> <span class=dt>TyCon</span>
  <span class=fu>|</span> <span class=dt>TApp</span> <span class=dt>Type</span> <span class=dt>Type</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Eq</span>, <span class=dt>Ord</span>)


pattern <span class=dt>TArr</span> t1 t2 <span class=fu>=</span> <span class=dt>TApp</span> (<span class=dt>TApp</span> (<span class=dt>TCon</span> <span class=st>"(-&gt;)"</span>) t1) t2

<span class=ot>tapp ::</span> <span class=dt>TyCon</span> <span class=ot>-&gt;</span> [<span class=dt>Type</span>] <span class=ot>-&gt;</span> <span class=dt>Type</span>
tapp tcon args <span class=fu>=</span> foldl <span class=dt>TApp</span> (<span class=dt>TCon</span> tcon) args

<span class=ot>arr ::</span> [<span class=dt>Type</span>] <span class=ot>-&gt;</span> <span class=dt>Type</span>
arr ts <span class=fu>=</span> foldl1' (\t1 t2 <span class=ot>-&gt;</span> tapp <span class=st>"(-&gt;)"</span> [t1, t2]) ts

<span class=ot>elimTArr ::</span> <span class=dt>Type</span> <span class=ot>-&gt;</span> [<span class=dt>Type</span>]
elimTArr (<span class=dt>TArr</span> (<span class=dt>TArr</span> t1 t2) t3) <span class=fu>=</span> t1 <span class=fu>:</span> t2 <span class=fu>:</span> elimTArr t3
elimTArr (<span class=dt>TArr</span> t1 t2) <span class=fu>=</span> t1 <span class=fu>:</span> elimTArr t2
elimTArr t <span class=fu>=</span> [t]

<span class=co>-- (-&gt;) a ((-&gt;) b a)</span>
<span class=co>-- a -&gt; b -&gt; a</span>
<span class=ot>to ::</span> <span class=dt>Type</span>
to <span class=fu>=</span> arr [<span class=dt>TVar</span> <span class=st>"a"</span>, <span class=dt>TVar</span> <span class=st>"b"</span>, <span class=dt>TVar</span> <span class=st>"a"</span>]

<span class=ot>from ::</span> [<span class=dt>Type</span>]
from <span class=fu>=</span> elimTArr to</code></pre></div>
<p><font>Pattern synonyms can be exported from a module like any other definition by prefixing them with the prefix </font><code>pattern</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模式同义词可以像任何其他定义一样从模块中导出，方法是在它们前面加上前缀模式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>MyModule</span> (
  pattern <span class=dt>Elt</span>
) <span class=kw>where</span>

pattern <span class=dt>Elt</span> <span class=fu>=</span> [a]</code></pre></div>
<ul>
<li><a href=http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html>Pattern Synonyms in GHC 8<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GHC 8 中的模式同义词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=derivetraversable><font>DeriveTraversable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>导出Traversable</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=derivefoldable><font>DeriveFoldable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Derive可折叠</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=derivefunctor><font>DeriveFunctor</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>派生函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=derivegeneric><font>DeriveGeneric</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>派生泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=deriveanyclass><font>DeriveAnyClass</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>派生类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>With </font><code>-XDeriveAnyClass</code><font> we can derive any class. The deriving logic s generates an instance declaration for the type with no explicitly-defined methods. If the typeclass implements a default for each method then this will be well-defined and give rise to an automatic instances.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 -XDeriveAnyClass 我们可以派生任何类。派生逻辑 s 为没有显式定义方法的类型生成实例声明。如果类型类为每个方法实现一个默认值，那么这将是明确定义的并产生一个自动实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=staticpointers><font>StaticPointers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>静态指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=duplicaterecordfields><font>DuplicateRecordFields</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重复记录字段</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>GHC 8.0 introduced the DuplicateRecordFields extensions which loosens GHC's restriction on records in the same module with identical accessors. The precise type that is being projected into is now deferred to the callsite.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 8.0 引入了 DuplicateRecordFields 扩展，它放宽了 GHC 对同一模块中具有相同访问器的记录的限制。被投影到的精确类型现在被推迟到调用站点。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DuplicateRecordFields #-}</span>

<span class=kw>data</span> <span class=dt>Person</span> <span class=fu>=</span> <span class=dt>Person</span> {<span class=ot> id ::</span> <span class=dt>Int</span> }
<span class=kw>data</span> <span class=dt>Animal</span> <span class=fu>=</span> <span class=dt>Animal</span> {<span class=ot> id ::</span> <span class=dt>Int</span> }
<span class=kw>data</span> <span class=dt>Vegetable</span> <span class=fu>=</span> <span class=dt>Vegetable</span> {<span class=ot> id ::</span> <span class=dt>Int</span> }

<span class=ot>test ::</span> (<span class=dt>Person</span>, <span class=dt>Animal</span>, <span class=dt>Vegetable</span>)
test <span class=fu>=</span> (<span class=dt>Person</span> {id <span class=fu>=</span> <span class=dv>1</span>}, <span class=dt>Animal</span> {id <span class=fu>=</span> <span class=dv>2</span>}, <span class=dt>Vegetable</span> {id <span class=fu>=</span> <span class=dv>3</span>})</code></pre></div>
<p><font>Using just DuplicateRecordFields, projection is still not supported so the following will not work. OverloadedLabels fixes this to some extent.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>仅使用 DuplicateRecordFields，仍不支持投影，因此以下内容将不起作用。 OverloadedLabels 在一定程度上解决了这个问题。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>test ::</span> (<span class=dt>Person</span>, <span class=dt>Animal</span>, <span class=dt>Vegetable</span>)
test <span class=fu>=</span> (id (<span class=dt>Person</span> <span class=dv>1</span>), id (<span class=dt>Animal</span> <span class=dv>2</span>), id (<span class=dt>Animal</span> <span class=dv>3</span>))</code></pre></div>
<h2 id=overloadedlabels><font>OverloadedLabels</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>GHC 8.0 also introduced the OverloadedLabels extension which allows a limited form of polymorphism over labels that share the same name.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 8.0 还引入了 OverloadedLabels 扩展，它允许对共享相同名称的标签进行有限形式的多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To work with overloaded labels types we need to enable several language extensions to work with promoted strings and multiparam typeclasses that underly it's implementation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要处理重载的标签类型，我们需要启用多种语言扩展以处理作为其实现基础的提升字符串和多参数类型类。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>extract ::</span> <span class=dt>IsLabel</span> <span class=st>"id"</span> t <span class=ot>=&gt;</span> t
extract <span class=fu>=</span> <span class=fu>#</span>id</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedLabels #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE DuplicateRecordFields #-}</span>
<span class=ot>{-# LANGUAGE ExistentialQuantification #-}</span>

<span class=kw>import </span><span class=dt>GHC.Records</span> (<span class=dt>HasField</span>(..))
<span class=kw>import </span><span class=dt>GHC.OverloadedLabels</span> (<span class=dt>IsLabel</span>(..))

<span class=kw>data</span> <span class=dt>S</span> <span class=fu>=</span> <span class=dt>MkS</span> {<span class=ot> foo ::</span> <span class=dt>Int</span> }
<span class=kw>data</span> <span class=dt>T</span> x y z <span class=fu>=</span> forall b <span class=fu>.</span> <span class=dt>MkT</span> {<span class=ot> foo ::</span> y,<span class=ot> bar ::</span> b }

<span class=kw>instance</span> <span class=dt>HasField</span> x r a <span class=ot>=&gt;</span> <span class=dt>IsLabel</span> x (r <span class=ot>-&gt;</span> a) <span class=kw>where</span>
  fromLabel <span class=fu>=</span> getField

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print (<span class=fu>#</span>foo (<span class=dt>MkS</span> <span class=dv>42</span>))
  print (<span class=fu>#</span>foo (<span class=dt>MkT</span> <span class=dt>True</span> <span class=dt>False</span>))</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/>OverloadedRecordFields revived<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>OverloadedRecordFields 恢复</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=cpp><font>Cpp</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Cpp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The C++ preprocessor is the fallback whenever we really need to separate out logic that has to span multiple versions of GHC and language changes while maintaining backwards compatibility. It can dispatch on the version of GHC being used to compile a module.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>每当我们确实需要分离出必须跨越多个版本的 GHC 和语言更改同时保持向后兼容性的逻辑时，C++ 预处理器就是后备。它可以分派用于编译模块的 GHC 版本。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE CPP #-}</span>

<span class=st>#if (__GLASGOW_HASKELL__ &gt; 710)</span>
<span class=co>-- Imports for GHC 7.10.x</span>
<span class=st>#else</span>
<span class=co>-- Imports for other GHC</span>
<span class=st>#endif</span></code></pre></div>
<p><font>To demarcate code based on the operating system compiled on.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>根据编译的操作系统来划分代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE CPP #-}</span>

<span class=st>#ifdef OS_Linux</span>
  <span class=co>-- Linux specific logic</span>
<span class=st>#else</span>
<span class=st># ifdef OS_Win32</span>
  <span class=co>-- Windows specific logic</span>
<span class=st># else</span>
<span class=st># ifdef OS_Mac</span>
  <span class=co>-- Macintosh specific logic</span>
<span class=st># else</span>
  <span class=co>-- Other operating systems</span>
<span class=st># endif</span>
<span class=st># endif</span>
<span class=st>#endif</span></code></pre></div>
<p><font>Or on the version of the base library used.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者在所用基础库的版本上。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=st>#if !MIN_VERSION_base(4,6,0)</span>
  <span class=co>-- Base specific logic</span>
<span class=st>#endif</span></code></pre></div>
<p><font>It can also be abused to do terrible things like metaprogrammming with strings, but please don't do this.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>它也可能被滥用来做一些可怕的事情，比如用字符串进行元编程，但请不要这样做。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=historical-extensions><font>Historical Extensions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>历史延伸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Several language extensions have either been absorbed into the core language or become deprecated in favor of others. Others are just considered misfeatures.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一些语言扩展要么被吸收到核心语言中，要么被弃用以支持其他语言。其他人只是被认为是错误的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Rank2Types - Rank2Types has been subsumed by RankNTypes</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rank2Types - Rank2Types 已被 RankNTypes 包含</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>XPolymorphicComponents - Was an implementation detail of higher-rank polymorphism that no longer exists.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>XPolymorphicComponents - 是不再存在的高级多态性的实现细节。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>NPlusKPatterns - These were largely considered an ugly edge-case of pattern matching language that was best removed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>NPlusKPatterns - 这些在很大程度上被认为是模式匹配语言的丑陋边缘案例，最好删除。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>TraditionalRecordSyntax - Traditional record syntax was an extension to the Haskell 98 specification for what we now consider standard record syntax.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>TraditionalRecordSyntax - 传统记录语法是我们现在认为标准记录语法的 Haskell 98 规范的扩展。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>OverlappingInstances - Subsumed by explicit OVERLAPPING pragmas.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OverlappingInstances - 包含在明确的 OVERLAPPING 编译指示中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>IncoherentInstances - Subsumed by explicit INCOHERENT pragmas.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>IncoherentInstances - 包含在明确的 INCOHERENT pragma 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>NullaryTypeClasses - Subsumed by explicit Multiparameter Typeclasses with no parameters.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>NullaryTypeClasses - 由没有参数的显式多参数类型类包含。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<hr>
<h1 id=type-classes><font>Type Classes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=minimal-annotations><font>Minimal Annotations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>最少的注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>In the presence of default implementations of typeclasses methods, there may be several ways to implement a typeclass. For instance Eq is entirely defined by either defining when two values are equal or not equal by implying taking the negation of the other. We can define equality in terms of non-equality and vice-versa.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在存在类型类方法的默认实现的情况下，可能有多种方法来实现类型类。例如，Eq 完全通过定义两个值何时相等或不相等来定义，这意味着取另一个的否定。我们可以根据不平等来定义平等，反之亦然。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Eq</span> a <span class=kw>where</span>
  (<span class=fu>==</span>),<span class=ot> (/=) ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
  x <span class=fu>==</span> y <span class=fu>=</span> not (x <span class=fu>/=</span> y)
  x <span class=fu>/=</span> y <span class=fu>=</span> not (x <span class=fu>==</span> y)</code></pre></div>
<p><font>Before 7.6.1 there was no way to specify what was the "minimal" definition required to implement a typeclass</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 7.6.1 之前，无法指定实现类型类所需的“最小”定义是什么</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Eq</span> a <span class=kw>where</span>
  (<span class=fu>==</span>),<span class=ot> (/=) ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
  x <span class=fu>==</span> y <span class=fu>=</span> not (x <span class=fu>/=</span> y)
  x <span class=fu>/=</span> y <span class=fu>=</span> not (x <span class=fu>==</span> y)
  <span class=ot>{-# MINIMAL (==) #-}</span>
  <span class=ot>{-# MINIMAL (/=) #-}</span></code></pre></div>
<p><font>Minimal pragmas are boolean expressions, with </font><code>|</code><font> as logical </font><code>OR</code><font>, </font><em>either</em><font> definition must be defined). Comma indicates logical </font><code>AND</code><font> where both sides </font><em>both</em><font> definitions must be defined.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最小编译指示是布尔表达式，带有 |作为逻辑或，必须定义任一定义）。逗号表示逻辑与，其中两边都必须定义两个定义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# MINIMAL (==) | (/=) #-}</span> <span class=co>-- Either (==) or (/=)</span>
<span class=ot>{-# MINIMAL (==) , (/=) #-}</span> <span class=co>-- Both (==) and (/=)</span></code></pre></div>
<p><font>Compiling the </font><code>-Wmissing-methods</code><font> will warn when a instance is defined that does not meet the minimal criterion.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当定义的实例不符合最低标准时，编译 -Wmissing-methods 将发出警告。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=flexibleinstances><font>FlexibleInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>弹性实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode include=src/04-extensions/flexinstances.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>

<span class=kw>class</span> <span class=dt>MyClass</span> a

<span class=co>-- Without flexible instances, all instance heads must be type variable. The</span>
<span class=co>-- following would be legal.</span>
<span class=kw>instance</span> <span class=dt>MyClass</span> (<span class=dt>Maybe</span> a)

<span class=co>-- With flexible instances, typeclass heads can be arbitrary nested types. The</span>
<span class=co>-- following would be forbidden without it.</span>
<span class=kw>instance</span> <span class=dt>MyClass</span> (<span class=dt>Maybe</span> <span class=dt>Int</span>)</code></pre></div>
<h2 id=flexiblecontexts><font>FlexibleContexts</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>灵活上下文</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode include=src/04-extensions/flexcontexts.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>

<span class=kw>class</span> <span class=dt>MyClass</span> a

<span class=co>-- Without flexible contexts, all contexts must be type variable. The</span>
<span class=co>-- following would be legal.</span>
<span class=kw>instance</span> (<span class=dt>MyClass</span> a) <span class=ot>=&gt;</span> <span class=dt>MyClass</span> (<span class=dt>Either</span> a b)

<span class=co>-- With flexible contexts, typeclass contexts can be arbitrary nested types. The</span>
<span class=co>-- following would be forbidden without it.</span>
<span class=kw>instance</span> (<span class=dt>MyClass</span> (<span class=dt>Maybe</span> a)) <span class=ot>=&gt;</span> <span class=dt>MyClass</span> (<span class=dt>Either</span> a b)</code></pre></div>
<h2 id=overlappinginstances><font>OverlappingInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重叠实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Typeclasses are normally globally coherent, there is only ever one instance that can be resolved for a type unambiguously for a type at any call site in the program. There are however extensions to loosen this restriction and perform more manual direction of the instance search.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类通常是全局一致的，在程序的任何调用站点上，只有一个实例可以明确地解析为一种类型。然而，有一些扩展可以放宽此限制并执行更多的实例搜索手动指导。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Overlapping instances loosens the coherent condition (there can be multiple instances) but introduces a criterion that it will resolve to the most specific one.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重叠实例放松了连贯条件（可以有多个实例）但引入了一个标准，它将解析为最具体的一个。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/overlapping.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE OverlappingInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>class</span> <span class=dt>MyClass</span> a b <span class=kw>where</span>
<span class=ot>  fn ::</span> (a,b)

<span class=kw>instance</span> <span class=dt>MyClass</span> <span class=dt>Int</span> b <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"b"</span>

<span class=kw>instance</span> <span class=dt>MyClass</span> a <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"a"</span>

<span class=kw>instance</span> <span class=dt>MyClass</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"c"</span>

<span class=ot>example ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
example <span class=fu>=</span> fn</code></pre></div>
<p><font>Historically enabling this on module-level was not the best idea, since generally we define multiple classes in a module only a subset of which may be incoherent. So as of 7.10 we now have the capacity to just annotate instances with the OVERLAPPING and INCOHERENT pragmas.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从历史上看，在模块级别启用它并不是最好的主意，因为通常我们在一个模块中定义多个类，其中只有一个子集可能不连贯。因此，从 7.10 开始，我们现在可以使用 OVERLAPPING 和 INCOHERENT pragma 注释实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/overlapping_anno.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>class</span> <span class=dt>MyClass</span> a b <span class=kw>where</span>
<span class=ot>  fn ::</span> (a,b)

<span class=kw>instance</span> <span class=ot>{-# OVERLAPPING #-}</span> <span class=dt>MyClass</span> <span class=dt>Int</span> b <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"b"</span>

<span class=kw>instance</span> <span class=ot>{-# OVERLAPPING #-}</span> <span class=dt>MyClass</span> a <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"a"</span>

<span class=kw>instance</span> <span class=ot>{-# OVERLAPPING #-}</span> <span class=dt>MyClass</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"c"</span>

<span class=ot>example ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
example <span class=fu>=</span> fn</code></pre></div>
<h2 id=incoherentinstances><font>IncoherentInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>不相干实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Incoherent instance loosens the restriction that there be only one specific instance, will choose one arbitrarily (based on the arbitrary sorting of it's internal representation ) and the resulting program will typecheck. This is generally pretty crazy and usually a sign of poor design.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Incoherent instance 放宽了只有一个特定实例的限制，将任意选择一个（基于对其内部表示的任意排序）并且生成的程序将进行类型检查。这通常是非常疯狂的，通常是设计不佳的标志。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/incoherent.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE IncoherentInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>class</span> <span class=dt>MyClass</span> a b <span class=kw>where</span>
<span class=ot>  fn ::</span> (a,b)

<span class=kw>instance</span> <span class=dt>MyClass</span> <span class=dt>Int</span> b <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"a"</span>

<span class=kw>instance</span> <span class=dt>MyClass</span> a <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"b"</span>

<span class=ot>example ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
example <span class=fu>=</span> fn</code></pre></div>
<p><font>There is also an incoherent instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>还有一个不连贯的例子。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/04-extensions/incoherent_anno.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>class</span> <span class=dt>MyClass</span> a b <span class=kw>where</span>
<span class=ot>  fn ::</span> (a,b)

<span class=kw>instance</span> <span class=ot>{-# INCOHERENT #-}</span> <span class=dt>MyClass</span> a <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"general"</span>

<span class=kw>instance</span> <span class=ot>{-# INCOHERENT #-}</span> <span class=dt>MyClass</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=kw>where</span>
  fn <span class=fu>=</span> error <span class=st>"specific"</span>

<span class=ot>example ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
example <span class=fu>=</span> fn</code></pre></div>
<h2 id=typesynonyminstances><font>TypeSynonymInstances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>TypeSynonymInstances</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode include=src/04-extensions/synonym.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>

<span class=kw>type</span> <span class=dt>IntList</span> <span class=fu>=</span> [<span class=dt>Int</span>]

<span class=kw>class</span> <span class=dt>MyClass</span> a

<span class=co>-- Without type synonym instances, we're forced to manually expand out type</span>
<span class=co>-- synonyms in the typeclass head.</span>
<span class=kw>instance</span> <span class=dt>MyClass</span> [<span class=dt>Int</span>]

<span class=co>-- With it GHC will do this for us automatically. Type synonyms still need to</span>
<span class=co>-- be fully applied.</span>
<span class=kw>instance</span> <span class=dt>MyClass</span> <span class=dt>IntList</span></code></pre></div>
<hr>
<h1 id=laziness><font>Laziness</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>懒惰</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>Again, a subject on which </font><em>much</em><font> ink has been spilled. There is an ongoing discussion in the land of Haskell about the compromises between lazy and strict evaluation, and there are nuanced arguments for having either paradigm be the default. Haskell takes a hybrid approach and allows strict evaluation when needed and uses laziness by default. Needless to say, we can always find examples where strict evaluation exhibits worse behavior than lazy evaluation and vice versa.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>又是一个泼墨过多的主题。在 Haskell 领域，关于惰性求值和严格求值之间的折衷的讨论正在进行中，并且对于将任一范式作为默认值存在微妙的争论。 Haskell 采用混合方法，在需要时允许严格评估，默认情况下使用惰性。不用说，我们总能找到严格评估表现出比惰性评估更糟糕的行为的例子，反之亦然。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The primary advantage of lazy evaluation in the large is that algorithms that operate over both unbounded and bounded data structures can inhabit the same type signatures and be composed without additional need to restructure their logic or force intermediate computations. Languages that attempt to bolt laziness on to a strict evaluation model often bifurcate classes of algorithms into ones that are hand-adjusted to consume unbounded structures and those which operate over bounded structures. In strict languages mixing and matching between lazy vs strict processing often necessitates manifesting large intermediate structures in memory when such composition would "just work" in a lazy language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>大型惰性求值的主要优势在于，在无界和有界数据结构上运行的算法可以驻留在相同的类型签名中，并且无需额外重组其逻辑或强制进行中间计算即可进行组合。试图将惰性与严格的评估模型联系起来的语言通常会将算法分类为手动调整以使用无界结构的算法和在有界结构上运行的算法。在严格的语言中，惰性处理与严格处理之间的混合和匹配通常需要在内存中显示大型中间结构，而这种组合在惰性语言中“恰好有效”。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>By virtue of Haskell being the only language to actually explore this point in the design space to the point of being industrial strength; knowledge about lazy evaluation is not widely absorbed into the collective programmer consciousness and can often be non-intuitive to the novice. This doesn't reflect on the model itself, merely on the need for more instruction material and research on optimizing lazy compilers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>凭借 Haskell 是唯一在设计空间中真正探索这一点的语言，以达到工业实力；关于惰性求值的知识并没有被广泛地吸收到集体程序员的意识中，而且对于新手来说往往是不直观的。这并不反映在模型本身，只是需要更多的指导材料和研究优化惰性编译器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The paradox of Haskell is that it explores so many definably unique ideas ( laziness, purity, typeclasses ) that it becomes difficult to separate out the discussion of any one from the gestalt of the whole implementation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 的悖论在于它探索了如此多明确独特的想法（惰性、纯度、类型类），以至于很难将任何一个的讨论与整个实现的格式塔分开。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html>Oh My Laziness!<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哦，我的懒惰！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://www.slideshare.net/tibbe/reasoning-about-laziness>Reasoning about Laziness<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>关于懒惰的推理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://www.vex.net/~trebla/haskell/lazy.xhtml>Lazy Evaluation of Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Haskell 的惰性求值</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://augustss.blogspot.hu/2011/05/more-points-for-lazy-evaluation-in.html>More Points For Lazy Evaluation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>惰性评估的更多积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://hackhands.com/lazy-evaluation-works-haskell/>How Lazy Evaluation Works in Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Haskell 中惰性求值的工作原理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=strictness><font>Strictness</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>There are several evaluation models for the lambda calculus:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>lambda 演算有几种评估模型：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Strict - Evaluation is said to be strict if all arguments are evaluated before the body of a function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格 - 如果所有参数都在函数体之前进行评估，则称评估是严格的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Non-strict - Evaluation is non-strict if the arguments are not necessarily evaluated before entering the body of a function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Non-strict - 如果在进入函数体之前不必对参数进行求值，则求值是非严格的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>These ideas give rise to several models, Haskell itself use the </font><em>call-by-need</em><font> model.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些想法产生了几种模型，Haskell 本身使用按需调用模型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Model</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Strictness</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Description</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Call-by-value</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>按值调用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Strict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>arguments evaluated before function entered</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在函数进入之前评估的参数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Call-by-name</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>点名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Non-strict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>非严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>arguments passed unevaluated</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>未评估的参数传递</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Call-by-need</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>按需呼叫</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Non-strict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>非严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>arguments passed unevaluated but an expression is only evaluated once (sharing)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>传递的参数未计算但表达式仅计算一次（共享）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<h2 id=seq-and-whnf><font>Seq and WHNF</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序列和 WHNF</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A term is said to be in </font><em>weak head normal-form</em><font> if the outermost constructor or lambda cannot be reduced further. A term is said to be in </font><em>normal form</em><font> if it is fully evaluated and all sub-expressions and thunks contained within are evaluated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果最外层的构造函数或 lambda 不能进一步减少，则称项处于弱头部范式。如果一个术语被完全评估并且其中包含的所有子表达式和 thunk 都被评估，则称该术语处于正常形式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- In Normal Form</span>
<span class=dv>42</span>
(<span class=dv>2</span>, <span class=st>"foo"</span>)
\x <span class=ot>-&gt;</span> x <span class=fu>+</span> <span class=dv>1</span>

<span class=co>-- Not in Normal Form</span>
<span class=dv>1</span> <span class=fu>+</span> <span class=dv>2</span>
(\x <span class=ot>-&gt;</span> x <span class=fu>+</span> <span class=dv>1</span>) <span class=dv>2</span>
<span class=st>"foo"</span> <span class=fu>++</span> <span class=st>"bar"</span>
(<span class=dv>1</span> <span class=fu>+</span> <span class=dv>1</span>, <span class=st>"foo"</span>)

<span class=co>-- In Weak Head Normal Form</span>
(<span class=dv>1</span> <span class=fu>+</span> <span class=dv>1</span>, <span class=st>"foo"</span>)
\x <span class=ot>-&gt;</span> <span class=dv>2</span> <span class=fu>+</span> <span class=dv>2</span>
<span class=ch>'f'</span> <span class=fu>:</span> (<span class=st>"oo"</span> <span class=fu>++</span> <span class=st>"bar"</span>)

<span class=co>-- Not In Weak Head Normal Form</span>
<span class=dv>1</span> <span class=fu>+</span> <span class=dv>1</span>
(\x <span class=ot>-&gt;</span> x <span class=fu>+</span> <span class=dv>1</span>) <span class=dv>2</span>
<span class=st>"foo"</span> <span class=fu>++</span> <span class=st>"bar"</span></code></pre></div>
<p><font>In Haskell normal evaluation only occurs at the outer constructor of case-statements in Core. If we pattern match on a list we don't implicitly force all values in the list. An element in a data structure is only evaluated up to the most outer constructor. For example, to evaluate the length of a list we need only scrutinize the outer Cons constructors without regard for their inner values.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Haskell 中，正常评估仅发生在 Core 中案例语句的外部构造函数中。如果我们在列表上进行模式匹配，我们不会隐式地强制列表中的所有值。数据结构中的元素只会评估到最外层的构造函数。例如，要评估列表的长度，我们只需要仔细检查外部 Cons 构造函数而不考虑它们的内部值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> length [undefined, <span class=dv>1</span>]
<span class=dv>2</span>

λ<span class=fu>:</span> head [undefined, <span class=dv>1</span>]
Prelude.undefined

λ<span class=fu>:</span> snd (undefined, <span class=dv>1</span>)
<span class=dv>1</span>

λ<span class=fu>:</span> fst (undefined, <span class=dv>1</span>)
Prelude.undefined</code></pre></div>
<p><font>For example, in a lazy language the following program terminates even though it contains diverging terms.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，在惰性语言中，即使包含不同的术语，以下程序也会终止。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/05-laziness/nodiverge.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>ignore ::</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>
ignore x <span class=fu>=</span> <span class=dv>0</span>

<span class=ot>loop ::</span> a
loop <span class=fu>=</span> loop

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> print <span class=fu>$</span> ignore loop</code></pre></div>
<p><font>In a strict language like OCaml ( ignoring its suspensions for the moment ), the same program diverges.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在像 OCaml 这样的严格语言中（暂时忽略它的暂停），同一个程序会发散。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/05-laziness/diverge.ml><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>let</span> ignore x <span class=fu>=</span> <span class=dv>0</span>;; 
<span class=kw>let</span> rec loop a <span class=fu>=</span> loop a;;

print_int (ignore (loop ()));</code></pre></div>
<p><font>In Haskell a </font><em>thunk</em><font> is created to stand for an unevaluated computation. Evaluation of a thunk is called </font><em>forcing</em><font> the thunk. The result is an </font><em>update</em><font>, a referentially transparent effect, which replaces the memory representation of the thunk with the computed value. The fundamental idea is that a thunk is only updated once ( although it may be forced simultaneously in a multi-threaded environment ) and its resulting value is shared when referenced subsequently.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Haskell 中，创建了一个 thunk 来代表未评估的计算。对 thunk 的评估称为强制 thunk。结果是一个更新，一个引用透明的效果，它将 thunk 的内存表示替换为计算值。基本思想是一个 thunk 只更新一次（尽管它可能在多线程环境中同时被强制更新）并且它的结果值在随后被引用时共享。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The command </font><code>:sprint</code><font> can be used to introspect the state of unevaluated thunks inside an expression without forcing evaluation. For instance:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>命令 :sprint 可用于在不强制评估的情况下内省表达式中未评估的 thunk 的状态。例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=kw>let</span> a <span class=fu>=</span> [<span class=dv>1</span><span class=fu>..</span>]<span class=ot> ::</span> [<span class=dt>Integer</span>]
λ<span class=fu>:</span> <span class=kw>let</span> b <span class=fu>=</span> map (<span class=fu>+</span> <span class=dv>1</span>) a

λ<span class=fu>:</span> <span class=fu>:</span>sprint a
a <span class=fu>=</span> _
λ<span class=fu>:</span> <span class=fu>:</span>sprint b
b <span class=fu>=</span> _
λ<span class=fu>:</span> a <span class=fu>!!</span> <span class=dv>4</span>
<span class=dv>5</span>
λ<span class=fu>:</span> <span class=fu>:</span>sprint a
a <span class=fu>=</span> <span class=dv>1</span> <span class=fu>:</span> <span class=dv>2</span> <span class=fu>:</span> <span class=dv>3</span> <span class=fu>:</span> <span class=dv>4</span> <span class=fu>:</span> <span class=dv>5</span> <span class=fu>:</span> _
λ<span class=fu>:</span> b <span class=fu>!!</span> <span class=dv>10</span>
<span class=dv>12</span>
λ<span class=fu>:</span> <span class=fu>:</span>sprint a
a <span class=fu>=</span> <span class=dv>1</span> <span class=fu>:</span> <span class=dv>2</span> <span class=fu>:</span> <span class=dv>3</span> <span class=fu>:</span> <span class=dv>4</span> <span class=fu>:</span> <span class=dv>5</span> <span class=fu>:</span> <span class=dv>6</span> <span class=fu>:</span> <span class=dv>7</span> <span class=fu>:</span> <span class=dv>8</span> <span class=fu>:</span> <span class=dv>9</span> <span class=fu>:</span> <span class=dv>10</span> <span class=fu>:</span> <span class=dv>11</span> <span class=fu>:</span> _
λ<span class=fu>:</span> <span class=fu>:</span>sprint b
b <span class=fu>=</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> _ <span class=fu>:</span> <span class=dv>12</span> <span class=fu>:</span> _</code></pre></div>
<p><font>While a thunk is being computed its memory representation is replaced with a special form known as </font><em>blackhole</em><font> which indicates that computation is ongoing and allows for a short circuit for when a computation might depend on itself to complete. The implementation of this is some of the more subtle details of the GHC runtime.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当一个 thunk 正在被计算时，它的内存表示被一种称为黑洞的特殊形式所取代，它表示计算正在进行并允许短路，以便计算可能依赖于它自己来完成。这个的实现是 GHC 运行时的一些更微妙的细节。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><code>seq</code><font> function introduces an artificial dependence on the evaluation of order of two terms by requiring that the first argument be evaluated to WHNF before the evaluation of the second. The implementation of the </font><code>seq</code><font> function is an implementation detail of GHC.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>seq 函数通过要求在评估第二个参数之前将第一个参数评估为 WHNF，从而引入了对两项顺序评估的人为依赖。 seq函数的实现是GHC的一个实现细节。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">seq<span class=ot> ::</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b

⊥ <span class=ot>`seq`</span> a <span class=fu>=</span> ⊥
a <span class=ot>`seq`</span> b <span class=fu>=</span> b</code></pre></div>
<p><font>The infamous </font><code>foldl</code><font> is well-known to leak space when used carelessly and without several compiler optimizations applied. The strict </font><code>foldl'</code><font> variant uses seq to overcome this.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>众所周知，臭名昭著的 foldl 在使用不当且未应用多个编译器优化时会泄漏空间。严格的 foldl' 变体使用 seq 来克服这个问题。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> [b] <span class=ot>-&gt;</span> a
foldl f z [] <span class=fu>=</span> z
foldl f z (x<span class=fu>:</span>xs) <span class=fu>=</span> foldl f (f z x) xs</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>foldl' ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> [b] <span class=ot>-&gt;</span> a
foldl' _ z [] <span class=fu>=</span> z
foldl' f z (x<span class=fu>:</span>xs) <span class=fu>=</span> <span class=kw>let</span> z' <span class=fu>=</span> f z x <span class=kw>in</span> z' <span class=ot>`seq`</span> foldl' f z' xs</code></pre></div>
<p><font>In practice, a combination between the strictness analyzer and the inliner on </font><code>-O2</code><font> will ensure that the strict variant of </font><code>foldl</code><font> is used whenever the function is inlinable at call site so manually using </font><code>foldl'</code><font> is most often not required.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>实际上，严格性分析器和 -O2 上的内联器之间的组合将确保只要函数在调用站点可内联，就使用 foldl 的严格变体，因此通常不需要手动使用 foldl'。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Of important note is that GHCi runs without any optimizations applied so the same program that performs poorly in GHCi may not have the same performance characteristics when compiled with GHC.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>值得注意的是，GHCi 运行时未应用任何优化，因此在 GHCi 中表现不佳的同一程序在使用 GHC 编译时可能不具有相同的性能特征。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=strictness-annotations><font>Strictness Annotations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格注释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The extension </font><code>BangPatterns</code><font> allows an alternative syntax to force arguments to functions to be wrapped in seq. A bang operator on an arguments forces its evaluation to weak head normal form before performing the pattern match. This can be used to keep specific arguments evaluated throughout recursion instead of creating a giant chain of thunks.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>扩展 BangPatterns 允许使用替代语法来强制将函数的参数包装在 seq 中。参数上的 bang 运算符在执行模式匹配之前强制其评估为弱头部范式。这可用于在整个递归过程中保持对特定参数的评估，而不是创建一个巨大的 thunk 链。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE BangPatterns #-}</span>

sum<span class=ot> ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a
sum <span class=fu>=</span> go <span class=dv>0</span>
  <span class=kw>where</span>
    go <span class=fu>!</span>acc (x<span class=fu>:</span>xs) <span class=fu>=</span> go (acc <span class=fu>+</span> x) xs
    go  acc []     <span class=fu>=</span> acc</code></pre></div>
<p><font>This is desugared into code effectively equivalent to the following:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这被脱糖为有效等效于以下代码的代码：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class=ot> ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a
sum <span class=fu>=</span> go <span class=dv>0</span>
  <span class=kw>where</span>
    go acc _ <span class=fu>|</span> acc <span class=ot>`seq`</span> <span class=dt>False</span> <span class=fu>=</span> undefined
    go acc (x<span class=fu>:</span>xs)              <span class=fu>=</span> go (acc <span class=fu>+</span> x) xs
    go acc []                  <span class=fu>=</span> acc</code></pre></div>
<p><font>Function application to seq'd arguments is common enough that it has a special operator.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>seq 参数的函数应用很常见，它有一个特殊的运算符。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>($!) ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
f <span class=fu>$!</span> x  <span class=fu>=</span> <span class=kw>let</span> <span class=fu>!</span>vx <span class=fu>=</span> x <span class=kw>in</span> f vx</code></pre></div>
<h2 id=strict-haskell><font>Strict Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格的 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>As of GHC 8.0 strictness annotations can be applied to all definitions in a module automatically. In previous versions it was necessary to definitions via explicit syntactic annotations at all sites.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 GHC 8.0 开始，严格注释可以自动应用于模块中的所有定义。在以前的版本中，必须在所有站点通过显式句法注释来定义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=strictdata><font>StrictData</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Enabling StrictData makes constructor fields strict by default on any module it is enabled on.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用 StrictData 会使构造函数字段在任何启用它的模块上默认严格。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE StrictData #-}</span>

<span class=kw>data</span> <span class=dt>Employee</span> <span class=fu>=</span> <span class=dt>Employee</span>
  {<span class=ot> name ::</span> <span class=dt>T.Text</span>
  ,<span class=ot> age ::</span> <span class=dt>Int</span>
  }</code></pre></div>
<p><font>Is equivalent to:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>相当于：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Employee</span> <span class=fu>=</span> <span class=dt>Employee</span>
  {<span class=ot> name ::</span> <span class=fu>!</span><span class=dt>T.Text</span>
  ,<span class=ot> age ::</span> <span class=fu>!</span><span class=dt>Int</span>
  }</code></pre></div>
<h4 id=strict><font>Strict</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Strict implies </font><code>-XStrictData</code><font> and extends strictness annotations to all arguments of functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Strict 意味着 -XStrictData 并将严格性注释扩展到函数的所有参数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f x y <span class=fu>=</span> x <span class=fu>+</span> y</code></pre></div>
<p><font>Is equivalent to the following function declaration with explicit bang patterns:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>等效于以下带有显式 bang 模式的函数声明：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class=fu>!</span>x <span class=fu>!</span>y <span class=fu>=</span> x <span class=fu>+</span> y</code></pre></div>
<p><font>On a module-level this effectively makes Haskell a call-by-value language with some caveats. All arguments to functions are now explicitly evaluated and all data in constructors within this module are in head normal form by construction. However there are some subtle points to this that are better explained in the language guide.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在模块级别，这有效地使 Haskell 成为一种具有一些注意事项的按值调用语言。函数的所有参数现在都被显式评估，并且该模块中构造函数中的所有数据在构造时都采用头部范式。然而，语言指南中对此有一些微妙的解释。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html?highlight=typefamilydependencies#strict-by-default-pattern-bindings">Strict Extensions<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>严格扩展</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=deepseq><font>Deepseq</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>深度测序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>There are often times when for performance reasons we need to deeply evaluate a data structure to normal form leaving no terms unevaluated. The </font><code>deepseq</code><font> library performs this task.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>很多时候，出于性能原因，我们需要深入评估数据结构的正常形式，不遗余力。 deepseq 库执行此任务。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The typeclass </font><code>NFData</code><font> (Normal Form Data) allows us to seq all elements of a structure across any subtypes which themselves implement NFData.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类 NFData（普通格式数据）允许我们跨本身实现 NFData 的任何子类型对结构的所有元素进行排序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>NFData</span> a <span class=kw>where</span>
<span class=ot>  rnf ::</span> a <span class=ot>-&gt;</span> ()
  rnf a <span class=fu>=</span> a <span class=ot>`seq`</span> ()

<span class=ot>deepseq ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b
<span class=ot>($!!) ::</span> (<span class=dt>NFData</span> a) <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>NFData</span> <span class=dt>Int</span>
<span class=kw>instance</span> <span class=dt>NFData</span> (a <span class=ot>-&gt;</span> b)

<span class=kw>instance</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>NFData</span> (<span class=dt>Maybe</span> a) <span class=kw>where</span>
    rnf <span class=dt>Nothing</span>  <span class=fu>=</span> ()
    rnf (<span class=dt>Just</span> x) <span class=fu>=</span> rnf x

<span class=kw>instance</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>NFData</span> [a] <span class=kw>where</span>
    rnf [] <span class=fu>=</span> ()
    rnf (x<span class=fu>:</span>xs) <span class=fu>=</span> rnf x <span class=ot>`seq`</span> rnf xs</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class=dv>1</span>, undefined] <span class=ot>`seq`</span> ()
<span class=co>-- ()</span>

[<span class=dv>1</span>, undefined] <span class=ot>`deepseq`</span> ()
<span class=co>-- Prelude.undefined</span></code></pre></div>
<p><font>To force a data structure itself to be fully evaluated we share the same argument in both positions of deepseq.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了强制对数据结构本身进行全面评估，我们在 deepseq 的两个位置共享相同的参数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>force ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
force x <span class=fu>=</span> x <span class=ot>`deepseq`</span> x</code></pre></div>
<h2 id=irrefutable-patterns><font>Irrefutable Patterns</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>无可辩驳的模式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A lazy pattern doesn't require a match on the outer constructor, instead it lazily calls the accessors of the values as needed. In the presence of a bottom, we fail at the usage site instead of the outer pattern match.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>惰性模式不需要匹配外部构造函数，而是根据需要惰性地调用值的访问器。在存在底部的情况下，我们在使用站点而不是外部模式匹配处失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/05-laziness/lazy_patterns.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> (a, b) <span class=ot>-&gt;</span> <span class=dt>Int</span>
f (a,b) <span class=fu>=</span> const <span class=dv>1</span> a

<span class=ot>g ::</span> (a, b) <span class=ot>-&gt;</span> <span class=dt>Int</span>
g <span class=fu>~</span>(a,b) <span class=fu>=</span> const <span class=dv>1</span> a

<span class=co>-- λ: f undefined</span>
<span class=co>-- *** Exception: Prelude.undefined</span>
<span class=co>-- λ: g undefined</span>
<span class=co>-- 1</span>

<span class=ot>j ::</span> <span class=dt>Maybe</span> t <span class=ot>-&gt;</span> t
j <span class=fu>~</span>(<span class=dt>Just</span> x) <span class=fu>=</span> x

<span class=ot>k ::</span> <span class=dt>Maybe</span> t <span class=ot>-&gt;</span> t
k (<span class=dt>Just</span> x) <span class=fu>=</span> x

<span class=co>-- λ: j Nothing</span>
<span class=co>-- *** Exception: src/05-laziness/lazy_patterns.hs:15:1-15: Irrefutable pattern failed for pattern (Just x)</span>
<span class=fu>--</span>
<span class=co>-- λ: k Nothing</span>
<span class=co>-- *** Exception: src/05-laziness/lazy_patterns.hs:18:1-14: Non-exhaustive patterns in function k</span></code></pre></div>
<hr>
<h1 id=prelude><font>Prelude</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序幕</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=what-to-avoid><font>What to Avoid?</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>要避免什么？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell being a 25 year old language has witnessed several revolutions in the way we structure and compose functional programs. Yet as a result several portions of the Prelude still reflect old schools of thought that simply can't be removed without breaking significant parts of the ecosystem.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 作为一门有 25 年历史的语言，见证了我们构建和编写函数式程序的方式的数次革命。然而，Prelude 的几个部分仍然反映了旧的思想流派，如果不破坏生态系统的重要部分，就无法将其移除。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Currently it really only exists in folklore which parts to use and which not to use, although this is a topic that almost all introductory books don't mention and instead make extensive use of the Prelude for simplicity's sake.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>目前它实际上只存在于民间传说中哪些部分可以使用哪些部分不可以使用，尽管这是一个几乎所有介绍性书籍都没有提及的主题，而是为了简单起见而大量使用前奏曲。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The short version of the advice on the Prelude is:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>关于 Prelude 的简短建议是：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class="alert alert-success">
<ul>
<li><font>Avoid String.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>避免字符串。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Use </font><code>fmap</code><font> instead of </font><code>map</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 fmap 而不是地图。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Use Foldable and Traversable instead of the Control.Monad, and Data.List versions of traversals.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 Foldable 和 Traversable 而不是 Control.Monad 和 Data.List 版本的遍历。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Avoid partial functions like </font><code>head</code><font> and </font><code>read</code><font> or use their total variants.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>避免部分功能，如 head 和 read 或使用它们的总变体。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Avoid exceptions, use ExceptT or Either instead.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>避免异常，改用 ExceptT 或 Either。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Avoid boolean blind functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>避免布尔盲函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
</div>
<p><font>The instances of Foldable for the list type often conflict with the monomorphic versions in the Prelude which are left in for historical reasons. So often times it is desirable to explicitly mask these functions from implicit import and force the use of Foldable and Traversable instead.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>列表类型的 Foldable 实例经常与 Prelude 中由于历史原因保留的单态版本冲突。因此，通常需要从隐式导入中显式屏蔽这些函数，并强制使用 Foldable 和 Traversable 代替。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Of course often times one wishes only to use the Prelude explicitly and one can explicitly import it qualified and use the pieces as desired without the implicit import of the whole namespace.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，很多时候人们只希望明确地使用 Prelude，并且可以明确地导入它并根据需要使用片段，而无需隐式导入整个命名空间。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Prelude</span> <span class=kw>as</span> <span class=dt>P</span></code></pre></div>
<h2 id=what-should-be-in-base><font>What Should be in Base</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基地应该有什么</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>To get work done you probably need.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要完成工作，您可能需要。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class="alert alert-success">
<ul>
<li><font>async</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>异步</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>bytestring</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>containers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>容器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>mtl</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>母线</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>stm</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>stm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>text</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>transformers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>变形金刚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>unordered-containers</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>无序容器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>vector</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>filepath</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>文件路径</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>directory</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>目录</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>process</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>过程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>unix</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>unix</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>deepseq</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>深度序列</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>optparse-applicative</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>optparse-applicative</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
</div>
<h2 id=custom-preludes><font>Custom Preludes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>定制前奏曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The default Prelude can be disabled in it's entirety by twiddling the </font><code>-XNoImplicitPrelude</code><font> flag.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以通过调整 -XNoImplicitPrelude 标志来完全禁用默认的 Prelude。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE NoImplicitPrelude #-}</span></code></pre></div>
<p><font>We are then free to build an equivalent Prelude that is more to our liking. Using module reexporting we can pluck the good parts of the prelude and libraries like </font><code>safe</code><font> to build up a more industrial focused set of default functions. For example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>然后我们可以自由地构建一个更符合我们喜好的等效 Prelude。使用模块再导出，我们可以提取 prelude 和库（如 safe）的好部分，以构建一组更专注于工业的默认函数。例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Custom</span> (
  <span class=kw>module</span> <span class=dt>Exports</span>,
) <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Data.Int</span> <span class=kw>as</span> <span class=dt>Exports</span>
<span class=kw>import </span><span class=dt>Data.Tuple</span> <span class=kw>as</span> <span class=dt>Exports</span>
<span class=kw>import </span><span class=dt>Data.Maybe</span> <span class=kw>as</span> <span class=dt>Exports</span>
<span class=kw>import </span><span class=dt>Data.String</span> <span class=kw>as</span> <span class=dt>Exports</span>
<span class=kw>import </span><span class=dt>Data.Foldable</span> <span class=kw>as</span> <span class=dt>Exports</span>
<span class=kw>import </span><span class=dt>Data.Traversable</span> <span class=kw>as</span> <span class=dt>Exports</span>

<span class=kw>import </span><span class=dt>Control.Monad.Trans.Except</span>
  as <span class=dt>Exports</span>
  (<span class=dt>ExceptT</span>(<span class=dt>ExceptT</span>), <span class=dt>Except</span>, except, runExcept, runExceptT,
   mapExcept, mapExceptT, withExcept, withExceptT)</code></pre></div>
<p><font>The Prelude itself is entirely replicable as well, presuming that an entire project is compiled without the implicit Prelude. Several packages have arisen that supply much of the same functionality in a way that appeals to more modern design principles.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Prelude 本身也是完全可复制的，假定整个项目是在没有隐式 Prelude 的情况下编译的。已经出现了几个包，它们以吸引更现代设计原则的方式提供大部分相同的功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=protolude><font>Protolude</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Protolude is a minimalist Prelude which provides many sensible defaults for writing modern Haskell and is compatible with existing code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Protolude 是一个极简主义的 Prelude，它为编写现代 Haskell 提供了许多合理的默认值，并且与现有代码兼容。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/package/protolude>protolude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>序曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class=kw>import </span><span class=dt>Protolude</span></code></pre></div>
<p><font>Other examples for alternative Preludes include (your mileage may vary with these):</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>替代 Preludes 的其他示例包括（您的里程可能会因这些而异）：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/package/base-prelude>base-prelude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基本前奏</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://hackage.haskell.org/package/basic-prelude>basic-prelude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基本前奏</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://hackage.haskell.org/package/classy-prelude>classy-prelude<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>优雅的前奏</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://hackage.haskell.org/packages/#cat:Prelude>Other Preludes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>其他序曲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=partial-functions><font>Partial Functions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>偏函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A </font><em>partial function</em><font> is a function which doesn't terminate and yield a value for all given inputs. Conversely a </font><em>total function</em><font> terminates and is always defined for all inputs. As mentioned previously, certain historical parts of the Prelude are full of partial functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>部分函数是一个不会终止并为所有给定输入产生值的函数。相反，总函数终止并始终为所有输入定义。如前所述，前奏曲的某些历史部分充满了部分功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The difference between partial and total functions is the compiler can't reason about the runtime safety of partial functions purely from the information specified in the language and as such the proof of safety is left to the user to guarantee. They are safe to use in the case where the user can guarantee that invalid inputs cannot occur, but like any unchecked property its safety or not-safety is going to depend on the diligence of the programmer. This very much goes against the overall philosophy of Haskell and as such they are discouraged when not necessary.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>部分函数和总函数之间的区别是编译器不能仅根据语言中指定的信息来推断部分函数的运行时安全性，因此安全性证明留给用户来保证。在用户可以保证不会发生无效输入的情况下，它们可以安全使用，但就像任何未经检查的财产一样，它的安全性或不安全性将取决于程序员的勤奋程度。这与 Haskell 的整体理念背道而驰，因此在不必要时不鼓励这样做。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class=ot> ::</span> [a] <span class=ot>-&gt;</span> a
read<span class=ot> ::</span> <span class=dt>Read</span> a <span class=ot>=&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> a
<span class=ot>(!!) ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a</code></pre></div>
<h2 id=safe><font>Safe</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The Prelude has total variants of the historical partial functions (i.e. </font><code>Text.Read.readMaybe</code><font>)in some cases, but often these are found in the various utility libraries like </font><code>safe</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在某些情况下，Prelude 具有历史部分函数（即 Text.Read.readMaybe）的全部变体，但通常这些可以在各种实用程序库中找到，例如 safe。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The total versions provided fall into three cases:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>提供的总版本分为三种情况：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><code>May</code><font> - return Nothing when the function is not defined for the inputs</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可能 - 当未为输入定义函数时返回 Nothing</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><code>Def</code><font> - provide a default value when the function is not defined for the inputs</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Def - 当未为输入定义函数时提供默认值</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><code>Note</code><font> - call </font><code>error</code><font> with a custom error message when the function is not defined for the inputs. This is not safe, but slightly easier to debug!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>注意 - 当没有为输入定义函数时，使用自定义错误消息调用错误。这不安全，但更容易调试！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Total</span>
<span class=ot>headMay ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
<span class=ot>readMay ::</span> <span class=dt>Read</span> a <span class=ot>=&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
<span class=ot>atMay ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a

<span class=co>-- Total</span>
<span class=ot>headDef ::</span> a <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> a
<span class=ot>readDef ::</span> <span class=dt>Read</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> a
<span class=ot>atDef   ::</span> a <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a

<span class=co>-- Partial</span>
<span class=ot>headNote ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> a
<span class=ot>readNote ::</span> <span class=dt>Read</span> a <span class=ot>=&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> a
<span class=ot>atNote   ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a</code></pre></div>
<h2 id=boolean-blindness><font>Boolean Blindness</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>布尔盲</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Bool</span> <span class=fu>=</span> <span class=dt>True</span> <span class=fu>|</span> <span class=dt>False</span>

<span class=ot>isJust ::</span> <span class=dt>Maybe</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
isJust (<span class=dt>Just</span> x) <span class=fu>=</span> <span class=dt>True</span>
isJust <span class=dt>Nothing</span>  <span class=fu>=</span> <span class=dt>False</span></code></pre></div>
<p><font>The problem with the boolean type is that there is effectively no difference between True and False at the type level. A proposition taking a value to a Bool takes any information given and destroys it. To reason about the behavior we have to trace the provenance of the proposition we're getting the boolean answer from, and this introduces a whole slew of possibilities for misinterpretation. In the worst case, the only way to reason about safe and unsafe use of a function is by trusting that a predicate's lexical name reflects its provenance!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>布尔类型的问题在于，在类型级别上，True 和 False 之间实际上没有区别。将值赋给 Bool 的命题会获取任何给定的信息并将其销毁。为了推断行为，我们必须追溯我们从中获得布尔答案的命题的来源，这会引入一大堆误解的可能性。在最坏的情况下，推断安全和不安全使用函数的唯一方法是相信谓词的词法名称反映了它的出处！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For instance, testing some proposition over a Bool value representing whether the branch can perform the computation safely in the presence of a null is subject to accidental interchange. Consider that in a language like C or Python testing whether a value is null is indistinguishable to the language from testing whether the value is </font><em>not null</em><font>. Which of these programs encodes safe usage and which segfaults?</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，在表示分支是否可以在空值存在的情况下安全地执行计算的 Bool 值上测试一些命题会受到意外交换的影响。考虑一下，在像 C 或 Python 这样的语言中，测试值是否为 null 与测试值是否不为 null 的语言是无法区分的。这些程序中的哪些编码安全使用，哪些段错误？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode python"><code class="sourceCode python"><span class=co># This one?</span>
<span class=cf>if</span> p(x):
    <span class=co># use x</span>
<span class=cf>elif</span> <span class=op>not</span> p(x):
    <span class=co># don't use x</span>

<span class=co># Or this one?</span>
<span class=cf>if</span> p(x):
    <span class=co># don't use x</span>
<span class=cf>elif</span> <span class=op>not</span> p(x):
    <span class=co># use x</span></code></pre></div>
<p><font>From inspection we can't tell without knowing how p is defined, the compiler can't distinguish the two either and thus the language won't save us if we happen to mix them up. Instead of making invalid states </font><em>unrepresentable</em><font> we've made the invalid state </font><em>indistinguishable</em><font> from the valid one!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从检查中我们无法知道 p 是如何定义的，编译器也无法区分两者，因此如果我们碰巧将它们混淆，语言将无法拯救我们。我们没有让无效状态无法表示，而是让无效状态与有效状态无法区分！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The more desirable practice is to match on terms which explicitly witness the proposition as a type ( often in a sum type ) and won't typecheck otherwise.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>更可取的做法是匹配明确证明命题为类型（通常是求和类型）的术语，否则不会进行类型检查。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>case</span> x <span class=kw>of</span>
  <span class=dt>Just</span> a  <span class=ot>-&gt;</span> use x
  <span class=dt>Nothing</span> <span class=ot>-&gt;</span> don't use x

<span class=co>-- not ideal</span>
<span class=kw>case</span> p x <span class=kw>of</span>
  <span class=dt>True</span>  <span class=ot>-&gt;</span> use x
  <span class=dt>False</span> <span class=ot>-&gt;</span> don't use x

<span class=co>-- not ideal</span>
<span class=kw>if</span> p x
  <span class=kw>then</span> use x
  <span class=kw>else</span> don't use x</code></pre></div>
<p><font>To be fair though, many popular languages completely lack the notion of sum types ( the source of many woes in my opinion ) and only have product types, so this type of reasoning sometimes has no direct equivalence for those not familiar with ML family languages.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>公平地说，许多流行的语言完全没有求和类型的概念（在我看来是许多问题的根源）并且只有乘积类型，因此对于那些不熟悉 ML 系列语言的人来说，这种类型的推理有时没有直接的等价性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In Haskell, the Prelude provides functions like </font><code>isJust</code><font> and </font><code>fromJust</code><font> both of which can be used to subvert this kind of reasoning and make it easy to introduce bugs and should often be avoided.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Haskell 中，Prelude 提供了类似 isJust 和 fromJust 的函数，这两个函数都可以用来颠覆这种推理，并且很容易引入错误，应该经常避免。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=foldable-traversable><font>Foldable / Traversable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可折叠/可穿越</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>If coming from an imperative background retraining one's self to think about iteration over lists in terms of maps, folds, and scans can be challenging.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果来自命令式背景，重新训练自己思考在地图、折叠和扫描方面对列表进行迭代可能具有挑战性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">Prelude.foldl<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> [b] <span class=ot>-&gt;</span> a
Prelude.foldr<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> b

<span class=co>-- pseudocode</span>
foldr f z [a<span class=fu>...</span>] <span class=fu>=</span> f a (f b ( <span class=fu>...</span> (f y z) <span class=fu>...</span> ))
foldl f z [a<span class=fu>...</span>] <span class=fu>=</span> f <span class=fu>...</span> (f (f z a) b) <span class=fu>...</span> y</code></pre></div>
<p><font>For a concrete consider the simple arithmetic sequence over the binary operator </font><code>(+)</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>具体考虑二元运算符 (+) 上的简单算术序列：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- foldr (+) 1 [2..]</span>
(<span class=dv>1</span> <span class=fu>+</span> (<span class=dv>2</span> <span class=fu>+</span> (<span class=dv>3</span> <span class=fu>+</span> (<span class=dv>4</span> <span class=fu>+</span> <span class=fu>...</span>))))</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- foldl (+) 1 [2..]</span>
((((<span class=dv>1</span> <span class=fu>+</span> <span class=dv>2</span>) <span class=fu>+</span> <span class=dv>3</span>) <span class=fu>+</span> <span class=dv>4</span>) <span class=fu>+</span> <span class=fu>...</span>)</code></pre></div>
<p><font>Foldable and Traversable are the general interface for all traversals and folds of any data structure which is parameterized over its element type ( List, Map, Set, Maybe, ...). These two classes are used everywhere in modern Haskell and are extremely important.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Foldable 和 Traversable 是所有遍历和折叠任何数据结构的通用接口，这些数据结构在其元素类型（List、Map、Set、Maybe 等）上进行了参数化。这两个类在现代 Haskell 中无处不在，极其重要。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>A foldable instance allows us to apply functions to data types of monoidal values that collapse the structure using some logic over </font><code>mappend</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可折叠实例允许我们将函数应用于幺半群值的数据类型，这些数据类型使用 mappend 上的一些逻辑来折叠结构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>A traversable instance allows us to apply functions to data types that walk the structure left-to-right within an applicative context.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可遍历实例允许我们将函数应用于在应用上下文中从左到右遍历结构的数据类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> (<span class=dt>Functor</span> f, <span class=dt>Foldable</span> f) <span class=ot>=&gt;</span> <span class=dt>Traversable</span> f <span class=kw>where</span>
<span class=ot>  traverse ::</span> <span class=dt>Applicative</span> g <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> g b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> g (f b)

<span class=kw>class</span> <span class=dt>Foldable</span> f <span class=kw>where</span>
<span class=ot>  foldMap ::</span> <span class=dt>Monoid</span> m <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> m) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> m</code></pre></div>
<p><font>The </font><code>foldMap</code><font> function is extremely general and non-intuitively many of the monomorphic list folds can themselves be written in terms of this single polymorphic function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>foldMap 函数非常通用并且非直观地许多单态列表折叠本身可以根据这个单一的多态函数来编写。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><code>foldMap</code><font> takes a function of values to a monoidal quantity, a functor over the values and collapses the functor into the monoid. For instance for the trivial Sum monoid:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>foldMap 将值的函数取为幺半群，一个值上的函子，并将函子折叠成幺半群。例如对于平凡的 Sum 幺半群：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> foldMap <span class=dt>Sum</span> [<span class=dv>1</span><span class=fu>..</span><span class=dv>10</span>]
<span class=dt>Sum</span> {getSum <span class=fu>=</span> <span class=dv>55</span>}</code></pre></div>
<p><font>For instance if we wanted to map a list of some abstract element types into a hashtable of elements based on pattern matching we could use it.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，如果我们想将一些抽象元素类型的列表映射到基于模式匹配的元素哈希表中，我们可以使用它。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Foldable</span>
<span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>Map</span>

<span class=kw>data</span> <span class=dt>Elt</span>
  <span class=fu>=</span> <span class=dt>Elt</span> <span class=dt>Int</span> <span class=dt>Double</span>
  <span class=fu>|</span> <span class=dt>Nil</span>

<span class=ot>foo ::</span> [<span class=dt>Elt</span>] <span class=ot>-&gt;</span> <span class=dt>Map.Map</span> <span class=dt>Int</span> <span class=dt>Double</span>
foo <span class=fu>=</span> foldMap go
  <span class=kw>where</span>
    go (<span class=dt>Elt</span> x y) <span class=fu>=</span> Map.singleton x y
    go <span class=dt>Nil</span> <span class=fu>=</span> Map.empty</code></pre></div>
<p><font>The full Foldable class (with all default implementations) contains a variety of derived functions which themselves can be written in terms of </font><code>foldMap</code><font> and </font><code>Endo</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>完整的 Foldable 类（具有所有默认实现）包含各种派生函数，它们本身可以根据 foldMap 和 Endo 编写。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Endo</span> a <span class=fu>=</span> <span class=dt>Endo</span> {<span class=ot>appEndo ::</span> a <span class=ot>-&gt;</span> a}

<span class=kw>instance</span> <span class=dt>Monoid</span> (<span class=dt>Endo</span> a) <span class=kw>where</span>
  mempty <span class=fu>=</span> <span class=dt>Endo</span> id
  <span class=dt>Endo</span> f <span class=ot>`mappend`</span> <span class=dt>Endo</span> g <span class=fu>=</span> <span class=dt>Endo</span> (f <span class=fu>.</span> g)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Foldable</span> t <span class=kw>where</span>
<span class=ot>    fold    ::</span> <span class=dt>Monoid</span> m <span class=ot>=&gt;</span> t m <span class=ot>-&gt;</span> m
<span class=ot>    foldMap ::</span> <span class=dt>Monoid</span> m <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> m) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> m

<span class=ot>    foldr   ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> b
<span class=ot>    foldr'  ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> b

<span class=ot>    foldl   ::</span> (b <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> b
<span class=ot>    foldl'  ::</span> (b <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> b

<span class=ot>    foldr1  ::</span> (a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> a
<span class=ot>    foldl1  ::</span> (a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> a</code></pre></div>
<p><font>For example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> b
foldr f z t <span class=fu>=</span> appEndo (foldMap (<span class=dt>Endo</span> <span class=fu>.</span> f) t) z</code></pre></div>
<p><font>Most of the operations over lists can be generalized in terms of combinations of Foldable and Traversable to derive more general functions that work over all data structures implementing Foldable.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>大多数对列表的操作都可以根据 Foldable 和 Traversable 的组合来概括，以派生出更通用的函数，这些函数适用于所有实现 Foldable 的数据结构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">Data.Foldable.elem<span class=ot>    ::</span> (<span class=dt>Eq</span> a, <span class=dt>Foldable</span> t) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
Data.Foldable.sum<span class=ot>     ::</span> (<span class=dt>Num</span> a, <span class=dt>Foldable</span> t) <span class=ot>=&gt;</span> t a <span class=ot>-&gt;</span> a
Data.Foldable.minimum<span class=ot> ::</span> (<span class=dt>Ord</span> a, <span class=dt>Foldable</span> t) <span class=ot>=&gt;</span> t a <span class=ot>-&gt;</span> a
Data.Traversable.mapM<span class=ot> ::</span> (<span class=dt>Monad</span> m, <span class=dt>Traversable</span> t) <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> m (t b)</code></pre></div>
<p><font>Unfortunately for historical reasons the names exported by foldable quite often conflict with ones defined in the Prelude, either import them qualified or just disable the Prelude. The operations in the Foldable all specialize to the same and behave the same as the ones in Prelude for List types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不幸的是，由于历史原因，foldable 导出的名称经常与 Prelude 中定义的名称冲突，要么导入合格的名称，要么禁用 Prelude。 Foldable 中的操作都专门针对相同的操作，并且与 Prelude 中的 List 类型的操作相同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/06-prelude/foldable_traversable.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Monoid</span>
<span class=kw>import </span><span class=dt>Data.Foldable</span>
<span class=kw>import </span><span class=dt>Data.Traversable</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import </span><span class=dt>Control.Monad.Identity</span> (runIdentity)
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (mapM_, foldr)

<span class=co>-- Rose Tree</span>
<span class=kw>data</span> <span class=dt>Tree</span> a <span class=fu>=</span> <span class=dt>Node</span> a [<span class=dt>Tree</span> a] <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Functor</span> <span class=dt>Tree</span> <span class=kw>where</span>
  fmap f (<span class=dt>Node</span> x ts) <span class=fu>=</span> <span class=dt>Node</span> (f x) (fmap (fmap f) ts)

<span class=kw>instance</span> <span class=dt>Traversable</span> <span class=dt>Tree</span> <span class=kw>where</span>
  traverse f (<span class=dt>Node</span> x ts) <span class=fu>=</span> <span class=dt>Node</span> <span class=fu>&lt;$&gt;</span> f x <span class=fu>&lt;*&gt;</span> traverse (traverse f) ts

<span class=kw>instance</span> <span class=dt>Foldable</span> <span class=dt>Tree</span> <span class=kw>where</span>
  foldMap f (<span class=dt>Node</span> x ts) <span class=fu>=</span> f x <span class=ot>`mappend`</span> foldMap (foldMap f) ts


<span class=ot>tree ::</span> <span class=dt>Tree</span> <span class=dt>Integer</span>
tree <span class=fu>=</span> <span class=dt>Node</span> <span class=dv>1</span> [<span class=dt>Node</span> <span class=dv>1</span> [], <span class=dt>Node</span> <span class=dv>2</span> [] ,<span class=dt>Node</span> <span class=dv>3</span> []]


<span class=ot>example1 ::</span> <span class=dt>IO</span> ()
example1 <span class=fu>=</span> mapM_ print tree

<span class=ot>example2 ::</span> <span class=dt>Integer</span>
example2 <span class=fu>=</span> foldr (<span class=fu>+</span>) <span class=dv>0</span> tree

<span class=ot>example3 ::</span> <span class=dt>Maybe</span> (<span class=dt>Tree</span> <span class=dt>Integer</span>)
example3 <span class=fu>=</span> traverse (\x <span class=ot>-&gt;</span> <span class=kw>if</span> x <span class=fu>&gt;</span> <span class=dv>2</span> <span class=kw>then</span> <span class=dt>Just</span> x <span class=kw>else</span> <span class=dt>Nothing</span>) tree

<span class=ot>example4 ::</span> <span class=dt>Tree</span> <span class=dt>Integer</span>
example4 <span class=fu>=</span> runIdentity <span class=fu>$</span> traverse (\x <span class=ot>-&gt;</span> pure (x<span class=fu>+</span><span class=dv>1</span>)) tree</code></pre></div>
<p><font>The instances we defined above can also be automatically derived by GHC using several language extensions. The automatic instances are identical to the hand-written versions above.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们上面定义的实例也可以由 GHC 使用多种语言扩展自动派生。自动实例与上面的手写版本相同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveFunctor #-}</span>
<span class=ot>{-# LANGUAGE DeriveFoldable #-}</span>
<span class=ot>{-# LANGUAGE DeriveTraversable #-}</span>

<span class=kw>data</span> <span class=dt>Tree</span> a <span class=fu>=</span> <span class=dt>Node</span> a [<span class=dt>Tree</span> a]
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Functor</span>, <span class=dt>Foldable</span>, <span class=dt>Traversable</span>)</code></pre></div>
<p><font>See: </font><a href=http://wiki.haskell.org/Typeclassopedia>Typeclassopedia</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：Typeclassopedia</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=corecursion><font>Corecursion</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>核心游说</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>unfoldr ::</span> (b <span class=ot>-&gt;</span> <span class=dt>Maybe</span> (a, b)) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> [a]</code></pre></div>
<p><font>A recursive function consumes data and eventually terminates, a corecursive function generates data and </font><strong>coterminates</strong><font>. A corecursive function is said to be </font><em>productive</em><font> if it can always evaluate more of the resulting value in bounded time.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>递归函数消耗数据并最终终止，核心递归函数生成数据并最终终止。如果一个核心递归函数总是能够在有限的时间内评估更多的结果值，那么它就被认为是高效的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.List</span>

<span class=ot>f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
f <span class=dv>0</span> <span class=fu>=</span> <span class=dt>Nothing</span>
f x <span class=fu>=</span> <span class=dt>Just</span> (x, x<span class=fu>-</span><span class=dv>1</span>)

<span class=ot>rev ::</span> [<span class=dt>Int</span>]
rev <span class=fu>=</span> unfoldr f <span class=dv>10</span>

<span class=ot>fibs ::</span> [<span class=dt>Int</span>]
fibs <span class=fu>=</span> unfoldr (\(a,b) <span class=ot>-&gt;</span> <span class=dt>Just</span> (a,(b,a<span class=fu>+</span>b))) (<span class=dv>0</span>,<span class=dv>1</span>)</code></pre></div>
<h2 id=split><font>split</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>分裂</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><a href=http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html>split</a><font> package provides a variety of missing functions for splitting list and string types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>split 包提供了多种用于拆分列表和字符串类型的缺失函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/06-prelude/split.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.List.Split</span>

<span class=ot>example1 ::</span> [<span class=dt>String</span>]
example1 <span class=fu>=</span> splitOn <span class=st>"."</span> <span class=st>"foo.bar.baz"</span>
<span class=co>-- ["foo","bar","baz"]</span>

<span class=ot>example2 ::</span> [<span class=dt>String</span>]
example2 <span class=fu>=</span> chunksOf <span class=dv>10</span> <span class=st>"To be or not to be that is the question."</span>
<span class=co>-- ["To be or n","ot to be t","hat is the"," question."]</span></code></pre></div>
<h2 id=monad-loops><font>monad-loops</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子循环</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><a href=http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html>monad-loops</a><font> package provides a variety of missing functions for control logic in monadic contexts.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>monad-loops 包为 monadic 上下文中的控制逻辑提供了各种缺失的功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>whileM ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m <span class=dt>Bool</span> <span class=ot>-&gt;</span> m a <span class=ot>-&gt;</span> m [a]
<span class=ot>untilM ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> m <span class=dt>Bool</span> <span class=ot>-&gt;</span> m [a]
<span class=ot>iterateUntilM ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>Bool</span>) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> m a
<span class=ot>whileJust ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m (<span class=dt>Maybe</span> a) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m [b]</code></pre></div>
<h2 id=foundation><font>Foundation</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>基础</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>TODO</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>去做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=https://github.com/haskell-foundation/foundation>Foundation</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：基金会</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<hr>
<h1 id=strings><font>Strings</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=string><font>String</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>细绳</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><b>The default String type is broken and should be avoided whenever possible.</b><font> Unfortunately for historical reasons large portions of GHC and Base depend on String.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认的 String 类型已损坏，应尽可能避免使用。不幸的是，由于历史原因，大部分 GHC 和 Base 都依赖于 String。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>The default Haskell string type is implemented as a naive linked list of characters, this is terrible for most purposes but no one knows how to fix it without rewriting large portions of all code that exists and nobody can commit the time to fix it. So it remains broken, likely forever.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认的 Haskell 字符串类型是作为一个简单的字符链表实现的，这对大多数用途来说都很糟糕，但是没有人知道如何在不重写所有现有代码的大部分的情况下修复它，也没有人可以花时间修复它。所以它仍然破碎，可能永远。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>String</span> <span class=fu>=</span> [<span class=dt>Char</span>]</code></pre></div>
<p><font>For more performance sensitive cases there are two libraries for processing textual data: </font><code>text</code><font> and </font><code>bytestring</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于对性能更敏感的情况，有两个用于处理文本数据的库：text 和 bytestring。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><b>text</b><font> - Used for handling unicode data.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>text - 用于处理 unicode 数据。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><b>bytestring</b><font> - Used for handling ASCII data that needs to interchanged with C code or network protocols.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>bytestring - 用于处理需要与 C 代码或网络协议交换的 ASCII 数据。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>For each of these there are two variants for both text and bytestring.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于其中的每一个，文本和字节串都有两种变体。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><b>lazy</b><font> Lazy text objects are encoded as lazy lists of strict chunks of bytes.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>惰性 惰性文本对象被编码为严格的字节块的惰性列表。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><b>strict</b><font> Byte vectors are encoded as strict Word8 arrays of bytes or code points</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格的字节向量被编码为严格的 Word8 字节数组或代码点</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>Giving rise to the four types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生起四种。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Variant</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>变体</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Module</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模块</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><b>strict text<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格的文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></b></td>
<td align=left><font>Data.Text</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><b>lazy text<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>懒惰的文字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></b></td>
<td align=left><font>Data.Text.Lazy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.文本.惰性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><b>strict bytestring<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></b></td>
<td align=left><font>Data.ByteString</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><b>lazy bytestring<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>惰性字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></b></td>
<td align=left><font>Data.ByteString.Lazy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.ByteString.Lazy</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<h4 id=conversions><font>Conversions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>转换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Conversions between strings types ( from : left column, to : top row ) are done with several functions across the bytestring and text libraries. The mapping between text and bytestring is inherently lossy so there is some degree of freedom in choosing the encoding. We'll just consider utf-8 for simplicity.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字符串类型之间的转换（从：左列，到：顶行）是通过字节串和文本库中的几个函数完成的。文本和字节串之间的映射本质上是有损的，因此在选择编码时有一定程度的自由度。为简单起见，我们只考虑 utf-8。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left></th>
<th align=left><font>Data.Text</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Data.Text.Lazy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.文本.惰性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Data.ByteString</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Data.ByteString.Lazy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.ByteString.Lazy</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Data.Text</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromStrict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>encodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>编码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>encodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>编码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Data.Text.Lazy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.文本.惰性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>toStrict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>encodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>编码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>encodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>编码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Data.ByteString</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>decodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>decodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromStrict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Data.ByteString.Lazy</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.ByteString.Lazy</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>decodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>decodeUtf8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解码Utf8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>toStrict</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>严格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<h4 id=overloaded-strings><font>Overloaded Strings</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载的字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>With the </font><code>-XOverloadedStrings</code><font> extension string literals can be overloaded without the need for explicit packing and can be written as string literals in the Haskell source and overloaded via a typeclass </font><code>IsString</code><font>. Sometimes this is desirable.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 -XOverloadedStrings 扩展字符串文字可以重载而无需显式打包，并且可以在 Haskell 源代码中写成字符串文字并通过类型类 IsString 重载。有时这是可取的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>IsString</span> a <span class=kw>where</span>
<span class=ot>  fromString ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> a</code></pre></div>
<p><font>For instance:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span><span class=kw>type</span> <span class=st>"foo"</span>
<span class=st>"foo"</span><span class=ot> ::</span> [<span class=dt>Char</span>]

λ<span class=fu>:</span> <span class=fu>:</span>set <span class=fu>-</span><span class=dt>XOverloadedStrings</span>

λ<span class=fu>:</span> <span class=fu>:</span><span class=kw>type</span> <span class=st>"foo"</span>
<span class=st>"foo"</span><span class=ot> ::</span> <span class=dt>IsString</span> a <span class=ot>=&gt;</span> a</code></pre></div>
<p><font>We can also derive IsString for newtypes using </font><code>GeneralizedNewtypeDeriving</code><font>, although much of the safety of the newtype is then lost if it is interchangeable with other strings.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们还可以使用 GeneralizedNewtypeDeriving 为新类型派生 IsString，尽管如果新类型可以与其他字符串互换，那么它的大部分安全性就会丧失。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Cat</span> <span class=fu>=</span> <span class=dt>Cat</span> <span class=dt>Text</span>
  <span class=kw>deriving</span> (<span class=dt>IsString</span>)

<span class=ot>fluffy ::</span> <span class=dt>Cat</span>
fluffy <span class=fu>=</span> <span class=st>"Fluffy"</span></code></pre></div>
<h2 id=import-conventions><font>Import Conventions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>导入约定</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy</span> <span class=kw>as</span> <span class=dt>TL</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString</span> <span class=kw>as</span> <span class=dt>BS</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Char8</span> <span class=kw>as</span> <span class=dt>C</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy.Char8</span> <span class=kw>as</span> <span class=dt>CL</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.Text.IO</span> <span class=kw>as</span> <span class=dt>TIO</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>TLIO</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.Text.Encoding</span> <span class=kw>as</span> <span class=dt>TE</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.Encoding</span> <span class=kw>as</span> <span class=dt>TLE</span></code></pre></div>
<h2 id=text><font>Text</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A </font><code>Text</code><font> type is a packed blob of Unicode characters.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Text 类型是 Unicode 字符的打包块。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">pack<span class=ot> ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Text</span>
<span class=ot>unpack ::</span> <span class=dt>Text</span> <span class=ot>-&gt;</span> <span class=dt>String</span></code></pre></div>
<div class=sourceCode include=src/07-text-bytestring/text.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>

<span class=co>-- From pack</span>
<span class=ot>myTStr1 ::</span> <span class=dt>T.Text</span>
myTStr1 <span class=fu>=</span> T.pack (<span class=st>"foo"</span><span class=ot> ::</span> <span class=dt>String</span>)

<span class=co>-- From overloaded string literal.</span>
<span class=ot>myTStr2 ::</span> <span class=dt>T.Text</span>
myTStr2 <span class=fu>=</span> <span class=st>"bar"</span></code></pre></div>
<p><font>See: </font><a href=http://hackage.haskell.org/package/text-1.1.0.1/docs/Data-Text.html>Text</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=text.builder><font>Text.Builder</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>文本生成器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>toLazyText ::</span> <span class=dt>Builder</span> <span class=ot>-&gt;</span> <span class=dt>Data.Text.Lazy.Internal.Text</span>
<span class=ot>fromLazyText ::</span> <span class=dt>Data.Text.Lazy.Internal.Text</span> <span class=ot>-&gt;</span> <span class=dt>Builder</span></code></pre></div>
<p><font>The Text.Builder allows the efficient monoidal construction of lazy Text types without having to go through inefficient forms like String or List types as intermediates.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Text.Builder 允许惰性 Text 类型的高效幺半群构造，而不必通过像 String 或 List 类型这样的低效形式作为中间体。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/07-text-bytestring/builder.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.Monoid</span> (mconcat, (&lt;&gt;))

<span class=kw>import </span><span class=dt>Data.Text.Lazy.Builder</span> (<span class=dt>Builder</span>, toLazyText)
<span class=kw>import </span><span class=dt>Data.Text.Lazy.Builder.Int</span> (decimal)
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>L</span>

<span class=ot>beer ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Builder</span>
beer n <span class=fu>=</span> decimal n <span class=fu>&lt;&gt;</span> <span class=st>" bottles of beer on the wall.\n"</span>

<span class=ot>wall ::</span> <span class=dt>Builder</span>
wall <span class=fu>=</span> mconcat <span class=fu>$</span> fmap beer [<span class=dv>1</span><span class=fu>..</span><span class=dv>1000</span>]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> L.putStrLn <span class=fu>$</span> toLazyText wall</code></pre></div>
<h2 id=bytestring><font>ByteString</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>ByteStrings are arrays of unboxed characters with either strict or lazy evaluation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ByteStrings 是具有严格或惰性评估的未装箱字符数组。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">pack<span class=ot> ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>ByteString</span>
<span class=ot>unpack ::</span> <span class=dt>ByteString</span> <span class=ot>-&gt;</span> <span class=dt>String</span></code></pre></div>
<div class=sourceCode include=src/07-text-bytestring/bytestring.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.ByteString</span> <span class=kw>as</span> <span class=dt>S</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Char8</span> <span class=kw>as</span> <span class=dt>S8</span>

<span class=co>-- From pack</span>
<span class=ot>bstr1 ::</span> <span class=dt>S.ByteString</span>
bstr1 <span class=fu>=</span> S.pack (<span class=st>"foo"</span><span class=ot> ::</span> <span class=dt>String</span>)

<span class=co>-- From overloaded string literal.</span>
<span class=ot>bstr2 ::</span> <span class=dt>S.ByteString</span>
bstr2 <span class=fu>=</span> <span class=st>"bar"</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/bytestring-bits-and-pieces>Bytestring: Bits and Pieces<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字节串：点点滴滴</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString.html>ByteString<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=utf8-string><font>utf8-string</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>utf8 字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>See: </font><a href=https://hackage.haskell.org/package/utf8-string>utf8-string</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参见：utf8 字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=base64-bytestring><font>base64-bytestring</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>base64字节串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=printf><font>Printf</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>打印</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell also has a variadic </font><code>printf</code><font> function in the style of C.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 也有一个 C 风格的可变参数 printf 函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/07-text-bytestring/printf.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import </span><span class=dt>Text.Printf</span>

<span class=ot>a ::</span> <span class=dt>Int</span>
a <span class=fu>=</span> <span class=dv>3</span>

<span class=ot>b ::</span> <span class=dt>Double</span>
b <span class=fu>=</span> <span class=fl>3.14159</span>

<span class=ot>c ::</span> <span class=dt>String</span>
c <span class=fu>=</span> <span class=st>"haskell"</span>

<span class=ot>example ::</span> <span class=dt>String</span>
example <span class=fu>=</span> printf <span class=st>"(%i, %f, %s)"</span> a b c
<span class=co>-- "(3, 3.14159, haskell)"</span></code></pre></div>
<h2 id=overloaded-lists><font>Overloaded Lists</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>It is ubiquitous for data structure libraries to expose </font><code>toList</code><font> and </font><code>fromList</code><font> functions to construct various structures out of lists. As of GHC 7.8 we now have the ability to overload the list syntax in the surface language with a typeclass </font><code>IsList</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据结构库公开 toList 和 fromList 函数以从列表中构造各种结构是无处不在的。从 GHC 7.8 开始，我们现在可以使用类型类 IsList 重载表面语言中的列表语法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>IsList</span> l <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Item</span> l
<span class=ot>  fromList  ::</span> [<span class=dt>Item</span> l] <span class=ot>-&gt;</span> l
<span class=ot>  toList    ::</span> l <span class=ot>-&gt;</span> [<span class=dt>Item</span> l]

<span class=kw>instance</span> <span class=dt>IsList</span> [a] <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Item</span> [a] <span class=fu>=</span> a
  fromList <span class=fu>=</span> id
  toList   <span class=fu>=</span> id</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span><span class=kw>type</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]
[<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]<span class=ot> ::</span> (<span class=dt>Num</span> (<span class=dt>Item</span> l), <span class=dt>IsList</span> l) <span class=ot>=&gt;</span> l</code></pre></div>
<div class=sourceCode include=src/07-text-bytestring/overloadedlist.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedLists #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>Map</span>
<span class=kw>import </span><span class=dt>GHC.Exts</span> (<span class=dt>IsList</span>(..))

<span class=kw>instance</span> (<span class=dt>Ord</span> k) <span class=ot>=&gt;</span> <span class=dt>IsList</span> (<span class=dt>Map.Map</span> k v) <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Item</span> (<span class=dt>Map.Map</span> k v) <span class=fu>=</span> (k,v)
  fromList <span class=fu>=</span> Map.fromList
  toList <span class=fu>=</span> Map.toList

<span class=ot>example1 ::</span> <span class=dt>Map.Map</span> <span class=dt>String</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> [(<span class=st>"a"</span>, <span class=dv>1</span>), (<span class=st>"b"</span>, <span class=dv>2</span>)]</code></pre></div>
<h2 id=string-conversions><font>String Conversions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>字符串转换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Playing "type-tetris" to convert between Strings explicitly can be frustrating, fortunately there are several packages that automate the conversion using typeclasses to automatically convert between any two common string representations automatically. We can then write generic comparison and concatenation operators that automatically convert types of operands to a like form.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>玩“类型俄罗斯方块”以在字符串之间显式转换可能会令人沮丧，幸运的是，有几个包可以使用类型类自动转换任何两个常见字符串表示形式之间的自动转换。然后我们可以编写通用的比较和连接运算符，自动将操作数类型转换为类似的形式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/07-text-bytestring/convert.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.String.Conv</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>TL</span>

<span class=kw>import qualified</span> <span class=dt>Data.ByteString</span> <span class=kw>as</span> <span class=dt>B</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>import </span><span class=dt>Data.Monoid</span>

<span class=ot>a ::</span> <span class=dt>String</span>
a <span class=fu>=</span> <span class=st>"Gödel"</span>

<span class=ot>b ::</span> <span class=dt>BL.ByteString</span>
b <span class=fu>=</span> <span class=st>"Einstein"</span>

<span class=ot>c ::</span> <span class=dt>T.Text</span>
c <span class=fu>=</span> <span class=st>"Feynmann"</span>

<span class=ot>d ::</span> <span class=dt>B.ByteString</span>
d <span class=fu>=</span> <span class=st>"Schrödinger"</span>

<span class=co>-- Compare unlike strings</span>
<span class=ot>(==~) ::</span> (<span class=dt>Eq</span> a, <span class=dt>StringConv</span> b a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> <span class=dt>Bool</span>
(<span class=fu>==~</span>) a b <span class=fu>=</span> a <span class=fu>==</span> toS b

<span class=co>-- Concat unlike strings</span>
<span class=ot>(&lt;&gt;~) ::</span> (<span class=dt>Monoid</span> a, <span class=dt>StringConv</span> b a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a
(<span class=fu>&lt;&gt;~</span>) a b <span class=fu>=</span> a <span class=fu>&lt;&gt;</span> toS b

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  putStrLn (toS a)
  TL.putStrLn (toS b)
  print (a <span class=fu>==~</span> b)
  print (c <span class=fu>==~</span> d)
  print (c <span class=fu>==~</span> c)
  print (b <span class=fu>&lt;&gt;~</span> c)</code></pre></div>
<hr>
<h1 id=applicatives><font>Applicatives</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>应用程序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>Like monads Applicatives are an abstract structure for a wide class of computations that sit between functors and monads in terms of generality.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>像 monads Applicatives 是一种抽象结构，用于广泛的计算类，在通用性方面介于函子和 monads 之间。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>pure ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> f a
<span class=ot>(&lt;$&gt;) ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b
<span class=ot>(&lt;*&gt;) ::</span> f (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b</code></pre></div>
<p><font>As of GHC 7.6, Applicative is defined as:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 GHC 7.6 开始，Applicative 定义为：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Applicative</span> f <span class=kw>where</span>
<span class=ot>  pure ::</span> a <span class=ot>-&gt;</span> f a
<span class=ot>  (&lt;*&gt;) ::</span> f (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b

<span class=ot>(&lt;$&gt;) ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b
(<span class=fu>&lt;$&gt;</span>) <span class=fu>=</span> fmap</code></pre></div>
<p><font>With the following laws:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>具有以下法律：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">pure id <span class=fu>&lt;*&gt;</span> v <span class=fu>=</span> v
pure f <span class=fu>&lt;*&gt;</span> pure x <span class=fu>=</span> pure (f x)
u <span class=fu>&lt;*&gt;</span> pure y <span class=fu>=</span> pure (<span class=fu>$</span> y) <span class=fu>&lt;*&gt;</span> u
u <span class=fu>&lt;*&gt;</span> (v <span class=fu>&lt;*&gt;</span> w) <span class=fu>=</span> pure (<span class=fu>.</span>) <span class=fu>&lt;*&gt;</span> u <span class=fu>&lt;*&gt;</span> v <span class=fu>&lt;*&gt;</span> w</code></pre></div>
<p><font>As an example, consider the instance for Maybe:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，考虑 Maybe 的实例：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Applicative</span> <span class=dt>Maybe</span> <span class=kw>where</span>
  pure              <span class=fu>=</span> <span class=dt>Just</span>
  <span class=dt>Nothing</span> <span class=fu>&lt;*&gt;</span> _     <span class=fu>=</span> <span class=dt>Nothing</span>
  _ <span class=fu>&lt;*&gt;</span> <span class=dt>Nothing</span>     <span class=fu>=</span> <span class=dt>Nothing</span>
  <span class=dt>Just</span> f <span class=fu>&lt;*&gt;</span> <span class=dt>Just</span> x <span class=fu>=</span> <span class=dt>Just</span> (f x)</code></pre></div>
<p><font>As a rule of thumb, whenever we would use </font><code>m &gt;&gt;= return . f</code><font> what we probably want is an applicative functor, and not a monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>根据经验，每当我们使用 m &gt;&gt;= return 时。 f 我们可能想要的是一个应用函子，而不是一个单子。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/08-applicatives/applicative.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Network.HTTP</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span> ((&lt;$&gt;),(&lt;*&gt;))

<span class=ot>example1 ::</span> <span class=dt>Maybe</span> <span class=dt>Integer</span>
example1 <span class=fu>=</span> (<span class=fu>+</span>) <span class=fu>&lt;$&gt;</span> m1 <span class=fu>&lt;*&gt;</span> m2
  <span class=kw>where</span>
    m1 <span class=fu>=</span> <span class=dt>Just</span> <span class=dv>3</span>
    m2 <span class=fu>=</span> <span class=dt>Nothing</span>
<span class=co>-- Nothing</span>

<span class=ot>example2 ::</span> [(<span class=dt>Int</span>, <span class=dt>Int</span>, <span class=dt>Int</span>)]
example2 <span class=fu>=</span> (,,) <span class=fu>&lt;$&gt;</span> m1 <span class=fu>&lt;*&gt;</span> m2 <span class=fu>&lt;*&gt;</span> m3
  <span class=kw>where</span>
    m1 <span class=fu>=</span> [<span class=dv>1</span>,<span class=dv>2</span>]
    m2 <span class=fu>=</span> [<span class=dv>10</span>,<span class=dv>20</span>]
    m3 <span class=fu>=</span> [<span class=dv>100</span>,<span class=dv>200</span>]
<span class=co>-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span>

<span class=ot>example3 ::</span> <span class=dt>IO</span> <span class=dt>String</span>
example3 <span class=fu>=</span> (<span class=fu>++</span>) <span class=fu>&lt;$&gt;</span> fetch1 <span class=fu>&lt;*&gt;</span> fetch2
  <span class=kw>where</span>
    fetch1 <span class=fu>=</span> simpleHTTP (getRequest <span class=st>"http://www.fpcomplete.com/"</span>) <span class=fu>&gt;&gt;=</span> getResponseBody
    fetch2 <span class=fu>=</span> simpleHTTP (getRequest <span class=st>"http://www.haskell.org/"</span>) <span class=fu>&gt;&gt;=</span> getResponseBody</code></pre></div>
<p><font>The pattern </font><code>f &lt;$&gt; a &lt;*&gt; b ...</code><font> shows up so frequently that there are a family of functions to lift applicatives of a fixed number arguments. This pattern also shows up frequently with monads (</font><code>liftM</code><font>, </font><code>liftM2</code><font>, </font><code>liftM3</code><font>).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模式 f &lt;$&gt; a &lt;*&gt; b ... 出现得如此频繁，以至于有一系列函数可以提升固定数量参数的应用程序。这种模式也经常出现在 monads（liftM、liftM2、liftM3）中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>liftA ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b
liftA f a <span class=fu>=</span> pure f <span class=fu>&lt;*&gt;</span> a

<span class=ot>liftA2 ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b <span class=ot>-&gt;</span> f c
liftA2 f a b <span class=fu>=</span> f <span class=fu>&lt;$&gt;</span> a <span class=fu>&lt;*&gt;</span> b

<span class=ot>liftA3 ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c <span class=ot>-&gt;</span> d) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b <span class=ot>-&gt;</span> f c <span class=ot>-&gt;</span> f d
liftA3 f a b c <span class=fu>=</span> f <span class=fu>&lt;$&gt;</span> a <span class=fu>&lt;*&gt;</span> b <span class=fu>&lt;*&gt;</span> c</code></pre></div>
<p><font>Applicative also has functions </font><code>*&gt;</code><font> and </font><code>&lt;*</code><font> that sequence applicative actions while discarding the value of one of the arguments. The operator </font><code>*&gt;</code><font> discard the left while </font><code>&lt;*</code><font> discards the right. For example in a monadic parser combinator library the </font><code>*&gt;</code><font> would parse with first parser argument but return the second.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Applicative 还具有函数 *&gt; 和 &lt;*，它们在丢弃其中一个参数的值的同时对应用程序操作进行排序。运算符 *&gt; 丢弃左边，而 &lt;* 丢弃右边。例如，在 monadic 解析器组合器库中， *&gt; 将使用第一个解析器参数进行解析，但返回第二个。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The Applicative functions </font><code>&lt;$&gt;</code><font> and </font><code>&lt;*&gt;</code><font> are generalized by </font><code>liftM</code><font> and </font><code>ap</code><font> for monads.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Applicative 函数 &lt;$&gt; 和 &lt;*&gt; 由 monad 的 liftM 和 ap 泛化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=kw>data</span> <span class=dt>C</span> a b <span class=fu>=</span> <span class=dt>C</span> a b

<span class=ot>mnd ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m a <span class=ot>-&gt;</span> m b <span class=ot>-&gt;</span> m (<span class=dt>C</span> a b)
mnd a b <span class=fu>=</span> <span class=dt>C</span> <span class=ot>`liftM`</span> a <span class=ot>`ap`</span> b

<span class=ot>apl ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> f a <span class=ot>-&gt;</span> f b <span class=ot>-&gt;</span> f (<span class=dt>C</span> a b)
apl a b <span class=fu>=</span> <span class=dt>C</span> <span class=fu>&lt;$&gt;</span> a <span class=fu>&lt;*&gt;</span> b</code></pre></div>
<p><font>See: </font><a href=http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf>Applicative Programming with Effects</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：具有效果的应用程序编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=alternative><font>Alternative</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>选择</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Alternative is an extension of the Applicative class with a zero element and an associative binary operation respecting the zero.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Alternative 是 Applicative 类的扩展，具有零元素和关于零的关联二元运算。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> <span class=dt>Alternative</span> f <span class=kw>where</span>
  <span class=co>-- | The identity of '&lt;|&gt;'</span>
<span class=ot>  empty ::</span> f a
  <span class=co>-- | An associative binary operation</span>
<span class=ot>  (&lt;|&gt;) ::</span> f a <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f a
  <span class=co>-- | One or more.</span>
<span class=ot>  some ::</span> f a <span class=ot>-&gt;</span> f [a]
  <span class=co>-- | Zero or more.</span>
<span class=ot>  many ::</span> f a <span class=ot>-&gt;</span> f [a]

<span class=ot>optional ::</span> <span class=dt>Alternative</span> f <span class=ot>=&gt;</span> f a <span class=ot>-&gt;</span> f (<span class=dt>Maybe</span> a)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Alternative</span> <span class=dt>Maybe</span> <span class=kw>where</span>
    empty <span class=fu>=</span> <span class=dt>Nothing</span>
    <span class=dt>Nothing</span> <span class=fu>&lt;|&gt;</span> r <span class=fu>=</span> r
    l       <span class=fu>&lt;|&gt;</span> _ <span class=fu>=</span> l

<span class=kw>instance</span> <span class=dt>Alternative</span> [] <span class=kw>where</span>
    empty <span class=fu>=</span> []
    (<span class=fu>&lt;|&gt;</span>) <span class=fu>=</span> (<span class=fu>++</span>)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> foldl1 (<span class=fu>&lt;|&gt;</span>) [<span class=dt>Nothing</span>, <span class=dt>Just</span> <span class=dv>5</span>, <span class=dt>Just</span> <span class=dv>3</span>]
<span class=dt>Just</span> <span class=dv>5</span></code></pre></div>
<p><font>These instances show up very frequently in parsers where the alternative operator can model alternative parse branches.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些实例非常频繁地出现在解析器中，其中替代运算符可以对替代解析分支进行建模。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=arrows><font>Arrows</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>箭头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A category is an algebraic structure that includes a notion of an identity and a composition operation that is associative and preserves identities.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>范畴是一种代数结构，包括身份的概念和结合并保留身份的组合操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Category</span> cat <span class=kw>where</span>
<span class=ot>  id ::</span> cat a a
<span class=ot>  (.) ::</span> cat b c <span class=ot>-&gt;</span> cat a b <span class=ot>-&gt;</span> cat a c</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Category</span> (<span class=ot>-&gt;</span>) <span class=kw>where</span>
  id <span class=fu>=</span> Prelude.id
  (<span class=fu>.</span>) <span class=fu>=</span> (<span class=fu>Prelude..</span>)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>(&lt;&lt;&lt;) ::</span> <span class=dt>Category</span> cat <span class=ot>=&gt;</span> cat b c <span class=ot>-&gt;</span> cat a b <span class=ot>-&gt;</span> cat a c
(<span class=fu>&lt;&lt;&lt;</span>) <span class=fu>=</span> (<span class=fu>.</span>)

<span class=ot>(&gt;&gt;&gt;) ::</span> <span class=dt>Category</span> cat <span class=ot>=&gt;</span> cat a b <span class=ot>-&gt;</span> cat b c <span class=ot>-&gt;</span> cat a c
f <span class=fu>&gt;&gt;&gt;</span> g <span class=fu>=</span> g <span class=fu>.</span> f</code></pre></div>
<p><font>Arrows are an extension of categories with the notion of products.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>箭头是具有产品概念的类别的扩展。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Category</span> a <span class=ot>=&gt;</span> <span class=dt>Arrow</span> a <span class=kw>where</span>
<span class=ot>  arr ::</span> (b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> a b c
<span class=ot>  first ::</span> a b c <span class=ot>-&gt;</span> a (b,d) (c,d)
<span class=ot>  second ::</span> a b c <span class=ot>-&gt;</span> a (d,b) (d,c)
<span class=ot>  (***) ::</span> a b c <span class=ot>-&gt;</span> a b' c' <span class=ot>-&gt;</span> a (b,b') (c,c')
<span class=ot>  (&amp;&amp;&amp;) ::</span> a b c <span class=ot>-&gt;</span> a b c' <span class=ot>-&gt;</span> a b (c,c')</code></pre></div>
<p><font>The canonical example is for functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>典型的例子是函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Arrow</span> (<span class=ot>-&gt;</span>) <span class=kw>where</span>
  arr f <span class=fu>=</span> f
  first f <span class=fu>=</span> f <span class=fu>***</span> id
  second f <span class=fu>=</span> id <span class=fu>***</span> f
  (<span class=fu>***</span>) f g <span class=fu>~</span>(x,y) <span class=fu>=</span> (f x, g y)</code></pre></div>
<p><font>In this form functions of multiple arguments can be threaded around using the arrow combinators in a much more pointfree form. For instance a histogram function has a nice one-liner.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在这种形式中，多个参数的函数可以使用箭头组合器以更加无意义的形式进行串联。例如，直方图函数有一个很好的单线。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.List</span> (group, sort)

<span class=ot>histogram ::</span> <span class=dt>Ord</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> [(a, <span class=dt>Int</span>)]
histogram <span class=fu>=</span> map (head <span class=fu>&amp;&amp;&amp;</span> length) <span class=fu>.</span> group <span class=fu>.</span> sort</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> histogram <span class=st>"Hello world"</span>
[(<span class=ch>' '</span>,<span class=dv>1</span>),(<span class=ch>'H'</span>,<span class=dv>1</span>),(<span class=ch>'d'</span>,<span class=dv>1</span>),(<span class=ch>'e'</span>,<span class=dv>1</span>),(<span class=ch>'l'</span>,<span class=dv>3</span>),(<span class=ch>'o'</span>,<span class=dv>2</span>),(<span class=ch>'r'</span>,<span class=dv>1</span>),(<span class=ch>'w'</span>,<span class=dv>1</span>)]</code></pre></div>
<p><strong>Arrow notation<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>箭头符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>GHC has builtin syntax for composing arrows using </font><code>proc</code><font> notation. The following are equivalent after desugaring:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 具有使用 proc 表示法组合箭头的内置语法。脱糖后等价于：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE Arrows #-}</span>

<span class=ot>addA ::</span> <span class=dt>Arrow</span> a <span class=ot>=&gt;</span> a b <span class=dt>Int</span> <span class=ot>-&gt;</span> a b <span class=dt>Int</span> <span class=ot>-&gt;</span> a b <span class=dt>Int</span>
addA f g <span class=fu>=</span> proc x <span class=ot>-&gt;</span> <span class=kw>do</span>
                y <span class=ot>&lt;-</span> f <span class=fu>-&lt;</span> x
                z <span class=ot>&lt;-</span> g <span class=fu>-&lt;</span> x
                returnA <span class=fu>-&lt;</span> y <span class=fu>+</span> z</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">addA f g <span class=fu>=</span> arr (\ x <span class=ot>-&gt;</span> (x, x)) <span class=fu>&gt;&gt;&gt;</span>
           first f <span class=fu>&gt;&gt;&gt;</span> arr (\ (y, x) <span class=ot>-&gt;</span> (x, y)) <span class=fu>&gt;&gt;&gt;</span>
           first g <span class=fu>&gt;&gt;&gt;</span> arr (\ (z, y) <span class=ot>-&gt;</span> y <span class=fu>+</span> z)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">addA f g <span class=fu>=</span> f <span class=fu>&amp;&amp;&amp;</span> g <span class=fu>&gt;&gt;&gt;</span> arr (\ (y, z) <span class=ot>-&gt;</span> y <span class=fu>+</span> z)</code></pre></div>
<p><font>In practice this notation is not often used and may become deprecated in the future.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在实践中，这种表示法并不经常使用，将来可能会被弃用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/arrow-notation.html>Arrow Notation</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：箭头表示法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=bifunctors><font>Bifunctors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>双函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Bifunctors are a generalization of functors to include types parameterized by two parameters and include two map functions for each parameter.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双函子是函子的概括，包括由两个参数参数化的类型，并为每个参数包括两个映射函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Bifunctor</span> p <span class=kw>where</span>
<span class=ot>  bimap ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> (c <span class=ot>-&gt;</span> d) <span class=ot>-&gt;</span> p a c <span class=ot>-&gt;</span> p b d
<span class=ot>  first ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> p a c <span class=ot>-&gt;</span> p b c
<span class=ot>  second ::</span> (b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> p a b <span class=ot>-&gt;</span> p a c</code></pre></div>
<p><font>The bifunctor laws are a natural generalization of the usual functor. Namely they respect identities and composition in the usual way:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双函子定律是通常函子的自然推广。也就是说，他们以通常的方式尊重身份和组成：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">bimap id id ≡ id
first id ≡ id
second id ≡ id</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">bimap f g ≡ first f <span class=fu>.</span> second g</code></pre></div>
<p><font>The canonical example is for 2-tuples.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>典型示例是针对 2 元组的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> first (<span class=fu>+</span><span class=dv>1</span>) (<span class=dv>1</span>,<span class=dv>2</span>)
(<span class=dv>2</span>,<span class=dv>2</span>)
λ<span class=fu>:</span> second (<span class=fu>+</span><span class=dv>1</span>) (<span class=dv>1</span>,<span class=dv>2</span>)
(<span class=dv>1</span>,<span class=dv>3</span>)
λ<span class=fu>:</span> bimap (<span class=fu>+</span><span class=dv>1</span>) (<span class=fu>+</span><span class=dv>1</span>) (<span class=dv>1</span>,<span class=dv>2</span>)
(<span class=dv>2</span>,<span class=dv>3</span>)

λ<span class=fu>:</span> first (<span class=fu>+</span><span class=dv>1</span>) (<span class=dt>Left</span> <span class=dv>3</span>)
<span class=dt>Left</span> <span class=dv>4</span>
λ<span class=fu>:</span> second (<span class=fu>+</span><span class=dv>1</span>) (<span class=dt>Left</span> <span class=dv>3</span>)
<span class=dt>Left</span> <span class=dv>3</span>
λ<span class=fu>:</span> second (<span class=fu>+</span><span class=dv>1</span>) (<span class=dt>Right</span> <span class=dv>3</span>)
<span class=dt>Right</span> <span class=dv>4</span></code></pre></div>
<h2 id=polyvariadic-functions><font>Polyvariadic Functions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多元函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>One surprising application of typeclasses is the ability to construct functions which take an arbitrary number of arguments by defining instances over function types. The arguments may be of arbitrary type, but the resulting collected arguments must either converted into a single type or unpacked into a sum type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型类的一个令人惊讶的应用是能够通过在函数类型上定义实例来构造接受任意数量参数的函数。参数可以是任意类型，但生成的收集参数必须转换为单一类型或解压缩为总和类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/08-applicatives/variadic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>

<span class=kw>class</span> <span class=dt>Arg</span> a <span class=kw>where</span>
<span class=ot>  collect' ::</span> [<span class=dt>String</span>] <span class=ot>-&gt;</span> a

<span class=co>-- extract to IO</span>
<span class=kw>instance</span> <span class=dt>Arg</span> (<span class=dt>IO</span> ()) <span class=kw>where</span>
  collect' acc <span class=fu>=</span> mapM_ putStrLn acc

<span class=co>-- extract to [String]</span>
<span class=kw>instance</span> <span class=dt>Arg</span> [<span class=dt>String</span>] <span class=kw>where</span>
  collect' acc <span class=fu>=</span> acc

<span class=kw>instance</span> (<span class=dt>Show</span> a, <span class=dt>Arg</span> r) <span class=ot>=&gt;</span> <span class=dt>Arg</span> (a <span class=ot>-&gt;</span> r) <span class=kw>where</span>
  collect' acc <span class=fu>=</span> \x <span class=ot>-&gt;</span> collect' (acc <span class=fu>++</span> [show x])

<span class=ot>collect ::</span> <span class=dt>Arg</span> t <span class=ot>=&gt;</span> t
collect <span class=fu>=</span> collect' []

<span class=ot>example1 ::</span> [<span class=dt>String</span>]
example1 <span class=fu>=</span> collect <span class=ch>'a'</span> <span class=dv>2</span> <span class=fl>3.0</span>

<span class=ot>example2 ::</span> <span class=dt>IO</span> ()
example2 <span class=fu>=</span> collect () <span class=st>"foo"</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]</code></pre></div>
<p><font>See: </font><a href=http://okmij.org/ftp/Haskell/polyvariadic.html>Polyvariadic functions</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：多元函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h1 id=error-handling><font>Error Handling</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>错误处理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=control.exception><font>Control.Exception</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>控制异常</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The low-level (and most dangerous) way to handle errors is to use the </font><code>throw</code><font> and </font><code>catch</code><font> functions which allow us to throw extensible exceptions in pure code but catch the resulting exception within IO. Of specific note is that return value of the </font><code>throw</code><font> inhabits all types. There's no reason to use this for custom code that doesn't use low-level system operations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>处理错误的低级（也是最危险的）方法是使用 throw 和 catch 函数，它们允许我们在纯代码中抛出可扩展的异常，但在 IO 中捕获由此产生的异常。特别要注意的是，throw 的返回值适用于所有类型。没有理由将它用于不使用低级系统操作的自定义代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>throw ::</span> <span class=dt>Exception</span> e <span class=ot>=&gt;</span> e <span class=ot>-&gt;</span> a
catch<span class=ot> ::</span> <span class=dt>Exception</span> e <span class=ot>=&gt;</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> (e <span class=ot>-&gt;</span> <span class=dt>IO</span> a) <span class=ot>-&gt;</span> <span class=dt>IO</span> a
<span class=ot>try ::</span> <span class=dt>Exception</span> e <span class=ot>=&gt;</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Either</span> e a)
<span class=ot>evaluate ::</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a</code></pre></div>
<div class=sourceCode include=src/09-errors/ioexception.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Data.Typeable</span>
<span class=kw>import </span><span class=dt>Control.Exception</span>

<span class=kw>data</span> <span class=dt>MyException</span> <span class=fu>=</span> <span class=dt>MyException</span>
    <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Typeable</span>)

<span class=kw>instance</span> <span class=dt>Exception</span> <span class=dt>MyException</span>

<span class=ot>evil ::</span> [<span class=dt>Int</span>]
evil <span class=fu>=</span> [throw <span class=dt>MyException</span>]

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> head evil

<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> length evil

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> try (evaluate example1)<span class=ot> ::</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>MyException</span> <span class=dt>Int</span>)
  print a

  b <span class=ot>&lt;-</span> try (return example2)<span class=ot> ::</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>MyException</span> <span class=dt>Int</span>)
  print b</code></pre></div>
<p><font>Because a value will not be evaluated unless needed, if one desires to know for sure that an exception is either caught or not it can be deeply forced into head normal form before invoking catch. The </font><code>strictCatch</code><font> is not provided by standard library but has a simple implementation in terms of </font><code>deepseq</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因为除非需要，否则不会评估一个值，如果想要确定异常是否被捕获，则可以在调用 catch 之前将其强制转换为 head 范式。 strictCatch 不是由标准库提供的，但在 deepseq 方面有一个简单的实现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>strictCatch ::</span> (<span class=dt>NFData</span> a, <span class=dt>Exception</span> e) <span class=ot>=&gt;</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> (e <span class=ot>-&gt;</span> <span class=dt>IO</span> a) <span class=ot>-&gt;</span> <span class=dt>IO</span> a
strictCatch <span class=fu>=</span> catch <span class=fu>.</span> (toNF <span class=fu>=&lt;&lt;</span>)</code></pre></div>
<h2 id=exceptions><font>Exceptions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>例外情况</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The problem with the previous approach is having to rely on GHC's asynchronous exception handling inside of IO to handle basic operations. The </font><code>exceptions</code><font> provides the same API as </font><code>Control.Exception</code><font> but loosens the dependency on IO.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>先前方法的问题是必须依赖 GHC 在 IO 内部的异步异常处理来处理基本操作。异常提供与 Control.Exception 相同的 API，但放松了对 IO 的依赖。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/09-errors/exceptions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Data.Typeable</span>
<span class=kw>import </span><span class=dt>Control.Monad.Catch</span>
<span class=kw>import </span><span class=dt>Control.Monad.Identity</span>

<span class=kw>data</span> <span class=dt>MyException</span> <span class=fu>=</span> <span class=dt>MyException</span>
    <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Typeable</span>)

<span class=kw>instance</span> <span class=dt>Exception</span> <span class=dt>MyException</span>

<span class=ot>example ::</span> <span class=dt>MonadCatch</span> m <span class=ot>=&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> m <span class=dt>Int</span>
example x y <span class=fu>|</span> y <span class=fu>==</span> <span class=dv>0</span> <span class=fu>=</span> throwM <span class=dt>MyException</span>
            <span class=fu>|</span> otherwise <span class=fu>=</span> return <span class=fu>$</span> x <span class=ot>`div`</span> y

<span class=ot>pure ::</span> <span class=dt>MonadCatch</span> m <span class=ot>=&gt;</span> m (<span class=dt>Either</span> <span class=dt>MyException</span> <span class=dt>Int</span>)
pure <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> try (example <span class=dv>1</span> <span class=dv>2</span>)
  b <span class=ot>&lt;-</span> try (example <span class=dv>1</span> <span class=dv>0</span>)
  return (a <span class=fu>&gt;&gt;</span> b)</code></pre></div>
<p><font>See: </font><a href=http://hackage.haskell.org/package/exceptions>exceptions</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：异常</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=exceptt><font>ExceptT</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>除了T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>As of mtl 2.2 or higher, the </font><code>ErrorT</code><font> class has been replaced by the </font><code>ExceptT</code><font>. At transformers level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 mtl 2.2 或更高版本开始，ErrorT 类已被 ExceptT 取代。在变压器级别。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>ExceptT</span> e m a <span class=fu>=</span> <span class=dt>ExceptT</span> (m (<span class=dt>Either</span> e a))

<span class=ot>runExceptT ::</span> <span class=dt>ExceptT</span> e m a <span class=ot>-&gt;</span> m (<span class=dt>Either</span> e a)
runExceptT (<span class=dt>ExceptT</span> m) <span class=fu>=</span> m

<span class=kw>instance</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>Monad</span> (<span class=dt>ExceptT</span> e m) <span class=kw>where</span>
    return a <span class=fu>=</span> <span class=dt>ExceptT</span> <span class=fu>$</span> return (<span class=dt>Right</span> a)
    m <span class=fu>&gt;&gt;=</span> k <span class=fu>=</span> <span class=dt>ExceptT</span> <span class=fu>$</span> <span class=kw>do</span>
        a <span class=ot>&lt;-</span> runExceptT m
        <span class=kw>case</span> a <span class=kw>of</span>
            <span class=dt>Left</span> e <span class=ot>-&gt;</span> return (<span class=dt>Left</span> e)
            <span class=dt>Right</span> x <span class=ot>-&gt;</span> runExceptT (k x)
    fail <span class=fu>=</span> <span class=dt>ExceptT</span> <span class=fu>.</span> fail

<span class=ot>throwE ::</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> e <span class=ot>-&gt;</span> <span class=dt>ExceptT</span> e m a
throwE <span class=fu>=</span> <span class=dt>ExceptT</span> <span class=fu>.</span> return <span class=fu>.</span> <span class=dt>Left</span>

<span class=ot>catchE ::</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span>
    <span class=dt>ExceptT</span> e m a               <span class=co>-- ^ the inner computation</span>
    <span class=ot>-&gt;</span> (e <span class=ot>-&gt;</span> <span class=dt>ExceptT</span> e' m a)    <span class=co>-- ^ a handler for exceptions in the inner</span>
                                <span class=co>-- computation</span>
    <span class=ot>-&gt;</span> <span class=dt>ExceptT</span> e' m a
m <span class=ot>`catchE`</span> h <span class=fu>=</span> <span class=dt>ExceptT</span> <span class=fu>$</span> <span class=kw>do</span>
    a <span class=ot>&lt;-</span> runExceptT m
    <span class=kw>case</span> a <span class=kw>of</span>
        <span class=dt>Left</span>  l <span class=ot>-&gt;</span> runExceptT (h l)
        <span class=dt>Right</span> r <span class=ot>-&gt;</span> return (<span class=dt>Right</span> r)</code></pre></div>
<p><font>Using mtl:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 mtl：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>MonadTrans</span> (<span class=dt>ExceptT</span> e) <span class=kw>where</span>
    lift <span class=fu>=</span> <span class=dt>ExceptT</span> <span class=fu>.</span> liftM <span class=dt>Right</span>

<span class=kw>class</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>MonadError</span> e m <span class=fu>|</span> m <span class=ot>-&gt;</span> e <span class=kw>where</span>
<span class=ot>    throwError ::</span> e <span class=ot>-&gt;</span> m a
<span class=ot>    catchError ::</span> m a <span class=ot>-&gt;</span> (e <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> m a

<span class=kw>instance</span> <span class=dt>MonadError</span> <span class=dt>IOException</span> <span class=dt>IO</span> <span class=kw>where</span>
    throwError <span class=fu>=</span> ioError
    catchError <span class=fu>=</span> catch

<span class=kw>instance</span> <span class=dt>MonadError</span> e (<span class=dt>Either</span> e) <span class=kw>where</span>
    throwError             <span class=fu>=</span> <span class=dt>Left</span>
    <span class=dt>Left</span>  l <span class=ot>`catchError`</span> h <span class=fu>=</span> h l
    <span class=dt>Right</span> r <span class=ot>`catchError`</span> _ <span class=fu>=</span> <span class=dt>Right</span> r</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html>Control.Monad.Except<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>控制.Monad.Except</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=spoon><font>spoon</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>勺子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Sometimes you'll be forced to deal with seemingly pure functions that can throw up at any point. There are many functions in the standard library like this, and many more on Hackage. You'd like to be handle this logic purely as if it were returning a proper </font><code>Maybe a</code><font> but to catch the logic you'd need to install a IO handler inside IO to catch it. Spoon allows us to safely (and "purely", although it uses a referentially transparent invocation of unsafePerformIO) to catch these exceptions and put them in Maybe where they belong.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有时，您将被迫处理看似纯函数，但它们随时都可能抛出。像这样的函数在标准库里有很多，Hackage上还有很多。您希望纯粹地处理此逻辑，就好像它正在返回一个正确的 Maybe a 但要捕获您需要在 IO 中安装 IO 处理程序以捕获它的逻辑。 Spoon 允许我们安全地（并且“纯粹地”，尽管它使用对 unsafePerformIO 的引用透明调用）捕获这些异常并将它们放在它们所属的 Maybe 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><code>spoon</code><font> function evaluates its argument to head normal form, while </font><code>teaspoon</code><font> evaluates to </font><a href=#seq-and-whnf>weak head normal form</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>spoon 函数将其参数评估为头部范式，而 teaspoon 函数评估为弱头部范式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/09-errors/spoon.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Spoon</span>

<span class=ot>goBoom ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
goBoom x y <span class=fu>=</span> x <span class=ot>`div`</span> y

<span class=co>-- evaluate to normal form</span>
<span class=ot>test1 ::</span> <span class=dt>Maybe</span> [<span class=dt>Int</span>]
test1 <span class=fu>=</span> spoon [<span class=dv>1</span>, <span class=dv>2</span>, undefined]

<span class=co>-- evaluate to weak head normal form</span>
<span class=ot>test2 ::</span> <span class=dt>Maybe</span> [<span class=dt>Int</span>]
test2 <span class=fu>=</span> teaspoon [<span class=dv>1</span>, <span class=dv>2</span>, undefined]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  maybe (putStrLn <span class=st>"Nothing"</span>) (print <span class=fu>.</span> length) test1
  maybe (putStrLn <span class=st>"Nothing"</span>) (print <span class=fu>.</span> length) test2</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://hackage.haskell.org/package/spoon>Spoon<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>勺子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=safe-exceptions><font>safe-exceptions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全异常</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>TODO</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>去做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h1 id=advanced-monads><font>Advanced Monads</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高级单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=function-monad><font>Function Monad</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>函数单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>If one writes Haskell long enough one might eventually encounter the curious beast that is the </font><code>((-&gt;) r)</code><font> monad instance. It generally tends to be non-intuitive to work with, but is quite simple when one considers it as an unwrapped Reader monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果一个人编写 Haskell 的时间足够长，那么他最终可能会遇到奇怪的野兽，即 ((-&gt;) r) monad 实例。它通常使用起来不直观，但当将其视为未包装的 Reader monad 时，它非常简单。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Functor</span> ((<span class=ot>-&gt;</span>) r) <span class=kw>where</span>
  fmap <span class=fu>=</span> (<span class=fu>.</span>)

<span class=kw>instance</span> <span class=dt>Monad</span> ((<span class=ot>-&gt;</span>) r) <span class=kw>where</span>
  return <span class=fu>=</span> const
  f <span class=fu>&gt;&gt;=</span> k <span class=fu>=</span> \r <span class=ot>-&gt;</span> k (f r) r</code></pre></div>
<p><font>This just uses a prefix form of the arrow type operator.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这只是使用了箭头类型运算符的前缀形式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/function.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>

<span class=ot>id' ::</span> (<span class=ot>-&gt;</span>) a a
id' <span class=fu>=</span> id

<span class=ot>const' ::</span> (<span class=ot>-&gt;</span>) a ((<span class=ot>-&gt;</span>) b a)
const' <span class=fu>=</span> const

<span class=co>-- Monad m =&gt; a -&gt; m a</span>
<span class=ot>fret ::</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a
fret <span class=fu>=</span> return

<span class=co>-- Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span>
<span class=ot>fbind ::</span> (r <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> b)) <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> b)
fbind f k <span class=fu>=</span> f <span class=fu>&gt;&gt;=</span> k

<span class=co>-- Monad m =&gt; m (m a) -&gt; m a</span>
<span class=ot>fjoin ::</span> (r <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> a)) <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> a)
fjoin <span class=fu>=</span> join

<span class=ot>fid ::</span> a <span class=ot>-&gt;</span> a
fid <span class=fu>=</span> const <span class=fu>&gt;&gt;=</span> id

<span class=co>-- Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span>
<span class=ot>fcompose ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> b)
fcompose <span class=fu>=</span> (<span class=fu>.</span>)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>Reader</span> r <span class=fu>=</span> (<span class=ot>-&gt;</span>) r <span class=co>-- pseudocode</span>

<span class=kw>instance</span> <span class=dt>Monad</span> (<span class=dt>Reader</span> r) <span class=kw>where</span>
  return a <span class=fu>=</span> \_ <span class=ot>-&gt;</span> a
  f <span class=fu>&gt;&gt;=</span> k <span class=fu>=</span> \r <span class=ot>-&gt;</span> k (f r) r

<span class=ot>ask' ::</span> r <span class=ot>-&gt;</span> r
ask' <span class=fu>=</span> id

<span class=ot>asks' ::</span> (r <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (r <span class=ot>-&gt;</span> a)
asks' f <span class=fu>=</span> id <span class=fu>.</span> f

<span class=ot>runReader' ::</span> (r <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> a
runReader' <span class=fu>=</span> id</code></pre></div>
<h2 id=rws-monad><font>RWS Monad</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>RWS Monad</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The RWS monad combines the functionality of the three monads discussed above, the </font><strong>R</strong><font>eader, </font><strong>W</strong><font>riter, and </font><strong>S</strong><font>tate. There is also a </font><code>RWST</code><font> transformer.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>RWS monad 结合了上面讨论的三个 monad 的功能，Reader、Writer 和 State。还有一个 RWST 变压器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runReader ::</span> <span class=dt>Reader</span> r a <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> a
<span class=ot>runWriter ::</span> <span class=dt>Writer</span> w a <span class=ot>-&gt;</span> (a, w)
<span class=ot>runState  ::</span> <span class=dt>State</span> s a <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> (a, s)</code></pre></div>
<p><font>These three eval functions are now combined into the following functions:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这三个 eval 函数现在组合成以下函数：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runRWS  ::</span> <span class=dt>RWS</span> r w s a <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> (a, s, w)
<span class=ot>execRWS ::</span> <span class=dt>RWS</span> r w s a <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> (s, w)
<span class=ot>evalRWS ::</span> <span class=dt>RWS</span> r w s a <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> s <span class=ot>-&gt;</span> (a, w)</code></pre></div>
<div class=sourceCode include=src/10-advanced-monads/rws.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.RWS</span>

<span class=kw>type</span> <span class=dt>R</span> <span class=fu>=</span> <span class=dt>Int</span>
<span class=kw>type</span> <span class=dt>W</span> <span class=fu>=</span> [<span class=dt>Int</span>]
<span class=kw>type</span> <span class=dt>S</span> <span class=fu>=</span> <span class=dt>Int</span>

<span class=ot>computation ::</span> <span class=dt>RWS</span> <span class=dt>R</span> <span class=dt>W</span> <span class=dt>S</span> ()
computation <span class=fu>=</span> <span class=kw>do</span>
  e <span class=ot>&lt;-</span> ask
  a <span class=ot>&lt;-</span> get
  <span class=kw>let</span> b <span class=fu>=</span> a <span class=fu>+</span> e
  put b
  tell [b]

example <span class=fu>=</span> runRWS computation <span class=dv>2</span> <span class=dv>3</span></code></pre></div>
<p><font>The usual caveat about Writer laziness also applies to RWS.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通常关于 Writer 懒惰的警告也适用于 RWS。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=cont><font>Cont</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>续</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runCont ::</span> <span class=dt>Cont</span> r a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> r
<span class=ot>callCC ::</span> <span class=dt>MonadCont</span> m <span class=ot>=&gt;</span> ((a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> m a
<span class=ot>cont ::</span> ((a <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> <span class=dt>Cont</span> r a</code></pre></div>
<p><font>In continuation passing style, composite computations are built up from sequences of nested computations which are terminated by a final continuation which yields the result of the full computation by passing a function into the continuation chain.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在延续传递样式中，复合计算由嵌套计算序列构建，这些计算由最终延续终止，最终延续通过将函数传递到延续链中来产生完整计算的结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>add ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
add x y <span class=fu>=</span> x <span class=fu>+</span> y

<span class=ot>add ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> (<span class=dt>Int</span> <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> r
add x y k <span class=fu>=</span> k (x <span class=fu>+</span> y)</code></pre></div>
<div class=sourceCode include=src/10-advanced-monads/cont.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.Cont</span>

<span class=ot>add ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Cont</span> k <span class=dt>Int</span>
add x y <span class=fu>=</span> return <span class=fu>$</span> x <span class=fu>+</span> y

<span class=ot>mult ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Cont</span> k <span class=dt>Int</span>
mult x y <span class=fu>=</span> return <span class=fu>$</span> x <span class=fu>*</span> y

<span class=ot>contt ::</span> <span class=dt>ContT</span> () <span class=dt>IO</span> ()
contt <span class=fu>=</span> <span class=kw>do</span>
    k <span class=ot>&lt;-</span> <span class=kw>do</span>
      callCC <span class=fu>$</span> \exit <span class=ot>-&gt;</span> <span class=kw>do</span>
        lift <span class=fu>$</span> putStrLn <span class=st>"Entry"</span>
        exit <span class=fu>$</span> \_ <span class=ot>-&gt;</span> <span class=kw>do</span>
          putStrLn <span class=st>"Exit"</span>
    lift <span class=fu>$</span> putStrLn <span class=st>"Inside"</span>
    lift <span class=fu>$</span> k ()

<span class=ot>callcc ::</span> <span class=dt>Cont</span> <span class=dt>String</span> <span class=dt>Integer</span>
callcc <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> return <span class=dv>1</span>
  b <span class=ot>&lt;-</span> callCC (\k <span class=ot>-&gt;</span> k <span class=dv>2</span>)
  return <span class=fu>$</span> a<span class=fu>+</span>b

<span class=ot>ex1 ::</span> <span class=dt>IO</span> ()
ex1 <span class=fu>=</span> print <span class=fu>$</span> runCont (f <span class=fu>&gt;&gt;=</span> g) id
  <span class=kw>where</span>
    f <span class=fu>=</span> add <span class=dv>1</span> <span class=dv>2</span>
    g <span class=fu>=</span> mult <span class=dv>3</span>
<span class=co>-- 9</span>

<span class=ot>ex2 ::</span> <span class=dt>IO</span> ()
ex2 <span class=fu>=</span> print <span class=fu>$</span> runCont callcc show
<span class=co>-- "3"</span>

<span class=ot>ex3 ::</span> <span class=dt>IO</span> ()
ex3 <span class=fu>=</span> runContT contt print
<span class=co>-- Entry</span>
<span class=co>-- Inside</span>
<span class=co>-- Exit</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  ex1
  ex2
  ex3</code></pre></div>
<div class=sourceCode include=src/10-advanced-monads/cont_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Cont</span> r a <span class=fu>=</span> <span class=dt>Cont</span> {<span class=ot> runCont ::</span> ((a <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> r) }

<span class=kw>instance</span> <span class=dt>Monad</span> (<span class=dt>Cont</span> r) <span class=kw>where</span>
  return a       <span class=fu>=</span> <span class=dt>Cont</span> <span class=fu>$</span> \k <span class=ot>-&gt;</span> k a
  (<span class=dt>Cont</span> c) <span class=fu>&gt;&gt;=</span> f <span class=fu>=</span> <span class=dt>Cont</span> <span class=fu>$</span> \k <span class=ot>-&gt;</span> c (\a <span class=ot>-&gt;</span> runCont (f a) k)

<span class=kw>class</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>MonadCont</span> m <span class=kw>where</span>
<span class=ot>  callCC ::</span> ((a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> m a

<span class=kw>instance</span> <span class=dt>MonadCont</span> (<span class=dt>Cont</span> r) <span class=kw>where</span>
  callCC f <span class=fu>=</span> <span class=dt>Cont</span> <span class=fu>$</span> \k <span class=ot>-&gt;</span> runCont (f (\a <span class=ot>-&gt;</span> <span class=dt>Cont</span> <span class=fu>$</span> \_ <span class=ot>-&gt;</span> k a)) k</code></pre></div>
<ul>
<li><a href=http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style>Wikibooks: Continuation Passing Style<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>维基教科书：延续传递风格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://wiki.haskell.org/MonadCont_under_the_hood>MonadCont Under the Hood<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>引擎盖下的 MonadCont</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=monadplus><font>MonadPlus</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MonadPlus</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Choice and failure.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>选择与失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>MonadPlus</span> m <span class=kw>where</span>
<span class=ot>   mzero ::</span> m a
<span class=ot>   mplus ::</span> m a <span class=ot>-&gt;</span> m a <span class=ot>-&gt;</span> m a

<span class=kw>instance</span> <span class=dt>MonadPlus</span> [] <span class=kw>where</span>
   mzero <span class=fu>=</span> []
   mplus <span class=fu>=</span> (<span class=fu>++</span>)

<span class=kw>instance</span> <span class=dt>MonadPlus</span> <span class=dt>Maybe</span> <span class=kw>where</span>
   mzero <span class=fu>=</span> <span class=dt>Nothing</span>

   <span class=dt>Nothing</span> <span class=ot>`mplus`</span> ys  <span class=fu>=</span> ys
   xs      <span class=ot>`mplus`</span> _ys <span class=fu>=</span> xs</code></pre></div>
<p><font>MonadPlus forms a monoid with</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>MonadPlus 形成一个幺半群</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">mzero <span class=ot>`mplus`</span> a <span class=fu>=</span> a
a <span class=ot>`mplus`</span> mzero <span class=fu>=</span> a
(a <span class=ot>`mplus`</span> b) <span class=ot>`mplus`</span> c <span class=fu>=</span> a <span class=ot>`mplus`</span> (b <span class=ot>`mplus`</span> c)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>when ::</span> (<span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>Bool</span> <span class=ot>-&gt;</span> m () <span class=ot>-&gt;</span> m ()
when p s <span class=fu>=</span>  <span class=kw>if</span> p <span class=kw>then</span> s <span class=kw>else</span> return ()

<span class=ot>guard ::</span> <span class=dt>MonadPlus</span> m <span class=ot>=&gt;</span> <span class=dt>Bool</span> <span class=ot>-&gt;</span> m ()
guard <span class=dt>True</span>  <span class=fu>=</span> return ()
guard <span class=dt>False</span> <span class=fu>=</span> mzero

<span class=ot>msum ::</span> <span class=dt>MonadPlus</span> m <span class=ot>=&gt;</span> [m a] <span class=ot>-&gt;</span> m a
msum <span class=fu>=</span>  foldr mplus mzero</code></pre></div>
<div class=sourceCode include=src/10-advanced-monads/monadplus.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Safe</span>
<span class=kw>import </span><span class=dt>Control.Monad</span>

<span class=ot>list1 ::</span> [(<span class=dt>Int</span>,<span class=dt>Int</span>)]
list1 <span class=fu>=</span> [(a,b) <span class=fu>|</span> a <span class=ot>&lt;-</span> [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>], b <span class=ot>&lt;-</span> [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>], a <span class=fu>&lt;</span> b]

<span class=ot>list2 ::</span> [(<span class=dt>Int</span>,<span class=dt>Int</span>)]
list2 <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>]
  b <span class=ot>&lt;-</span> [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>]
  guard (a <span class=fu>&lt;</span> b)
  return <span class=fu>$</span> (a,b)

<span class=ot>maybe1 ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Double</span>
maybe1 a b <span class=fu>=</span> <span class=kw>do</span>
  a' <span class=ot>&lt;-</span> readMay a
  b' <span class=ot>&lt;-</span> readMay b
  guard (b' <span class=fu>/=</span> <span class=fl>0.0</span>)
  return <span class=fu>$</span> a'<span class=fu>/</span>b'

<span class=ot>maybe2 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
maybe2 <span class=fu>=</span> msum [<span class=dt>Nothing</span>, <span class=dt>Nothing</span>, <span class=dt>Just</span> <span class=dv>3</span>, <span class=dt>Just</span> <span class=dv>4</span>]</code></pre></div>
<div class=sourceCode include=src/10-advanced-monads/logict.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>

range<span class=ot> ::</span> <span class=dt>MonadPlus</span> m <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> m a
range [] <span class=fu>=</span> mzero
range (x<span class=fu>:</span>xs) <span class=fu>=</span> range xs <span class=ot>`mplus`</span> return x

<span class=ot>pyth ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> [(<span class=dt>Integer</span>,<span class=dt>Integer</span>,<span class=dt>Integer</span>)]
pyth n <span class=fu>=</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> range [<span class=dv>1</span><span class=fu>..</span>n]
  y <span class=ot>&lt;-</span> range [<span class=dv>1</span><span class=fu>..</span>n]
  z <span class=ot>&lt;-</span> range [<span class=dv>1</span><span class=fu>..</span>n]
  <span class=kw>if</span> x<span class=fu>*</span>x <span class=fu>+</span> y<span class=fu>*</span>y <span class=fu>==</span> z<span class=fu>*</span>z <span class=kw>then</span> return (x,y,z) <span class=kw>else</span> mzero

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> print <span class=fu>$</span> pyth <span class=dv>15</span>
<span class=co>{-</span>
<span class=co>[ ( 12 , 9 , 15 )</span>
<span class=co>, ( 12 , 5 , 13 )</span>
<span class=co>, ( 9 , 12 , 15 )</span>
<span class=co>, ( 8 , 6 , 10 )</span>
<span class=co>, ( 6 , 8 , 10 )</span>
<span class=co>, ( 5 , 12 , 13 )</span>
<span class=co>, ( 4 , 3 , 5 )</span>
<span class=co>, ( 3 , 4 , 5 )</span>
<span class=co>]</span>
<span class=co>-}</span></code></pre></div>
<h2 id=monadfix><font>MonadFix</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>MonadFix</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The fixed point of a monadic computation. </font><code>mfix f</code><font> executes the action </font><code>f</code><font> only once, with the eventual output fed back as the input.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一元计算的固定点。 mfix f 只执行动作 f 一次，最终输出作为输入反馈。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>fix ::</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a
fix f <span class=fu>=</span> <span class=kw>let</span> x <span class=fu>=</span> f x <span class=kw>in</span> x

<span class=ot>mfix ::</span> (a <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> m a</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>MonadFix</span> m <span class=kw>where</span>
<span class=ot>   mfix ::</span> (a <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> m a

<span class=kw>instance</span> <span class=dt>MonadFix</span> <span class=dt>Maybe</span> <span class=kw>where</span>
   mfix f <span class=fu>=</span> <span class=kw>let</span> a <span class=fu>=</span> f (unJust a) <span class=kw>in</span> a
            <span class=kw>where</span> unJust (<span class=dt>Just</span> x) <span class=fu>=</span> x
                  unJust <span class=dt>Nothing</span>  <span class=fu>=</span> error <span class=st>"mfix Maybe: Nothing"</span></code></pre></div>
<p><font>The regular do-notation can also be extended with </font><code>-XRecursiveDo</code><font> to accommodate recursive monadic bindings.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>还可以使用 -XRecursiveDo 扩展常规 do-notation 以适应递归单子绑定。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/monadfix.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RecursiveDo #-}</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import </span><span class=dt>Control.Monad.Fix</span>

<span class=ot>stream1 ::</span> <span class=dt>Maybe</span> [<span class=dt>Int</span>]
stream1 <span class=fu>=</span> <span class=kw>do</span>
  rec xs <span class=ot>&lt;-</span> <span class=dt>Just</span> (<span class=dv>1</span><span class=fu>:</span>xs)
  return (map negate xs)

<span class=ot>stream2 ::</span> <span class=dt>Maybe</span> [<span class=dt>Int</span>]
stream2 <span class=fu>=</span> mfix <span class=fu>$</span> \xs <span class=ot>-&gt;</span> <span class=kw>do</span>
  xs' <span class=ot>&lt;-</span> <span class=dt>Just</span> (<span class=dv>1</span><span class=fu>:</span>xs)
  return (map negate xs')</code></pre></div>
<h2 id=st-monad><font>ST Monad</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>圣莫纳德</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The ST monad models "threads" of stateful computations which can manipulate mutable references but are restricted to only return pure values when evaluated and are statically confined to the ST monad of a </font><code>s</code><font> thread.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ST monad 为有状态计算的“线程”建模，这些线程可以操作可变引用，但仅限于在评估时仅返回纯值，并且静态地限制在 s 线程的 ST monad 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runST ::</span> (forall s<span class=fu>.</span> <span class=dt>ST</span> s a) <span class=ot>-&gt;</span> a
<span class=ot>newSTRef ::</span> a <span class=ot>-&gt;</span> <span class=dt>ST</span> s (<span class=dt>STRef</span> s a)
<span class=ot>readSTRef ::</span> <span class=dt>STRef</span> s a <span class=ot>-&gt;</span> <span class=dt>ST</span> s a
<span class=ot>writeSTRef ::</span> <span class=dt>STRef</span> s a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>ST</span> s ()</code></pre></div>
<div class=sourceCode include=src/10-advanced-monads/st.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.STRef</span>
<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.ST</span>
<span class=kw>import </span><span class=dt>Control.Monad.State.Strict</span>

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> runST <span class=fu>$</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> newSTRef <span class=dv>0</span>

  forM_ [<span class=dv>1</span><span class=fu>..</span><span class=dv>1000</span>] <span class=fu>$</span> \j <span class=ot>-&gt;</span> <span class=kw>do</span>
    writeSTRef x j

  readSTRef x

<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> runST <span class=fu>$</span> <span class=kw>do</span>
  count <span class=ot>&lt;-</span> newSTRef <span class=dv>0</span>
  replicateM_ (<span class=dv>10</span><span class=fu>^</span><span class=dv>6</span>) <span class=fu>$</span> modifySTRef' count (<span class=fu>+</span><span class=dv>1</span>)
  readSTRef count

<span class=ot>example3 ::</span> <span class=dt>Int</span>
example3 <span class=fu>=</span> flip evalState <span class=dv>0</span> <span class=fu>$</span> <span class=kw>do</span>
  replicateM_ (<span class=dv>10</span><span class=fu>^</span><span class=dv>6</span>) <span class=fu>$</span> modify' (<span class=fu>+</span><span class=dv>1</span>)
  get

<span class=ot>modify' ::</span> <span class=dt>MonadState</span> a m <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> m ()
modify' f <span class=fu>=</span> get <span class=fu>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span> put <span class=fu>$!</span> f x)</code></pre></div>
<p><font>Using the ST monad we can create a class of efficient purely functional data structures that use mutable references in a referentially transparent way.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 ST monad，我们可以创建一类高效的纯函数式数据结构，它们以引用透明的方式使用可变引用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=free-monads><font>Free Monads</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>免费单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Pure</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Free</span> f a
<span class=dt>Free</span><span class=ot> ::</span> f (<span class=dt>Free</span> f a) <span class=ot>-&gt;</span> <span class=dt>Free</span> f a

<span class=ot>liftF ::</span> (<span class=dt>Functor</span> f, <span class=dt>MonadFree</span> f m) <span class=ot>=&gt;</span> f a <span class=ot>-&gt;</span> m a
<span class=ot>retract ::</span> <span class=dt>Monad</span> f <span class=ot>=&gt;</span> <span class=dt>Free</span> f a <span class=ot>-&gt;</span> f a</code></pre></div>
<p><font>Free monads are monads which instead of having a </font><code>join</code><font> operation that combines computations, instead forms composite computations from application of a functor.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自由 monad 是 monad，它没有结合计算的连接操作，而是从仿函数的应用中形成复合计算。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>join ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> m (m a) <span class=ot>-&gt;</span> m a
<span class=ot>wrap ::</span> <span class=dt>MonadFree</span> f m <span class=ot>=&gt;</span> f (m a) <span class=ot>-&gt;</span> m a</code></pre></div>
<p><font>One of the best examples is the Partiality monad which models computations which can diverge. Haskell allows unbounded recursion, but for example we can create a free monad from the </font><code>Maybe</code><font> functor which can be used to fix the call-depth of, for example the </font><a href=https://smunix.github.io/en.wikipedia.org/wiki/Ackermann_function.html>Ackermann function</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最好的例子之一是 Partiality monad，它模拟可以发散的计算。 Haskell 允许无限递归，但是例如我们可以从 Maybe 仿函数创建一个自由的 monad，它可以用来固定调用深度，例如 Ackermann 函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/partiality.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.Fix</span>
<span class=kw>import </span><span class=dt>Control.Monad.Free</span>

<span class=kw>type</span> <span class=dt>Partiality</span> a <span class=fu>=</span> <span class=dt>Free</span> <span class=dt>Maybe</span> a

<span class=co>-- Non-termination.</span>
<span class=ot>never ::</span> <span class=dt>Partiality</span> a
never <span class=fu>=</span> fix (<span class=dt>Free</span> <span class=fu>.</span> <span class=dt>Just</span>)

<span class=ot>fromMaybe ::</span> <span class=dt>Maybe</span> a <span class=ot>-&gt;</span> <span class=dt>Partiality</span> a
fromMaybe (<span class=dt>Just</span> x) <span class=fu>=</span> <span class=dt>Pure</span> x
fromMaybe <span class=dt>Nothing</span> <span class=fu>=</span> <span class=dt>Free</span> <span class=dt>Nothing</span>

<span class=ot>runPartiality ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Partiality</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
runPartiality <span class=dv>0</span> _ <span class=fu>=</span> <span class=dt>Nothing</span>
runPartiality _ (<span class=dt>Pure</span> a) <span class=fu>=</span> <span class=dt>Just</span> a
runPartiality _ (<span class=dt>Free</span> <span class=dt>Nothing</span>) <span class=fu>=</span> <span class=dt>Nothing</span>
runPartiality n (<span class=dt>Free</span> (<span class=dt>Just</span> a)) <span class=fu>=</span> runPartiality (n<span class=fu>-</span><span class=dv>1</span>) a

<span class=ot>ack ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Partiality</span> <span class=dt>Int</span>
ack <span class=dv>0</span> n <span class=fu>=</span> <span class=dt>Pure</span> <span class=fu>$</span> n <span class=fu>+</span> <span class=dv>1</span>
ack m <span class=dv>0</span> <span class=fu>=</span> <span class=dt>Free</span> <span class=fu>$</span> <span class=dt>Just</span> <span class=fu>$</span> ack (m<span class=fu>-</span><span class=dv>1</span>) <span class=dv>1</span>
ack m n <span class=fu>=</span> <span class=dt>Free</span> <span class=fu>$</span> <span class=dt>Just</span> <span class=fu>$</span> ack m (n<span class=fu>-</span><span class=dv>1</span>) <span class=fu>&gt;&gt;=</span> ack (m<span class=fu>-</span><span class=dv>1</span>)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> diverge <span class=fu>=</span><span class=ot> never ::</span> <span class=dt>Partiality</span> ()
  print <span class=fu>$</span> runPartiality <span class=dv>1000</span> diverge
  print <span class=fu>$</span> runPartiality <span class=dv>1000</span> (ack <span class=dv>3</span> <span class=dv>4</span>)
  print <span class=fu>$</span> runPartiality <span class=dv>5500</span> (ack <span class=dv>3</span> <span class=dv>4</span>)</code></pre></div>
<p><font>The other common use for free monads is to build embedded domain-specific languages to describe computations. We can model a subset of the IO monad by building up a pure description of the computation inside of the IOFree monad and then using the free monad to encode the translation to an effectful IO computation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>免费 monad 的另一个常见用途是构建嵌入式领域特定语言来描述计算。我们可以通过在 IOFree monad 内部建立计算的纯描述，然后使用 free monad 将转换编码为有效的 IO 计算，从而对 IO monad 的子集进行建模。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/free_dsl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveFunctor #-}</span>

<span class=kw>import </span><span class=dt>System.Exit</span>
<span class=kw>import </span><span class=dt>Control.Monad.Free</span>

<span class=kw>data</span> <span class=dt>Interaction</span> x
  <span class=fu>=</span> <span class=dt>Puts</span> <span class=dt>String</span> x
  <span class=fu>|</span> <span class=dt>Gets</span> (<span class=dt>Char</span> <span class=ot>-&gt;</span> x)
  <span class=fu>|</span> <span class=dt>Exit</span>
  <span class=kw>deriving</span> <span class=dt>Functor</span>

<span class=kw>type</span> <span class=dt>IOFree</span> a <span class=fu>=</span> <span class=dt>Free</span> <span class=dt>Interaction</span> a

<span class=ot>puts ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>IOFree</span> ()
puts s <span class=fu>=</span> liftF <span class=fu>$</span> <span class=dt>Puts</span> s ()

<span class=ot>get ::</span> <span class=dt>IOFree</span> <span class=dt>Char</span>
get <span class=fu>=</span> liftF <span class=fu>$</span> <span class=dt>Gets</span> id

<span class=ot>exit ::</span> <span class=dt>IOFree</span> r
exit <span class=fu>=</span> liftF <span class=dt>Exit</span>

<span class=ot>gets ::</span> <span class=dt>IOFree</span> <span class=dt>String</span>
gets <span class=fu>=</span> <span class=kw>do</span>
  c <span class=ot>&lt;-</span> get
  <span class=kw>if</span> c <span class=fu>==</span> <span class=ch>'\n'</span>
    <span class=kw>then</span> return <span class=st>""</span>
    <span class=kw>else</span> gets <span class=fu>&gt;&gt;=</span> \line <span class=ot>-&gt;</span> return (c <span class=fu>:</span> line)

<span class=co>-- Collapse our IOFree DSL into IO monad actions.</span>
<span class=ot>interp ::</span> <span class=dt>IOFree</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a
interp (<span class=dt>Pure</span> r) <span class=fu>=</span> return r
interp (<span class=dt>Free</span> x) <span class=fu>=</span> <span class=kw>case</span> x <span class=kw>of</span>
  <span class=dt>Puts</span> s t <span class=ot>-&gt;</span> putStrLn s <span class=fu>&gt;&gt;</span> interp t
  <span class=dt>Gets</span> f   <span class=ot>-&gt;</span> getChar <span class=fu>&gt;&gt;=</span> interp <span class=fu>.</span> f
  <span class=dt>Exit</span>     <span class=ot>-&gt;</span> exitSuccess

<span class=ot>echo ::</span> <span class=dt>IOFree</span> ()
echo <span class=fu>=</span> <span class=kw>do</span>
  puts <span class=st>"Enter your name:"</span>
  str <span class=ot>&lt;-</span> gets
  puts str
  <span class=kw>if</span> length str <span class=fu>&gt;</span> <span class=dv>10</span>
    <span class=kw>then</span> puts <span class=st>"You have a long name."</span>
    <span class=kw>else</span> puts <span class=st>"You have a short name."</span>
  exit

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> interp echo</code></pre></div>
<p><font>An implementation such as the one found in </font><a href=http://hackage.haskell.org/package/free>free</a><font> might look like the following:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>诸如免费中的实现之类的实现可能如下所示：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/free_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=kw>data</span> <span class=dt>Free</span> f a
  <span class=fu>=</span> <span class=dt>Pure</span> a
  <span class=fu>|</span> <span class=dt>Free</span> (f (<span class=dt>Free</span> f a))

<span class=kw>instance</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Monad</span> (<span class=dt>Free</span> f) <span class=kw>where</span>
  return a     <span class=fu>=</span> <span class=dt>Pure</span> a
  <span class=dt>Pure</span> a <span class=fu>&gt;&gt;=</span> f <span class=fu>=</span> f a
  <span class=dt>Free</span> f <span class=fu>&gt;&gt;=</span> g <span class=fu>=</span> <span class=dt>Free</span> (fmap (<span class=fu>&gt;&gt;=</span> g) f)

<span class=kw>class</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>MonadFree</span> f m  <span class=kw>where</span>
<span class=ot>  wrap ::</span> f (m a) <span class=ot>-&gt;</span> m a

<span class=ot>liftF ::</span> (<span class=dt>Functor</span> f, <span class=dt>MonadFree</span> f m) <span class=ot>=&gt;</span> f a <span class=ot>-&gt;</span> m a
liftF <span class=fu>=</span> wrap <span class=fu>.</span> fmap return

<span class=ot>iter ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (f a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>Free</span> f a <span class=ot>-&gt;</span> a
iter _ (<span class=dt>Pure</span> a) <span class=fu>=</span> a
iter phi (<span class=dt>Free</span> m) <span class=fu>=</span> phi (iter phi <span class=fu>&lt;$&gt;</span> m)

<span class=ot>retract ::</span> <span class=dt>Monad</span> f <span class=ot>=&gt;</span> <span class=dt>Free</span> f a <span class=ot>-&gt;</span> f a
retract (<span class=dt>Pure</span> a) <span class=fu>=</span> return a
retract (<span class=dt>Free</span> as) <span class=fu>=</span> as <span class=fu>&gt;&gt;=</span> retract</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://www.andres-loeh.de/Free.pdf>Monads for Free!<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>免费的单子！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://r6.ca/blog/20110520T220201Z.html>I/O is not a Monad<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>I/O 不是 Monad</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=indexed-monads><font>Indexed Monads</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>索引单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Indexed monads are a generalisation of monads that adds an additional type parameter to the class that carries information about the computation or structure of the monadic implementation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Indexed monads 是 monads 的泛化，它将一个额外的类型参数添加到类中，该类携带有关 monadic 实现的计算或结构的信息。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>IxMonad</span> md <span class=kw>where</span>
<span class=ot>  return ::</span> a <span class=ot>-&gt;</span> md i i a
<span class=ot>  (&gt;&gt;=) ::</span> md i m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> md m o b) <span class=ot>-&gt;</span> md i o b</code></pre></div>
<p><font>The canonical use-case is a variant of the vanilla State which allows type-changing on the state for intermediate steps inside of the monad. This indeed turns out to be very useful for handling a class of problems involving resource management since the extra index parameter gives us space to statically enforce the sequence of monadic actions by allowing and restricting certain state transitions on the index parameter at compile-time.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>规范用例是 vanilla State 的变体，它允许在 monad 内部的中间步骤的状态上进行类型更改。这确实对处理涉及资源管理的一类问题非常有用，因为额外的索引参数为我们提供了空间，通过在编译时允许和限制索引参数上的某些状态转换来静态强制执行单子操作序列。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To make this more usable we'll use the somewhat esoteric </font><code>-XRebindableSyntax</code><font> allowing us to overload the do-notation and if-then-else syntax by providing alternative definitions local to the module.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了使它更有用，我们将使用有点深奥的 -XRebindableSyntax 允许我们通过提供模块本地的替代定义来重载 do-notation 和 if-then-else 语法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/10-advanced-monads/indexed.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RebindableSyntax #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class=ot>{-# LANGUAGE NoMonomorphismRestriction #-}</span>

<span class=kw>import </span><span class=dt>Data.IORef</span>
<span class=kw>import </span><span class=dt>Data.Char</span>
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (fmap, (&gt;&gt;=), (&gt;&gt;), return)
<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=kw>newtype</span> <span class=dt>IState</span> i o a <span class=fu>=</span> <span class=dt>IState</span> {<span class=ot> runIState ::</span> i <span class=ot>-&gt;</span> (a, o) }

<span class=ot>evalIState ::</span> <span class=dt>IState</span> i o a <span class=ot>-&gt;</span> i <span class=ot>-&gt;</span> a
evalIState st i <span class=fu>=</span> fst <span class=fu>$</span> runIState st i

<span class=ot>execIState ::</span> <span class=dt>IState</span> i o a <span class=ot>-&gt;</span> i <span class=ot>-&gt;</span> o
execIState st i <span class=fu>=</span> snd <span class=fu>$</span> runIState st i

<span class=ot>ifThenElse ::</span> <span class=dt>Bool</span> <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
ifThenElse b i j <span class=fu>=</span> <span class=kw>case</span> b <span class=kw>of</span>
  <span class=dt>True</span> <span class=ot>-&gt;</span> i
  <span class=dt>False</span> <span class=ot>-&gt;</span> j

return<span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>IState</span> s s a
return a <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \s <span class=ot>-&gt;</span> (a, s)

fmap<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> <span class=dt>IState</span> i o a <span class=ot>-&gt;</span> <span class=dt>IState</span> i o b
fmap f v <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \i <span class=ot>-&gt;</span> <span class=kw>let</span> (a, o) <span class=fu>=</span> runIState v i
                          <span class=kw>in</span> (f a, o)

<span class=ot>join ::</span> <span class=dt>IState</span> i m (<span class=dt>IState</span> m o a) <span class=ot>-&gt;</span> <span class=dt>IState</span> i o a
join v <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \i <span class=ot>-&gt;</span> <span class=kw>let</span> (w, m) <span class=fu>=</span> runIState v i
                        <span class=kw>in</span> runIState w m

<span class=ot>(&gt;&gt;=) ::</span> <span class=dt>IState</span> i m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>IState</span> m o b) <span class=ot>-&gt;</span> <span class=dt>IState</span> i o b
v <span class=fu>&gt;&gt;=</span> f <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \i <span class=ot>-&gt;</span> <span class=kw>let</span> (a, m) <span class=fu>=</span> runIState v i
                         <span class=kw>in</span> runIState (f a) m

<span class=ot>(&gt;&gt;) ::</span> <span class=dt>IState</span> i m a <span class=ot>-&gt;</span> <span class=dt>IState</span> m o b <span class=ot>-&gt;</span> <span class=dt>IState</span> i o b
v <span class=fu>&gt;&gt;</span> w <span class=fu>=</span> v <span class=fu>&gt;&gt;=</span> \_ <span class=ot>-&gt;</span> w

<span class=ot>get ::</span> <span class=dt>IState</span> s s s
get <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \s <span class=ot>-&gt;</span> (s, s)

<span class=ot>gets ::</span> (a <span class=ot>-&gt;</span> o) <span class=ot>-&gt;</span> <span class=dt>IState</span> a o a
gets f <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \s <span class=ot>-&gt;</span> (s, f s)

<span class=ot>put ::</span> o <span class=ot>-&gt;</span> <span class=dt>IState</span> i o ()
put o <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \_ <span class=ot>-&gt;</span> ((), o)

<span class=ot>modify ::</span> (i <span class=ot>-&gt;</span> o) <span class=ot>-&gt;</span> <span class=dt>IState</span> i o ()
modify f <span class=fu>=</span> <span class=dt>IState</span> <span class=fu>$</span> \i <span class=ot>-&gt;</span> ((), f i)



<span class=kw>data</span> <span class=dt>Locked</span> <span class=fu>=</span> <span class=dt>Locked</span>
<span class=kw>data</span> <span class=dt>Unlocked</span> <span class=fu>=</span> <span class=dt>Unlocked</span>

<span class=kw>type</span> <span class=dt>Stateful</span> a <span class=fu>=</span> <span class=dt>IState</span> a <span class=dt>Unlocked</span> a

<span class=ot>acquire ::</span> <span class=dt>IState</span> i <span class=dt>Locked</span> ()
acquire <span class=fu>=</span> put <span class=dt>Locked</span>

<span class=co>-- Can only release the lock if it's held, try release the lock</span>
<span class=co>-- that's not held is a now a type error.</span>
<span class=ot>release ::</span> <span class=dt>IState</span> <span class=dt>Locked</span> <span class=dt>Unlocked</span> ()
release <span class=fu>=</span> put <span class=dt>Unlocked</span>

<span class=co>-- Statically forbids improper handling of resources.</span>
<span class=ot>lockExample ::</span> <span class=dt>Stateful</span> a
lockExample <span class=fu>=</span> <span class=kw>do</span>
  ptr <span class=ot>&lt;- get  ::</span> <span class=dt>IState</span> a a a
<span class=ot>  acquire     ::</span> <span class=dt>IState</span> a <span class=dt>Locked</span> ()
  <span class=co>-- ...</span>
<span class=ot>  release     ::</span> <span class=dt>IState</span> <span class=dt>Locked</span> <span class=dt>Unlocked</span> ()
  return ptr

<span class=co>-- Couldn't match type `Locked' with `Unlocked'</span>
<span class=co>-- In a stmt of a 'do' block: return ptr</span>
<span class=ot>failure1 ::</span> <span class=dt>Stateful</span> a
failure1 <span class=fu>=</span> <span class=kw>do</span>
  ptr <span class=ot>&lt;-</span> get
  acquire
  return ptr <span class=co>-- didn't release</span>

<span class=co>-- Couldn't match type `a' with `Locked'</span>
<span class=co>-- In a stmt of a 'do' block: release</span>
<span class=ot>failure2 ::</span> <span class=dt>Stateful</span> a
failure2 <span class=fu>=</span> <span class=kw>do</span>
  ptr <span class=ot>&lt;-</span> get
  release <span class=co>-- didn't acquire</span>
  return ptr

<span class=co>-- Evaluate the resulting state, statically ensuring that the</span>
<span class=co>-- lock is released when finished.</span>
<span class=ot>evalReleased ::</span> <span class=dt>IState</span> i <span class=dt>Unlocked</span> a <span class=ot>-&gt;</span> i <span class=ot>-&gt;</span> a
evalReleased f st <span class=fu>=</span> evalIState f st

<span class=ot>example ::</span> <span class=dt>IO</span> (<span class=dt>IORef</span> <span class=dt>Integer</span>)
example <span class=fu>=</span> evalReleased <span class=fu>&lt;$&gt;</span> pure lockExample <span class=fu>&lt;*&gt;</span> newIORef <span class=dv>0</span></code></pre></div>
<p><font>See: </font><a href=http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf>Fun with Indexed monads</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：使用索引 monad 的乐趣</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=lifted-base><font>lifted-base</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>提升基地</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The default prelude predates a lot of the work on monad transformers and as such many of the common functions for handling errors and interacting with IO are bound strictly to the IO monad and not to functions implementing stacks on top of IO or ST. The lifted-base provides generic control operations such as </font><code>catch</code><font> can be lifted from IO or any other base monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认序言早于 monad 转换器的大量工作，因此许多用于处理错误和与 IO 交互的常用函数严格绑定到 IO monad，而不是绑定到在 IO 或 ST 之上实现堆栈的函数。 lifted-base 提供通用的控制操作，例如 catch 可以从 IO 或任何其他基础 monad 中提升。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=monad-base><font>monad-base</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子基础</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Monad base provides an abstraction over </font><code>liftIO</code><font> and other functions to explicitly lift into a "privileged" layer of the transformer stack. It's implemented a multiparamater typeclass with the "base" monad as the parameter b.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad base 提供了对 liftIO 和其他函数的抽象，以显式提升到转换器堆栈的“特权”层。它实现了一个多参数类型类，以“基本”monad 作为参数 b。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Lift a computation from the base monad</span>
<span class=kw>class</span> (<span class=dt>Applicative</span> b, <span class=dt>Applicative</span> m, <span class=dt>Monad</span> b, <span class=dt>Monad</span> m)
      <span class=ot>=&gt;</span> <span class=dt>MonadBase</span> b m <span class=fu>|</span> m <span class=ot>-&gt;</span> b <span class=kw>where</span>
  liftBase <span class=ot>∷</span> b a <span class=ot>-&gt;</span> m a</code></pre></div>
<h4 id=monad-control><font>monad-control</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子控制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Monad control builds on top of monad-base to extended lifting operation to control operations like </font><code>catch</code><font> and </font><code>bracket</code><font> can be written generically in terms of any transformer with a base layer supporting these operations. Generic operations can then be expressed in terms of a </font><code>MonadBaseControl</code><font> and written in terms of the combinator </font><code>control</code><font> which handles the bracket and automatic handler lifting.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Monad 控件建立在 monad-base 之上，以扩展提升操作以控制诸如 catch 和 bracket 之类的操作，可以根据任何具有支持这些操作的基础层的转换器来编写。然后可以用 MonadBaseControl 表示通用操作，并用处理括号和自动处理程序提升的组合器控件编写。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>control ::</span> <span class=dt>MonadBaseControl</span> b m <span class=ot>=&gt;</span> (<span class=dt>RunInBase</span> m b <span class=ot>-&gt;</span> b (<span class=dt>StM</span> m a)) <span class=ot>-&gt;</span> m a</code></pre></div>
<p><font>For example the function catch provided by </font><code>Control.Exception</code><font> is normally locked into IO.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，Control.Exception 提供的函数 catch 通常锁定在 IO 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<pre><code>catch :: Exception e =&gt; IO a -&gt; (e -&gt; IO a) -&gt; IO a</code></pre>
<p><font>By composing it in terms of control we can construct a generic version which automatically lifts inside of any combination of the usual transformer stacks that has </font><code>MonadBaseControl</code><font> instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通过在控制方面组合它，我们可以构建一个通用版本，它自动提升具有 MonadBaseControl 实例的常用转换器堆栈的任何组合。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">catch
<span class=ot>  ::</span> (<span class=dt>MonadBaseControl</span> <span class=dt>IO</span> m, <span class=dt>Exception</span> e)
  <span class=ot>=&gt;</span> m a        <span class=co>-- ^ Computation</span>
  <span class=ot>-&gt;</span> (e <span class=ot>-&gt;</span> m a) <span class=co>-- ^ Handler</span>
  <span class=ot>-&gt;</span> m a
catch a handler <span class=fu>=</span> control <span class=fu>$</span> \runInIO <span class=ot>-&gt;</span>
                    E.catch (runInIO a)
                            (\e <span class=ot>-&gt;</span> runInIO <span class=fu>$</span> handler e)</code></pre></div>
<hr>
<h1 id=quantification><font>Quantification</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h2 id=universal-quantification><font>Universal Quantification</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Universal quantification the primary mechanism of encoding polymorphism in Haskell. The essence of universal quantification is that we can express functions which operate the same way for a set of types and whose function behavior is entirely determined </font><em>only</em><font> by the behavior of all types in this span.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通用量化是 Haskell 中编码多态性的主要机制。通用量化的本质是我们可以表达对一组类型以相同方式运行的函数，并且其函数行为完全仅由该范围内所有类型的行为决定。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/11-quantification/universal.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>

<span class=co>-- ∀a. [a]</span>
<span class=ot>example1 ::</span> forall a<span class=fu>.</span> [a]
example1 <span class=fu>=</span> []

<span class=co>-- ∀a. [a]</span>
<span class=ot>example2 ::</span> forall a<span class=fu>.</span> [a]
example2 <span class=fu>=</span> [undefined]

<span class=co>-- ∀a. ∀b. (a → b) → [a] → [b]</span>
<span class=ot>map' ::</span> forall a<span class=fu>.</span> forall b<span class=fu>.</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [b]
map' f <span class=fu>=</span> foldr ((<span class=fu>:</span>) <span class=fu>.</span> f) []

<span class=co>-- ∀a. [a] → [a]</span>
<span class=ot>reverse' ::</span> forall a<span class=fu>.</span> [a] <span class=ot>-&gt;</span> [a]
reverse' <span class=fu>=</span> foldl (flip (<span class=fu>:</span>)) []</code></pre></div>
<p><font>Normally quantifiers are omitted in type signatures since in Haskell's vanilla surface language it is unambiguous to assume to that free type variables are universally quantified.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通常在类型签名中省略量词，因为在 Haskell 的普通表面语言中，可以明确地假设自由类型变量是普遍量化的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=free-theorems><font>Free theorems</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自由定理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A universally quantified type-variable actually implies quite a few rather deep properties about the implementation of a function that can be deduced from its type signature. For instance the identity function in Haskell is guaranteed to only have one implementation since the only information that the information that can present in the body</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个普遍量化的类型变量实际上暗示了一些关于函数实现的相当深的属性，这些属性可以从它的类型签名中推导出来。例如，Haskell 中的身份函数保证只有一种实现，因为唯一的信息是可以在主体中呈现的信息</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class=ot> ::</span> forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> a
id x <span class=fu>=</span> x</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap<span class=ot> ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b</code></pre></div>
<p><font>The free theorem of fmap:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>fmap的自由定理：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">forall f g<span class=fu>.</span> fmap f <span class=fu>.</span> fmap g <span class=fu>=</span> fmap (f <span class=fu>.</span> g)</code></pre></div>
<p><font>See: </font><a href=http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi?>Theorems for Free</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：免费定理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=type-systems><font>Type Systems</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型系统</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><strong>Hindley-Milner type system<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>欣德利-米尔纳型系统</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>The Hindley-Milner type system is historically important as one of the first typed lambda calculi that admitted both polymorphism and a variety of inference techniques that could always decide principal types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Hindley-Milner 类型系统作为第一个类型化的 lambda 演算系统具有重要的历史意义，它承认多态性和各种始终可以确定主要类型的推理技术。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class=fu>:</span> x
  <span class=fu>|</span> λx<span class=fu>:</span>t<span class=fu>.</span>e            <span class=co>-- value abstraction</span>
  <span class=fu>|</span> e1 e2             <span class=co>-- application</span>
  <span class=fu>|</span> <span class=kw>let</span> x <span class=fu>=</span> e1 <span class=kw>in</span> e2  <span class=co>-- let</span>

t <span class=fu>:</span> t <span class=ot>-&gt;</span> t     <span class=co>-- function types</span>
  <span class=fu>|</span> a          <span class=co>-- type variables</span>

σ <span class=fu>:</span> <span class=ot>∀</span> a <span class=fu>.</span> t    <span class=co>-- type scheme</span></code></pre></div>
<p><font>In an implementation, the function </font><code>generalize</code><font> converts all type variables within the type into polymorphic type variables yielding a type scheme. The function </font><code>instantiate</code><font> maps a scheme to a type, but with any polymorphic variables converted into unbound type variables.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在实现中，函数 generalize 将类型中的所有类型变量转换为多态类型变量，从而产生类型方案。函数 instantiate 将方案映射到类型，但将任何多态变量转换为未绑定类型变量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=rank-n-types><font>Rank-N Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>N 阶类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>System-F is the type system that underlies Haskell. System-F subsumes the HM type system in the sense that every type expressible in HM can be expressed within System-F. System-F is sometimes referred to in texts as the </font><em>Girald-Reynolds polymorphic lambda calculus</em><font> or </font><em>second-order lambda calculus</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>System-F 是作为 Haskell 基础的类型系统。 System-F 包含 HM 类型系统，因为在 HM 中可以表达的每个类型都可以在 System-F 中表达。 System-F 有时在文本中称为 Girald-Reynolds 多态 lambda 演算或二阶 lambda 演算。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">t <span class=fu>:</span> t <span class=ot>-&gt;</span> t     <span class=co>-- function types</span>
  <span class=fu>|</span> a          <span class=co>-- type variables</span>
  <span class=fu>|</span> <span class=ot>∀</span> a <span class=fu>.</span> t    <span class=co>-- forall</span>

e <span class=fu>:</span> x          <span class=co>-- variables</span>
  <span class=fu>|</span> λ(x<span class=fu>:</span>t)<span class=fu>.</span>e   <span class=co>-- value abstraction</span>
  <span class=fu>|</span> e1 e2      <span class=co>-- value application</span>
  <span class=fu>|</span> Λa<span class=fu>.</span>e       <span class=co>-- type abstraction</span>
  <span class=fu>|</span> e_t        <span class=co>-- type application</span></code></pre></div>
<p><font>An example with equivalents of GHC Core in comments:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个在评论中包含 GHC Core 等价物的例子：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">id <span class=fu>:</span> <span class=ot>∀</span> t<span class=fu>.</span> t <span class=ot>-&gt;</span> t
id <span class=fu>=</span> Λt<span class=fu>.</span> λx<span class=fu>:</span>t<span class=fu>.</span> x
<span class=co>-- id :: forall t. t -&gt; t</span>
<span class=co>-- id = \ (@ t) (x :: t) -&gt; x</span>

tr <span class=fu>:</span> <span class=ot>∀</span> a<span class=fu>.</span> <span class=ot>∀</span> b<span class=fu>.</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a
tr <span class=fu>=</span> Λa<span class=fu>.</span> Λb<span class=fu>.</span> λx<span class=fu>:</span>a<span class=fu>.</span> λy<span class=fu>:</span>b<span class=fu>.</span> x
<span class=co>-- tr :: forall a b. a -&gt; b -&gt; a</span>
<span class=co>-- tr = \ (@ a) (@ b) (x :: a) (y :: b) -&gt; x</span>

fl <span class=fu>:</span> <span class=ot>∀</span> a<span class=fu>.</span> <span class=ot>∀</span> b<span class=fu>.</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b
fl <span class=fu>=</span> Λa<span class=fu>.</span> Λb<span class=fu>.</span> λx<span class=fu>:</span>a<span class=fu>.</span> λy<span class=fu>:</span>b<span class=fu>.</span> y
<span class=co>-- fl :: forall a b. a -&gt; b -&gt; b</span>
<span class=co>-- fl = \ (@ a) (@ b) (x :: a) (y :: b) -&gt; y</span>

nil <span class=fu>:</span> <span class=ot>∀</span> a<span class=fu>.</span> [a]
nil <span class=fu>=</span> Λa<span class=fu>.</span> Λb<span class=fu>.</span> λz<span class=fu>:</span>b<span class=fu>.</span> λf<span class=fu>:</span>(a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b)<span class=fu>.</span> z
<span class=co>-- nil :: forall a. [a]</span>
<span class=co>-- nil = \ (@ a) (@ b) (z :: b) (f :: a -&gt; b -&gt; b) -&gt; z</span>

cons <span class=fu>:</span> <span class=ot>∀</span> a<span class=fu>.</span> a <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [a]
cons <span class=fu>=</span> Λa<span class=fu>.</span> λx<span class=fu>:</span>a<span class=fu>.</span> λxs<span class=fu>:</span>(<span class=ot>∀</span> b<span class=fu>.</span> b <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b)<span class=fu>.</span>
    Λb<span class=fu>.</span> λz<span class=fu>:</span>b<span class=fu>.</span> λf <span class=fu>:</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b)<span class=fu>.</span> f x (xs_b z f)
<span class=co>-- cons :: forall a. a</span>
<span class=co>--       -&gt; (forall b. (a -&gt; b -&gt; b) -&gt; b) -&gt; (forall b. (a -&gt; b -&gt; b) -&gt; b)</span>
<span class=co>-- cons = \ (@ a) (x :: a) (xs :: forall b. (a -&gt; b -&gt; b) -&gt; b)</span>
<span class=co>--     (@ b) (z :: b) (f :: a -&gt; b -&gt; b) -&gt; f x (xs @ b z f)</span></code></pre></div>
<p><font>Normally when Haskell's typechecker infers a type signature it places all quantifiers of type variables at the outermost position such that no quantifiers appear within the body of the type expression, called the prenex restriction. This restricts an entire class of type signatures that would otherwise be expressible within System-F, but has the benefit of making inference much easier.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通常，当 Haskell 的类型检查器推断类型签名时，它会将类型变量的所有量词放在最外层的位置，这样就不会在类型表达式的主体内出现任何量词，这被称为 prenex 限制。这限制了整个类的类型签名，否则这些类型签名可以在 System-F 中表达，但具有使推理更容易的好处。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><code>-XRankNTypes</code><font> loosens the prenex restriction such that we may explicitly place quantifiers within the body of the type. The bad news is that the general problem of inference in this relaxed system is undecidable in general, so we're required to explicitly annotate functions which use RankNTypes or they are otherwise inferred as rank 1 and may not typecheck at all.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-XRankNTypes 放宽了前缀限制，这样我们就可以明确地将量词放在类型的主体中。坏消息是，在这个宽松的系统中，推理的一般问题通常是无法确定的，因此我们需要显式注释使用 RankNTypes 的函数，否则它们将被推断为等级 1，并且可能根本不会进行类型检查。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/11-quantification/rankn.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RankNTypes #-}</span>

<span class=co>-- Can't unify ( Bool ~ Char )</span>
<span class=ot>rank1 ::</span> forall a<span class=fu>.</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (<span class=dt>Bool</span>, <span class=dt>Char</span>)
rank1 f <span class=fu>=</span> (f <span class=dt>True</span>, f <span class=ch>'a'</span>)

<span class=ot>rank2 ::</span> (forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (<span class=dt>Bool</span>, <span class=dt>Char</span>)
rank2 f <span class=fu>=</span> (f <span class=dt>True</span>, f <span class=ch>'a'</span>)

<span class=ot>auto ::</span> (forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (forall b<span class=fu>.</span> b <span class=ot>-&gt;</span> b)
auto x <span class=fu>=</span> x

<span class=ot>xauto ::</span> forall a<span class=fu>.</span> (forall b<span class=fu>.</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
xauto f <span class=fu>=</span> f</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Monomorphic</span> <span class=dt>Rank</span> <span class=dv>0</span><span class=fu>:</span> t
<span class=dt>Polymorphic</span> <span class=dt>Rank</span> <span class=dv>1</span><span class=fu>:</span> forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> t
<span class=dt>Polymorphic</span> <span class=dt>Rank</span> <span class=dv>2</span><span class=fu>:</span> (forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> t) <span class=ot>-&gt;</span> t
<span class=dt>Polymorphic</span> <span class=dt>Rank</span> <span class=dv>3</span><span class=fu>:</span> ((forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> t) <span class=ot>-&gt;</span> t) <span class=ot>-&gt;</span> t</code></pre></div>
<p><font>Of important note is that the type variables bound by an explicit quantifier in a higher ranked type may not escape their enclosing scope. The typechecker will explicitly enforce this by enforcing that variables bound inside of rank-n types (called skolem constants) will not unify with free meta type variables inferred by the inference engine.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>需要注意的是，在较高级别类型中由显式量词绑定的类型变量可能无法逃脱其封闭范围。类型检查器将通过强制绑定在 rank-n 类型内部的变量（称为 skolem 常量）不会与推理引擎推断的自由元类型变量统一来明确地执行此操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/11-quantification/skolem_capture.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RankNTypes #-}</span>

<span class=ot>escape ::</span> (forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>Int</span>
escape f <span class=fu>=</span> f <span class=dv>0</span>

g x <span class=fu>=</span> escape (\a <span class=ot>-&gt;</span> x)</code></pre></div>
<p><font>In this example in order for the expression to be well typed, </font><code>f</code><font> would necessarily have (</font><code>Int -&gt; Int</code><font>) which implies that </font><code>a ~ Int</code><font> over the whole type, but since </font><code>a</code><font> is bound under the quantifier it must not be unified with </font><code>Int</code><font> and so the typechecker must fail with a skolem capture error.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在此示例中，为了使表达式的类型正确，f 必须具有 (Int -&gt; Int)，这意味着整个类型上都有一个 ~ Int，但由于 a 被限定在量词下，因此它不能与 Int 和因此类型检查器必须因 skolem 捕获错误而失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode perl"><code class="sourceCode perl">Couldn<span class=kw>'</span><span class=st>t match expected type `a</span><span class=kw>'</span> with actual type <span class=kw>`</span><span class=st>t'</span>
<span class=kw>`</span>a<span class=kw>'</span><span class=st> is a rigid type variable bound by a type expected by the context: a -&gt; a</span>
<span class=st>`t</span><span class=kw>'</span> is a rigid type variable bound by the inferred type of g :: t -&gt; Int
In the expression: x In the first argument of <span class=kw>`</span><span class=st>escape', namely </span><span class=kw>`</span>(\ a -&gt; x)<span class=kw>'</span>
<span class=st>In the expression: escape (\ a -&gt; x)</span></code></pre></div>
<p><font>This can actually be used for our advantage to enforce several types of invariants about scope and use of specific type variables. For example the ST monad uses a second rank type to prevent the capture of references between ST monads with separate state threads where the </font><code>s</code><font> type variable is bound within a rank-2 type and cannot escape, statically guaranteeing that the implementation details of the ST internals can't leak out and thus ensuring its referential transparency.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这实际上可以用于我们的优势，以强制执行关于范围和特定类型变量使用的几种类型的不变量。例如，ST monad 使用第二等级类型来防止捕获具有单独状态线程的 ST monad 之间的引用，其中 s 类型变量绑定在等级 2 类型中并且无法逃逸，静态保证 ST 内部的实现细节不能泄漏，从而确保其引用透明性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=existential-quantification><font>Existential Quantification</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>存在量化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>An existential type is a pair of a type and a term with a special set of packing and unpacking semantics. The type of the value encoded in the existential is known by the producer but not by the consumer of the existential value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在类型是一对具有一组特殊打包和解包语义的类型和术语。存在值中编码的值的类型为生产者所知，但不为存在值的消费者所知。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/11-quantification/existential.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ExistentialQuantification #-}</span>
<span class=ot>{-# LANGUAGE RankNTypes #-}</span>

<span class=co>-- ∃ t. (t, t → t, t → String)</span>
<span class=kw>data</span> <span class=dt>Box</span> <span class=fu>=</span> forall a<span class=fu>.</span> <span class=dt>Box</span> a (a <span class=ot>-&gt;</span> a) (a <span class=ot>-&gt;</span> <span class=dt>String</span>)

<span class=ot>boxa ::</span> <span class=dt>Box</span>
boxa <span class=fu>=</span> <span class=dt>Box</span> <span class=dv>1</span> negate show

<span class=ot>boxb ::</span> <span class=dt>Box</span>
boxb <span class=fu>=</span> <span class=dt>Box</span> <span class=st>"foo"</span> reverse show

<span class=ot>apply ::</span> <span class=dt>Box</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
apply (<span class=dt>Box</span> x f p) <span class=fu>=</span> p (f x)

<span class=co>-- ∃ t. Show t =&gt; t</span>
<span class=kw>data</span> <span class=dt>SBox</span> <span class=fu>=</span> forall a<span class=fu>.</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> <span class=dt>SBox</span> a

<span class=ot>boxes ::</span> [<span class=dt>SBox</span>]
boxes <span class=fu>=</span> [<span class=dt>SBox</span> (), <span class=dt>SBox</span> <span class=dv>2</span>, <span class=dt>SBox</span> <span class=st>"foo"</span>]

<span class=ot>showBox ::</span> <span class=dt>SBox</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
showBox (<span class=dt>SBox</span> a) <span class=fu>=</span> show a

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> mapM_ (putStrLn <span class=fu>.</span> showBox) boxes
<span class=co>-- ()</span>
<span class=co>-- 2</span>
<span class=co>-- "foo"</span></code></pre></div>
<p><font>The existential over </font><code>SBox</code><font> gathers a collection of values defined purely in terms of their Show interface and an opaque pointer, no other information is available about the values and they can't be accessed or unpacked in any other way.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SBox 上的存在收集纯粹根据其 Show 接口和不透明指针定义的值集合，没有关于这些值的其他可用信息，并且不能以任何其他方式访问或解压缩它们。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Passing around existential types allows us to hide information from consumers of data types and restrict the behavior that functions can use. Passing records around with existential variables allows a type to be "bundled" with a fixed set of functions that operate over its hidden internals.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>传递存在类型允许我们向数据类型的消费者隐藏信息并限制函数可以使用的行为。使用存在变量传递记录允许类型与一组固定的函数“捆绑”在一起，这些函数在其隐藏的内部进行操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/11-quantification/existential_records.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RankNTypes #-}</span>
<span class=ot>{-# LANGUAGE ExistentialQuantification #-}</span>

<span class=co>-- a b are existentially bound type variables, m is a free type variable</span>
<span class=kw>data</span> <span class=dt>MonadI</span> m <span class=fu>=</span> <span class=dt>MonadI</span>
  { _<span class=ot>return ::</span> forall a <span class=fu>.</span> a <span class=ot>-&gt;</span> m a
  , _<span class=ot>bind   ::</span> forall a b <span class=fu>.</span> m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m b
  }

<span class=ot>monadMaybe::</span> <span class=dt>MonadI</span> <span class=dt>Maybe</span>
monadMaybe <span class=fu>=</span> <span class=dt>MonadI</span>
  { _return <span class=fu>=</span> <span class=dt>Just</span>
  , _bind   <span class=fu>=</span> \m f <span class=ot>-&gt;</span> <span class=kw>case</span> m <span class=kw>of</span>
      <span class=dt>Nothing</span> <span class=ot>-&gt;</span> <span class=dt>Nothing</span>
      <span class=dt>Just</span> x  <span class=ot>-&gt;</span> f x
  }</code></pre></div>
<h2 id=impredicative-types><font>Impredicative Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>指示类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Although extremely brittle, GHC also has limited support for impredicative polymorphism which allows instantiating type variable with a polymorphic type. Implied is that this loosens the restriction that quantifiers must precede arrow types and now they may be placed inside of type-constructors.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>虽然非常脆弱，但 GHC 对允许使用多态类型实例化类型变量的指示多态性也有有限的支持。这意味着这放宽了量词必须在箭头类型之前的限制，现在它们可以放在类型构造函数中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Can't unify ( Int ~ Char )</span>

<span class=ot>revUni ::</span> forall a<span class=fu>.</span> <span class=dt>Maybe</span> ([a] <span class=ot>-&gt;</span> [a]) <span class=ot>-&gt;</span> <span class=dt>Maybe</span> ([<span class=dt>Int</span>], [<span class=dt>Char</span>])
revUni (<span class=dt>Just</span> g) <span class=fu>=</span> <span class=dt>Just</span> (g [<span class=dv>3</span>], g <span class=st>"hello"</span>)
revUni <span class=dt>Nothing</span>  <span class=fu>=</span> <span class=dt>Nothing</span></code></pre></div>
<div class=sourceCode include=src/11-quantification/impredicative.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ImpredicativeTypes #-}</span>

<span class=co>-- Uses higher-ranked polymorphism.</span>
<span class=ot>f ::</span> (forall a<span class=fu>.</span> [a] <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (<span class=dt>Int</span>, <span class=dt>Char</span>)
f get <span class=fu>=</span> (get [<span class=dv>1</span>,<span class=dv>2</span>], get [<span class=ch>'a'</span>, <span class=ch>'b'</span>, <span class=ch>'c'</span>])

<span class=co>-- Uses impredicative polymorphism.</span>
<span class=ot>g ::</span> <span class=dt>Maybe</span> (forall a<span class=fu>.</span> [a] <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> (<span class=dt>Int</span>, <span class=dt>Char</span>)
g <span class=dt>Nothing</span> <span class=fu>=</span> (<span class=dv>0</span>, <span class=ch>'0'</span>)
g (<span class=dt>Just</span> get) <span class=fu>=</span> (get [<span class=dv>1</span>,<span class=dv>2</span>], get [<span class=ch>'a'</span>,<span class=ch>'b'</span>,<span class=ch>'c'</span>])</code></pre></div>
<p><font>Use of this extension is very rare, and there is some consideration that </font><code>-XImpredicativeTypes</code><font> is fundamentally broken. Although GHC is very liberal about telling us to enable it when one accidentally makes a typo in a type signature!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此扩展的使用非常少见，并且有人认为 -XImpredicativeTypes 从根本上被破坏了。尽管 GHC 非常慷慨地告诉我们当一个人不小心在类型签名中输入错误时启用它！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Some notable trivia, the </font><code>($)</code><font> operator is wired into GHC in a very special way as to allow impredicative instantiation of </font><code>runST</code><font> to be applied via </font><code>($)</code><font> by special-casing the </font><code>($)</code><font> operator only when used for the ST monad. If this sounds like an ugly hack it's because it is, but a rather convenient hack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一些值得注意的琐事，$) 运算符以一种非常特殊的方式连接到 GHC 中，以允许仅在用于 ST monad 时通过特殊套管 ($) 运算符通过 ($) 应用 runST 的非谓语实例化。如果这听起来像一个丑陋的 hack，那是因为它确实是一个相当方便的 hack。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example if we define a function </font><code>apply</code><font> which should behave identically to </font><code>($)</code><font> we'll get an error about polymorphic instantiation even though they are defined identically!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，如果我们定义一个 apply 函数，它的行为应该与 ($) 相同，即使它们的定义相同，我们也会收到有关多态实例化的错误！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RankNTypes #-}</span>

<span class=kw>import </span><span class=dt>Control.Monad.ST</span>

f <span class=ot>`apply`</span> x <span class=fu>=</span>  f x

<span class=ot>foo ::</span> (forall s<span class=fu>.</span> <span class=dt>ST</span> s a) <span class=ot>-&gt;</span> a
foo st <span class=fu>=</span> runST <span class=fu>$</span> st

<span class=ot>bar ::</span> (forall s<span class=fu>.</span> <span class=dt>ST</span> s a) <span class=ot>-&gt;</span> a
bar st <span class=fu>=</span> runST <span class=ot>`apply`</span> st</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class=dt>Couldn't</span> match expected <span class=kw>type</span> <span class=ot>`forall s. ST s a'</span>
<span class=ot>                with actual type `</span><span class=dt>ST</span> s0 a'
    <span class=dt>In</span> the second argument <span class=kw>of</span> <span class=ot>`apply', namely `</span>st'
    <span class=dt>In</span> the expression<span class=fu>:</span> runST <span class=ot>`apply`</span> st
    <span class=dt>In</span> an equation for <span class=ot>`bar': bar st = runST `</span>apply<span class=ot>` st</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html>SPJ Notes on $<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>SPJ 注释 $</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=scoped-type-variables><font>Scoped Type Variables</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>作用域类型变量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Normally the type variables used within the toplevel signature for a function are only scoped to the type-signature and not the body of the function and its rigid signatures over terms and let/where clauses. Enabling </font><code>-XScopedTypeVariables</code><font> loosens this restriction allowing the type variables mentioned in the toplevel to be scoped within the value-level body of a function and all signatures contained therein.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通常，在函数的顶层签名中使用的类型变量仅限于类型签名，而不是函数体及其在术语和 let/where 子句上的严格签名。启用 -XScopedTypeVariables 放宽了此限制，允许将顶层中提到的类型变量限定在函数的值级主体和其中包含的所有签名内。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/11-quantification/scopedtvars.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=ot>poly ::</span> forall a b c<span class=fu>.</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c <span class=ot>-&gt;</span> (a, a)
poly x y z <span class=fu>=</span> (f x y, f x z)
  <span class=kw>where</span>
    <span class=co>-- second argument is universally quantified from inference</span>
    <span class=co>-- f :: forall t0 t1. t0 -&gt; t1 -&gt; t0</span>
    f x' _ <span class=fu>=</span> x'

<span class=ot>mono ::</span> forall a b c<span class=fu>.</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c <span class=ot>-&gt;</span> (a, a)
mono x y z <span class=fu>=</span> (f x y, f x z)
  <span class=kw>where</span>
    <span class=co>-- b is not implictly universally quantified because it is in scope</span>
<span class=ot>    f ::</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a
    f x' _ <span class=fu>=</span> x'

<span class=ot>example ::</span> <span class=dt>IO</span> ()
example <span class=fu>=</span> <span class=kw>do</span>
<span class=ot>  x ::</span> [<span class=dt>Int</span>] <span class=ot>&lt;-</span> readLn
  print x</code></pre></div>
<hr>
<h1 id=gadts><font>GADTs</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=gadts-1><font>GADTs</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GADTs</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><em>Generalized Algebraic Data types</em><font> (GADTs) are an extension to algebraic datatypes that allow us to qualify the constructors to datatypes with type equality constraints, allowing a class of types that are not expressible using vanilla ADTs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>广义代数数据类型 (GADT) 是对代数数据类型的扩展，它允许我们将构造函数限定为具有类型相等约束的数据类型，从而允许使用普通 ADT 无法表达的一类类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><code>-XGADTs</code><font> implicitly enables an alternative syntax for datatype declarations ( </font><code>-XGADTSyntax</code><font> ) such that the following declarations are equivalent:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-XGADTs 隐式启用数据类型声明的替代语法 (-XGADTSyntax)，这样以下声明是等效的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Vanilla</span>
<span class=kw>data</span> <span class=dt>List</span> a
  <span class=fu>=</span> <span class=dt>Empty</span>
  <span class=fu>|</span> <span class=dt>Cons</span> a (<span class=dt>List</span> a)

<span class=co>-- GADTSyntax</span>
<span class=kw>data</span> <span class=dt>List</span> a <span class=kw>where</span>
  <span class=dt>Empty</span><span class=ot> ::</span> <span class=dt>List</span> a
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>List</span> a <span class=ot>-&gt;</span> <span class=dt>List</span> a</code></pre></div>
<p><font>For an example use consider the data type </font><code>Term</code><font>, we have a term in which we </font><code>Succ</code><font> which takes a </font><code>Term</code><font> parameterized by </font><code>a</code><font> which span all types. Problems arise between the clash whether (</font><code>a ~ Bool</code><font>) or (</font><code>a ~ Int</code><font>) when trying to write the evaluator.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于使用数据类型 Term 的示例，我们有一个术语，其中我们 Succ 采用一个由跨越所有类型的 a 参数化的 Term。在尝试编写求值器时，无论是 (a ~ Bool) 还是 (a ~ Int) 之间的冲突都会出现问题。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Term</span> a
  <span class=fu>=</span> <span class=dt>Lit</span> a
  <span class=fu>|</span> <span class=dt>Succ</span> (<span class=dt>Term</span> a)
  <span class=fu>|</span> <span class=dt>IsZero</span> (<span class=dt>Term</span> a)

<span class=co>-- can't be well-typed :(</span>
eval (<span class=dt>Lit</span> i)      <span class=fu>=</span> i
eval (<span class=dt>Succ</span> t)     <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> eval t
eval (<span class=dt>IsZero</span> i)   <span class=fu>=</span> eval i <span class=fu>==</span> <span class=dv>0</span></code></pre></div>
<p><font>And we admit the construction of meaningless terms which forces more error handling cases.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们承认构造无意义的术语会强制出现更多的错误处理案例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- This is a valid type.</span>
failure <span class=fu>=</span> <span class=dt>Succ</span> ( <span class=dt>Lit</span> <span class=dt>True</span> )</code></pre></div>
<p><font>Using a GADT we can express the type invariants for our language (i.e. only type-safe expressions are representable). Pattern matching on this GADTs then carries type equality constraints without the need for explicit tags.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 GADT 我们可以表达我们语言的类型不变量（即只有类型安全的表达式是可表示的）。然后，此 GADT 上的模式匹配带有类型相等约束，而不需要显式标记。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/12-gadts/gadt.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# Language GADTs #-}</span>

<span class=kw>data</span> <span class=dt>Term</span> a <span class=kw>where</span>
  <span class=dt>Lit</span><span class=ot>    ::</span> a <span class=ot>-&gt;</span> <span class=dt>Term</span> a
  <span class=dt>Succ</span><span class=ot>   ::</span> <span class=dt>Term</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Term</span> <span class=dt>Int</span>
  <span class=dt>IsZero</span><span class=ot> ::</span> <span class=dt>Term</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Term</span> <span class=dt>Bool</span>
  <span class=dt>If</span><span class=ot>     ::</span> <span class=dt>Term</span> <span class=dt>Bool</span> <span class=ot>-&gt;</span> <span class=dt>Term</span> a <span class=ot>-&gt;</span> <span class=dt>Term</span> a <span class=ot>-&gt;</span> <span class=dt>Term</span> a

<span class=ot>eval ::</span> <span class=dt>Term</span> a <span class=ot>-&gt;</span> a
eval (<span class=dt>Lit</span> i)      <span class=fu>=</span> i                                   <span class=co>-- Term a</span>
eval (<span class=dt>Succ</span> t)     <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> eval t                          <span class=co>-- Term (a ~ Int)</span>
eval (<span class=dt>IsZero</span> i)   <span class=fu>=</span> eval i <span class=fu>==</span> <span class=dv>0</span>                         <span class=co>-- Term (a ~ Int)</span>
eval (<span class=dt>If</span> b e1 e2) <span class=fu>=</span> <span class=kw>if</span> eval b <span class=kw>then</span> eval e1 <span class=kw>else</span> eval e2 <span class=co>-- Term (a ~ Bool)</span>

<span class=ot>example ::</span> <span class=dt>Int</span>
example <span class=fu>=</span> eval (<span class=dt>Succ</span> (<span class=dt>Succ</span> (<span class=dt>Lit</span> <span class=dv>3</span>)))</code></pre></div>
<p><font>This time around:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这阵子：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- This is rejected at compile-time.</span>
failure <span class=fu>=</span> <span class=dt>Succ</span> ( <span class=dt>Lit</span> <span class=dt>True</span> )</code></pre></div>
<p><font>Explicit equality constraints (</font><code>a ~ b</code><font>) can be added to a function's context. For example the following expand out to the same types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以将显式等式约束 (a ~ b) 添加到函数的上下文中。例如，以下扩展到相同的类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> (a, a)
<span class=ot>f ::</span> (a <span class=fu>~</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> (a,b)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class=dt>Int</span> <span class=fu>~</span> <span class=dt>Int</span>)  <span class=ot>=&gt;</span> <span class=fu>...</span>
(a <span class=fu>~</span> <span class=dt>Int</span>)    <span class=ot>=&gt;</span> <span class=fu>...</span>
(<span class=dt>Int</span> <span class=fu>~</span> a)    <span class=ot>=&gt;</span> <span class=fu>...</span>
(a <span class=fu>~</span> b)      <span class=ot>=&gt;</span> <span class=fu>...</span>
(<span class=dt>Int</span> <span class=fu>~</span> <span class=dt>Bool</span>) <span class=ot>=&gt;</span> <span class=fu>...</span> <span class=co>-- Will not typecheck.</span></code></pre></div>
<p><font>This is effectively the implementation detail of what GHC is doing behind the scenes to implement GADTs ( implicitly passing and threading equality terms around ). If we wanted we could do the same setup that GHC does just using equality constraints and existential quantification. Indeed, the internal representation of GADTs is as regular algebraic datatypes that carry coercion evidence as arguments.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这实际上是 GHC 在幕后为实现 GADT 所做的工作的实现细节（隐式传递和线程平等条款）。如果我们愿意，我们可以做与 GHC 相同的设置，只是使用等式约束和存在量化。事实上，GADT 的内部表示是作为参数携带强制证据的常规代数数据类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE ExistentialQuantification #-}</span>

<span class=co>-- Using Constraints</span>
<span class=kw>data</span> <span class=dt>Exp</span> a
  <span class=fu>=</span> (a <span class=fu>~</span> <span class=dt>Int</span>) <span class=ot>=&gt;</span> <span class=dt>LitInt</span> a
  <span class=fu>|</span> (a <span class=fu>~</span> <span class=dt>Bool</span>) <span class=ot>=&gt;</span> <span class=dt>LitBool</span> a
  <span class=fu>|</span> forall b<span class=fu>.</span> (b <span class=fu>~</span> <span class=dt>Bool</span>) <span class=ot>=&gt;</span> <span class=dt>If</span> (<span class=dt>Exp</span> b) (<span class=dt>Exp</span> a) (<span class=dt>Exp</span> a)

<span class=co>-- Using GADTs</span>
<span class=co>-- data Exp a where</span>
<span class=co>--   LitInt  :: Int  -&gt; Exp Int</span>
<span class=co>--   LitBool :: Bool -&gt; Exp Bool</span>
<span class=co>--   If      :: Exp Bool -&gt; Exp a -&gt; Exp a -&gt; Exp a</span>

<span class=ot>eval ::</span> <span class=dt>Exp</span> a <span class=ot>-&gt;</span> a
eval e <span class=fu>=</span> <span class=kw>case</span> e <span class=kw>of</span>
  <span class=dt>LitInt</span> i   <span class=ot>-&gt;</span> i
  <span class=dt>LitBool</span> b  <span class=ot>-&gt;</span> b
  <span class=dt>If</span> b tr fl <span class=ot>-&gt;</span> <span class=kw>if</span> eval b <span class=kw>then</span> eval tr <span class=kw>else</span> eval fl</code></pre></div>
<p><font>In the presence of GADTs inference becomes intractable in many cases, often requiring an explicit annotation. For example </font><code>f</code><font> can either have </font><code>T a -&gt; [a]</code><font> or </font><code>T a -&gt; [Int]</code><font> and neither is principal.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 GADTs 存在的情况下，推理在许多情况下变得棘手，通常需要明确的注释。例如 f 可以有 T a -&gt; [a] 或 T a -&gt; [Int] 并且两者都不是主体。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>T</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>T1</span><span class=ot> ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>T</span> <span class=dt>Int</span>
  <span class=dt>T2</span><span class=ot> ::</span> <span class=dt>T</span> a

f (<span class=dt>T1</span> n) <span class=fu>=</span> [n]
f <span class=dt>T2</span>     <span class=fu>=</span> []</code></pre></div>
<h2 id=kind-signatures><font>Kind Signatures</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>亲切签名</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell's kind system (i.e. the "type of the types") is a system consisting the single kind </font><code>*</code><font> and an arrow kind </font><code>-&gt;</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 的种类系统（即“类型中的类型”）是一个由单一种类 * 和箭头种类 -&gt; 组成的系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">κ <span class=fu>:</span> <span class=fu>*</span>
  <span class=fu>|</span> κ <span class=ot>-&gt;</span> κ</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Int</span><span class=ot> ::</span> <span class=fu>*</span>
<span class=dt>Maybe</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=dt>Either</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span></code></pre></div>
<p><font>There are in fact some extensions to this system that will be covered later ( see: PolyKinds and Unboxed types in later sections ) but most kinds in everyday code are simply either stars or arrows.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>事实上，这个系统有一些扩展将在后面介绍（参见：PolyKinds 和 Unboxed types in later sections），但日常代码中的大多数类型只是星号或箭头。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>With the KindSignatures extension enabled we can now annotate top level type signatures with their explicit kinds, bypassing the normal kind inference procedures.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用 KindSignatures 扩展后，我们现在可以使用显式类型注释顶级类型签名，从而绕过正常的类型推断过程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE KindSignatures #-}</span>

id<span class=ot> ::</span> forall (<span class=ot>a ::</span> <span class=fu>*</span>)<span class=fu>.</span> a <span class=ot>-&gt;</span> a
id x <span class=fu>=</span> x</code></pre></div>
<p><font>On top of default GADT declaration we can also constrain the parameters of the GADT to specific kinds. For basic usage Haskell's kind inference can deduce this reasonably well, but combined with some other type system extensions that extend the kind system this becomes essential.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在默认的 GADT 声明之上，我们还可以将 GADT 的参数限制为特定种类。对于基本用法，Haskell 的种类推断可以相当好地推断出这一点，但结合一些扩展种类系统的其他类型系统扩展，这变得必不可少。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/12-gadts/kindsignatures.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# Language GADTs #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>

<span class=kw>data</span> <span class=dt>Term</span><span class=ot> a ::</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Lit</span><span class=ot>    ::</span> a <span class=ot>-&gt;</span> <span class=dt>Term</span> a
  <span class=dt>Succ</span><span class=ot>   ::</span> <span class=dt>Term</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Term</span> <span class=dt>Int</span>
  <span class=dt>IsZero</span><span class=ot> ::</span> <span class=dt>Term</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Term</span> <span class=dt>Bool</span>
  <span class=dt>If</span><span class=ot>     ::</span> <span class=dt>Term</span> <span class=dt>Bool</span> <span class=ot>-&gt;</span> <span class=dt>Term</span> a <span class=ot>-&gt;</span> <span class=dt>Term</span> a <span class=ot>-&gt;</span> <span class=dt>Term</span> a

<span class=kw>data</span> <span class=dt>Vec</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>Vec</span> n a
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Vec</span> n a <span class=ot>-&gt;</span> <span class=dt>Vec</span> n a

<span class=kw>data</span> <span class=dt>Fix</span><span class=ot> ::</span> (<span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>In</span><span class=ot> ::</span> f (<span class=dt>Fix</span> f) <span class=ot>-&gt;</span> <span class=dt>Fix</span> f</code></pre></div>
<h2 id=void><font>Void</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>空白</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The Void type is the type with no inhabitants. It unifies only with itself.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Void 类型是没有居民的类型。它只与自身统一。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Using a newtype wrapper we can create a type where recursion makes it impossible to construct an inhabitant.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用新类型包装器，我们可以创建一个类型，其中递归使得无法构造居民。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Void :: Void -&gt; Void</span>
<span class=kw>newtype</span> <span class=dt>Void</span> <span class=fu>=</span> <span class=dt>Void</span> <span class=dt>Void</span></code></pre></div>
<p><font>Or using </font><code>-XEmptyDataDecls</code><font> we can also construct the uninhabited type equivalently as a data declaration with no constructors.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者使用 -XEmptyDataDecls 我们也可以将无人居住的类型等效地构造为没有构造函数的数据声明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Void</span></code></pre></div>
<p><font>The only inhabitant of both of these types is a diverging term like (</font><code>undefined</code><font>).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这两种类型的唯一居民是一个发散的术语，如（未定义）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=phantom-types><font>Phantom Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>幻影类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Phantom types are parameters that appear on the left hand side of a type declaration but which are not constrained by the values of the types inhabitants. They are effectively slots for us to encode additional information at the type-level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>虚类型是出现在类型声明左侧但不受类型居民值约束的参数。它们是我们在类型级别编码附加信息的有效槽。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/12-gadts/phantom.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Void</span>

<span class=kw>data</span> <span class=dt>Foo</span> tag a <span class=fu>=</span> <span class=dt>Foo</span> a

<span class=ot>combine ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>Foo</span> tag a <span class=ot>-&gt;</span> <span class=dt>Foo</span> tag a <span class=ot>-&gt;</span> <span class=dt>Foo</span> tag a
combine (<span class=dt>Foo</span> a) (<span class=dt>Foo</span> b) <span class=fu>=</span> <span class=dt>Foo</span> (a<span class=fu>+</span>b)

<span class=co>-- All identical at the value level, but differ at the type level.</span>
<span class=ot>a ::</span> <span class=dt>Foo</span> () <span class=dt>Int</span>
a <span class=fu>=</span> <span class=dt>Foo</span> <span class=dv>1</span>

<span class=ot>b ::</span> <span class=dt>Foo</span> t <span class=dt>Int</span>
b <span class=fu>=</span> <span class=dt>Foo</span> <span class=dv>1</span>

<span class=ot>c ::</span> <span class=dt>Foo</span> <span class=dt>Void</span> <span class=dt>Int</span>
c <span class=fu>=</span> <span class=dt>Foo</span> <span class=dv>1</span>

<span class=co>-- () ~ ()</span>
<span class=ot>example1 ::</span> <span class=dt>Foo</span> () <span class=dt>Int</span>
example1 <span class=fu>=</span> combine a a

<span class=co>-- t ~ ()</span>
<span class=ot>example2 ::</span> <span class=dt>Foo</span> () <span class=dt>Int</span>
example2 <span class=fu>=</span> combine a b

<span class=co>-- t0 ~ t1</span>
<span class=ot>example3 ::</span> <span class=dt>Foo</span> t <span class=dt>Int</span>
example3 <span class=fu>=</span> combine b b

<span class=co>-- Couldn't match type `t' with `Void'</span>
<span class=ot>example4 ::</span> <span class=dt>Foo</span> t <span class=dt>Int</span>
example4 <span class=fu>=</span> combine b c</code></pre></div>
<p><font>Notice the type variable </font><code>tag</code><font> does not appear in the right hand side of the declaration. Using this allows us to express invariants at the type-level that need not manifest at the value-level. We're effectively programming by adding extra information at the type-level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>注意类型变量标签没有出现在声明的右侧。使用它可以让我们在类型级别表达不需要在值级别表现出来的不变量。我们通过在类型级别添加额外信息来有效地进行编程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Consider the case of using newtypes to statically distinguish between plaintext and cryptotext.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑使用新类型静态区分明文和密文的情况。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Plaintext</span> <span class=fu>=</span> <span class=dt>Plaintext</span> <span class=dt>Text</span>
<span class=kw>newtype</span> <span class=dt>Crytpotext</span> <span class=fu>=</span> <span class=dt>Cryptotext</span> <span class=dt>Text</span>

<span class=ot>encrypt ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Plaintext</span> <span class=ot>-&gt;</span> <span class=dt>Cryptotext</span>
<span class=ot>decrypt ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Cryptotext</span> <span class=ot>-&gt;</span> <span class=dt>Plaintext</span></code></pre></div>
<p><font>Using phantom types we use an extra parameter.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用幻像类型，我们使用一个额外的参数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/12-gadts/phantom_example.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Text</span>

<span class=kw>data</span> <span class=dt>Cryptotext</span>
<span class=kw>data</span> <span class=dt>Plaintext</span>

<span class=kw>data</span> <span class=dt>Msg</span> a <span class=fu>=</span> <span class=dt>Msg</span> <span class=dt>Text</span>

<span class=ot>encrypt ::</span> <span class=dt>Msg</span> <span class=dt>Plaintext</span> <span class=ot>-&gt;</span> <span class=dt>Msg</span> <span class=dt>Cryptotext</span>
encrypt <span class=fu>=</span> undefined

<span class=ot>decrypt ::</span> <span class=dt>Msg</span> <span class=dt>Cryptotext</span> <span class=ot>-&gt;</span> <span class=dt>Msg</span> <span class=dt>Plaintext</span>
decrypt <span class=fu>=</span> undefined</code></pre></div>
<p><font>Using </font><code>-XEmptyDataDecls</code><font> can be a powerful combination with phantom types that contain no value inhabitants and are "anonymous types".</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 -XEmptyDataDecls 可以与不包含任何值居民并且是“匿名类型”的幻影类型形成强大的组合。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE EmptyDataDecls #-}</span>

<span class=kw>data</span> <span class=dt>Token</span> a</code></pre></div>
<p><font>See: </font><a href=http://www.researchgate.net/publication/228707929_Fun_with_phantom_types/file/9c960525654760c169.pdf>Fun with Phantom Types</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：幻影类型的乐趣</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=typelevel-operations><font>Typelevel Operations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级操作</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>With a richer language for datatypes we can express terms that witness the relationship between terms in the constructors, for example we can now express a term which expresses propositional equality between two types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用更丰富的数据类型语言，我们可以表达证明构造函数中术语之间关系的术语，例如，我们现在可以表达一个表达两种类型之间命题相等性的术语。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The type </font><code>Eql a b</code><font> is a proof that types </font><code>a</code><font> and </font><code>b</code><font> are equal, by pattern matching on the single </font><code>Refl</code><font> constructor we introduce the equality constraint into the body of the pattern match.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型 Eql a b 是类型 a 和 b 相等的证明，通过在单个 Refl 构造函数上进行模式匹配，我们将等式约束引入模式匹配的主体中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/12-gadts/equal.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>

<span class=co>-- a ≡ b</span>
<span class=kw>data</span> <span class=dt>Eql</span> a b <span class=kw>where</span>
  <span class=dt>Refl</span><span class=ot> ::</span> <span class=dt>Eql</span> a a

<span class=co>-- Congruence</span>
<span class=co>-- (f : A → B) {x y} → x ≡ y → f x ≡ f y</span>
<span class=ot>cong ::</span> <span class=dt>Eql</span> a b <span class=ot>-&gt;</span> <span class=dt>Eql</span> (f a) (f b)
cong <span class=dt>Refl</span> <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- Symmetry</span>
<span class=co>-- {a b : A} → a ≡ b → a ≡ b</span>
<span class=ot>sym ::</span> <span class=dt>Eql</span> a b <span class=ot>-&gt;</span> <span class=dt>Eql</span> b a
sym <span class=dt>Refl</span> <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- Transitivity</span>
<span class=co>-- {a b c : A} → a ≡ b → b ≡ c → a ≡ c</span>
<span class=ot>trans ::</span> <span class=dt>Eql</span> a b <span class=ot>-&gt;</span> <span class=dt>Eql</span> b c <span class=ot>-&gt;</span> <span class=dt>Eql</span> a c
trans <span class=dt>Refl</span> <span class=dt>Refl</span> <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- Coerce one type to another given a proof of their equality.</span>
<span class=co>-- {a b : A} → a ≡ b → a → b</span>
<span class=ot>castWith ::</span> <span class=dt>Eql</span> a b <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
castWith <span class=dt>Refl</span> <span class=fu>=</span> id

<span class=co>-- Trivial cases</span>
<span class=ot>a ::</span> forall n<span class=fu>.</span> <span class=dt>Eql</span> n n
a <span class=fu>=</span> <span class=dt>Refl</span>

<span class=ot>b ::</span> forall<span class=fu>.</span> <span class=dt>Eql</span> () ()
b <span class=fu>=</span> <span class=dt>Refl</span></code></pre></div>
<p><font>As of GHC 7.8 these constructors and functions are included in the Prelude in the </font><a href=http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Type-Equality.html>Data.Type.Equality</a><font> module.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 GHC 7.8 开始，这些构造函数和函数包含在 Data.Type.Equality 模块的 Prelude 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h1 id=interpreters><font>Interpreters</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>口译员</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>The lambda calculus forms the theoretical and practical foundation for many languages. At the heart of every calculus is three components:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>lambda 演算构成了许多语言的理论和实践基础。每个微积分的核心都是三个组成部分：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><strong>Var</strong><font> - A variable</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Var - 一个变量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Lam</strong><font> - A lambda abstraction</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Lam - 一个 lambda 抽象</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>App</strong><font> - An application</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>App - 一个应用程序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<div class=center>
<div class=figure>
<img src="data:image/png;base64,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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/lambda.png>
</div>
</div>
<p><font>There are many different ways of modeling these constructions and data structure representations, but they all more or less contain these three elements. For example, a lambda calculus that uses String names on lambda binders and variables might be written like the following:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对这些构造和数据结构表示进行建模的方法有很多种，但它们或多或少都包含这三个元素。例如，在 lambda 绑定器和变量上使用字符串名称的 lambda 演算可能如下所示：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>Name</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Exp</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>Name</span>
  <span class=fu>|</span> <span class=dt>Lam</span> <span class=dt>Name</span> <span class=dt>Exp</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Exp</span> <span class=dt>Exp</span></code></pre></div>
<p><font>A lambda expression in which all variables that appear in the body of the expression are referenced in an outer lambda binder is said to be </font><em>closed</em><font> while an expression with unbound free variables is </font><em>open</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个 lambda 表达式，其中出现在表达式主体中的所有变量都在外部 lambda 绑定器中被引用，而具有未绑定自由变量的表达式是开放的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=hoas><font>HOAS</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>HOAS</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Higher Order Abstract Syntax (</font><em>HOAS</em><font>) is a technique for implementing the lambda calculus in a language where the binders of the lambda expression map directly onto lambda binders of the host language ( i.e. Haskell ) to give us substitution machinery in our custom language by exploiting Haskell's implementation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>高阶抽象语法 (HOAS) 是一种在语言中实现 lambda 演算的技术，其中 lambda 表达式的绑定器直接映射到宿主语言（即 Haskell）的 lambda 绑定器，通过利用 Haskell 的执行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/13-lambda-calculus/hoas.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>

<span class=kw>data</span> <span class=dt>Expr</span> a <span class=kw>where</span>
  <span class=dt>Con</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span> a
  <span class=dt>Lam</span><span class=ot> ::</span> (<span class=dt>Expr</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span> b) <span class=ot>-&gt;</span> <span class=dt>Expr</span> (a <span class=ot>-&gt;</span> b)
  <span class=dt>App</span><span class=ot> ::</span> <span class=dt>Expr</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> <span class=dt>Expr</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span> b

<span class=ot>i ::</span> <span class=dt>Expr</span> (a <span class=ot>-&gt;</span> a)
i <span class=fu>=</span> <span class=dt>Lam</span> (\x <span class=ot>-&gt;</span> x)

<span class=ot>k ::</span> <span class=dt>Expr</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a)
k <span class=fu>=</span> <span class=dt>Lam</span> (\x <span class=ot>-&gt;</span> <span class=dt>Lam</span> (\y <span class=ot>-&gt;</span> x))

<span class=ot>s ::</span> <span class=dt>Expr</span> ((a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> c))
s <span class=fu>=</span> <span class=dt>Lam</span> (\x <span class=ot>-&gt;</span> <span class=dt>Lam</span> (\y <span class=ot>-&gt;</span> <span class=dt>Lam</span> (\z <span class=ot>-&gt;</span> <span class=dt>App</span> (<span class=dt>App</span> x z) (<span class=dt>App</span> y z))))

<span class=ot>eval ::</span> <span class=dt>Expr</span> a <span class=ot>-&gt;</span> a
eval (<span class=dt>Con</span> v) <span class=fu>=</span> v
eval (<span class=dt>Lam</span> f) <span class=fu>=</span> \x <span class=ot>-&gt;</span> eval (f (<span class=dt>Con</span> x))
eval (<span class=dt>App</span> e1 e2) <span class=fu>=</span> (eval e1) (eval e2)


<span class=ot>skk ::</span> <span class=dt>Expr</span> (a <span class=ot>-&gt;</span> a)
skk <span class=fu>=</span> <span class=dt>App</span> (<span class=dt>App</span> s k) k

<span class=ot>example ::</span> <span class=dt>Integer</span>
example <span class=fu>=</span> eval skk <span class=dv>1</span>
<span class=co>-- 1</span></code></pre></div>
<p><font>Pretty printing HOAS terms can also be quite complicated since the body of the function is under a Haskell lambda binder.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂亮的打印 HOAS 术语也可能非常复杂，因为函数体位于 Haskell lambda 活页夹下。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=phoas><font>PHOAS</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>恐惧症</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A slightly different form of HOAS called PHOAS uses lambda datatype parameterized over the binder type. In this form evaluation requires unpacking into a separate Value type to wrap the lambda expression.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一种略有不同的 HOAS 形式称为 PHOAS，它使用在 binder 类型上参数化的 lambda 数据类型。在这种形式中，求值需要解包成一个单独的值类型来包装 lambda 表达式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/13-lambda-calculus/phoas.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RankNTypes #-}</span>

<span class=kw>data</span> <span class=dt>ExprP</span> a
  <span class=fu>=</span> <span class=dt>VarP</span> a
  <span class=fu>|</span> <span class=dt>AppP</span> (<span class=dt>ExprP</span> a) (<span class=dt>ExprP</span> a)
  <span class=fu>|</span> <span class=dt>LamP</span> (a <span class=ot>-&gt;</span> <span class=dt>ExprP</span> a)
  <span class=fu>|</span> <span class=dt>LitP</span> <span class=dt>Integer</span>

<span class=kw>data</span> <span class=dt>Value</span>
  <span class=fu>=</span> <span class=dt>VLit</span> <span class=dt>Integer</span>
  <span class=fu>|</span> <span class=dt>VFun</span> (<span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Value</span>)

<span class=ot>fromVFun ::</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> (<span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Value</span>)
fromVFun val <span class=fu>=</span> <span class=kw>case</span> val <span class=kw>of</span>
  <span class=dt>VFun</span> f <span class=ot>-&gt;</span> f
  _      <span class=ot>-&gt;</span> error <span class=st>"not a function"</span>

<span class=ot>fromVLit ::</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Integer</span>
fromVLit val <span class=fu>=</span> <span class=kw>case</span> val <span class=kw>of</span>
  <span class=dt>VLit</span> n <span class=ot>-&gt;</span> n
  _      <span class=ot>-&gt;</span> error <span class=st>"not a integer"</span>

<span class=kw>newtype</span> <span class=dt>Expr</span> <span class=fu>=</span> <span class=dt>Expr</span> {<span class=ot> unExpr ::</span> forall a <span class=fu>.</span> <span class=dt>ExprP</span> a }

<span class=ot>eval ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Value</span>
eval e <span class=fu>=</span> ev (unExpr e) <span class=kw>where</span>
  ev (<span class=dt>LamP</span> f)      <span class=fu>=</span> <span class=dt>VFun</span>(ev <span class=fu>.</span> f)
  ev (<span class=dt>VarP</span> v)      <span class=fu>=</span> v
  ev (<span class=dt>AppP</span> e1 e2)  <span class=fu>=</span> fromVFun (ev e1) (ev e2)
  ev (<span class=dt>LitP</span> n)      <span class=fu>=</span> <span class=dt>VLit</span> n

<span class=ot>i ::</span> <span class=dt>ExprP</span> a
i <span class=fu>=</span> <span class=dt>LamP</span> (\a <span class=ot>-&gt;</span> <span class=dt>VarP</span> a)

<span class=ot>k ::</span> <span class=dt>ExprP</span> a
k <span class=fu>=</span> <span class=dt>LamP</span> (\x <span class=ot>-&gt;</span> <span class=dt>LamP</span> (\y <span class=ot>-&gt;</span> <span class=dt>VarP</span> x))

<span class=ot>s ::</span> <span class=dt>ExprP</span> a
s <span class=fu>=</span> <span class=dt>LamP</span> (\x <span class=ot>-&gt;</span> <span class=dt>LamP</span> (\y <span class=ot>-&gt;</span> <span class=dt>LamP</span> (\z <span class=ot>-&gt;</span> <span class=dt>AppP</span> (<span class=dt>AppP</span> (<span class=dt>VarP</span> x) (<span class=dt>VarP</span> z)) (<span class=dt>AppP</span> (<span class=dt>VarP</span> y) (<span class=dt>VarP</span> z)))))

<span class=ot>skk ::</span> <span class=dt>ExprP</span> a
skk <span class=fu>=</span> <span class=dt>AppP</span> (<span class=dt>AppP</span> s k) k

<span class=ot>example ::</span> <span class=dt>Integer</span>
example <span class=fu>=</span> fromVLit <span class=fu>$</span> eval <span class=fu>$</span> <span class=dt>Expr</span> (<span class=dt>AppP</span> skk (<span class=dt>LitP</span> <span class=dv>3</span>))</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08Talk.pdf>PHOAS<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>恐惧症</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf>Encoding Higher-Order Abstract Syntax with Parametric Polymorphism<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>使用参数多态性编码高阶抽象语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=final-interpreters><font>Final Interpreters</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>最终口译员</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using typeclasses we can implement a </font><em>final interpreter</em><font> which models a set of extensible terms using functions bound to typeclasses rather than data constructors. Instances of the typeclass form interpreters over these terms.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用类型类，我们可以实现一个最终解释器，它使用绑定到类型类而不是数据构造函数的函数对一组可扩展术语进行建模。类型类的实例构成了这些术语的解释器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example we can write a small language that includes basic arithmetic, and then retroactively extend our expression language with a multiplication operator without changing the base. At the same time our interpreter logic remains invariant under extension with new expressions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们可以编写一种包含基本算术的小型语言，然后在不改变基数的情况下用乘法运算符追溯扩展我们的表达式语言。同时，我们的解释器逻辑在新表达式的扩展下保持不变。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/14-interpreters/fext.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class=ot>{-# LANGUAGE NoMonomorphismRestriction #-}</span>

<span class=kw>class</span> <span class=dt>Expr</span> repr <span class=kw>where</span>
<span class=ot>  lit ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> repr
<span class=ot>  neg ::</span> repr <span class=ot>-&gt;</span> repr
<span class=ot>  add ::</span> repr <span class=ot>-&gt;</span> repr <span class=ot>-&gt;</span> repr
<span class=ot>  mul ::</span> repr <span class=ot>-&gt;</span> repr <span class=ot>-&gt;</span> repr

<span class=kw>instance</span> <span class=dt>Expr</span> <span class=dt>Int</span> <span class=kw>where</span>
  lit n <span class=fu>=</span> n
  neg a <span class=fu>=</span> <span class=fu>-</span>a
  add a b <span class=fu>=</span> a <span class=fu>+</span> b
  mul a b <span class=fu>=</span> a <span class=fu>*</span> b

<span class=kw>instance</span> <span class=dt>Expr</span> <span class=dt>String</span> <span class=kw>where</span>
  lit n <span class=fu>=</span> show n
  neg a <span class=fu>=</span> <span class=st>"(-"</span> <span class=fu>++</span> a <span class=fu>++</span> <span class=st>")"</span>
  add a b <span class=fu>=</span> <span class=st>"("</span> <span class=fu>++</span> a <span class=fu>++</span> <span class=st>" + "</span> <span class=fu>++</span> b <span class=fu>++</span> <span class=st>")"</span>
  mul a b <span class=fu>=</span> <span class=st>"("</span> <span class=fu>++</span> a <span class=fu>++</span> <span class=st>" * "</span> <span class=fu>++</span> b <span class=fu>++</span> <span class=st>")"</span>

<span class=kw>class</span> <span class=dt>BoolExpr</span> repr <span class=kw>where</span>
<span class=ot>  eq ::</span> repr <span class=ot>-&gt;</span> repr <span class=ot>-&gt;</span> repr
<span class=ot>  tr ::</span> repr
<span class=ot>  fl ::</span> repr

<span class=kw>instance</span> <span class=dt>BoolExpr</span> <span class=dt>Int</span> <span class=kw>where</span>
  eq a b <span class=fu>=</span> <span class=kw>if</span> a <span class=fu>==</span> b <span class=kw>then</span> tr <span class=kw>else</span> fl
  tr <span class=fu>=</span> <span class=dv>1</span>
  fl <span class=fu>=</span> <span class=dv>0</span>

<span class=kw>instance</span> <span class=dt>BoolExpr</span> <span class=dt>String</span> <span class=kw>where</span>
  eq a b <span class=fu>=</span> <span class=st>"("</span> <span class=fu>++</span> a <span class=fu>++</span> <span class=st>" == "</span> <span class=fu>++</span> b <span class=fu>++</span> <span class=st>")"</span>
  tr <span class=fu>=</span> <span class=st>"true"</span>
  fl <span class=fu>=</span> <span class=st>"false"</span>

<span class=ot>eval ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
eval <span class=fu>=</span> id

<span class=ot>render ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
render <span class=fu>=</span> id

<span class=ot>expr ::</span> (<span class=dt>BoolExpr</span> repr, <span class=dt>Expr</span> repr) <span class=ot>=&gt;</span> repr
expr <span class=fu>=</span> eq (add (lit <span class=dv>1</span>) (lit <span class=dv>2</span>)) (lit <span class=dv>3</span>)

<span class=ot>result ::</span> <span class=dt>Int</span>
result <span class=fu>=</span> eval expr
<span class=co>-- 1</span>

<span class=ot>string ::</span> <span class=dt>String</span>
string <span class=fu>=</span> render expr
<span class=co>-- "((1 + 2) == 3)"</span></code></pre></div>
<h2 id=finally-tagless><font>Finally Tagless</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>终于无标签</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Writing an evaluator for the lambda calculus can likewise also be modeled with a final interpreter and a Identity functor.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为 lambda 演算编写求值器同样可以用最终解释器和恒等函子建模。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/14-interpreters/final.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (id)

<span class=kw>class</span> <span class=dt>Expr</span> rep <span class=kw>where</span>
<span class=ot>  lam ::</span> (rep a <span class=ot>-&gt;</span> rep b) <span class=ot>-&gt;</span> rep (a <span class=ot>-&gt;</span> b)
<span class=ot>  app ::</span> rep (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> (rep a <span class=ot>-&gt;</span> rep b)
<span class=ot>  lit ::</span> a <span class=ot>-&gt;</span> rep a

<span class=kw>newtype</span> <span class=dt>Interpret</span> a <span class=fu>=</span> <span class=dt>R</span> {<span class=ot> reify ::</span> a }

<span class=kw>instance</span> <span class=dt>Expr</span> <span class=dt>Interpret</span> <span class=kw>where</span>
  lam f   <span class=fu>=</span> <span class=dt>R</span> <span class=fu>$</span> reify <span class=fu>.</span> f <span class=fu>.</span> <span class=dt>R</span>
  app f a <span class=fu>=</span> <span class=dt>R</span> <span class=fu>$</span> reify f <span class=fu>$</span> reify a
  lit     <span class=fu>=</span> <span class=dt>R</span>

<span class=ot>eval ::</span> <span class=dt>Interpret</span> a <span class=ot>-&gt;</span> a
eval e <span class=fu>=</span> reify e

<span class=ot>e1 ::</span> <span class=dt>Expr</span> rep <span class=ot>=&gt;</span> rep <span class=dt>Int</span>
e1 <span class=fu>=</span> app (lam (\x <span class=ot>-&gt;</span> x)) (lit <span class=dv>3</span>)

<span class=ot>e2 ::</span> <span class=dt>Expr</span> rep <span class=ot>=&gt;</span> rep <span class=dt>Int</span>
e2 <span class=fu>=</span> app (lam (\x <span class=ot>-&gt;</span> lit <span class=dv>4</span>)) (lam <span class=fu>$</span> \x <span class=ot>-&gt;</span> lam <span class=fu>$</span> \y <span class=ot>-&gt;</span> y)

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> eval e1
<span class=co>-- 3</span>

<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> eval e2
<span class=co>-- 4</span></code></pre></div>
<p><font>See: </font><a href=http://okmij.org/ftp/tagless-final/>Typed Tagless Interpretations and Typed Compilation</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：类型化无标记解释和类型化编译</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=datatypes><font>Datatypes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The usual hand-wavy of describing algebraic datatypes is to indicate the how natural correspondence between sum types, product types, and polynomial expressions arises.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述代数数据类型的常用技巧是指出求和类型、乘积类型和多项式表达式之间的自然对应关系是如何产生的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Void</span>                       <span class=co>-- 0</span>
<span class=kw>data</span> <span class=dt>Unit</span>     <span class=fu>=</span> <span class=dt>Unit</span>            <span class=co>-- 1</span>
<span class=kw>data</span> <span class=dt>Sum</span> a b  <span class=fu>=</span> <span class=dt>Inl</span> a <span class=fu>|</span> <span class=dt>Inr</span> b   <span class=co>-- a + b</span>
<span class=kw>data</span> <span class=dt>Prod</span> a b <span class=fu>=</span> <span class=dt>Prod</span> a b        <span class=co>-- a * b</span>
<span class=kw>type</span> (<span class=ot>-&gt;</span>) a b <span class=fu>=</span> a <span class=ot>-&gt;</span> b          <span class=co>-- b ^ a</span></code></pre></div>
<p><font>Intuitively it follows the notion that the cardinality of set of inhabitants of a type can always be given as a function of the number of its holes. A product type admits a number of inhabitants as a function of the product (i.e. cardinality of the Cartesian product), a sum type as the sum of its holes and a function type as the exponential of the span of the domain and codomain.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>直观上它遵循这样的概念，即一个类型的居民集合的基数总是可以作为其孔数的函数给出。乘积类型允许许多居民作为乘积的函数（即笛卡尔乘积的基数），作为其空穴之和的和类型以及作为域和余域跨度指数的函数类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- 1 + A</span>
<span class=kw>data</span> <span class=dt>Maybe</span> a <span class=fu>=</span> <span class=dt>Nothing</span> <span class=fu>|</span> <span class=dt>Just</span> a</code></pre></div>
<p><font>Recursive types are correspond to infinite series of these terms.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>递归类型对应于这些术语的无限系列。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- pseudocode</span>

<span class=co>-- μX. 1 + X</span>
<span class=kw>data</span> <span class=dt>Nat</span> a <span class=fu>=</span> <span class=dt>Z</span> <span class=fu>|</span> <span class=dt>S</span> <span class=dt>Nat</span>
<span class=dt>Nat</span> a <span class=fu>=</span> μ a<span class=fu>.</span> <span class=dv>1</span> <span class=fu>+</span> a
      <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> (<span class=dv>1</span> <span class=fu>+</span> (<span class=dv>1</span> <span class=fu>+</span> <span class=fu>...</span>))

<span class=co>-- μX. 1 + A * X</span>
<span class=kw>data</span> <span class=dt>List</span> a <span class=fu>=</span> <span class=dt>Nil</span> <span class=fu>|</span> <span class=dt>Cons</span> a (<span class=dt>List</span> a)
<span class=dt>List</span> a <span class=fu>=</span> μ a<span class=fu>.</span> <span class=dv>1</span> <span class=fu>+</span> a <span class=fu>*</span> (<span class=dt>List</span> a)
       <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> a <span class=fu>+</span> a<span class=fu>^</span><span class=dv>2</span> <span class=fu>+</span> a<span class=fu>^</span><span class=dv>3</span> <span class=fu>+</span> a<span class=fu>^</span><span class=dv>4</span> <span class=fu>...</span>

<span class=co>-- μX. A + A*X*X</span>
<span class=kw>data</span> <span class=dt>Tree</span> a f <span class=fu>=</span> <span class=dt>Leaf</span> a <span class=fu>|</span> <span class=dt>Tree</span> a f f
<span class=dt>Tree</span> a <span class=fu>=</span> μ a<span class=fu>.</span> <span class=dv>1</span> <span class=fu>+</span> a <span class=fu>*</span> (<span class=dt>List</span> a)
       <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> a<span class=fu>^</span><span class=dv>2</span> <span class=fu>+</span> a<span class=fu>^</span><span class=dv>4</span> <span class=fu>+</span> a<span class=fu>^</span><span class=dv>6</span> <span class=fu>+</span> a<span class=fu>^</span><span class=dv>8</span> <span class=fu>...</span></code></pre></div>
<p><font>See: </font><a href=http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf>Species and Functors and Types, Oh My!</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：物种、函子和类型，天啊！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=f-algebras><font>F-Algebras</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>F代数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>The </font><em>initial algebra</em><font> approach differs from the final interpreter approach in that we now represent our terms as algebraic datatypes and the interpreter implements recursion and evaluation occurs through pattern matching.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始代数方法与最终解释器方法的不同之处在于，我们现在将我们的术语表示为代数数据类型，并且解释器通过模式匹配实现递归和评估。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>Algebra</span> f a <span class=fu>=</span> f a <span class=ot>-&gt;</span> a
<span class=kw>type</span> <span class=dt>Coalgebra</span> f a <span class=fu>=</span> a <span class=ot>-&gt;</span> f a
<span class=kw>newtype</span> <span class=dt>Fix</span> f <span class=fu>=</span> <span class=dt>Fix</span> {<span class=ot> unFix ::</span> f (<span class=dt>Fix</span> f) }

<span class=ot>cata ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> a
<span class=ot>ana  ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f
<span class=ot>hylo ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f b <span class=ot>-&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b</code></pre></div>
<p><font>In Haskell a F-algebra is a functor </font><code>f a</code><font> together with a function </font><code>f a -&gt; a</code><font>. A coalgebra reverses the function. For a functor </font><code>f</code><font> we can form its recursive unrolling using the recursive </font><code>Fix</code><font> newtype wrapper.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Haskell 中，F-代数是一个函子 f a 和一个函数 f a -&gt; a。余代数反转函数。对于函子 f，我们可以使用递归 Fix 新类型包装器形成它的递归展开。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>newtype</span> <span class=dt>Fix</span> f <span class=fu>=</span> <span class=dt>Fix</span> {<span class=ot> unFix ::</span> f (<span class=dt>Fix</span> f) }

<span class=dt>Fix</span><span class=ot> ::</span> f (<span class=dt>Fix</span> f) <span class=ot>-&gt;</span> <span class=dt>Fix</span> f
<span class=ot>unFix ::</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> f (<span class=dt>Fix</span> f)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Fix</span> f <span class=fu>=</span> f (f (f (f (f (f ( <span class=fu>...</span> ))))))

<span class=kw>newtype</span> <span class=dt>T</span> b a <span class=fu>=</span> <span class=dt>T</span> (a <span class=ot>-&gt;</span> b)

<span class=dt>Fix</span> (<span class=dt>T</span> a)
<span class=dt>Fix</span> <span class=dt>T</span> <span class=ot>-&gt;</span> a
(<span class=dt>Fix</span> <span class=dt>T</span> <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a
(<span class=dt>Fix</span> <span class=dt>T</span> <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
<span class=fu>...</span></code></pre></div>
<p><font>In this form we can write down a generalized fold/unfold function that are datatype generic and written purely in terms of the recursing under the functor.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在这种形式中，我们可以写下一个通用的折叠/展开函数，它是通用数据类型，并且纯粹根据函子下的递归编写。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>cata ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> a
cata alg <span class=fu>=</span> alg <span class=fu>.</span> fmap (cata alg) <span class=fu>.</span> unFix

<span class=ot>ana ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f
ana coalg <span class=fu>=</span> <span class=dt>Fix</span> <span class=fu>.</span> fmap (ana coalg) <span class=fu>.</span> coalg</code></pre></div>
<p><font>We call these functions </font><em>catamorphisms</em><font> and </font><em>anamorphisms</em><font>. Notice especially that the types of these two functions simply reverse the direction of arrows. Interpreted in another way they transform an algebra/coalgebra which defines a flat structure-preserving mapping between </font><code>Fix f</code> <code>f</code><font> into a function which either rolls or unrolls the fixpoint. What is particularly nice about this approach is that the recursion is abstracted away inside the functor definition and we are free to just implement the flat transformation logic!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们称这些函数为变形和变形。请特别注意，这两个函数的类型只是简单地反转了箭头的方向。以另一种方式解释，他们将定义 Fix f f 之间的平面结构保留映射的代数/余代数转换为滚动或展开固定点的函数。这种方法特别好的是递归被抽象到仿函数定义中，我们可以自由地实现平面转换逻辑！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example a construction of the natural numbers in this form:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，以这种形式构造自然数：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/14-interpreters/initial.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE DeriveFunctor #-}</span>
<span class=ot>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>type</span> <span class=dt>Algebra</span> f a <span class=fu>=</span> f a <span class=ot>-&gt;</span> a
<span class=kw>type</span> <span class=dt>Coalgebra</span> f a <span class=fu>=</span> a <span class=ot>-&gt;</span> f a

<span class=kw>newtype</span> <span class=dt>Fix</span> f <span class=fu>=</span> <span class=dt>Fix</span> {<span class=ot> unFix ::</span> f (<span class=dt>Fix</span> f) }

<span class=co>-- catamorphism</span>
<span class=ot>cata ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> a
cata alg <span class=fu>=</span> alg <span class=fu>.</span> fmap (cata alg) <span class=fu>.</span> unFix

<span class=co>-- anamorphism</span>
<span class=ot>ana ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f
ana coalg <span class=fu>=</span> <span class=dt>Fix</span> <span class=fu>.</span> fmap (ana coalg) <span class=fu>.</span> coalg

<span class=co>-- hylomorphism</span>
<span class=ot>hylo ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f b <span class=ot>-&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
hylo f g <span class=fu>=</span> cata f <span class=fu>.</span> ana g

<span class=kw>type</span> <span class=dt>Nat</span> <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>NatF</span>
<span class=kw>data</span> <span class=dt>NatF</span> a <span class=fu>=</span> <span class=dt>S</span> a <span class=fu>|</span> <span class=dt>Z</span> <span class=kw>deriving</span> (<span class=dt>Eq</span>,<span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Functor</span> <span class=dt>NatF</span> <span class=kw>where</span>
  fmap f <span class=dt>Z</span>     <span class=fu>=</span> <span class=dt>Z</span>
  fmap f (<span class=dt>S</span> x) <span class=fu>=</span> <span class=dt>S</span> (f x)

<span class=ot>plus ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
plus n <span class=fu>=</span> cata phi <span class=kw>where</span>
  phi <span class=dt>Z</span>     <span class=fu>=</span> n
  phi (<span class=dt>S</span> m) <span class=fu>=</span> s m

<span class=ot>times ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
times n <span class=fu>=</span> cata phi <span class=kw>where</span>
  phi <span class=dt>Z</span>     <span class=fu>=</span> z
  phi (<span class=dt>S</span> m) <span class=fu>=</span> plus n m

<span class=ot>int ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
int <span class=fu>=</span> cata phi <span class=kw>where</span>
  phi  <span class=dt>Z</span>    <span class=fu>=</span> <span class=dv>0</span>
  phi (<span class=dt>S</span> f) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> f

<span class=ot>nat ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
nat <span class=fu>=</span> ana (psi <span class=dt>Z</span> <span class=dt>S</span>) <span class=kw>where</span>
  psi f _ <span class=dv>0</span> <span class=fu>=</span> f
  psi _ f n <span class=fu>=</span> f (n<span class=fu>-</span><span class=dv>1</span>)

<span class=ot>z ::</span> <span class=dt>Nat</span>
z <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>Z</span>

<span class=ot>s ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
s <span class=fu>=</span> <span class=dt>Fix</span> <span class=fu>.</span> <span class=dt>S</span>


<span class=kw>type</span> <span class=dt>Str</span> <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>StrF</span>
<span class=kw>data</span> <span class=dt>StrF</span> x <span class=fu>=</span> <span class=dt>Cons</span> <span class=dt>Char</span> x <span class=fu>|</span> <span class=dt>Nil</span>

<span class=kw>instance</span> <span class=dt>Functor</span> <span class=dt>StrF</span> <span class=kw>where</span>
  fmap f (<span class=dt>Cons</span> a as) <span class=fu>=</span> <span class=dt>Cons</span> a (f as)
  fmap f <span class=dt>Nil</span> <span class=fu>=</span> <span class=dt>Nil</span>

<span class=ot>nil ::</span> <span class=dt>Str</span>
nil <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>Nil</span>

<span class=ot>cons ::</span> <span class=dt>Char</span> <span class=ot>-&gt;</span> <span class=dt>Str</span> <span class=ot>-&gt;</span> <span class=dt>Str</span>
cons x xs <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>Cons</span> x xs)

<span class=ot>str ::</span> <span class=dt>Str</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
str <span class=fu>=</span> cata phi <span class=kw>where</span>
  phi <span class=dt>Nil</span>         <span class=fu>=</span> []
  phi (<span class=dt>Cons</span> x xs) <span class=fu>=</span> x <span class=fu>:</span> xs

<span class=ot>str' ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Str</span>
str' <span class=fu>=</span> ana (psi <span class=dt>Nil</span> <span class=dt>Cons</span>) <span class=kw>where</span>
  psi f _ []     <span class=fu>=</span> f
  psi _ f (a<span class=fu>:</span>as) <span class=fu>=</span> f a as

<span class=ot>map' ::</span> (<span class=dt>Char</span> <span class=ot>-&gt;</span> <span class=dt>Char</span>) <span class=ot>-&gt;</span> <span class=dt>Str</span> <span class=ot>-&gt;</span> <span class=dt>Str</span>
map' f <span class=fu>=</span> hylo g unFix
  <span class=kw>where</span>
    g <span class=dt>Nil</span>        <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>Nil</span>
    g (<span class=dt>Cons</span> a x) <span class=fu>=</span> <span class=dt>Fix</span> <span class=fu>$</span> <span class=dt>Cons</span> (f a) x


<span class=kw>type</span> <span class=dt>Tree</span> a <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>TreeF</span> a)
<span class=kw>data</span> <span class=dt>TreeF</span> a f <span class=fu>=</span> <span class=dt>Leaf</span> a <span class=fu>|</span> <span class=dt>Tree</span> a f f <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Functor</span> (<span class=dt>TreeF</span> a) <span class=kw>where</span>
  fmap f (<span class=dt>Leaf</span> a) <span class=fu>=</span> <span class=dt>Leaf</span> a
  fmap f (<span class=dt>Tree</span> a b c) <span class=fu>=</span> <span class=dt>Tree</span> a (f b) (f c)

<span class=ot>depth ::</span> <span class=dt>Tree</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>
depth <span class=fu>=</span> cata phi <span class=kw>where</span>
  phi (<span class=dt>Leaf</span> _)     <span class=fu>=</span> <span class=dv>0</span>
  phi (<span class=dt>Tree</span> _ l r) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> max l r


<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> int (plus (nat <span class=dv>125</span>) (nat <span class=dv>25</span>))
<span class=co>-- 150</span></code></pre></div>
<p><font>Or for example an interpreter for a small expression language that depends on a scoping dictionary.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者例如依赖于作用域字典的小型表达式语言的解释器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/14-interpreters/initial_interpreter.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DeriveFunctor #-}</span>
<span class=ot>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>M</span>

<span class=kw>type</span> <span class=dt>Algebra</span> f a <span class=fu>=</span> f a <span class=ot>-&gt;</span> a
<span class=kw>type</span> <span class=dt>Coalgebra</span> f a <span class=fu>=</span> a <span class=ot>-&gt;</span> f a

<span class=kw>newtype</span> <span class=dt>Fix</span> f <span class=fu>=</span> <span class=dt>Fix</span> {<span class=ot> unFix ::</span> f (<span class=dt>Fix</span> f) }

<span class=ot>cata ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> a
cata alg <span class=fu>=</span> alg <span class=fu>.</span> fmap (cata alg) <span class=fu>.</span> unFix

<span class=ot>ana ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f
ana coalg <span class=fu>=</span> <span class=dt>Fix</span> <span class=fu>.</span> fmap (ana coalg) <span class=fu>.</span> coalg

<span class=ot>hylo ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Algebra</span> f b <span class=ot>-&gt;</span> <span class=dt>Coalgebra</span> f a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
hylo f g <span class=fu>=</span> cata f <span class=fu>.</span> ana g

<span class=kw>type</span> <span class=dt>Id</span> <span class=fu>=</span> <span class=dt>String</span>
<span class=kw>type</span> <span class=dt>Env</span> <span class=fu>=</span> <span class=dt>M.Map</span> <span class=dt>Id</span> <span class=dt>Int</span>

<span class=kw>type</span> <span class=dt>Expr</span> <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>
<span class=kw>data</span> <span class=dt>ExprF</span> a
  <span class=fu>=</span> <span class=dt>Lit</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>Var</span> <span class=dt>Id</span>
  <span class=fu>|</span> <span class=dt>Add</span> a a
  <span class=fu>|</span> <span class=dt>Mul</span> a a
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Eq</span>, <span class=dt>Ord</span>, <span class=dt>Functor</span>)

<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Eq</span> (f (<span class=dt>Fix</span> f)) <span class=ot>=&gt;</span> <span class=dt>Eq</span> (<span class=dt>Fix</span> f)
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Ord</span> (f (<span class=dt>Fix</span> f)) <span class=ot>=&gt;</span> <span class=dt>Ord</span> (<span class=dt>Fix</span> f)
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> (f (<span class=dt>Fix</span> f)) <span class=ot>=&gt;</span> <span class=dt>Show</span> (<span class=dt>Fix</span> f)

<span class=ot>eval ::</span> <span class=dt>M.Map</span> <span class=dt>Id</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Fix</span> <span class=dt>ExprF</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
eval env <span class=fu>=</span> cata phi <span class=kw>where</span>
  phi ex <span class=fu>=</span> <span class=kw>case</span> ex <span class=kw>of</span>
    <span class=dt>Lit</span> c   <span class=ot>-&gt;</span> pure c
    <span class=dt>Var</span> i   <span class=ot>-&gt;</span> M.lookup i env
    <span class=dt>Add</span> x y <span class=ot>-&gt;</span> liftA2 (<span class=fu>+</span>) x y
    <span class=dt>Mul</span> x y <span class=ot>-&gt;</span> liftA2 (<span class=fu>*</span>) x y

<span class=ot>expr ::</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>Mul</span> n (<span class=dt>Fix</span> (<span class=dt>Add</span> x y)))
  <span class=kw>where</span>
    n <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>Lit</span> <span class=dv>10</span>)
    x <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>Var</span> <span class=st>"x"</span>)
    y <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>Var</span> <span class=st>"y"</span>)

<span class=ot>env ::</span> <span class=dt>M.Map</span> <span class=dt>Id</span> <span class=dt>Int</span>
env <span class=fu>=</span> M.fromList [(<span class=st>"x"</span>, <span class=dv>1</span>), (<span class=st>"y"</span>, <span class=dv>2</span>)]

<span class=ot>compose ::</span> (f (<span class=dt>Fix</span> f) <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> c
compose x y <span class=fu>=</span> x <span class=fu>.</span> unFix <span class=fu>.</span> y

<span class=ot>example ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
example <span class=fu>=</span> eval env expr
<span class=co>-- Just 30</span></code></pre></div>
<p><font>What's especially nice about this approach is how naturally catamorphisms compose into efficient composite transformations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这种方法特别好的地方在于，变质如何自然地组合成高效的复合转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>compose ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (f (<span class=dt>Fix</span> f) <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>Fix</span> f) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> c
compose f g <span class=fu>=</span> f <span class=fu>.</span> unFix <span class=fu>.</span> g</code></pre></div>
<ul>
<li><a href=https://www.fpcomplete.com/user/bartosz/understanding-algebras>Understanding F-Algebras<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>了解 F 代数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=recursion-schemes><font>recursion-schemes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>递归方案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>The code from the F-algebra examples above is implemented in an off-the-shelf library called </font><code>recursion-schemes</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>上述 F 代数示例中的代码是在称为递归方案的现成库中实现的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/14-interpreters/recursion_schemes.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE DeriveFunctor #-}</span>

<span class=kw>import </span><span class=dt>Data.Functor.Foldable</span>

<span class=kw>type</span> <span class=dt>Var</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Exp</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>Var</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Exp</span> <span class=dt>Exp</span>
  <span class=fu>|</span> <span class=dt>Lam</span> [<span class=dt>Var</span>] <span class=dt>Exp</span>
  <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>data</span> <span class=dt>ExpF</span> a
  <span class=fu>=</span> <span class=dt>VarF</span> <span class=dt>Var</span>
  <span class=fu>|</span> <span class=dt>AppF</span> a a
  <span class=fu>|</span> <span class=dt>LamF</span> [<span class=dt>Var</span>] a
  <span class=kw>deriving</span> <span class=dt>Functor</span>

<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Base</span> <span class=dt>Exp</span> <span class=fu>=</span> <span class=dt>ExpF</span>

<span class=kw>instance</span> <span class=dt>Foldable</span> <span class=dt>Exp</span> <span class=kw>where</span>
  project (<span class=dt>Var</span> a)     <span class=fu>=</span> <span class=dt>VarF</span> a
  project (<span class=dt>App</span> a b)   <span class=fu>=</span> <span class=dt>AppF</span> a b
  project (<span class=dt>Lam</span> a b)   <span class=fu>=</span> <span class=dt>LamF</span> a b

<span class=kw>instance</span> <span class=dt>Unfoldable</span> <span class=dt>Exp</span> <span class=kw>where</span>
  embed (<span class=dt>VarF</span> a)      <span class=fu>=</span> <span class=dt>Var</span> a
  embed (<span class=dt>AppF</span> a b)    <span class=fu>=</span> <span class=dt>App</span> a b
  embed (<span class=dt>LamF</span> a b)    <span class=fu>=</span> <span class=dt>Lam</span> a b

<span class=ot>fvs ::</span> <span class=dt>Exp</span> <span class=ot>-&gt;</span> [<span class=dt>Var</span>]
fvs <span class=fu>=</span> cata phi
  <span class=kw>where</span> phi (<span class=dt>VarF</span> a)    <span class=fu>=</span> [a]
        phi (<span class=dt>AppF</span> a b)  <span class=fu>=</span> a <span class=fu>++</span> b
        phi (<span class=dt>LamF</span> a b) <span class=fu>=</span> foldr (filter <span class=fu>.</span> (<span class=fu>/=</span>)) a b</code></pre></div>
<p><font>An example of usage:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用示例：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/14-interpreters/catamorphism.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveFunctor #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class=kw>import </span><span class=dt>Data.Traversable</span>
<span class=kw>import </span><span class=dt>Control.Monad</span> <span class=kw>hiding</span> (forM_, mapM, sequence)
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (mapM)
<span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>M</span>

<span class=kw>newtype</span> <span class=dt>Fix</span> (<span class=ot>f ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=fu>=</span> <span class=dt>Fix</span> {<span class=ot> outF ::</span> f (<span class=dt>Fix</span> f) }

<span class=co>-- Catamorphism</span>
<span class=ot>cata ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (f a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> a
cata f <span class=fu>=</span> f <span class=fu>.</span> fmap (cata f) <span class=fu>.</span> outF

<span class=co>-- Monadic catamorphism</span>
<span class=ot>cataM ::</span> (<span class=dt>Traversable</span> f, <span class=dt>Monad</span> m) <span class=ot>=&gt;</span> (f a <span class=ot>-&gt;</span> m a) <span class=ot>-&gt;</span> <span class=dt>Fix</span> f <span class=ot>-&gt;</span> m a
cataM f <span class=fu>=</span> f <span class=fu>&lt;=&lt;</span> mapM (cataM f) <span class=fu>.</span> outF

<span class=kw>data</span> <span class=dt>ExprF</span> r
  <span class=fu>=</span> <span class=dt>EVar</span> <span class=dt>String</span>
  <span class=fu>|</span> <span class=dt>EApp</span> r r
  <span class=fu>|</span> <span class=dt>ELam</span> r r
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Eq</span>, <span class=dt>Ord</span>, <span class=dt>Functor</span>)

<span class=kw>type</span> <span class=dt>Expr</span> <span class=fu>=</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>

<span class=kw>instance</span> <span class=dt>Show</span> (<span class=dt>Fix</span> <span class=dt>ExprF</span>) <span class=kw>where</span>
  show (<span class=dt>Fix</span> f) <span class=fu>=</span> show f

<span class=kw>instance</span> <span class=dt>Eq</span> (<span class=dt>Fix</span> <span class=dt>ExprF</span>) <span class=kw>where</span>
  <span class=dt>Fix</span> x <span class=fu>==</span> <span class=dt>Fix</span> y <span class=fu>=</span> x <span class=fu>==</span> y

<span class=kw>instance</span> <span class=dt>Ord</span> (<span class=dt>Fix</span> <span class=dt>ExprF</span>) <span class=kw>where</span>
  compare (<span class=dt>Fix</span> x) (<span class=dt>Fix</span> y) <span class=fu>=</span> compare x y


<span class=ot>mkApp ::</span> <span class=dt>Fix</span> <span class=dt>ExprF</span> <span class=ot>-&gt;</span> <span class=dt>Fix</span> <span class=dt>ExprF</span> <span class=ot>-&gt;</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>
mkApp x y <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>EApp</span> x y)

<span class=ot>mkVar ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>
mkVar x <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>EVar</span> x)

<span class=ot>mkLam ::</span> <span class=dt>Fix</span> <span class=dt>ExprF</span> <span class=ot>-&gt;</span> <span class=dt>Fix</span> <span class=dt>ExprF</span> <span class=ot>-&gt;</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>
mkLam x y <span class=fu>=</span> <span class=dt>Fix</span> (<span class=dt>ELam</span> x y)

<span class=ot>i ::</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>
i <span class=fu>=</span> mkLam (mkVar <span class=st>"x"</span>) (mkVar <span class=st>"x"</span>)

<span class=ot>k ::</span> <span class=dt>Fix</span> <span class=dt>ExprF</span>
k <span class=fu>=</span> mkLam (mkVar <span class=st>"x"</span>) <span class=fu>$</span> mkLam (mkVar <span class=st>"y"</span>) <span class=fu>$</span> (mkVar <span class=st>"x"</span>)

<span class=ot>subst ::</span> <span class=dt>M.Map</span> <span class=dt>String</span> (<span class=dt>ExprF</span> <span class=dt>Expr</span>) <span class=ot>-&gt;</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
subst env <span class=fu>=</span> cata alg <span class=kw>where</span>
  alg (<span class=dt>EVar</span> x) <span class=fu>|</span> <span class=dt>Just</span> e <span class=ot>&lt;-</span> M.lookup x env <span class=fu>=</span> <span class=dt>Fix</span> e
  alg e <span class=fu>=</span> <span class=dt>Fix</span> e</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/package/recursion-schemes>recursion-schemes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>递归方案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=data-types-à-la-carte><font>Data types à la carte</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据类型按菜单点菜</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>TODO</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>去做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=hint-and-mueval><font>Hint and Mueval</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>提示和穆瓦尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>GHC itself can actually interpret arbitrary Haskell source on the fly by hooking into the GHC's bytecode interpreter ( the same used for GHCi ). The hint package allows us to parse, typecheck, and evaluate arbitrary strings into arbitrary Haskell programs and evaluate them.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 本身实际上可以通过连接到 GHC 的字节码解释器（与 GHCi 相同）来即时解释任意的 Haskell 源代码。 hint 包允许我们将任意字符串解析、类型检查和评估为任意 Haskell 程序并评估它们。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Language.Haskell.Interpreter</span>

<span class=ot>foo ::</span> <span class=dt>Interpreter</span> <span class=dt>String</span>
foo <span class=fu>=</span> eval <span class=st>"(\\x -&gt; x) 1"</span>

<span class=ot>example ::</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>InterpreterError</span> <span class=dt>String</span>)
example <span class=fu>=</span> runInterpreter foo</code></pre></div>
<p><font>This is generally not a wise thing to build a library around, unless of course the purpose of the program is itself to evaluate arbitrary Haskell code ( something like an online Haskell shell or the likes ).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这通常不是构建库的明智之举，当然除非程序的目的本身就是评估任意 Haskell 代码（类似于在线 Haskell shell 之类的东西）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Both hint and mueval do effectively the same task, designed around slightly different internals of the GHC Api.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>hint 和 mueval 都有效地完成相同的任务，围绕 GHC Api 的内部略有不同而设计。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/package/mueval>hint<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>暗示</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://hackage.haskell.org/package/mueval>mueval<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>中世纪的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h1 id=testing><font>Testing</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>测试</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>Contrary to a lot of misinformation, unit testing in Haskell is quite common and robust. Although generally speaking unit tests tend to be of less importance in Haskell since the type system makes an enormous amount of invalid programs completely inexpressible by construction. Unit tests tend to be written later in the development lifecycle and generally tend to be about the core logic of the program and not the intermediate plumbing.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与许多错误信息相反，Haskell 中的单元测试非常普遍且健壮。虽然一般来说单元测试在 Haskell 中往往不太重要，因为类型系统使得大量无效程序完全无法通过构造来表达。单元测试倾向于在开发生命周期的后期编写，并且通常倾向于关于程序的核心逻辑而不是中间管道。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>A prominent school of thought on Haskell library design tends to favor constructing programs built around strong equation laws which guarantee strong invariants about program behavior under composition. Many of the testing tools are built around this style of design.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 库设计的一个著名学派倾向于支持围绕强大的方程法则构建程序，这些法则保证了程序行为在组合下的强不变性。许多测试工具都是围绕这种设计风格构建的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=quickcheck><font>QuickCheck</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>快速检查</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Probably the most famous Haskell library, QuickCheck is a testing framework for generating large random tests for arbitrary functions automatically based on the types of their arguments.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可能是最著名的 Haskell 库，QuickCheck 是一个测试框架，用于根据参数的类型自动为任意函数生成大型随机测试。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>quickCheck ::</span> <span class=dt>Testable</span> prop <span class=ot>=&gt;</span> prop <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
<span class=ot>(==&gt;) ::</span> <span class=dt>Testable</span> prop <span class=ot>=&gt;</span> <span class=dt>Bool</span> <span class=ot>-&gt;</span> prop <span class=ot>-&gt;</span> <span class=dt>Property</span>
<span class=ot>forAll ::</span> (<span class=dt>Show</span> a, <span class=dt>Testable</span> prop) <span class=ot>=&gt;</span> <span class=dt>Gen</span> a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> prop) <span class=ot>-&gt;</span> <span class=dt>Property</span>
<span class=ot>choose ::</span> <span class=dt>Random</span> a <span class=ot>=&gt;</span> (a, a) <span class=ot>-&gt;</span> <span class=dt>Gen</span> a</code></pre></div>
<div class=sourceCode include=src/15-testing/qcheck.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Test.QuickCheck</span>

<span class=ot>qsort ::</span> [<span class=dt>Int</span>] <span class=ot>-&gt;</span> [<span class=dt>Int</span>]
qsort []     <span class=fu>=</span> []
qsort (x<span class=fu>:</span>xs) <span class=fu>=</span> qsort lhs <span class=fu>++</span> [x] <span class=fu>++</span> qsort rhs
    <span class=kw>where</span> lhs <span class=fu>=</span> filter  (<span class=fu>&lt;</span> x) xs
          rhs <span class=fu>=</span> filter (<span class=fu>&gt;=</span> x) xs

<span class=ot>prop_maximum ::</span>  [<span class=dt>Int</span>] <span class=ot>-&gt;</span> <span class=dt>Property</span>
prop_maximum xs <span class=fu>=</span> not (null xs) <span class=fu>==&gt;</span>
                  last (qsort xs) <span class=fu>==</span> maximum xs

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> quickCheck prop_maximum</code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>runhaskell</span> qcheck.hs
<span class=kw>***</span> Failed! Falsifiable (after 3 tests and 4 shrinks)<span class=kw>:</span>
[<span class=kw>0</span>]
[<span class=kw>1</span>]

$ <span class=kw>runhaskell</span> qcheck.hs
<span class=kw>+++</span> OK, passed 1000 tests.</code></pre></div>
<p><font>The test data generator can be extended with custom types and refined with predicates that restrict the domain of cases to test.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>测试数据生成器可以使用自定义类型进行扩展，并使用限制要测试的案例域的谓词进行细化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/15-testing/arbitrary.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Test.QuickCheck</span>

<span class=kw>data</span> <span class=dt>Color</span> <span class=fu>=</span> <span class=dt>Red</span> <span class=fu>|</span> <span class=dt>Green</span> <span class=fu>|</span> <span class=dt>Blue</span> <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>instance</span> <span class=dt>Arbitrary</span> <span class=dt>Color</span> <span class=kw>where</span>
  arbitrary <span class=fu>=</span> <span class=kw>do</span>
    n <span class=ot>&lt;-</span> choose (<span class=dv>0</span>,<span class=dv>2</span>)<span class=ot> ::</span> <span class=dt>Gen</span> <span class=dt>Int</span>
    return <span class=fu>$</span> <span class=kw>case</span> n <span class=kw>of</span>
      <span class=dv>0</span> <span class=ot>-&gt;</span> <span class=dt>Red</span>
      <span class=dv>1</span> <span class=ot>-&gt;</span> <span class=dt>Green</span>
      <span class=dv>2</span> <span class=ot>-&gt;</span> <span class=dt>Blue</span>

<span class=ot>example1 ::</span> <span class=dt>IO</span> [<span class=dt>Color</span>]
example1 <span class=fu>=</span> sample' arbitrary
<span class=co>-- [Red,Green,Red,Blue,Red,Red,Red,Blue,Green,Red,Red]</span></code></pre></div>
<p><font>See: </font><a href=https://smunix.github.io/www.cse.chalmers.se/_rjmh/QuickCheck/manual.html>QuickCheck: An Automatic Testing Tool for Haskell</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：QuickCheck：Haskell 的自动测试工具</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=smallcheck><font>SmallCheck</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>小支票</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Like QuickCheck, SmallCheck is a property testing system but instead of producing random arbitrary test data it instead enumerates a deterministic series of test data to a fixed depth.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与 QuickCheck 一样，SmallCheck 是一个属性测试系统，但它不是生成随机的任意测试数据，而是将一系列确定性的测试数据枚举到固定深度。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>smallCheck ::</span> <span class=dt>Testable</span> <span class=dt>IO</span> a <span class=ot>=&gt;</span> <span class=dt>Depth</span> <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
<span class=ot>list ::</span> <span class=dt>Depth</span> <span class=ot>-&gt;</span> <span class=dt>Series</span> <span class=dt>Identity</span> a <span class=ot>-&gt;</span> [a]
<span class=ot>sample' ::</span> <span class=dt>Gen</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> [a]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> list <span class=dv>3</span><span class=ot> series ::</span> [<span class=dt>Int</span>]
[<span class=dv>0</span>,<span class=dv>1</span>,<span class=fu>-</span><span class=dv>1</span>,<span class=dv>2</span>,<span class=fu>-</span><span class=dv>2</span>,<span class=dv>3</span>,<span class=fu>-</span><span class=dv>3</span>]

λ<span class=fu>:</span> list <span class=dv>3</span><span class=ot> series ::</span> [<span class=dt>Double</span>]
[<span class=fl>0.0</span>,<span class=fl>1.0</span>,<span class=fu>-</span><span class=fl>1.0</span>,<span class=fl>2.0</span>,<span class=fl>0.5</span>,<span class=fu>-</span><span class=fl>2.0</span>,<span class=fl>4.0</span>,<span class=fl>0.25</span>,<span class=fu>-</span><span class=fl>0.5</span>,<span class=fu>-</span><span class=fl>4.0</span>,<span class=fu>-</span><span class=fl>0.25</span>]

λ<span class=fu>:</span> list <span class=dv>3</span><span class=ot> series ::</span> [(<span class=dt>Int</span>, <span class=dt>String</span>)]
[(<span class=dv>0</span>,<span class=st>""</span>),(<span class=dv>1</span>,<span class=st>""</span>),(<span class=dv>0</span>,<span class=st>"a"</span>),(<span class=fu>-</span><span class=dv>1</span>,<span class=st>""</span>),(<span class=dv>0</span>,<span class=st>"b"</span>),(<span class=dv>1</span>,<span class=st>"a"</span>),(<span class=dv>2</span>,<span class=st>""</span>),(<span class=dv>1</span>,<span class=st>"b"</span>),(<span class=fu>-</span><span class=dv>1</span>,<span class=st>"a"</span>),(<span class=fu>-</span><span class=dv>2</span>,<span class=st>""</span>),(<span class=fu>-</span><span class=dv>1</span>,<span class=st>"b"</span>),(<span class=dv>2</span>,<span class=st>"a"</span>),(<span class=fu>-</span><span class=dv>2</span>,<span class=st>"a"</span>),(<span class=dv>2</span>,<span class=st>"b"</span>),(<span class=fu>-</span><span class=dv>2</span>,<span class=st>"b"</span>)]</code></pre></div>
<p><font>It is useful to generate test cases over </font><em>all</em><font> possible inputs of a program up to some depth.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在程序的所有可能输入上生成一定深度的测试用例很有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/15-testing/smallcheck.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Test.SmallCheck</span>

<span class=ot>distrib ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
distrib a b c <span class=fu>=</span> a <span class=fu>*</span> (b <span class=fu>+</span> c) <span class=fu>==</span> a <span class=fu>*</span> b <span class=fu>+</span> a <span class=fu>*</span> c

<span class=ot>cauchy ::</span> [<span class=dt>Double</span>] <span class=ot>-&gt;</span> [<span class=dt>Double</span>] <span class=ot>-&gt;</span> <span class=dt>Bool</span>
cauchy xs ys <span class=fu>=</span> (abs (dot xs ys))<span class=fu>^</span><span class=dv>2</span> <span class=fu>&lt;=</span> (dot xs xs) <span class=fu>*</span> (dot ys ys)

<span class=ot>failure ::</span> [<span class=dt>Double</span>] <span class=ot>-&gt;</span> [<span class=dt>Double</span>] <span class=ot>-&gt;</span> <span class=dt>Bool</span>
failure xs ys <span class=fu>=</span> abs (dot xs ys) <span class=fu>&lt;=</span> (dot xs xs) <span class=fu>*</span> (dot ys ys)

<span class=ot>dot ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> a
dot xs ys <span class=fu>=</span> sum (zipWith (<span class=fu>*</span>) xs ys)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  putStrLn <span class=st>"Testing distributivity..."</span>
  smallCheck <span class=dv>25</span> distrib

  putStrLn <span class=st>"Testing Cauchy-Schwarz..."</span>
  smallCheck <span class=dv>4</span> cauchy

  putStrLn <span class=st>"Testing invalid Cauchy-Schwarz..."</span>
  smallCheck <span class=dv>4</span> failure</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> runhaskell smallcheck<span class=fu>.</span>hs
<span class=dt>Testing</span> distributivity<span class=fu>...</span>
<span class=dt>Completed</span> <span class=dv>132651</span> tests without failure<span class=fu>.</span>

<span class=dt>Testing</span> <span class=dt>Cauchy</span><span class=fu>-Schwarz...</span>
<span class=dt>Completed</span> <span class=dv>27556</span> tests without failure<span class=fu>.</span>

<span class=dt>Testing</span> invalid <span class=dt>Cauchy</span><span class=fu>-Schwarz...</span>
<span class=dt>Failed</span> test no<span class=fu>.</span> <span class=dv>349</span><span class=fu>.</span>
there exist [<span class=fl>1.0</span>] [<span class=fl>0.5</span>] such that
  condition is false</code></pre></div>
<p><font>Just like for QuickCheck we can implement series instances for our custom datatypes. For example there is no default instance for Vector, so let's implement one:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就像 QuickCheck 一样，我们可以为自定义数据类型实现系列实例。例如，Vector 没有默认实例，所以让我们实现一个：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/15-testing/smallcheck_series.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>import </span><span class=dt>Test.SmallCheck</span>
<span class=kw>import </span><span class=dt>Test.SmallCheck.Series</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=kw>import qualified</span> <span class=dt>Data.Vector</span> <span class=kw>as</span> <span class=dt>V</span>

<span class=ot>dot ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>V.Vector</span> a <span class=ot>-&gt;</span> <span class=dt>V.Vector</span> a <span class=ot>-&gt;</span> a
dot xs ys <span class=fu>=</span> V.sum (V.zipWith (<span class=fu>*</span>) xs ys)

<span class=ot>cauchy ::</span> <span class=dt>V.Vector</span> <span class=dt>Double</span> <span class=ot>-&gt;</span> <span class=dt>V.Vector</span> <span class=dt>Double</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
cauchy xs ys <span class=fu>=</span> (abs (dot xs ys))<span class=fu>^</span><span class=dv>2</span> <span class=fu>&lt;=</span> (dot xs xs) <span class=fu>*</span> (dot ys ys)

<span class=kw>instance</span> (<span class=dt>Serial</span> m a, <span class=dt>Monad</span> m) <span class=ot>=&gt;</span> <span class=dt>Serial</span> m (<span class=dt>V.Vector</span> a) <span class=kw>where</span>
  series <span class=fu>=</span> V.fromList <span class=fu>&lt;$&gt;</span> series

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> smallCheck <span class=dv>4</span> cauchy</code></pre></div>
<p><font>SmallCheck can also use Generics to derive Serial instances, for example to enumerate all trees of a certain depth we might use:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SmallCheck 还可以使用泛型派生 Serial 实例，例如枚举我们可能使用的特定深度的所有树：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/15-testing/smallcheck_tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>

<span class=kw>import </span><span class=dt>GHC.Generics</span>
<span class=kw>import </span><span class=dt>Test.SmallCheck.Series</span>

<span class=kw>data</span> <span class=dt>Tree</span> a <span class=fu>=</span> <span class=dt>Null</span> <span class=fu>|</span> <span class=dt>Fork</span> (<span class=dt>Tree</span> a) a (<span class=dt>Tree</span> a)
    <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Generic</span>)

<span class=kw>instance</span> <span class=dt>Serial</span> m a <span class=ot>=&gt;</span> <span class=dt>Serial</span> m (<span class=dt>Tree</span> a)

<span class=ot>example ::</span> [<span class=dt>Tree</span> ()]
example <span class=fu>=</span> list <span class=dv>3</span> series

main <span class=fu>=</span> print example</code></pre></div>
<h2 id=quickspec><font>QuickSpec</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>快速规格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using the QuickCheck arbitrary machinery we can also rather remarkably enumerate a large number of combinations of functions to try and deduce algebraic laws from trying out inputs for small cases.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 QuickCheck 任意机制，我们还可以非常显着地枚举大量函数组合，以通过尝试小案例的输入来尝试和推断代数定律。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Of course the fundamental limitation of this approach is that a function may not exhibit any interesting properties for small cases or for simple function compositions. So in general case this approach won't work, but practically it still quite useful.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，这种方法的基本局限性在于，对于小情况或简单的函数组合，函数可能不会表现出任何有趣的属性。所以在一般情况下这种方法是行不通的，但实际上它仍然非常有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/15-testing/quickspec.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>import </span><span class=dt>Data.List</span>
<span class=kw>import </span><span class=dt>Data.Typeable</span>

<span class=kw>import </span><span class=dt>Test.QuickSpec</span> <span class=kw>hiding</span> (lists, bools, arith)
<span class=kw>import </span><span class=dt>Test.QuickCheck</span>

<span class=kw>type</span> <span class=dt>Var</span> k a <span class=fu>=</span> (<span class=dt>Typeable</span> a, <span class=dt>Arbitrary</span> a, <span class=dt>CoArbitrary</span> a, k a)

<span class=ot>listCons ::</span> forall a<span class=fu>.</span> <span class=dt>Var</span> <span class=dt>Ord</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Sig</span>
listCons a <span class=fu>=</span> background
  [
    <span class=st>"[]"</span>      <span class=ot>`fun0`</span> ([]<span class=ot>      ::</span> [a]),
    <span class=st>":"</span>       <span class=ot>`fun2`</span> (<span class=ot>(:)     ::</span> a <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [a])
  ]

<span class=ot>lists ::</span> forall a<span class=fu>.</span> <span class=dt>Var</span> <span class=dt>Ord</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> [<span class=dt>Sig</span>]
lists a <span class=fu>=</span>
  [
    <span class=co>-- Names to print arbitrary variables</span>
    funs',
    funvars',
    vars',

    <span class=co>-- Ambient definitions</span>
    listCons a,

    <span class=co>-- Expressions to deduce properties of</span>
    <span class=st>"sort"</span>     <span class=ot>`fun1`</span> (sort<span class=ot>    ::</span> [a] <span class=ot>-&gt;</span> [a]),
    <span class=st>"map"</span>      <span class=ot>`fun2`</span> (map<span class=ot>     ::</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [a]),
    <span class=st>"id"</span>       <span class=ot>`fun1`</span> (id<span class=ot>      ::</span> [a] <span class=ot>-&gt;</span> [a]),
    <span class=st>"reverse"</span>  <span class=ot>`fun1`</span> (reverse<span class=ot> ::</span> [a] <span class=ot>-&gt;</span> [a]),
    <span class=st>"minimum"</span>  <span class=ot>`fun1`</span> (minimum<span class=ot> ::</span> [a] <span class=ot>-&gt;</span> a),
    <span class=st>"length"</span>   <span class=ot>`fun1`</span> (length<span class=ot>  ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Int</span>),
    <span class=st>"++"</span>       <span class=ot>`fun2`</span> (<span class=ot>(++)    ::</span> [a] <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [a])
  ]

  <span class=kw>where</span>
    funs'    <span class=fu>=</span> funs (undefined<span class=ot> ::</span> a)
    funvars' <span class=fu>=</span> vars [<span class=st>"f"</span>, <span class=st>"g"</span>, <span class=st>"h"</span>] (undefined<span class=ot> ::</span> a <span class=ot>-&gt;</span> a)
    vars'    <span class=fu>=</span> [<span class=st>"xs"</span>, <span class=st>"ys"</span>, <span class=st>"zs"</span>] <span class=ot>`vars`</span> (undefined<span class=ot> ::</span> [a])


<span class=ot>tvar ::</span> <span class=dt>A</span>
tvar <span class=fu>=</span> undefined

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> quickSpec (lists tvar)</code></pre></div>
<p><font>Running this we rather see it is able to deduce most of the laws for list functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>运行这个我们宁愿看到它能够推导出列表函数的大部分定律。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>runhaskell</span> src/quickspec.hs
== <span class=kw>API</span> ==
<span class=kw>--</span> functions --
<span class=kw>map</span> :: (A -<span class=kw>&gt;</span> A) <span class=kw>-&gt;</span> [A] -<span class=kw>&gt;</span> [A]
<span class=kw>minimum</span> :: [A] -<span class=kw>&gt;</span> A
<span class=kw>(++)</span> :: [<span class=kw>A</span>] -<span class=kw>&gt;</span> [A] -<span class=kw>&gt;</span> [A]
<span class=kw>length</span> :: [A] -<span class=kw>&gt;</span> Int
<span class=kw>sort</span>, id, reverse :: [A] -<span class=kw>&gt;</span> [A]

<span class=kw>--</span> background functions --
<span class=kw>id</span> :: A -<span class=kw>&gt;</span> A
<span class=kw>(:)</span> :: <span class=kw>A</span> -<span class=kw>&gt;</span> [A] -<span class=kw>&gt;</span> [A]
<span class=kw>(.)</span> :: <span class=kw>(A</span> -<span class=kw>&gt;</span> A<span class=kw>)</span> <span class=kw>-&gt;</span> (A -<span class=kw>&gt;</span> A) <span class=kw>-&gt;</span> A -<span class=kw>&gt;</span> A
[] :: [<span class=kw>A</span>]

<span class=kw>--</span> variables --
<span class=kw>f</span>, g, h :: A -<span class=kw>&gt;</span> A
<span class=kw>xs</span>, ys, zs :: [A]

<span class=kw>--</span> the following types are using non-standard equality --
<span class=kw>A</span> -<span class=kw>&gt;</span> A

<span class=kw>--</span> WARNING: there are no variables of the following types<span class=kw>;</span> <span class=kw>consider</span> adding some --
<span class=kw>A</span>

== <span class=kw>Testing</span> ==
<span class=kw>Depth</span> 1: 12 terms, 4 tests, 24 evaluations, 12 classes, 0 raw equations.
<span class=kw>Depth</span> 2: 80 terms, 500 tests, 18673 evaluations, 52 classes, 28 raw equations.
<span class=kw>Depth</span> 3: 1553 terms, 500 tests, 255056 evaluations, 1234 classes, 319 raw equations.
<span class=kw>319</span> raw equations<span class=kw>;</span> <span class=kw>1234</span> terms in universe.

== <span class=kw>Equations</span> about map ==
  <span class=kw>1</span>: map f [] == []
  <span class=kw>2</span>: map id xs == xs
  <span class=kw>3</span>: map (f.g) <span class=kw>xs</span> == map f (map g xs)

== <span class=kw>Equations</span> about minimum ==
  <span class=kw>4</span>: minimum [] == undefined

== <span class=kw>Equations</span> about (++) ==
  <span class=kw>5</span>: xs++[] == xs
  <span class=kw>6</span>: []++xs == xs
  <span class=kw>7</span>: (xs++ys)<span class=kw>++zs</span> == xs++(ys++zs)

== <span class=kw>Equations</span> about sort ==
  <span class=kw>8</span>: sort [] == []
  <span class=kw>9</span>: sort (sort xs) == <span class=kw>sort</span> xs

== <span class=kw>Equations</span> about id ==
 <span class=kw>10</span>: id xs == xs

== <span class=kw>Equations</span> about reverse ==
 <span class=kw>11</span>: reverse [] == []
 <span class=kw>12</span>: reverse (reverse xs) == <span class=kw>xs</span>

== <span class=kw>Equations</span> about several functions ==
 <span class=kw>13</span>: minimum (xs++ys) == <span class=kw>minimum</span> (ys++xs)
 <span class=kw>14</span>: length (map f xs) == <span class=kw>length</span> xs
 <span class=kw>15</span>: length (xs++ys) == <span class=kw>length</span> (ys++xs)
 <span class=kw>16</span>: sort (xs++ys) == <span class=kw>sort</span> (ys++xs)
 <span class=kw>17</span>: map f (reverse xs) == <span class=kw>reverse</span> (map f xs)
 <span class=kw>18</span>: minimum (sort xs) == <span class=kw>minimum</span> xs
 <span class=kw>19</span>: minimum (reverse xs) == <span class=kw>minimum</span> xs
 <span class=kw>20</span>: minimum (xs++xs) == <span class=kw>minimum</span> xs
 <span class=kw>21</span>: length (sort xs) == <span class=kw>length</span> xs
 <span class=kw>22</span>: length (reverse xs) == <span class=kw>length</span> xs
 <span class=kw>23</span>: sort (reverse xs) == <span class=kw>sort</span> xs
 <span class=kw>24</span>: map f xs++map f ys == map f (xs++ys)
 <span class=kw>25</span>: reverse xs++reverse ys == reverse (ys++xs)</code></pre></div>
<p><font>Keep in mind the rather remarkable fact that this is all deduced automatically from the types alone!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请记住一个相当值得注意的事实，即这一切都是从类型中自动推导出来的！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=criterion><font>Criterion</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>标准</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Criterion is a statistically aware benchmarking tool.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Criterion 是一种具有统计意义的基准测试工具。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>whnf ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Pure</span>
<span class=ot>nf ::</span> <span class=dt>NFData</span> b <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Pure</span>
<span class=ot>nfIO ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
<span class=ot>bench ::</span> <span class=dt>Benchmarkable</span> b <span class=ot>=&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> <span class=dt>Benchmark</span></code></pre></div>
<div class=sourceCode include=src/15-testing/criterion.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Criterion.Main</span>
<span class=kw>import </span><span class=dt>Criterion.Config</span>

<span class=co>-- Naive recursion for fibonacci numbers.</span>
<span class=ot>fib1 ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
fib1 <span class=dv>0</span> <span class=fu>=</span> <span class=dv>0</span>
fib1 <span class=dv>1</span> <span class=fu>=</span> <span class=dv>1</span>
fib1 n <span class=fu>=</span> fib1 (n<span class=fu>-</span><span class=dv>1</span>) <span class=fu>+</span> fib1 (n<span class=fu>-</span><span class=dv>2</span>)

<span class=co>-- Use the De Moivre closed form for fibonacci numbers.</span>
<span class=ot>fib2 ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
fib2 x <span class=fu>=</span> truncate <span class=fu>$</span> ( <span class=dv>1</span> <span class=fu>/</span> sqrt <span class=dv>5</span> ) <span class=fu>*</span> ( phi <span class=fu>^</span> x <span class=fu>-</span> psi <span class=fu>^</span> x )
  <span class=kw>where</span>
      phi <span class=fu>=</span> ( <span class=dv>1</span> <span class=fu>+</span> sqrt <span class=dv>5</span> ) <span class=fu>/</span> <span class=dv>2</span>
      psi <span class=fu>=</span> ( <span class=dv>1</span> <span class=fu>-</span> sqrt <span class=dv>5</span> ) <span class=fu>/</span> <span class=dv>2</span>

<span class=ot>suite ::</span> [<span class=dt>Benchmark</span>]
suite <span class=fu>=</span> [
    bgroup <span class=st>"naive"</span> [
      bench <span class=st>"fib 10"</span> <span class=fu>$</span> whnf fib1 <span class=dv>5</span>
    , bench <span class=st>"fib 20"</span> <span class=fu>$</span> whnf fib1 <span class=dv>10</span>
    ],
    bgroup <span class=st>"de moivre"</span> [
      bench <span class=st>"fib 10"</span> <span class=fu>$</span> whnf fib2 <span class=dv>5</span>
    , bench <span class=st>"fib 20"</span> <span class=fu>$</span> whnf fib2 <span class=dv>10</span>
    ]
  ]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> defaultMain suite</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> runhaskell criterion<span class=fu>.</span>hs
warming up
estimating clock resolution<span class=fu>...</span>
mean is <span class=fl>2.349801</span> us (<span class=dv>320001</span> iterations)
found <span class=dv>1788</span> outliers among <span class=dv>319999</span> samples (<span class=fl>0.6</span><span class=fu>%</span>)
  <span class=dv>1373</span> (<span class=fl>0.4</span><span class=fu>%</span>) high severe
estimating cost <span class=kw>of</span> a clock call<span class=fu>...</span>
mean is <span class=fl>65.52118</span> ns (<span class=dv>23</span> iterations)
found <span class=dv>1</span> outliers among <span class=dv>23</span> samples (<span class=fl>4.3</span><span class=fu>%</span>)
  <span class=dv>1</span> (<span class=fl>4.3</span><span class=fu>%</span>) high severe

benchmarking naive<span class=fu>/</span>fib <span class=dv>10</span>
mean<span class=fu>:</span> <span class=fl>9.903067</span> us, lb <span class=fl>9.885143</span> us, ub <span class=fl>9.924404</span> us, ci <span class=fl>0.950</span>
std dev<span class=fu>:</span> <span class=fl>100.4508</span> ns, lb <span class=fl>85.04638</span> ns, ub <span class=fl>123.1707</span> ns, ci <span class=fl>0.950</span>

benchmarking naive<span class=fu>/</span>fib <span class=dv>20</span>
mean<span class=fu>:</span> <span class=fl>120.7269</span> us, lb <span class=fl>120.5470</span> us, ub <span class=fl>120.9459</span> us, ci <span class=fl>0.950</span>
std dev<span class=fu>:</span> <span class=fl>1.014556</span> us, lb <span class=fl>858.6037</span> ns, ub <span class=fl>1.296920</span> us, ci <span class=fl>0.950</span>

benchmarking de moivre<span class=fu>/</span>fib <span class=dv>10</span>
mean<span class=fu>:</span> <span class=fl>7.699219</span> us, lb <span class=fl>7.671107</span> us, ub <span class=fl>7.802116</span> us, ci <span class=fl>0.950</span>
std dev<span class=fu>:</span> <span class=fl>247.3021</span> ns, lb <span class=fl>61.66586</span> ns, ub <span class=fl>572.1260</span> ns, ci <span class=fl>0.950</span>
found <span class=dv>4</span> outliers among <span class=dv>100</span> samples (<span class=fl>4.0</span><span class=fu>%</span>)
  <span class=dv>2</span> (<span class=fl>2.0</span><span class=fu>%</span>) high mild
  <span class=dv>2</span> (<span class=fl>2.0</span><span class=fu>%</span>) high severe
variance introduced by outliers<span class=fu>:</span> <span class=fl>27.726</span><span class=fu>%</span>
variance is moderately inflated by outliers

benchmarking de moivre<span class=fu>/</span>fib <span class=dv>20</span>
mean<span class=fu>:</span> <span class=fl>8.082639</span> us, lb <span class=fl>8.018560</span> us, ub <span class=fl>8.350159</span> us, ci <span class=fl>0.950</span>
std dev<span class=fu>:</span> <span class=fl>595.2161</span> ns, lb <span class=fl>77.46251</span> ns, ub <span class=fl>1.408784</span> us, ci <span class=fl>0.950</span>
found <span class=dv>8</span> outliers among <span class=dv>100</span> samples (<span class=fl>8.0</span><span class=fu>%</span>)
  <span class=dv>4</span> (<span class=fl>4.0</span><span class=fu>%</span>) high mild
  <span class=dv>4</span> (<span class=fl>4.0</span><span class=fu>%</span>) high severe
variance introduced by outliers<span class=fu>:</span> <span class=fl>67.628</span><span class=fu>%</span>
variance is severely inflated by outliers</code></pre></div>
<p><font>Criterion can also generate a HTML page containing the benchmark results plotted</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Criterion 还可以生成包含绘制的基准测试结果的 HTML 页面</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>ghc</span> -O2 --make criterion.hs
$ <span class=kw>./criterion</span> -o bench.html</code></pre></div>
<div class=figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA94AAAHKCAIAAAB61wTYAAAAA3NCSVQICAjb4U/gAAAgAElEQVR4Xuy9CXgc1Zn3W1vv3VJLrc2WLcuWkcEmtoAMe4IJIZhkkpBgMhCSi5mEhG/gfrHv3ATPJMyQm2XM5LmDMxdnI3fG3G8yYSZww0zCYLKSDwOOCUQGbLCxbMu2bC2W1Vp6r+X7l47dCMmWtbSk6up/PaKpPnXq1Ht+p1z99tvvIkuSZFkWXrmRAAmQAAmQAAmQAAmQAAnMIQGZevkc0uelSYAESIAESIAESIAESCBPQCELEiABEiABEiABEiABEiABJxCQIQQN505YCcpAAiRAAiRAAiRAAiRQ4gRoNS/xG4DTJwESIAESIAESIAEScAoB+po7ZSUoBwmQAAmQAAmQAAmQQIkToENLid8AnD4JkAAJkAAJkAAJkIBTCNBq7pSVoBwkQAIkQAIkQAIkQAIlToC+5iV+A3D6JEACJEACJEACJEACTiFA1dwpK0E5SIAESIAESIAESIAESpwAVfMSvwE4fRIgARIgARIgARIgAacQoGrulJWgHCRAAiRAAiRAAiRAAiVOgKp5id8AnD4JkAAJkAAJkAAJkIBTCFA1d8pKUA4SIAESIAESIAESIIESJ0DVvMRvAE6fBEiABEiABEiABEjAKQSomjtlJSgHCZAACZAACZAACZBAiROgal7iNwCnTwIkQAIkQAIkQAIk4BQCVM2dshKUgwRIgARIgARIgARIoMQJUDUv8RuA0ycBEiABEiABEiABEnAKAarmTlkJykECJEACJEACJEACJFDiBKial/gNwOmTAAmQAAmQAAmQAAk4hQBVc6esBOUgARIgARIgARIgARIocQJUzUv8BuD0SYAESIAESIAESIAEnEJgZlTzdOez37t7TUujX8YWbWxZs35ra1zq3LbufL/ceOtjnW/PPt765Oa716D58q0jWp1Ch3KQAAmQAAmQAAmQAAmQwKwRmAHVvHPb3S2NNz12/gPPHkqn3vjxHXXtu5759p0XNX742w8+tjcjtf/b93bEMb/ObZtuvbyu4qKPbfj+M2ie9Jbu3LF1/ZrG6OqRmv6kR+EJJEACJEACJEACJEACJOAQAgVXzd/cfNON398bXbf57sujkuQ//9at2/75hnLMtv+5vTd+eplPWvRnw0ekutXrH9tx6Ld31E6aRPzNJzfd2lI374o7v/1Me386PekBeAIJkAAJkAAJkAAJkAAJOI+AVliR4s8+8MDvMWRjS53/9MiN655sbXxsW2fLrbe2RL/0SP6CfrvH+WsapUe7JiFE/NnNm3b4z4ezzL/t6p/EeexKAiRAAiRAAiRAAiRAAs4mUFjVPP3mY88O68v+aF4zt981rl5395k5+IcV9Els0dXrN61G/zXxrf+xYe8kTmRXEiABEiABEiABEiABEnA0gcI6tKQ735yMBdwmM0nNPA8zWlfnaLAUjgRIgARIgARIgARIgAQmR6DAqnne8XuixvCpauZT1+knx4e9SYAESIAESIAESIAESGCWCBRINU9vW2MnSpx3m+1oju13NwbsvImyf822fJQmMipuXX9Ti99/9jyJ8datd69ujNonwgfmezvGyac4Ud1/ljjyMiRAAiRAAiRAAiRAAiQwTQIFUs1tFdyyrOP/fJmQ55qnU3hrWbbKjpbOJzeuOT8679o7v/0fuzJnS5TY+eTdl1905/d/1257q2faf/fof7ui5dbHDk1zgjydBEiABEiABEiABEiABIqDQIFU83NMtm7NA0/u2DZunsQ3N6/beOimH//2jYNvvPjj+66x0y1KUte/3Xbr5kPnGJyHSYAESIAESIAESIAESMANBGZHNZeQiCV6/urGcYj5WzY9iyJEq89vPP/yWzdt2/Hda3zDvX+/6YEdzFw+DjgeIgESIAESIAESIAEScAmBWVLNbVrvTKg4ml/j6pYRKVf856/bvH7RcJ+uZx97k7r5aFx8TwIkQAIkQAIkQAIk4DoCs6iaTy5PIuqI3iR08/bWQ1TNXXfjcUIkQAIkQAIkQAIkQAKjCcyiaj7JPIn+ustPmdHzGRlHC8/3JEACJEACJEACJEACJOAeArOomk8WWr5QaDQ62VPZnwRIgARIgARIgARIgASKjoCDVfN0XPixLGtppG5edDcWBSYBEiABEiABEiABEpgsAeeq5ulDOw7Zs1m05tbGyc6K/UmABEiABEiABEiABEig6AjMlGo+bf/w9JtPbuuSJN8ND2xsOZOXOiNDi+5eo8AkQAIkQAIkQAIkQALjEiisah7vjIur5XdGXHx8bR1njNS2Ox/buLldqv2zrVvXjcipOHIq1M3HXVgeJAESIAESIAESIAESKDYCBVTN04ee3PS9vQLArs2bt3WOUp47hYOKJMFT5e1DjTfdUGufs/evLl+z/rEd9knx1q3rLr/z2fM//9Mdj916FsVc6tzRKS6FYamlF9ttR3lJgARIgARIgARIgATGEpAtyxrbOumW9I51jVc8CgeUd26+G57u3LYmKsV3bN74wObvP9N+6nDtNXes37hp45pTenfnjsc2f+9727bt2NWVkaTyRZetvunujRvXnU6e+M4xDz25cdNjrTu2PbOr/9QB37Ibbrq85aYHNtEpffQC8D0JkAAJkAAJkAAJkEDxECiQal48E6akJEACJEACJEACJEACJOBMAgV0aHHmBCkVCZAACZAACZAACZAACRQHAarmxbFOlJIESIAESIAESIAESMD1BKiau36JOUESIAESIAESIAESIIHiIEDVvDjWiVKSAAmQAAmQAAmQAAm4ngBVc9cvMSdIAiRAAiRAAiRAAiRQHASomhfHOlFKEiABEiABEiABEiAB1xOgau76JeYESYAESIAESIAESIAEioMAVfPiWCdKSQIkQAIkQAIkQAIk4HoCVM1dv8ScIAmQAAmQAAmQAAmQQHEQoGpeHOtEKUmABEiABEiABEiABFxPgKq565eYEyQBEiABEiABEiABEigOAlTNi2OdKCUJkAAJkAAJkAAJkIDrCVA1d/0Sc4IkQAIkQAIkQAIkQALFQYCqeXGsE6UkARIgARIgARIgARJwPQGq5q5fYk6QBEiABEiABEiABEigOAhQNS+OdaKUJEACJEACJEACJEACridA1dz1S8wJkgAJkAAJkAAJkAAJFAcBqubFsU6UkgRIgARIgARIgARIwPUEqJq7fok5QRIgARIgARIgARIggeIgQNW8ONaJUpIACZAACZAACZAACbieAFVz1y8xJ0gCJEACJEACJEACJFAcBLQZFXPjxo0zOj4HJwESIAHXENi0adOszYUP51lDzQuRAAkUO4HZfDiDFa3mxX7DUH4SIAESIAESIAESIAGXEJhZq7mANOVvG/v27Wtubp5l0k93m890m5svHE1mToQ549wpyVgsZEImYwmMbXHOfQLZRgozVzbs4no4j11Q0eKcZaUkY9eITMhkLIGxLc65T5zwcB6tgI7lxRYSIAESIAESIAESIAESmCsClj6UOvxopnObZQwpvjpf3ZpAwx1zJcxMX5eq+UwT5vgkQAIkQAIkQAIkQAJT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AAmUOoHS85onIy6jySNYvQGf3SCLwB2JZuqjGc2+0IGkpkGnN5jtzW6nmb7IkZDx3BABPA3iQc5mlk3GnGQ+4rSLKNYAFZfy5EYCJEACJEACJEACIFB6pjm7hQSmggCmDcuWbpxsKZKJpAbTSrmRAAmQAAmQAAmQwDABmuYcCyRAAiRAAiRAAiRAAiRQEgRKMNa8JLhQCBIgARIgARIgARIgARIoMgGa5kUGzuZIgARIgARIgARIgARIQJ0ATXN1LkwlARIgARIgARIgARIggSIToGleZOBsjgRIgARIgARIgARIgATUCdA0V+fCVBIgARIgARIgARIgARIoMgGa5kUGzuZIgARIgARIgARIgARIQJ0ATXN1LkwlARIgARIgARIgARIggSIToGleZOBsjgRIgARIgARIgARIgATUCdA0V+fCVBIgARIgARIgARIgARIoMgGa5kUGzuZIgARIgARIgARIgARIQJ0ATXN1LkwlARIgARIgARIgARIggSIToGleZOBsjgRIgARIgARIgARIgATUCdA0V+fCVBIgARIgARIgARIgARIoMgGa5kUGzuZIgARIgARIgARIgARIQJ3A/w8OzyJ3i8CTawAAAABJRU5ErkJggg==" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/criterion.png>
</div>
<h2 id=tasty><font>Tasty</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Tasty combines all of the testing frameworks into a common API for forming runnable batches of tests and collecting the results.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Tasty 将所有测试框架组合成一个通用 API，用于形成可运行的测试批次并收集结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/15-testing/tasty.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Test.Tasty</span>
<span class=kw>import </span><span class=dt>Test.Tasty.HUnit</span>
<span class=kw>import </span><span class=dt>Test.Tasty.QuickCheck</span>
<span class=kw>import qualified</span> <span class=dt>Test.Tasty.SmallCheck</span> <span class=kw>as</span> <span class=dt>SC</span>

<span class=ot>arith ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Property</span>
arith x y <span class=fu>=</span> (x <span class=fu>&gt;</span> <span class=dv>0</span>) <span class=fu>&amp;&amp;</span> (y <span class=fu>&gt;</span> <span class=dv>0</span>) <span class=fu>==&gt;</span> (x<span class=fu>+</span>y)<span class=fu>^</span><span class=dv>2</span> <span class=fu>&gt;</span> x<span class=fu>^</span><span class=dv>2</span> <span class=fu>+</span> y<span class=fu>^</span><span class=dv>2</span>

<span class=ot>negation ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
negation x <span class=fu>=</span> abs (x<span class=fu>^</span><span class=dv>2</span>) <span class=fu>&gt;=</span> x

<span class=ot>suite ::</span> <span class=dt>TestTree</span>
suite <span class=fu>=</span> testGroup <span class=st>"Test Suite"</span> [
    testGroup <span class=st>"Units"</span>
      [ testCase <span class=st>"Equality"</span> <span class=fu>$</span> <span class=dt>True</span> <span class=fu>@=?</span> <span class=dt>True</span>
      , testCase <span class=st>"Assertion"</span> <span class=fu>$</span> assert <span class=fu>$</span> (length [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]) <span class=fu>==</span> <span class=dv>3</span>
      ],

    testGroup <span class=st>"QuickCheck tests"</span>
      [ testProperty <span class=st>"Quickcheck test"</span> arith
      ],

    testGroup <span class=st>"SmallCheck tests"</span>
      [ SC.testProperty <span class=st>"Negation"</span> negation
      ]
  ]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> defaultMain suite</code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>runhaskell</span> TestSuite.hs
<span class=kw>Unit</span> tests
  <span class=kw>Units</span>
    <span class=kw>Equality</span>:        OK
    <span class=kw>Assertion</span>:       OK
  <span class=kw>QuickCheck</span> tests
    <span class=kw>Quickcheck</span> test: OK
      <span class=kw>+++</span> OK, passed 100 tests.
  <span class=kw>SmallCheck</span> tests
    <span class=kw>Negation</span>:        OK
      <span class=kw>11</span> tests completed</code></pre></div>
<h2 id=silently><font>silently</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>默默</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Often in the process of testing IO heavy code we'll need to redirect stdout to compare it some known quantity. The </font><code>silently</code><font> package allows us to capture anything done to stdout across any library inside of IO block and return the result to the test runner.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通常在测试 IO 繁重代码的过程中，我们需要重定向标准输出以将其与某个已知数量进行比较。 silently 包允许我们捕获在 IO 块内的任何库中对 stdout 所做的任何操作，并将结果返回给测试运行器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>capture ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>String</span>, a)</code></pre></div>
<div class=sourceCode include=src/15-testing/silently.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Test.Tasty</span>
<span class=kw>import </span><span class=dt>Test.Tasty.HUnit</span>
<span class=kw>import </span><span class=dt>System.IO.Silently</span>

<span class=ot>test ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
test n <span class=fu>=</span> print (n <span class=fu>*</span> n)

testCapture n <span class=fu>=</span> <span class=kw>do</span>
  (stdout, result) <span class=ot>&lt;-</span> capture (test n)
  assert (stdout <span class=fu>==</span> show (n<span class=fu>*</span>n) <span class=fu>++</span> <span class=st>"\n"</span>)

<span class=ot>suite ::</span> <span class=dt>TestTree</span>
suite <span class=fu>=</span> testGroup <span class=st>"Test Suite"</span> [
    testGroup <span class=st>"Units"</span>
      [ testCase <span class=st>"Equality"</span> <span class=fu>$</span> testCapture <span class=dv>10</span>
      ]
  ]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> defaultMain suite</code></pre></div>
<h1 id=type-families><font>Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=multiparam-typeclasses><font>MultiParam Typeclasses</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多参数类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Resolution of vanilla Haskell 98 typeclasses proceeds via very simple context reduction that minimizes interdependency between predicates, resolves superclasses, and reduces the types to head normal form. For example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>vanilla Haskell 98 类型类的解析通过非常简单的上下文缩减进行，该上下文缩减最小化谓词之间的相互依赖性，解析超类，并将类型缩减为头部范式。例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class=dt>Eq</span> [a], <span class=dt>Ord</span> [a]) <span class=ot>=&gt;</span> [a]
<span class=fu>==&gt;</span> <span class=dt>Ord</span> a <span class=ot>=&gt;</span> [a]</code></pre></div>
<p><font>If a single parameter typeclass expresses a property of a type ( i.e. it's in a class or not in class ) then a multiparameter typeclass expresses relationships between types. For example if we wanted to express the relation a type can be converted to another type we might use a class like:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果单个参数类型类表示类型的属性（即它在类中或不在类中），那么多参数类型类表示类型之间的关系。例如，如果我们想表达一种类型可以转换为另一种类型的关系，我们可以使用如下类：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/mparam.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class=kw>import </span><span class=dt>Data.Char</span>

<span class=kw>class</span> <span class=dt>Convertible</span> a b <span class=kw>where</span>
<span class=ot>  convert ::</span> a <span class=ot>-&gt;</span> b

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=dt>Integer</span> <span class=kw>where</span>
  convert <span class=fu>=</span> toInteger

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=dt>Char</span> <span class=kw>where</span>
  convert <span class=fu>=</span> chr

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Char</span> <span class=dt>Int</span> <span class=kw>where</span>
  convert <span class=fu>=</span> ord</code></pre></div>
<p><font>Of course now our instances for </font><code>Convertible Int</code><font> are not unique anymore, so there no longer exists a nice procedure for determining the inferred type of </font><code>b</code><font> from just </font><code>a</code><font>. To remedy this let's add a functional dependency </font><code>a -&gt; b</code><font>, which tells GHC that an instance </font><code>a</code><font> uniquely determines the instance that b can be. So we'll see that our two instances relating </font><code>Int</code><font> to both </font><code>Integer</code><font> and </font><code>Char</code><font> conflict.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，现在我们的 Convertible Int 实例不再是唯一的，所以不再存在一个很好的过程来确定从 a 推断出 b 的类型。为了解决这个问题，让我们添加一个函数依赖 a -&gt; b，它告诉 GHC 一个实例 a 唯一地确定了 b 可以是的实例。所以我们会看到我们的两个实例将 Int 与 Integer 和 Char 相关联。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/mparam_fun.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE FunctionalDependencies #-}</span>


<span class=kw>import </span><span class=dt>Data.Char</span>

<span class=kw>class</span> <span class=dt>Convertible</span> a b <span class=fu>|</span> a <span class=ot>-&gt;</span> b <span class=kw>where</span>
<span class=ot>  convert ::</span> a <span class=ot>-&gt;</span> b

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=dt>Char</span> <span class=kw>where</span>
  convert <span class=fu>=</span> chr

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Char</span> <span class=dt>Int</span> <span class=kw>where</span>
  convert <span class=fu>=</span> ord</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Functional</span> dependencies conflict between <span class=kw>instance</span> declarations<span class=fu>:</span>
  <span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=dt>Integer</span>
  <span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=dt>Char</span></code></pre></div>
<p><font>Now there's a simpler procedure for determining instances uniquely and multiparameter typeclasses become more usable and inferable again. Effectively a functional dependency </font><code>| a -&gt; b</code><font> says that we can't define multiple multiparamater typeclass instances with the same </font><code>a</code><font> but different </font><code>b</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在有一个更简单的过程来唯一地确定实例，多参数类型类再次变得更有用和可推断。有效的功能依赖 | a -&gt; b 表示我们不能定义多个具有相同 a 但不同 b 的多参数类型类实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> convert (<span class=dv>42</span><span class=ot> ::</span> <span class=dt>Int</span>)
<span class=ch>'*'</span>
λ<span class=fu>:</span> convert <span class=ch>'*'</span>
<span class=dv>42</span></code></pre></div>
<p><font>Now let's make things not so simple. Turning on </font><code>UndecidableInstances</code><font> loosens the constraint on context reduction that can only allow constraints of the class to become structural smaller than its head. As a result implicit computation can now occur </font><em>within in the type class instance search</em><font>. Combined with a type-level representation of Peano numbers we find that we can encode basic arithmetic at the type-level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在让我们让事情变得不那么简单。打开 UndecidableInstances 会放松对上下文缩减的约束，这种约束只能允许类的约束在结构上小于其头部。因此，隐式计算现在可以在类型类实例搜索中进行。结合 Peano 数的类型级表示，我们发现我们可以在类型级对基本算术进行编码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/fundeps.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE FunctionalDependencies #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>data</span> <span class=dt>Z</span>
<span class=kw>data</span> <span class=dt>S</span> n

<span class=kw>type</span> <span class=dt>Zero</span>  <span class=fu>=</span> <span class=dt>Z</span>
<span class=kw>type</span> <span class=dt>One</span>   <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Zero</span>
<span class=kw>type</span> <span class=dt>Two</span>   <span class=fu>=</span> <span class=dt>S</span> <span class=dt>One</span>
<span class=kw>type</span> <span class=dt>Three</span> <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Two</span>
<span class=kw>type</span> <span class=dt>Four</span>  <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Three</span>

<span class=ot>zero ::</span> <span class=dt>Zero</span>
zero <span class=fu>=</span> undefined

<span class=ot>one ::</span> <span class=dt>One</span>
one <span class=fu>=</span> undefined

<span class=ot>two ::</span> <span class=dt>Two</span>
two <span class=fu>=</span> undefined

<span class=ot>three ::</span> <span class=dt>Three</span>
three <span class=fu>=</span> undefined

<span class=ot>four ::</span> <span class=dt>Four</span>
four <span class=fu>=</span> undefined

<span class=kw>class</span> <span class=dt>Eval</span> a <span class=kw>where</span>
<span class=ot>  eval ::</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>

<span class=kw>instance</span> <span class=dt>Eval</span> <span class=dt>Zero</span> <span class=kw>where</span>
  eval _ <span class=fu>=</span> <span class=dv>0</span>

<span class=kw>instance</span> <span class=dt>Eval</span> n <span class=ot>=&gt;</span> <span class=dt>Eval</span> (<span class=dt>S</span> n) <span class=kw>where</span>
  eval m <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> eval (prev m)

<span class=kw>class</span> <span class=dt>Pred</span> a b <span class=fu>|</span> a <span class=ot>-&gt;</span> b <span class=kw>where</span>
<span class=ot>  prev ::</span> a <span class=ot>-&gt;</span> b

<span class=kw>instance</span> <span class=dt>Pred</span> <span class=dt>Zero</span> <span class=dt>Zero</span> <span class=kw>where</span>
  prev <span class=fu>=</span> undefined

<span class=kw>instance</span> <span class=dt>Pred</span> (<span class=dt>S</span> n) n <span class=kw>where</span>
  prev <span class=fu>=</span> undefined

<span class=kw>class</span> <span class=dt>Add</span> a b c <span class=fu>|</span> a b <span class=ot>-&gt;</span> c <span class=kw>where</span>
<span class=ot>  add ::</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c

<span class=kw>instance</span> <span class=dt>Add</span> <span class=dt>Zero</span> a a <span class=kw>where</span>
  add <span class=fu>=</span> undefined

<span class=kw>instance</span> <span class=dt>Add</span> a b c <span class=ot>=&gt;</span> <span class=dt>Add</span> (<span class=dt>S</span> a) b (<span class=dt>S</span> c) <span class=kw>where</span>
  add <span class=fu>=</span> undefined

<span class=ot>f ::</span> <span class=dt>Three</span>
f <span class=fu>=</span> add one two

<span class=ot>g ::</span> <span class=dt>S</span> (<span class=dt>S</span> (<span class=dt>S</span> (<span class=dt>S</span> <span class=dt>Z</span>)))
g <span class=fu>=</span> add two two

<span class=ot>h ::</span> <span class=dt>Int</span>
h <span class=fu>=</span> eval (add three four)</code></pre></div>
<p><font>If the typeclass contexts look similar to Prolog you're not wrong, if one reads the contexts qualifier </font><code>(=&gt;)</code><font> backwards as turnstiles </font><code>:-</code><font> then it's precisely the same equations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果类型类上下文看起来与 Prolog 相似，那么您没有错，如果将上下文限定符 (=&gt;) 倒过来读作十字转门 :- 那么它就是完全相同的方程式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode prolog"><code class="sourceCode prolog">add(<span class=dv>0</span><span class=kw>,</span> <span class=dt>A</span><span class=kw>,</span> <span class=dt>A</span>)<span class=kw>.</span>
add(s(<span class=dt>A</span>)<span class=kw>,</span> <span class=dt>B</span><span class=kw>,</span> s(<span class=dt>C</span>)) <span class=kw>:-</span> add(<span class=dt>A</span><span class=kw>,</span> <span class=dt>B</span><span class=kw>,</span> <span class=dt>C</span>)<span class=kw>.</span>

pred(<span class=dv>0</span><span class=kw>,</span> <span class=dv>0</span>)<span class=kw>.</span>
pred(<span class=dt>S</span>(<span class=dt>A</span>)<span class=kw>,</span> <span class=dt>A</span>)<span class=kw>.</span></code></pre></div>
<p><font>This is kind of abusing typeclasses and if used carelessly it can fail to terminate or overflow at compile-time. </font><code>UndecidableInstances</code><font> shouldn't be turned on without careful forethought about what it implies.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一种滥用类型类，如果使用不当，它可能会在编译时无法终止或溢出。 UndecidableInstances 不应该在没有仔细考虑它的含义的情况下打开。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>&lt;</span>interactive<span class=fu>&gt;:</span><span class=dv>1</span><span class=fu>:</span><span class=dv>1</span><span class=fu>:</span>
    <span class=dt>Context</span> reduction stack overflow; size <span class=fu>=</span> <span class=dv>201</span></code></pre></div>
<h2 id=type-families-1><font>Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Type families allows us to write functions in the type domain which take types as arguments which can yield either types or values indexed on their arguments which are evaluated at compile-time in during typechecking. Type families come in two varieties: </font><strong>data families</strong><font> and </font><strong>type synonym families</strong><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型族允许我们在类型域中编写函数，这些函数将类型作为参数，这些参数可以产生类型或在其参数上索引的值，这些参数在编译时在类型检查期间进行评估。类型族有两种：数据族和类型同义词族。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><strong>type families</strong><font> are named function on types</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型族是类型上的命名函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>data families</strong><font> are type-indexed data types</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据族是类型索引的数据类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>First let's look at </font><em>type synonym families</em><font>, there are two equivalent syntactic ways of constructing them. Either as </font><em>associated</em><font> type families declared within a typeclass or as standalone declarations at the toplevel. The following forms are semantically equivalent, although the unassociated form is strictly more general:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>首先让我们看一下类型同义词族，有两种等价的构造它们的句法方式。作为在类型类中声明的关联类型族或作为顶层的独立声明。以下形式在语义上是等价的，尽管非关联形式更通用：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- (1) Unassociated form</span>
<span class=kw>type</span> family <span class=dt>Rep</span> a
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Rep</span> <span class=dt>Int</span> <span class=fu>=</span> <span class=dt>Char</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Rep</span> <span class=dt>Char</span> <span class=fu>=</span> <span class=dt>Int</span>

<span class=kw>class</span> <span class=dt>Convertible</span> a <span class=kw>where</span>
<span class=ot>  convert ::</span> a <span class=ot>-&gt;</span> <span class=dt>Rep</span> a

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=kw>where</span>
  convert <span class=fu>=</span> chr

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Char</span> <span class=kw>where</span>
  convert <span class=fu>=</span> ord



<span class=co>-- (2) Associated form</span>
<span class=kw>class</span> <span class=dt>Convertible</span> a <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Rep</span> a
<span class=ot>  convert ::</span> a <span class=ot>-&gt;</span> <span class=dt>Rep</span> a

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Int</span> <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Rep</span> <span class=dt>Int</span> <span class=fu>=</span> <span class=dt>Char</span>
  convert <span class=fu>=</span> chr

<span class=kw>instance</span> <span class=dt>Convertible</span> <span class=dt>Char</span> <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Rep</span> <span class=dt>Char</span> <span class=fu>=</span> <span class=dt>Int</span>
  convert <span class=fu>=</span> ord</code></pre></div>
<p><font>Using the same example we used for multiparameter + functional dependencies illustration we see that there is a direct translation between the type family approach and functional dependencies. These two approaches have the same expressive power.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用我们用于多参数 + 函数依赖说明的相同示例，我们看到类型族方法和函数依赖之间存在直接转换。这两种方法具有相同的表达能力。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>An associated type family can be queried using the </font><code>:kind!</code><font> command in GHCi.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以使用 :kind! 查询关联的类型族。 GHCi 中的命令。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>kind<span class=fu>!</span> <span class=dt>Rep</span> <span class=dt>Int</span>
<span class=dt>Rep</span> <span class=dt>Int</span><span class=ot> ::</span> <span class=fu>*</span>
<span class=fu>=</span> <span class=dt>Char</span>
λ<span class=fu>:</span> <span class=fu>:</span>kind<span class=fu>!</span> <span class=dt>Rep</span> <span class=dt>Char</span>
<span class=dt>Rep</span> <span class=dt>Char</span><span class=ot> ::</span> <span class=fu>*</span>
<span class=fu>=</span> <span class=dt>Int</span></code></pre></div>
<p><em>Data families</em><font> on the other hand allow us to create new type parameterized data constructors. Normally we can only define typeclasses functions whose behavior results in a uniform result which is purely a result of the typeclasses arguments. With data families we can allow specialized behavior indexed on the type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>另一方面，数据族允许我们创建新的类型参数化数据构造函数。通常我们只能定义类型类函数，其行为导致统一结果，这纯粹是类型类参数的结果。使用数据族，我们可以允许在类型上建立索引的特殊行为。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example if we wanted to create more complicated vector structures ( bit-masked vectors, vectors of tuples, ... ) that exposed a uniform API but internally handled the differences in their data layout we can use data families to accomplish this:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，如果我们想要创建更复杂的向量结构（位掩码向量、元组向量，...），这些结构公开统一的 API 但在内部处理其数据布局的差异，我们可以使用数据族来完成此操作：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/datafamily.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Vector.Unboxed</span> <span class=kw>as</span> <span class=dt>V</span>

<span class=kw>data</span> family <span class=dt>Array</span> a
<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Array</span> <span class=dt>Int</span>       <span class=fu>=</span> <span class=dt>IArray</span> (<span class=dt>V.Vector</span> <span class=dt>Int</span>)
<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Array</span> <span class=dt>Bool</span>      <span class=fu>=</span> <span class=dt>BArray</span> (<span class=dt>V.Vector</span> <span class=dt>Bool</span>)
<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Array</span> (a,b)     <span class=fu>=</span> <span class=dt>PArray</span> (<span class=dt>Array</span> a) (<span class=dt>Array</span> b)
<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Array</span> (<span class=dt>Maybe</span> a) <span class=fu>=</span> <span class=dt>MArray</span> (<span class=dt>V.Vector</span> <span class=dt>Bool</span>) (<span class=dt>Array</span> a)

<span class=kw>class</span> <span class=dt>IArray</span> a <span class=kw>where</span>
<span class=ot>  index ::</span> <span class=dt>Array</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a

<span class=kw>instance</span> <span class=dt>IArray</span> <span class=dt>Int</span> <span class=kw>where</span>
  index (<span class=dt>IArray</span> xs) i <span class=fu>=</span> xs <span class=fu>V.!</span> i

<span class=kw>instance</span> <span class=dt>IArray</span> <span class=dt>Bool</span> <span class=kw>where</span>
  index (<span class=dt>BArray</span> xs) i <span class=fu>=</span> xs <span class=fu>V.!</span> i

<span class=co>-- Vector of pairs</span>
<span class=kw>instance</span> (<span class=dt>IArray</span> a, <span class=dt>IArray</span> b) <span class=ot>=&gt;</span> <span class=dt>IArray</span> (a, b) <span class=kw>where</span>
  index (<span class=dt>PArray</span> xs ys) i <span class=fu>=</span> (index xs i, index ys i)

<span class=co>-- Vector of missing values</span>
<span class=kw>instance</span> (<span class=dt>IArray</span> a) <span class=ot>=&gt;</span> <span class=dt>IArray</span> (<span class=dt>Maybe</span> a) <span class=kw>where</span>
  index (<span class=dt>MArray</span> bm xs) i <span class=fu>=</span>
    <span class=kw>case</span> bm <span class=fu>V.!</span> i <span class=kw>of</span>
      <span class=dt>True</span>  <span class=ot>-&gt;</span> <span class=dt>Nothing</span>
      <span class=dt>False</span> <span class=ot>-&gt;</span> <span class=dt>Just</span> <span class=fu>$</span> index xs i</code></pre></div>
<h2 id=injectivity><font>Injectivity</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>内射性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The type level functions defined by type-families are not necessarily </font><em>injective</em><font>, the function may map two distinct input types to the same output type. This differs from the behavior of type constructors ( which are also type-level functions ) which are injective.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型族定义的类型级函数不一定是单射的，该函数可以将两个不同的输入类型映射到相同的输出类型。这不同于单射的类型构造函数（也是类型级函数）的行为。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example for the constructor </font><code>Maybe</code><font>, </font><code>Maybe t1 = Maybe t2</code><font> implies that </font><code>t1 = t2</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如对于构造函数 Maybe，Maybe t1 = Maybe t2 意味着 t1 = t2。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Maybe</span> a <span class=fu>=</span> <span class=dt>Nothing</span> <span class=fu>|</span> <span class=dt>Just</span> a
<span class=co>-- Maybe a ~ Maybe b  implies  a ~ b</span>

<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>F</span> <span class=dt>Int</span> <span class=fu>=</span> <span class=dt>Bool</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>F</span> <span class=dt>Char</span> <span class=fu>=</span> <span class=dt>Bool</span>

<span class=co>-- F a ~ F b does not imply  a ~ b, in general</span></code></pre></div>
<h2 id=roles><font>Roles</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>角色</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Roles are a further level of specification for type variables parameters of datatypes.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>角色是数据类型的类型变量参数的进一步规范。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><code>nominal<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>名义上的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></li>
<li><code>representational<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>代表性的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></li>
<li><code>phantom<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>幻影</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></li>
</ul>
<p><font>They were added to the language to address a rather nasty and long-standing bug around the correspondence between a newtype and its runtime representation. The fundamental distinction that roles introduce is there are two notions of type equality. Two types are </font><em>nominally equal</em><font> when they have the same name. This is the usual equality in Haskell or Core. Two types are </font><em>representationally equal</em><font> when they have the same representation. (If a type is higher-kinded, all nominally equal instantiations lead to representationally equal types.)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>它们被添加到语言中以解决围绕新类型与其运行时表示之间的对应关系的一个相当讨厌且长期存在的错误。角色引入的基本区别是有两个类型相等的概念。当两个类型具有相同的名称时，它们在名义上是相等的。这是 Haskell 或 Core 中常见的相等性。当两种类型具有相同的表示时，它们在表示上是相等的。 （如果一个类型是更高种类的，那么所有名义上相等的实例化都会导致表示上相等的类型。）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><code>nominal</code><font> - Two types are the same.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标称 - 两种类型相同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><code>representational</code><font> - Two types have the same runtime representation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>representational - 两种类型具有相同的运行时表示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<div class=sourceCode include=src/16-type-families/roles.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=ot>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class=kw>newtype</span> <span class=dt>Age</span> <span class=fu>=</span> <span class=dt>MkAge</span> {<span class=ot> unAge ::</span> <span class=dt>Int</span> }

<span class=kw>type</span> family <span class=dt>Inspect</span> x
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Inspect</span> <span class=dt>Age</span> <span class=fu>=</span> <span class=dt>Int</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Inspect</span> <span class=dt>Int</span> <span class=fu>=</span> <span class=dt>Bool</span>

<span class=kw>class</span> <span class=dt>Boom</span> a <span class=kw>where</span>
<span class=ot>  boom ::</span> a <span class=ot>-&gt;</span> <span class=dt>Inspect</span> a

<span class=kw>instance</span> <span class=dt>Boom</span> <span class=dt>Int</span> <span class=kw>where</span>
  boom <span class=fu>=</span> (<span class=fu>==</span> <span class=dv>0</span>)

<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Boom</span> <span class=dt>Age</span>

<span class=co>-- GHC 7.6.3 exhibits undefined behavior</span>
failure <span class=fu>=</span> boom (<span class=dt>MkAge</span> <span class=dv>3</span>)
<span class=co>-- -6341068275333450897</span></code></pre></div>
<p><font>Roles are normally inferred automatically, but with the </font><code>RoleAnnotations</code><font> extension they can be manually annotated. Except in rare cases this should not be necessary although it is helpful to know what is going on under the hood.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>角色通常是自动推断的，但使用 RoleAnnotations 扩展可以手动注释它们。除非在极少数情况下，这不是必需的，尽管了解引擎盖下发生的事情是有帮助的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/role_infer.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE RoleAnnotations #-}</span>

<span class=kw>data</span> <span class=dt>Nat</span> <span class=fu>=</span> <span class=dt>Zero</span> <span class=fu>|</span> <span class=dt>Suc</span> <span class=dt>Nat</span>

<span class=kw>type</span> role <span class=dt>Vec</span> nominal representational
<span class=kw>data</span> <span class=dt>Vec</span><span class=ot> ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot>  ::</span> <span class=dt>Vec</span> <span class=dt>Zero</span> a
<span class=ot>  (:*) ::</span> a <span class=ot>-&gt;</span> <span class=dt>Vec</span> n a <span class=ot>-&gt;</span> <span class=dt>Vec</span> (<span class=dt>Suc</span> n) a

<span class=kw>type</span> role <span class=dt>App</span> representational nominal
<span class=kw>data</span> <span class=dt>App</span> (<span class=ot>f ::</span> k <span class=ot>-&gt;</span> <span class=fu>*</span>) (<span class=ot>a ::</span> k) <span class=fu>=</span> <span class=dt>App</span> (f a)

<span class=kw>type</span> role <span class=dt>Mu</span> nominal nominal
<span class=kw>data</span> <span class=dt>Mu</span> (<span class=ot>f ::</span> (k <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> <span class=fu>*</span>) (<span class=ot>a ::</span> k) <span class=fu>=</span> <span class=dt>Roll</span> (f (<span class=dt>Mu</span> f) a)

<span class=kw>type</span> role <span class=dt>Proxy</span> phantom
<span class=kw>data</span> <span class=dt>Proxy</span> (<span class=ot>a ::</span> k) <span class=fu>=</span> <span class=dt>Proxy</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://smunix.github.io/ghc.haskell.org/trac/ghc/wiki/Roles.html>Roles<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>角色</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/>Roles: A New Feature of GHC<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>角色：GHC 的新特性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=monotraversable><font>Monotraversable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可单行</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using type families, mono-traversable generalizes the notion of Functor, Foldable, and Traversable to include both monomorphic and polymorphic types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用类型族，mono-traversable 将 Functor、Foldable 和 Traversable 的概念概括为包括单态和多态类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>omap ::</span> <span class=dt>MonoFunctor</span> mono <span class=ot>=&gt;</span> (<span class=dt>Element</span> mono <span class=ot>-&gt;</span> <span class=dt>Element</span> mono) <span class=ot>-&gt;</span> mono <span class=ot>-&gt;</span> mono

<span class=ot>otraverse ::</span> (<span class=dt>Applicative</span> f, <span class=dt>MonoTraversable</span> mono)
          <span class=ot>=&gt;</span> (<span class=dt>Element</span> mono <span class=ot>-&gt;</span> f (<span class=dt>Element</span> mono)) <span class=ot>-&gt;</span> mono <span class=ot>-&gt;</span> f mono

<span class=ot>ofoldMap ::</span> (<span class=dt>Monoid</span> m, <span class=dt>MonoFoldable</span> mono)
         <span class=ot>=&gt;</span> (<span class=dt>Element</span> mono <span class=ot>-&gt;</span> m) <span class=ot>-&gt;</span> mono <span class=ot>-&gt;</span> m
<span class=ot>ofoldl' ::</span> <span class=dt>MonoFoldable</span> mono
        <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>Element</span> mono <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> mono <span class=ot>-&gt;</span> a
<span class=ot>ofoldr ::</span> <span class=dt>MonoFoldable</span> mono
        <span class=ot>=&gt;</span> (<span class=dt>Element</span> mono <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> mono <span class=ot>-&gt;</span> b</code></pre></div>
<p><font>For example the text type normally does not admit any of these type-classes since, but now we can write down the instances that model the interface of Foldable and Traversable.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，文本类型通常不允许任何这些类型类，但现在我们可以写下模拟 Foldable 和 Traversable 接口的实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/mono.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import </span><span class=dt>Data.Char</span>
<span class=kw>import </span><span class=dt>Data.Monoid</span>
<span class=kw>import </span><span class=dt>Data.MonoTraversable</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=ot>bs ::</span> <span class=dt>Text</span>
bs <span class=fu>=</span> <span class=st>"Hello Haskell."</span>

<span class=ot>shift ::</span> <span class=dt>Text</span>
shift <span class=fu>=</span> omap (chr <span class=fu>.</span> (<span class=fu>+</span><span class=dv>1</span>) <span class=fu>.</span> ord) bs
<span class=co>-- "Ifmmp!Ibtlfmm/"</span>

<span class=ot>backwards ::</span> [<span class=dt>Char</span>]
backwards <span class=fu>=</span> ofoldl' (flip (<span class=fu>:</span>)) <span class=st>""</span> bs
<span class=co>-- ".lleksaH olleH"</span>


<span class=kw>data</span> <span class=dt>MyMonoType</span> <span class=fu>=</span> <span class=dt>MNil</span> <span class=fu>|</span> <span class=dt>MCons</span> <span class=dt>Int</span> <span class=dt>MyMonoType</span> <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Element</span> <span class=dt>MyMonoType</span> <span class=fu>=</span> <span class=dt>Int</span>

<span class=kw>instance</span> <span class=dt>MonoFunctor</span> <span class=dt>MyMonoType</span> <span class=kw>where</span>
  omap f <span class=dt>MNil</span> <span class=fu>=</span> <span class=dt>MNil</span>
  omap f (<span class=dt>MCons</span> x xs) <span class=fu>=</span> f x <span class=ot>`MCons`</span> omap f xs

<span class=kw>instance</span> <span class=dt>MonoFoldable</span> <span class=dt>MyMonoType</span> <span class=kw>where</span>
  ofoldMap f <span class=fu>=</span> ofoldr (mappend <span class=fu>.</span> f) mempty
  ofoldr       <span class=fu>=</span> mfoldr
  ofoldl'      <span class=fu>=</span> mfoldl'
  ofoldr1Ex f  <span class=fu>=</span> ofoldr1Ex f <span class=fu>.</span> mtoList
  ofoldl1Ex' f <span class=fu>=</span> ofoldl1Ex' f <span class=fu>.</span> mtoList

<span class=kw>instance</span> <span class=dt>MonoTraversable</span> <span class=dt>MyMonoType</span> <span class=kw>where</span>
  omapM f xs <span class=fu>=</span> mapM f (mtoList xs) <span class=fu>&gt;&gt;=</span> return <span class=fu>.</span> mfromList
  otraverse f <span class=fu>=</span> ofoldr acons (pure <span class=dt>MNil</span>)
    <span class=kw>where</span> acons x ys <span class=fu>=</span> <span class=dt>MCons</span> <span class=fu>&lt;$&gt;</span> f x <span class=fu>&lt;*&gt;</span> ys

<span class=ot>mtoList ::</span> <span class=dt>MyMonoType</span> <span class=ot>-&gt;</span> [<span class=dt>Int</span>]
mtoList (<span class=dt>MNil</span>) <span class=fu>=</span> []
mtoList (<span class=dt>MCons</span> x xs) <span class=fu>=</span> x <span class=fu>:</span> (mtoList xs)

<span class=ot>mfromList ::</span> [<span class=dt>Int</span>] <span class=ot>-&gt;</span> <span class=dt>MyMonoType</span>
mfromList [] <span class=fu>=</span> <span class=dt>MNil</span>
mfromList (x<span class=fu>:</span>xs) <span class=fu>=</span> <span class=dt>MCons</span> x (mfromList xs)

<span class=ot>mfoldr ::</span> (<span class=dt>Int</span> <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>MyMonoType</span> <span class=ot>-&gt;</span> a
mfoldr f z <span class=dt>MNil</span> <span class=fu>=</span>  z
mfoldr f z (<span class=dt>MCons</span> x xs) <span class=fu>=</span>  f x (mfoldr f z xs)

<span class=ot>mfoldl' ::</span> (a <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>MyMonoType</span> <span class=ot>-&gt;</span> a
mfoldl' f z <span class=dt>MNil</span> <span class=fu>=</span> z
mfoldl' f z (<span class=dt>MCons</span> x xs) <span class=fu>=</span> <span class=kw>let</span> z' <span class=fu>=</span> z <span class=ot>`f`</span> x
                           <span class=kw>in</span> seq z' <span class=fu>$</span> mfoldl' f z' xs

<span class=ot>ex1 ::</span> <span class=dt>Int</span>
ex1 <span class=fu>=</span> mfoldl' (<span class=fu>+</span>) <span class=dv>0</span> (mfromList [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>])

<span class=ot>ex2 ::</span> <span class=dt>MyMonoType</span>
ex2 <span class=fu>=</span> omap (<span class=fu>+</span><span class=dv>1</span>) (mfromList [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>])</code></pre></div>
<p><font>See: </font><a href=http://fundeps.com/tables/FromSemigroupToMonads.pdf>From Semigroups to Monads</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：从半群到单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=nonempty><font>NonEmpty</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>非空</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Rather than having degenerate (and often partial) cases of many of the Prelude functions to accommodate the null case of lists, it is sometimes preferable to statically enforce empty lists from even being constructed as an inhabitant of a type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与其使用许多 Prelude 函数的退化（通常是部分）情况来适应列表的 null 情况，有时更可取的是静态强制空列表甚至被构造为类型的居民。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>infixr</span> <span class=dv>5</span> <span class=fu>:|</span>, <span class=fu>&lt;|</span>
<span class=kw>data</span> <span class=dt>NonEmpty</span> a <span class=fu>=</span> a <span class=fu>:|</span> [a]

head<span class=ot> ::</span> <span class=dt>NonEmpty</span> a <span class=ot>-&gt;</span> a
<span class=ot>toList ::</span> <span class=dt>NonEmpty</span> a <span class=ot>-&gt;</span> [a]
<span class=ot>fromList ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>NonEmpty</span> a</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class=ot> ::</span> <span class=dt>NonEmpty</span> a <span class=ot>-&gt;</span> a
head <span class=fu>~</span>(a <span class=fu>:|</span> _) <span class=fu>=</span> a</code></pre></div>
<div class=sourceCode include=src/16-type-families/noempty.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.List.NonEmpty</span>
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (head, tail, foldl1)
<span class=kw>import </span><span class=dt>Data.Foldable</span> (foldl1)

<span class=ot>a ::</span> <span class=dt>NonEmpty</span> <span class=dt>Integer</span>
a <span class=fu>=</span> fromList [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]
<span class=co>-- 1 :| [2,3]</span>

<span class=ot>b ::</span> <span class=dt>NonEmpty</span> <span class=dt>Integer</span>
b <span class=fu>=</span> <span class=dv>1</span> <span class=fu>:|</span> [<span class=dv>2</span>,<span class=dv>3</span>]
<span class=co>-- 1 :| [2,3]</span>

<span class=ot>c ::</span> <span class=dt>NonEmpty</span> <span class=dt>Integer</span>
c <span class=fu>=</span> fromList []
<span class=co>-- *** Exception: NonEmpty.fromList: empty list</span>

<span class=ot>d ::</span> <span class=dt>Integer</span>
d <span class=fu>=</span> foldl1 (<span class=fu>+</span>) <span class=fu>$</span> fromList [<span class=dv>1</span><span class=fu>..</span><span class=dv>100</span>]
<span class=co>-- 5050</span></code></pre></div>
<h2 id=overloaded-lists-1><font>Overloaded Lists</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>重载列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>In GHC 7.8 </font><code>-XOverloadedLists</code><font> can be used to avoid the extraneous </font><code>fromList</code><font> and </font><code>toList</code><font> conversions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 GHC 7.8 中，-XOverloadedLists 可用于避免无关的 fromList 和 toList 转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=manual-proofs><font>Manual Proofs</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>人工校样</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>One of most deep results in computer science, the </font><a href=https://smunix.github.io/en.wikipedia.org/wiki/Curry%e2%80%93Howard_correspondence.html>Curry–Howard correspondence</a><font>, is the relation that logical propositions can be modeled by types and instantiating those types constitute proofs of these propositions. Programs are proofs and proofs are programs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>计算机科学中最深刻的成果之一，即 Curry-Howard 对应，是逻辑命题可以按类型建模的关系，并且实例化这些类型构成了这些命题的证明。程序是证明，证明也是程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Types</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Logic</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>逻辑</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>A<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>A</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>proposition</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主张</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>a : A<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个：一个</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>proof</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>证明</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>B(x)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>B(x)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>predicate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>谓词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>Void<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空白</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>⊥</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>⊥</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>Unit<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单元</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>⊤</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>⊤</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>A + B<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>甲+乙</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>A ∨ B</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个∨乙</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>A × B<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>甲×乙</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>A ∧ B</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个∧乙</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>A -&gt; B<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>A -&gt; B</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>A ⇒ B</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>甲⇒乙</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>In dependently typed languages we can exploit this result to its full extent, in Haskell we don't have the strength that dependent types provide but can still prove trivial results. For example, now we can model a type level function for addition and provide a small proof that zero is an additive identity.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在依赖类型语言中，我们可以充分利用这个结果，在 Haskell 中，我们没有依赖类型提供的力量，但仍然可以证明微不足道的结果。例如，现在我们可以为加法建模类型级函数，并提供零是加法恒等式的小证明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>P</span> <span class=dv>0</span>                   [ base step ]
<span class=ot>∀</span>n<span class=fu>.</span> <span class=dt>P</span> n  <span class=ot>→</span> <span class=dt>P</span> (<span class=dv>1</span><span class=fu>+</span>n)    [ inductive step ]
<span class=fu>-------------------</span>
<span class=ot>∀</span>n<span class=fu>.</span> <span class=dt>P</span>(n)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Axiom</span> <span class=dv>1</span><span class=fu>:</span> a <span class=fu>+</span> <span class=dv>0</span> <span class=fu>=</span> a
<span class=dt>Axiom</span> <span class=dv>2</span><span class=fu>:</span> a <span class=fu>+</span> suc b <span class=fu>=</span> suc (a <span class=fu>+</span> b)

  <span class=dv>0</span> <span class=fu>+</span> suc a
<span class=fu>=</span> suc (<span class=dv>0</span> <span class=fu>+</span> a)  [by <span class=dt>Axiom</span> <span class=dv>2</span>]
<span class=fu>=</span> suc a        [<span class=dt>Induction</span> hypothesis]
∎</code></pre></div>
<p><font>Translated into Haskell our axioms are simply type definitions and recursing over the inductive datatype constitutes the inductive step of our proof.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>翻译成 Haskell，我们的公理只是类型定义，递归归纳数据类型构成了我们证明的归纳步骤。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/proof.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>

<span class=kw>data</span> <span class=dt>Z</span>
<span class=kw>data</span> <span class=dt>S</span> n

<span class=kw>data</span> <span class=dt>SNat</span> n <span class=kw>where</span>
  <span class=dt>Zero</span><span class=ot> ::</span> <span class=dt>SNat</span> <span class=dt>Z</span>
  <span class=dt>Succ</span><span class=ot> ::</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> <span class=dt>SNat</span> (<span class=dt>S</span> n)

<span class=kw>data</span> <span class=dt>Eql</span> a b <span class=kw>where</span>
  <span class=dt>Refl</span><span class=ot> ::</span> <span class=dt>Eql</span> a a

<span class=kw>type</span> family <span class=dt>Add</span> m n
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Add</span> <span class=dt>Z</span> n <span class=fu>=</span> n
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Add</span> (<span class=dt>S</span> m) n <span class=fu>=</span> <span class=dt>S</span> (<span class=dt>Add</span> m n)

<span class=ot>add ::</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> <span class=dt>SNat</span> m <span class=ot>-&gt;</span> <span class=dt>SNat</span> (<span class=dt>Add</span> n m)
add <span class=dt>Zero</span>     m <span class=fu>=</span> m
add (<span class=dt>Succ</span> n) m <span class=fu>=</span> <span class=dt>Succ</span> (add n m)

<span class=ot>cong ::</span> <span class=dt>Eql</span> a b <span class=ot>-&gt;</span> <span class=dt>Eql</span> (f a) (f b)
cong <span class=dt>Refl</span> <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- ∀n. 0 + suc n = suc n</span>
<span class=ot>plus_suc ::</span> forall n<span class=fu>.</span>  <span class=dt>SNat</span> n
         <span class=ot>-&gt;</span> <span class=dt>Eql</span> (<span class=dt>Add</span> <span class=dt>Z</span> (<span class=dt>S</span> n)) (<span class=dt>S</span> n)
plus_suc <span class=dt>Zero</span> <span class=fu>=</span> <span class=dt>Refl</span>
plus_suc (<span class=dt>Succ</span> n) <span class=fu>=</span> cong (plus_suc n)

<span class=co>-- ∀n. 0 + n = n</span>
<span class=ot>plus_zero ::</span> forall n<span class=fu>.</span> <span class=dt>SNat</span> n
         <span class=ot>-&gt;</span> <span class=dt>Eql</span> (<span class=dt>Add</span> <span class=dt>Z</span> n) n
plus_zero <span class=dt>Zero</span> <span class=fu>=</span> <span class=dt>Refl</span>
plus_zero (<span class=dt>Succ</span> n) <span class=fu>=</span> cong (plus_zero n)</code></pre></div>
<p><font>Using the </font><code>TypeOperators</code><font> extension we can also use infix notation at the type-level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 TypeOperators 扩展，我们还可以在类型级别使用中缀表示法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> a <span class=fu>:=:</span> b <span class=kw>where</span>
  <span class=dt>Refl</span><span class=ot> ::</span> a <span class=fu>:=:</span> a

<span class=ot>cong ::</span> a <span class=fu>:=:</span> b <span class=ot>-&gt;</span> (f a) <span class=fu>:=:</span> (f b)
cong <span class=dt>Refl</span> <span class=fu>=</span> <span class=dt>Refl</span>

<span class=kw>type</span> family (<span class=ot>n ::</span> <span class=dt>Nat</span>) <span class=fu>:+</span> (<span class=ot>m ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Zero</span>     <span class=fu>:+</span> m <span class=fu>=</span> m
<span class=kw>type</span> <span class=kw>instance</span> (<span class=dt>Succ</span> n) <span class=fu>:+</span> m <span class=fu>=</span> <span class=dt>Succ</span> (n <span class=fu>:+</span> m)

<span class=ot>plus_suc ::</span> forall n m<span class=fu>.</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> <span class=dt>SNat</span> m <span class=ot>-&gt;</span> (n <span class=fu>:+</span> (<span class=dt>S</span> m)) <span class=fu>:=:</span> (<span class=dt>S</span> (n <span class=fu>:+</span> m))
plus_suc <span class=dt>Zero</span> m <span class=fu>=</span> <span class=dt>Refl</span>
plus_suc (<span class=dt>Succ</span> n) m <span class=fu>=</span> cong (plus_suc n m)</code></pre></div>
<h2 id=constraint-kinds><font>Constraint Kinds</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>约束种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>GHC's implementation also exposes the predicates that bound quantifiers in Haskell as types themselves, with the </font><code>-XConstraintKinds</code><font> extension enabled. Using this extension we work with constraints as first class types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 的实现还公开了在 Haskell 中绑定量词的谓词作为类型本身，并启用了 -XConstraintKinds 扩展。使用此扩展，我们将约束作为第一类类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Num</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=dt>Constraint</span>
<span class=dt>Odd</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=dt>Constraint</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>T1</span> a <span class=fu>=</span> (<span class=dt>Num</span> a, <span class=dt>Ord</span> a)</code></pre></div>
<p><font>The empty constraint set is indicated by </font><code>() :: Constraint</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空约束集由 ()::Constraint 表示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For a contrived example if we wanted to create a generic </font><code>Sized</code><font> class that carried with it constraints on the elements of the container in question we could achieve this quite simply using type families.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>举一个人为的例子，如果我们想创建一个通用的 Sized 类，它带有对相关容器元素的约束，我们可以非常简单地使用类型族来实现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/constraintkinds.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>

<span class=kw>import </span><span class=dt>GHC.Exts</span> (<span class=dt>Constraint</span>)
<span class=kw>import </span><span class=dt>Data.Hashable</span>
<span class=kw>import </span><span class=dt>Data.HashSet</span>

<span class=kw>type</span> family <span class=dt>Con</span><span class=ot> a ::</span> <span class=dt>Constraint</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Con</span> [a] <span class=fu>=</span> (<span class=dt>Ord</span> a, <span class=dt>Eq</span> a)
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Con</span> (<span class=dt>HashSet</span> a) <span class=fu>=</span> (<span class=dt>Hashable</span> a)

<span class=kw>class</span> <span class=dt>Sized</span> a <span class=kw>where</span>
<span class=ot>  gsize ::</span> <span class=dt>Con</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>

<span class=kw>instance</span> <span class=dt>Sized</span> [a] <span class=kw>where</span>
  gsize <span class=fu>=</span> length

<span class=kw>instance</span> <span class=dt>Sized</span> (<span class=dt>HashSet</span> a) <span class=kw>where</span>
  gsize <span class=fu>=</span> size</code></pre></div>
<p><font>One use-case of this is to capture the typeclass dictionary constrained by a function and reify it as a value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个用例是捕获受函数约束的类型类字典并将其具体化为一个值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/16-type-families/dict.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>

<span class=kw>import </span><span class=dt>GHC.Exts</span> (<span class=dt>Constraint</span>)

<span class=kw>data</span> <span class=dt>Dict</span><span class=ot> ::</span> <span class=dt>Constraint</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Dict</span><span class=ot> ::</span> (c) <span class=ot>=&gt;</span> <span class=dt>Dict</span> c

<span class=ot>dShow ::</span> <span class=dt>Dict</span> (<span class=dt>Show</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>String</span>
dShow <span class=dt>Dict</span> x <span class=fu>=</span> show x

<span class=ot>dEqNum ::</span> <span class=dt>Dict</span> (<span class=dt>Eq</span> a, <span class=dt>Num</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
dEqNum <span class=dt>Dict</span> x <span class=fu>=</span> x <span class=fu>==</span> <span class=dv>0</span>


<span class=ot>fShow ::</span> <span class=dt>String</span>
fShow <span class=fu>=</span> dShow <span class=dt>Dict</span> <span class=dv>10</span>

<span class=ot>fEqual ::</span> <span class=dt>Bool</span>
fEqual <span class=fu>=</span> dEqNum <span class=dt>Dict</span> <span class=dv>0</span></code></pre></div>
<h2 id=typefamilydependencies><font>TypeFamilyDependencies</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型FamilyDependencies</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Type families historically have not been injective, i.e. they are not guaranteed to maps distinct elements of its arguments to the same element of its result. The syntax is similar to the multiparmater typeclass functional dependencies in that the resulting type is uniquely determined by a set of the type families parameters.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从历史上看，类型族不是单射的，即它们不能保证将其参数的不同元素映射到其结果的相同元素。语法类似于多参数类型类函数依赖性，因为结果类型由一组类型族参数唯一确定。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE XTypeFamilyDependencies #-}</span>

<span class=kw>type</span> family <span class=dt>F</span> a b c <span class=fu>=</span> (<span class=ot>result ::</span> k) <span class=fu>|</span> result <span class=ot>-&gt;</span> a b c
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>F</span> <span class=dt>Int</span>  <span class=dt>Char</span> <span class=dt>Bool</span> <span class=fu>=</span> <span class=dt>Bool</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>F</span> <span class=dt>Char</span> <span class=dt>Bool</span> <span class=dt>Int</span>  <span class=fu>=</span> <span class=dt>Int</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>F</span> <span class=dt>Bool</span> <span class=dt>Int</span>  <span class=dt>Char</span> <span class=fu>=</span> <span class=dt>Char</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf>Injective type families for Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Haskell 的单射类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h1 id=promotion><font>Promotion</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>晋升</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=higher-kinded-types><font>Higher Kinded Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高等类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>What are higher kinded types?</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>什么是高等类型？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The kind system in Haskell is unique by contrast with most other languages in that it allows datatypes to be constructed which take types and type constructor to other types. Such a system is said to support </font><em>higher kinded types</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>与大多数其他语言相比，Haskell 中的种类系统是独一无二的，因为它允许构造将类型和类型构造函数用于其他类型的数据类型。据说这样的系统支持更高种类的类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>All kind annotations in Haskell necessarily result in a kind </font><code>*</code><font> although any terms to the left may be higher-kinded (</font><code>* -&gt; *</code><font>).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中的所有类型注解都必然导致类型 *，尽管左侧的任何项都可能是更高类型的 (* -&gt; *)。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The common example is the Monad which has kind </font><code>* -&gt; *</code><font>. But we have also seen this higher-kindedness in free monads.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>常见的例子是具有种类 * -&gt; * 的 Monad。但是我们也在自由单子中看到了这种更高的亲和性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Free</span> f a <span class=kw>where</span>
  <span class=dt>Pure</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Free</span> f a
  <span class=dt>Free</span><span class=ot> ::</span> f (<span class=dt>Free</span> f a) <span class=ot>-&gt;</span> <span class=dt>Free</span> f a

<span class=kw>data</span> <span class=dt>Cofree</span> f a <span class=kw>where</span>
  <span class=dt>Cofree</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> f (<span class=dt>Cofree</span> f a) <span class=ot>-&gt;</span> <span class=dt>Cofree</span> f a</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Free</span><span class=ot> ::</span> (<span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=dt>Cofree</span><span class=ot> ::</span> (<span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span></code></pre></div>
<p><font>For instance </font><code>Cofree Maybe a</code><font> for some monokinded type </font><code>a</code><font> models a non-empty list with </font><code>Maybe :: * -&gt; *</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如 Cofree Maybe a 对于一些 monokinded 类型 a 建模一个带有 Maybe :: * -&gt; * 的非空列表。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Cofree Maybe a is a non-empty list</span>
<span class=ot>testCofree ::</span> <span class=dt>Cofree</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
testCofree <span class=fu>=</span> (<span class=dt>Cofree</span> <span class=dv>1</span> (<span class=dt>Just</span> (<span class=dt>Cofree</span> <span class=dv>2</span> <span class=dt>Nothing</span>)))</code></pre></div>
<h2 id=kind-polymorphism><font>Kind Polymorphism</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>种类多态性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of kind polymorphism is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，种类多态性的知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>The regular value level function which takes a function and applies it to an argument is universally generalized over in the usual Hindley-Milner way.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>采用函数并将其应用于参数的常规值级别函数以通常的 Hindley-Milner 方式普遍推广。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>app ::</span> forall a b<span class=fu>.</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
app f a <span class=fu>=</span> f a</code></pre></div>
<p><font>But when we do the same thing at the type-level we see we lose information about the polymorphism of the constructor applied.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>但是当我们在类型级别做同样的事情时，我们会发现我们丢失了有关所应用的构造函数的多态性的信息。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- TApp :: (* -&gt; *) -&gt; * -&gt; *</span>
<span class=kw>data</span> <span class=dt>TApp</span> f a <span class=fu>=</span> <span class=dt>MkTApp</span> (f a)</code></pre></div>
<p><font>Turning on </font><code>-XPolyKinds</code><font> allows polymorphic variables at the kind level as well.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>打开 -XPolyKinds 也允许种类级别的多态变量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Default:   (* -&gt; *) -&gt; * -&gt; *</span>
<span class=co>-- PolyKinds: (k -&gt; *) -&gt; k -&gt; *</span>
<span class=kw>data</span> <span class=dt>TApp</span> f a <span class=fu>=</span> <span class=dt>MkTApp</span> (f a)

<span class=co>-- Default:   ((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</span>
<span class=co>-- PolyKinds: ((k -&gt; *) -&gt; (k -&gt; *)) -&gt; (k -&gt; *)</span>
<span class=kw>data</span> <span class=dt>Mu</span> f a <span class=fu>=</span> <span class=dt>Roll</span> (f (<span class=dt>Mu</span> f) a)

<span class=co>-- Default:   * -&gt; *</span>
<span class=co>-- PolyKinds: k -&gt; *</span>
<span class=kw>data</span> <span class=dt>Proxy</span> a <span class=fu>=</span> <span class=dt>Proxy</span></code></pre></div>
<p><font>Using the polykinded </font><code>Proxy</code><font> type allows us to write down type class functions over constructors of arbitrary kind arity.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用多元代理类型允许我们在任意种类的构造函数上写下类型类函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/kindpoly.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>

<span class=kw>data</span> <span class=dt>Proxy</span> a <span class=fu>=</span> <span class=dt>Proxy</span>
<span class=kw>data</span> <span class=dt>Rep</span> <span class=fu>=</span> <span class=dt>Rep</span>

<span class=kw>class</span> <span class=dt>PolyClass</span> a <span class=kw>where</span>
<span class=ot>  foo ::</span> <span class=dt>Proxy</span> a <span class=ot>-&gt;</span> <span class=dt>Rep</span>
  foo <span class=fu>=</span> const <span class=dt>Rep</span>

<span class=co>-- () :: *</span>
<span class=co>-- [] :: * -&gt; *</span>
<span class=co>-- Either :: * -&gt; * -&gt; *</span>

<span class=kw>instance</span> <span class=dt>PolyClass</span> ()
<span class=kw>instance</span> <span class=dt>PolyClass</span> []
<span class=kw>instance</span> <span class=dt>PolyClass</span> <span class=dt>Either</span></code></pre></div>
<p><font>For example we can write down the polymorphic </font><code>S</code> <code>K</code><font> combinators at the type level now.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们现在可以在类型级别写下多态 S K 组合子。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PolyKinds #-}</span>

<span class=kw>newtype</span> <span class=dt>I</span> (<span class=ot>a ::</span> <span class=fu>*</span>) <span class=fu>=</span> <span class=dt>I</span> a
<span class=kw>newtype</span> <span class=dt>K</span> (<span class=ot>a ::</span> <span class=fu>*</span>) (<span class=ot>b ::</span> k) <span class=fu>=</span> <span class=dt>K</span> a
<span class=kw>newtype</span> <span class=dt>Flip</span> (<span class=ot>f ::</span> k1 <span class=ot>-&gt;</span> k2 <span class=ot>-&gt;</span> <span class=fu>*</span>) (<span class=ot>x ::</span> k2) (<span class=ot>y ::</span> k1) <span class=fu>=</span> <span class=dt>Flip</span> (f y x)

<span class=ot>unI ::</span> <span class=dt>I</span> a <span class=ot>-&gt;</span> a
unI (<span class=dt>I</span> x) <span class=fu>=</span> x

<span class=ot>unK ::</span> <span class=dt>K</span> a b <span class=ot>-&gt;</span> a
unK (<span class=dt>K</span> x) <span class=fu>=</span> x

<span class=ot>unFlip ::</span> <span class=dt>Flip</span> f x y <span class=ot>-&gt;</span> f y x
unFlip (<span class=dt>Flip</span> x) <span class=fu>=</span> x</code></pre></div>
<h2 id=data-kinds><font>Data Kinds</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据种类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of kind data kinds is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，编写 Haskell 通常不需要种类数据类型的知识。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>The </font><code>-XDataKinds</code><font> extension allows us to use refer to constructors at the value level and the type level. Consider a simple sum type:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-XDataKinds 扩展允许我们在值级别和类型级别使用引用构造函数。考虑一个简单的求和类型：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>S</span> a b <span class=fu>=</span> <span class=dt>L</span> a <span class=fu>|</span> <span class=dt>R</span> b

<span class=co>-- S :: * -&gt; * -&gt; *</span>
<span class=co>-- L :: a -&gt; S a b</span>
<span class=co>-- R :: b -&gt; S a b</span></code></pre></div>
<p><font>With the extension enabled we see that our type constructors are now automatically promoted so that </font><code>L</code><font> or </font><code>R</code><font> can be viewed as both a data constructor of the type </font><code>S</code><font> or as the type </font><code>L</code><font> with kind </font><code>S</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用扩展后，我们看到我们的类型构造函数现在被自动提升，因此 L 或 R 可以被视为类型 S 的数据构造函数或类型 L 和类型 S。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>

<span class=kw>data</span> <span class=dt>S</span> a b <span class=fu>=</span> <span class=dt>L</span> a <span class=fu>|</span> <span class=dt>R</span> b

<span class=co>-- S :: * -&gt; * -&gt; *</span>
<span class=co>-- L :: * -&gt; S * *</span>
<span class=co>-- R :: * -&gt; S * *</span></code></pre></div>
<p><font>Promoted data constructors can referred to in type signatures by prefixing them with a single quote. Also of importance is that these promoted constructors are not exported with a module by default, but type synonym instances can be created for the ticked promoted types and exported directly.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>提升的数据构造函数可以在类型签名中通过在它们前面加上单引号来引用。同样重要的是，默认情况下，这些提升的构造函数不会与模块一起导出，但可以为勾选的提升类型创建类型同义词实例并直接导出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Foo</span> <span class=fu>=</span> <span class=dt>Bar</span> <span class=fu>|</span> <span class=dt>Baz</span>
<span class=kw>type</span> <span class=dt>Bar</span> <span class=fu>=</span> <span class=ch>'Bar</span>
<span class=kw>type</span> <span class=dt>Baz</span> <span class=fu>=</span> <span class=ch>'Baz</span></code></pre></div>
<p><font>Combining this with type families we see we can write meaningful, meaningful type-level functions by lifting types to the kind level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将其与类型族结合起来，我们看到我们可以通过将类型提升到种类级别来编写有意义的、有意义的类型级函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/typefamily.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>

<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (<span class=dt>Bool</span>(..))

<span class=kw>data</span> <span class=dt>Bool</span> <span class=fu>=</span> <span class=dt>True</span> <span class=fu>|</span> <span class=dt>False</span>

<span class=kw>type</span> family <span class=dt>Not</span> (<span class=ot>a ::</span> <span class=dt>Bool</span>)<span class=ot> ::</span> <span class=dt>Bool</span>

<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Not</span> <span class=dt>True</span> <span class=fu>=</span> <span class=dt>False</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Not</span> <span class=dt>False</span> <span class=fu>=</span> <span class=dt>True</span>

<span class=ot>false ::</span> <span class=dt>Not</span> <span class=dt>True</span> <span class=fu>~</span> <span class=dt>False</span> <span class=ot>=&gt;</span> a
false <span class=fu>=</span> undefined

<span class=ot>true ::</span> <span class=dt>Not</span> <span class=dt>False</span> <span class=fu>~</span> <span class=dt>True</span> <span class=ot>=&gt;</span> a
true <span class=fu>=</span> undefined

<span class=co>-- Fails at compile time.</span>
<span class=co>-- Couldn't match type 'False with 'True</span>
<span class=ot>invalid ::</span> <span class=dt>Not</span> <span class=dt>True</span> <span class=fu>~</span> <span class=dt>True</span> <span class=ot>=&gt;</span> a
invalid <span class=fu>=</span> undefined</code></pre></div>
<h2 id=size-indexed-vectors><font>Size-Indexed Vectors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>大小索引载体</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using this new structure we can create a </font><code>Vec</code><font> type which is parameterized by its length as well as its element type now that we have a kind language rich enough to encode the successor type in the kind signature of the generalized algebraic datatype.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用这个新结构，我们可以创建一个 Vec 类型，它由它的长度和它的元素类型参数化，现在我们有一种足够丰富的种类语言来编码广义代数数据类型的种类签名中的后继类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/datakinds.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>

<span class=kw>data</span> <span class=dt>Nat</span> <span class=fu>=</span> <span class=dt>Z</span> <span class=fu>|</span> <span class=dt>S</span> <span class=dt>Nat</span> <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=kw>type</span> <span class=dt>Zero</span>  <span class=fu>=</span> <span class=dt>Z</span>
<span class=kw>type</span> <span class=dt>One</span>   <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Zero</span>
<span class=kw>type</span> <span class=dt>Two</span>   <span class=fu>=</span> <span class=dt>S</span> <span class=dt>One</span>
<span class=kw>type</span> <span class=dt>Three</span> <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Two</span>
<span class=kw>type</span> <span class=dt>Four</span>  <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Three</span>
<span class=kw>type</span> <span class=dt>Five</span>  <span class=fu>=</span> <span class=dt>S</span> <span class=dt>Four</span>

<span class=kw>data</span> <span class=dt>Vec</span><span class=ot> ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>Vec</span> <span class=dt>Z</span> a
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Vec</span> n a <span class=ot>-&gt;</span> <span class=dt>Vec</span> (<span class=dt>S</span> n) a

<span class=kw>instance</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> <span class=dt>Show</span> (<span class=dt>Vec</span> n a) <span class=kw>where</span>
  show <span class=dt>Nil</span>         <span class=fu>=</span> <span class=st>"Nil"</span>
  show (<span class=dt>Cons</span> x xs) <span class=fu>=</span> <span class=st>"Cons "</span> <span class=fu>++</span> show x <span class=fu>++</span> <span class=st>" ("</span> <span class=fu>++</span> show xs <span class=fu>++</span> <span class=st>")"</span>

<span class=kw>class</span> <span class=dt>FromList</span> n <span class=kw>where</span>
<span class=ot>  fromList ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Vec</span> n a

<span class=kw>instance</span> <span class=dt>FromList</span> <span class=dt>Z</span> <span class=kw>where</span>
  fromList [] <span class=fu>=</span> <span class=dt>Nil</span>

<span class=kw>instance</span> <span class=dt>FromList</span> n <span class=ot>=&gt;</span> <span class=dt>FromList</span> (<span class=dt>S</span> n) <span class=kw>where</span>
  fromList (x<span class=fu>:</span>xs) <span class=fu>=</span> <span class=dt>Cons</span> x <span class=fu>$</span> fromList xs


<span class=ot>lengthVec ::</span> <span class=dt>Vec</span> n a <span class=ot>-&gt;</span> <span class=dt>Nat</span>
lengthVec <span class=dt>Nil</span> <span class=fu>=</span> <span class=dt>Z</span>
lengthVec (<span class=dt>Cons</span> x xs) <span class=fu>=</span> <span class=dt>S</span> (lengthVec xs)

<span class=ot>zipVec ::</span> <span class=dt>Vec</span> n a <span class=ot>-&gt;</span> <span class=dt>Vec</span> n b <span class=ot>-&gt;</span> <span class=dt>Vec</span> n (a,b)
zipVec <span class=dt>Nil</span> <span class=dt>Nil</span> <span class=fu>=</span> <span class=dt>Nil</span>
zipVec (<span class=dt>Cons</span> x xs) (<span class=dt>Cons</span> y ys) <span class=fu>=</span> <span class=dt>Cons</span> (x,y) (zipVec xs ys)

<span class=ot>vec4 ::</span> <span class=dt>Vec</span> <span class=dt>Four</span> <span class=dt>Int</span>
vec4 <span class=fu>=</span> fromList [<span class=dv>0</span>, <span class=dv>1</span>, <span class=dv>2</span>, <span class=dv>3</span>]

<span class=ot>vec5 ::</span> <span class=dt>Vec</span> <span class=dt>Five</span> <span class=dt>Int</span>
vec5 <span class=fu>=</span> fromList [<span class=dv>0</span>, <span class=dv>1</span>, <span class=dv>2</span>, <span class=dv>3</span>, <span class=dv>4</span>]


<span class=ot>example1 ::</span> <span class=dt>Nat</span>
example1 <span class=fu>=</span> lengthVec vec4
<span class=co>-- S (S (S (S Z)))</span>

<span class=ot>example2 ::</span> <span class=dt>Vec</span> <span class=dt>Four</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
example2 <span class=fu>=</span> zipVec vec4 vec4
<span class=co>-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))</span></code></pre></div>
<p><font>So now if we try to zip two </font><code>Vec</code><font> types with the wrong shape then we get an error at compile-time about the off-by-one error.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以现在如果我们尝试压缩两个形状错误的 Vec 类型，那么我们会在编译时得到一个关于差一错误的错误。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">example2 <span class=fu>=</span> zipVec vec4 vec5
<span class=co>-- Couldn't match type 'S 'Z with 'Z</span>
<span class=co>-- Expected type: Vec Four Int</span>
<span class=co>--   Actual type: Vec Five Int</span></code></pre></div>
<p><font>The same technique we can use to create a container which is statically indexed by an empty or non-empty flag, such that if we try to take the head of an empty list we'll get a compile-time error, or stated equivalently we have an obligation to prove to the compiler that the argument we hand to the head function is non-empty.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们可以使用相同的技术来创建一个由空或非空标志静态索引的容器，这样如果我们尝试获取空列表的头部，我们将得到一个编译时错误，或者等价地声明我们有义务向编译器证明我们传递给 head 函数的参数是非空的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/nonempty.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>

<span class=kw>data</span> <span class=dt>Size</span> <span class=fu>=</span> <span class=dt>Empty</span> <span class=fu>|</span> <span class=dt>NonEmpty</span>

<span class=kw>data</span> <span class=dt>List</span> a b <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot>  ::</span> <span class=dt>List</span> <span class=dt>Empty</span> a
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>List</span> b a <span class=ot>-&gt;</span> <span class=dt>List</span> <span class=dt>NonEmpty</span> a

<span class=ot>head' ::</span> <span class=dt>List</span> <span class=dt>NonEmpty</span> a <span class=ot>-&gt;</span> a
head' (<span class=dt>Cons</span> x _) <span class=fu>=</span> x

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> head' (<span class=dv>1</span> <span class=ot>`Cons`</span> (<span class=dv>2</span> <span class=ot>`Cons`</span> <span class=dt>Nil</span>))

<span class=co>-- Cannot match type Empty with NonEmpty</span>
<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> head' <span class=dt>Nil</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Couldn't</span> match <span class=kw>type</span> <span class=dt>None</span> with <span class=dt>Many</span>
<span class=dt>Expected</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>List</span> <span class=dt>NonEmpty</span> <span class=dt>Int</span>
  <span class=dt>Actual</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>List</span> <span class=dt>Empty</span> <span class=dt>Int</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf>Giving Haskell a Promotion<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>给 Haskell 升职</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=typelevel-numbers><font>Typelevel Numbers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级数字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>GHC's type literals can also be used in place of explicit Peano arithmetic.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 的类型文字也可以用来代替显式的 Peano 算术。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>GHC 7.6 is very conservative about performing reduction, GHC 7.8 is much less so and will can solve many typelevel constraints involving natural numbers but sometimes still needs a little coaxing.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 7.6 在执行缩减方面非常保守，GHC 7.8 则要少得多，并且可以解决许多涉及自然数的类型级约束，但有时仍需要一点哄骗。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/typenat.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=kw>data</span> <span class=dt>Vec</span><span class=ot> ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>Vec</span> <span class=dv>0</span> a
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Vec</span> n a <span class=ot>-&gt;</span> <span class=dt>Vec</span> (<span class=dv>1</span> <span class=fu>+</span> n) a

<span class=co>-- GHC 7.6 will not reduce</span>
<span class=co>-- vec3 :: Vec (1 + (1 + (1 + 0))) Int</span>

<span class=ot>vec3 ::</span> <span class=dt>Vec</span> <span class=dv>3</span> <span class=dt>Int</span>
vec3 <span class=fu>=</span> <span class=dv>0</span> <span class=ot>`Cons`</span> (<span class=dv>1</span> <span class=ot>`Cons`</span> (<span class=dv>2</span> <span class=ot>`Cons`</span> <span class=dt>Nil</span>))</code></pre></div>
<div class=sourceCode include=src/17-promotion/typenat_cmp.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>
<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=kw>data</span> <span class=dt>Foo</span><span class=ot> ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Small</span><span class=ot>    ::</span> (n <span class=fu>&lt;=</span> <span class=dv>2</span>)  <span class=ot>=&gt;</span> <span class=dt>Foo</span> n
  <span class=dt>Big</span><span class=ot>      ::</span> (<span class=dv>3</span> <span class=fu>&lt;=</span> n) <span class=ot>=&gt;</span> <span class=dt>Foo</span> n

  <span class=dt>Empty</span><span class=ot>    ::</span> ((n <span class=fu>==</span> <span class=dv>0</span>) <span class=fu>~</span> <span class=dt>True</span>) <span class=ot>=&gt;</span> <span class=dt>Foo</span> n
  <span class=dt>NonEmpty</span><span class=ot> ::</span> ((n <span class=fu>==</span> <span class=dv>0</span>) <span class=fu>~</span> <span class=dt>False</span>) <span class=ot>=&gt;</span> <span class=dt>Foo</span> n

<span class=ot>big ::</span> <span class=dt>Foo</span> <span class=dv>10</span>
big <span class=fu>=</span> <span class=dt>Big</span>

<span class=ot>small ::</span> <span class=dt>Foo</span> <span class=dv>2</span>
small <span class=fu>=</span> <span class=dt>Small</span>

<span class=ot>empty ::</span> <span class=dt>Foo</span> <span class=dv>0</span>
empty <span class=fu>=</span> <span class=dt>Empty</span>

<span class=ot>nonempty ::</span> <span class=dt>Foo</span> <span class=dv>3</span>
nonempty <span class=fu>=</span> <span class=dt>NonEmpty</span></code></pre></div>
<p><font>See: </font><a href=http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html>Type-Level Literals</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：类型级文字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=typelevel-strings><font>Typelevel Strings</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=custom-errors><font>Custom Errors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自定义错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>As of GHC 8.0 we have the capacity to provide custom type error using type families. The messages themselves hook into GHC and expressed using the small datatype found in </font><code>GHC.TypeLits</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 GHC 8.0 开始，我们有能力使用类型族提供自定义类型错误。消息本身挂接到 GHC 并使用 GHC.TypeLits 中的小型数据类型表示</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>ErrorMessage</span> <span class=kw>where</span>
  <span class=dt>Text</span><span class=ot> ::</span> <span class=dt>Symbol</span> <span class=ot>-&gt;</span> <span class=dt>ErrorMessage</span>
  <span class=dt>ShowType</span><span class=ot> ::</span> t <span class=ot>-&gt;</span> <span class=dt>ErrorMessage</span>

  <span class=co>-- Put two messages next to each other</span>
<span class=ot>  (:&lt;&gt;:) ::</span> <span class=dt>ErrorMessage</span> <span class=ot>-&gt;</span> <span class=dt>ErrorMessage</span> <span class=ot>-&gt;</span> <span class=dt>ErrorMessage</span>

  <span class=co>-- Put two messages on top of each other</span>
<span class=ot>  (:$$:) ::</span> <span class=dt>ErrorMessage</span> <span class=ot>-&gt;</span> <span class=dt>ErrorMessage</span> <span class=ot>-&gt;</span> <span class=dt>ErrorMessage</span></code></pre></div>
<p><font>If one of these expressions is found in the signature of an expression GHC reports an error message of the form:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果在表达式的签名中发现这些表达式之一，GHC 会报告以下形式的错误消息：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">example<span class=fu>.</span>hs<span class=fu>:</span><span class=dv>1</span><span class=fu>:</span><span class=dv>1</span><span class=fu>:</span> error<span class=fu>:</span>
    • <span class=dt>My</span> custom error message line <span class=dv>1</span><span class=fu>.</span>
    • <span class=dt>My</span> custom error message line <span class=dv>2</span><span class=fu>.</span>
    • <span class=dt>In</span> the expression<span class=fu>:</span> example
      <span class=dt>In</span> an equation for ‘foo’<span class=fu>:</span> foo <span class=fu>=</span> <span class=dt>ECoerce</span> (<span class=dt>EFloat</span> <span class=dv>3</span>) (<span class=dt>EInt</span> <span class=dv>4</span>)</code></pre></div>
<div class=sourceCode include=src/17-promotion/errors.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=kw>instance</span>
  <span class=co>-- Error Message</span>
  <span class=dt>TypeError</span> (<span class=dt>Text</span> <span class=st>"Equality is not defined for functions"</span>
  <span class=fu>:$$:</span>
  (<span class=dt>ShowType</span> a <span class=fu>:&lt;&gt;:</span> <span class=dt>Text</span> <span class=st>" -&gt; "</span> <span class=fu>:&lt;&gt;:</span> <span class=dt>ShowType</span> b))

  <span class=co>-- Instance head</span>
  <span class=ot>=&gt;</span> <span class=dt>Eq</span> (a <span class=ot>-&gt;</span> b) <span class=kw>where</span> (<span class=fu>==</span>) <span class=fu>=</span> undefined

<span class=co>-- Fail when we try to equate two functions</span>
example <span class=fu>=</span> id <span class=fu>==</span> id</code></pre></div>
<p><font>A less contrived example would be creating a type-safe embedded DSL that enforces invariants about the semantics at the type-level. We've been able to do this sort of thing using GADTs and type-families for a while but the error reporting has been horrible. With 8.0 we can have type-families that emit useful type errors that reflect what actually goes wrong and integrate this inside of GHC.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个不那么做作的例子是创建一个类型安全的嵌入式 DSL，它在类型级别强制执行关于语义的不变量。一段时间以来，我们已经能够使用 GADT 和类型系列来做这类事情，但错误报告一直很糟糕。在 8.0 中，我们可以拥有类型家族，这些类型家族会发出有用的类型错误，反映实际出错的地方，并将其集成到 GHC 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/errors_dsl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=kw>type</span> family <span class=dt>Coerce</span> a b <span class=kw>where</span>
  <span class=dt>Coerce</span> <span class=dt>Int</span> <span class=dt>Int</span>     <span class=fu>=</span> <span class=dt>Int</span>
  <span class=dt>Coerce</span> <span class=dt>Float</span> <span class=dt>Float</span> <span class=fu>=</span> <span class=dt>Float</span>
  <span class=dt>Coerce</span> <span class=dt>Int</span> <span class=dt>Float</span>   <span class=fu>=</span> <span class=dt>Float</span>
  <span class=dt>Coerce</span> <span class=dt>Float</span> <span class=dt>Int</span>   <span class=fu>=</span> <span class=dt>TypeError</span> (<span class=dt>Text</span> <span class=st>"Cannot cast to smaller type"</span>)

<span class=kw>data</span> <span class=dt>Expr</span> a <span class=kw>where</span>
  <span class=dt>EInt</span><span class=ot>    ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span> <span class=dt>Int</span>
  <span class=dt>EFloat</span><span class=ot>  ::</span> <span class=dt>Float</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span> <span class=dt>Float</span>
  <span class=dt>ECoerce</span><span class=ot> ::</span> <span class=dt>Expr</span> b <span class=ot>-&gt;</span> <span class=dt>Expr</span> c <span class=ot>-&gt;</span> <span class=dt>Expr</span> (<span class=dt>Coerce</span> b c)

<span class=ot>foo ::</span> <span class=dt>Expr</span> <span class=dt>Int</span>
foo <span class=fu>=</span> <span class=dt>ECoerce</span> (<span class=dt>EFloat</span> <span class=dv>3</span>) (<span class=dt>EInt</span> <span class=dv>4</span>)</code></pre></div>
<h2 id=type-equality><font>Type Equality</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型相等</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Continuing with the theme of building more elaborate proofs in Haskell, GHC 7.8 recently shipped with the </font><code>Data.Type.Equality</code><font> module which provides us with an extended set of type-level operations for expressing the equality of types as values, constraints, and promoted booleans.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>继续在 Haskell 中构建更精细证明的主题，GHC 7.8 最近附带了 Data.Type.Equality 模块，它为我们提供了一组扩展的类型级操作，用于将类型的相等性表示为值、约束和提升的布尔值.</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>(~)   ::</span> k <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> <span class=dt>Constraint</span>
<span class=ot>(==)  ::</span> k <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> <span class=dt>Bool</span>
<span class=ot>(&lt;=)  ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Constraint</span>
<span class=ot>(&lt;=?) ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
<span class=ot>(+)   ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
<span class=ot>(-)   ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
<span class=ot>(*)   ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span>
<span class=ot>(^)   ::</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>(:~:)     ::</span> k <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=dt>Refl</span><span class=ot>      ::</span> a1 <span class=fu>:~:</span> a1
<span class=ot>sym       ::</span> (a <span class=fu>:~:</span> b) <span class=ot>-&gt;</span> b <span class=fu>:~:</span> a
<span class=ot>trans     ::</span> (a <span class=fu>:~:</span> b) <span class=ot>-&gt;</span> (b <span class=fu>:~:</span> c) <span class=ot>-&gt;</span> a <span class=fu>:~:</span> c
<span class=ot>castWith  ::</span> (a <span class=fu>:~:</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
<span class=ot>gcastWith ::</span> (a <span class=fu>:~:</span> b) <span class=ot>-&gt;</span> (a <span class=fu>~</span> b <span class=ot>=&gt;</span> r) <span class=ot>-&gt;</span> r</code></pre></div>
<p><font>With this we have a much stronger language for writing restrictions that can be checked at a compile-time, and a mechanism that will later allow us to write more advanced proofs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有了这个，我们就有了一种更强大的语言来编写可以在编译时检查的限制，以及一种稍后允许我们编写更高级证明的机制。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/type_equality.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>
<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=kw>type</span> <span class=dt>Not</span> a b <span class=fu>=</span> ((b <span class=fu>==</span> a) <span class=fu>~</span> <span class=dt>False</span>)

<span class=ot>restrictUnit ::</span> <span class=dt>Not</span> () a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
restrictUnit <span class=fu>=</span> id

<span class=ot>restrictChar ::</span> <span class=dt>Not</span> <span class=dt>Char</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
restrictChar <span class=fu>=</span> id</code></pre></div>
<h2 id=proxies><font>Proxies</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using kind polymorphism with phantom types allows us to express the Proxy type which is inhabited by a single constructor with no arguments but with a polykinded phantom type variable which carries an arbitrary type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用带有幻象类型的种类多态性允许我们表达 Proxy 类型，它由一个没有参数的构造函数居住，但带有一个带有任意类型的多种类幻象类型变量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PolyKinds #-}</span>

<span class=co>-- | A concrete, poly-kinded proxy type</span>
<span class=kw>data</span> <span class=dt>Proxy</span> t <span class=fu>=</span> <span class=dt>Proxy</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Proxy</span>

<span class=ot>a ::</span> <span class=dt>Proxy</span> ()
a <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=ot>b ::</span> <span class=dt>Proxy</span> <span class=dv>3</span>
b <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=ot>c ::</span> <span class=dt>Proxy</span> <span class=st>"symbol"</span>
c <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=ot>d ::</span> <span class=dt>Proxy</span> <span class=dt>Maybe</span>
d <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=ot>e ::</span> <span class=dt>Proxy</span> (<span class=dt>Maybe</span> ())
e <span class=fu>=</span> <span class=dt>Proxy</span></code></pre></div>
<p><font>In cases where we'd normally pass around a </font><code>undefined</code><font> as a witness of a typeclass dictionary, we can instead pass a Proxy object which carries the phantom type without the need for the bottom. Using scoped type variables we can then operate with the phantom paramater and manipulate wherever is needed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在我们通常传递一个 undefined 作为类型类字典的见证的情况下，我们可以传递一个 Proxy 对象，它携带幻影类型而不需要底部。使用范围类型变量，我们可以使用幻影参数进行操作，并在需要的地方进行操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>t1 ::</span> a
t1 <span class=fu>=</span> (undefined<span class=ot> ::</span> a)

<span class=ot>t2 ::</span> <span class=dt>Proxy</span> a
t2 <span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> a</code></pre></div>
<h2 id=promoted-syntax><font>Promoted Syntax</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>提升语法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>We've seen constructors promoted using DataKinds, but just like at the value-level GHC also allows us some syntactic sugar for list and tuples instead of explicit cons'ing and pair'ing. This is enabled with the </font><code>-XTypeOperators</code><font> extension, which introduces list syntax and tuples of arbitrary arity at the type-level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们已经看到使用 DataKinds 提升构造函数，但就像在值级别一样，GHC 也允许我们为列表和元组提供一些语法糖，而不是显式的 cons'ing 和 pair'ing。这是通过 -XTypeOperators 扩展启用的，它在类型级别引入了列表语法和任意数量的元组。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>HList</span><span class=ot> ::</span> [<span class=fu>*</span>] <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>HNil</span><span class=ot>  ::</span> <span class=dt>HList</span> <span class=ch>'[]</span>
  <span class=dt>HCons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>HList</span> t <span class=ot>-&gt;</span> <span class=dt>HList</span> (a <span class=ch>': t)</span>

<span class=kw>data</span> <span class=dt>Tuple</span><span class=ot> ::</span> (<span class=fu>*</span>,<span class=fu>*</span>) <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Tuple</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> <span class=dt>Tuple</span> <span class=ch>'(a,b)</span></code></pre></div>
<p><font>Using this we can construct all variety of composite type-level objects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用它我们可以构造各种复合类型级对象。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>kind <span class=dv>1</span>
<span class=dv>1</span><span class=ot> ::</span> <span class=dt>Nat</span>

λ<span class=fu>:</span> <span class=fu>:</span>kind <span class=st>"foo"</span>
<span class=st>"foo"</span><span class=ot> ::</span> <span class=dt>Symbol</span>

λ<span class=fu>:</span> <span class=fu>:</span>kind [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]
[<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]<span class=ot> ::</span> [<span class=dt>Nat</span>]

λ<span class=fu>:</span> <span class=fu>:</span>kind [<span class=dt>Int</span>, <span class=dt>Bool</span>, <span class=dt>Char</span>]
[<span class=dt>Int</span>, <span class=dt>Bool</span>, <span class=dt>Char</span>]<span class=ot> ::</span> [<span class=fu>*</span>]

λ<span class=fu>:</span> <span class=fu>:</span>kind <span class=dt>Just</span> [<span class=dt>Int</span>, <span class=dt>Bool</span>, <span class=dt>Char</span>]
<span class=dt>Just</span> [<span class=dt>Int</span>, <span class=dt>Bool</span>, <span class=dt>Char</span>]<span class=ot> ::</span> <span class=dt>Maybe</span> [<span class=fu>*</span>]

λ<span class=fu>:</span> <span class=fu>:</span>kind <span class=ch>'("a", Int)</span>
(,) <span class=dt>Symbol</span> <span class=fu>*</span>

λ<span class=fu>:</span> <span class=fu>:</span>kind [ <span class=ch>'("a", Int), '</span>(<span class=st>"b"</span>, <span class=dt>Bool</span>) ]
[ <span class=ch>'("a", Int), '</span>(<span class=st>"b"</span>, <span class=dt>Bool</span>) ]<span class=ot> ::</span> [(,) <span class=dt>Symbol</span> <span class=fu>*</span>]</code></pre></div>
<h2 id=singleton-types><font>Singleton Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单例类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of singletons is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，单例知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>A singleton type is a type with a single value inhabitant. Singleton types can be constructed in a variety of ways using GADTs or with data families.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单例类型是具有单一值居民的类型。可以使用 GADT 或数据族以多种方式构造单例类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Sing</span> (<span class=ot>a ::</span> <span class=dt>Nat</span>) <span class=kw>where</span>
  <span class=dt>SZ</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=ch>'Z</span>
  <span class=dt>SS</span><span class=ot> ::</span> <span class=dt>Sing</span> n <span class=ot>-&gt;</span> <span class=dt>Sing</span> (<span class=ch>'S n)</span>

<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Sing</span> (<span class=ot>a ::</span> <span class=dt>Maybe</span> k) <span class=kw>where</span>
  <span class=dt>SNothing</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=ch>'Nothing</span>
  <span class=dt>SJust</span><span class=ot> ::</span> <span class=dt>Sing</span> x <span class=ot>-&gt;</span> <span class=dt>Sing</span> (<span class=ch>'Just x)</span>

<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Sing</span> (<span class=ot>a ::</span> <span class=dt>Bool</span>) <span class=kw>where</span>
  <span class=dt>STrue</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=dt>True</span>
  <span class=dt>SFalse</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=dt>False</span></code></pre></div>
<p><strong>Promoted Naturals<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>促进土黄</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Value-level</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>价值水平</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Type-level</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Models</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>楷模</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>SZ</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>深圳</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing 'Z</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唱'Z</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>0<hcfy-result style=display:none></hcfy-result></font></td>
</tr>
<tr class=even>
<td align=left><font>SS SZ</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SS 深圳</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing ('S 'Z)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唱 ('S 'Z)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>1<hcfy-result style=display:none></hcfy-result></font></td>
</tr>
<tr class=odd>
<td align=left><font>SS (SS SZ)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SS (SS 深圳)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing ('S ('S 'Z))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唱 ('S('S'Z))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>2<hcfy-result style=display:none></hcfy-result></font></td>
</tr>
</tbody>
</table>
<p><strong>Promoted Booleans<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>提升的布尔值</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Value-level</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>价值水平</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Type-level</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Models</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>楷模</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>STrue</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>真</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing 'False</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唱错了</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>False</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>错误的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>SFalse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>错误</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing 'True</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唱“真”</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>True</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>真的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><strong>Promoted Maybe<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>晋升也许</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Value-level</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>价值水平</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Type-level</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型级</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Models</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>楷模</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>SJust a</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>只是一个</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing (SJust 'a)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唱 (SJust 'a)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Just a</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>只是一个</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>SNothing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>S没什么</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Sing Nothing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>什么都不唱</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>Nothing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>没有什么</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Singleton types are an integral part of the small cottage industry of faking dependent types in Haskell, i.e. constructing types with terms predicated upon values. Singleton types are a way of "cheating" by modeling the map between types and values as a structural property of the type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单例类型是在 Haskell 中伪造依赖类型的小型家庭手工业的组成部分，即使用基于值的术语来构造类型。单例类型是一种通过将类型和值之间的映射建模为类型的结构属性来“作弊”的方式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/singleton_class.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE RankNTypes #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>Data.Proxy</span>
<span class=kw>import </span><span class=dt>GHC.Exts</span> (<span class=dt>Any</span>)
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (succ)

<span class=kw>data</span> <span class=dt>Nat</span> <span class=fu>=</span> <span class=dt>Z</span> <span class=fu>|</span> <span class=dt>S</span> <span class=dt>Nat</span>

<span class=co>-- kind-indexed data family</span>
<span class=kw>data</span> family <span class=dt>Sing</span> (<span class=ot>a ::</span> k)

<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Sing</span> (<span class=ot>a ::</span> <span class=dt>Nat</span>) <span class=kw>where</span>
  <span class=dt>SZ</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=ch>'Z</span>
  <span class=dt>SS</span><span class=ot> ::</span> <span class=dt>Sing</span> n <span class=ot>-&gt;</span> <span class=dt>Sing</span> (<span class=ch>'S n)</span>

<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Sing</span> (<span class=ot>a ::</span> <span class=dt>Maybe</span> k) <span class=kw>where</span>
  <span class=dt>SNothing</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=ch>'Nothing</span>
  <span class=dt>SJust</span><span class=ot> ::</span> <span class=dt>Sing</span> x <span class=ot>-&gt;</span> <span class=dt>Sing</span> (<span class=ch>'Just x)</span>

<span class=kw>data</span> <span class=kw>instance</span> <span class=dt>Sing</span> (<span class=ot>a ::</span> <span class=dt>Bool</span>) <span class=kw>where</span>
  <span class=dt>STrue</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=dt>True</span>
  <span class=dt>SFalse</span><span class=ot> ::</span> <span class=dt>Sing</span> <span class=dt>False</span>

<span class=kw>data</span> <span class=dt>Fin</span> (<span class=ot>n ::</span> <span class=dt>Nat</span>) <span class=kw>where</span>
  <span class=dt>FZ</span><span class=ot> ::</span> <span class=dt>Fin</span> (<span class=dt>S</span> n)
  <span class=dt>FS</span><span class=ot> ::</span> <span class=dt>Fin</span> n <span class=ot>-&gt;</span> <span class=dt>Fin</span> (<span class=dt>S</span> n)

<span class=kw>data</span> <span class=dt>Vec</span> a n <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot>  ::</span> <span class=dt>Vec</span> a <span class=dt>Z</span>
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a (<span class=dt>S</span> n)

<span class=kw>class</span> <span class=dt>SingI</span> (<span class=ot>a ::</span> k) <span class=kw>where</span>
<span class=ot>  sing ::</span> <span class=dt>Sing</span> a

<span class=kw>instance</span> <span class=dt>SingI</span> <span class=dt>Z</span> <span class=kw>where</span>
  sing <span class=fu>=</span> <span class=dt>SZ</span>

<span class=kw>instance</span> <span class=dt>SingI</span> n <span class=ot>=&gt;</span> <span class=dt>SingI</span> (<span class=dt>S</span> n) <span class=kw>where</span>
  sing <span class=fu>=</span> <span class=dt>SS</span> sing

<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> <span class=dt>Nat</span>
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> (<span class=dt>SNat</span> a)
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> (<span class=dt>SBool</span> a)
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> (<span class=dt>Fin</span> a)
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> <span class=dt>Show</span> (<span class=dt>Vec</span> a n)

<span class=kw>type</span> family (<span class=ot>m ::</span> <span class=dt>Nat</span>) <span class=fu>:+</span> (<span class=ot>n ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>Z</span> <span class=fu>:+</span> n <span class=fu>=</span> n
  <span class=dt>S</span> m <span class=fu>:+</span> n <span class=fu>=</span> <span class=dt>S</span> (m <span class=fu>:+</span> n)

<span class=kw>type</span> <span class=dt>SNat</span> (<span class=ot>k ::</span> <span class=dt>Nat</span>) <span class=fu>=</span> <span class=dt>Sing</span> k
<span class=kw>type</span> <span class=dt>SBool</span> (<span class=ot>k ::</span> <span class=dt>Bool</span>) <span class=fu>=</span> <span class=dt>Sing</span> k
<span class=kw>type</span> <span class=dt>SMaybe</span> (<span class=ot>b ::</span> a) (<span class=ot>k ::</span> <span class=dt>Maybe</span> a) <span class=fu>=</span> <span class=dt>Sing</span> k

<span class=ot>size ::</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>SNat</span> n
size <span class=dt>Nil</span>         <span class=fu>=</span> <span class=dt>SZ</span>
size (<span class=dt>Cons</span> x xs) <span class=fu>=</span> <span class=dt>SS</span> (size xs)

<span class=ot>forget ::</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> <span class=dt>Nat</span>
forget <span class=dt>SZ</span> <span class=fu>=</span> <span class=dt>Z</span>
forget (<span class=dt>SS</span> n) <span class=fu>=</span> <span class=dt>S</span> (forget n)

<span class=ot>natToInt ::</span> <span class=dt>Integral</span> n <span class=ot>=&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> n
natToInt <span class=dt>Z</span>     <span class=fu>=</span> <span class=dv>0</span>
natToInt (<span class=dt>S</span> n) <span class=fu>=</span> natToInt n <span class=fu>+</span> <span class=dv>1</span>

<span class=ot>intToNat ::</span> (<span class=dt>Integral</span> a, <span class=dt>Ord</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Nat</span>
intToNat <span class=dv>0</span> <span class=fu>=</span> <span class=dt>Z</span>
intToNat n <span class=fu>=</span> <span class=dt>S</span> <span class=fu>$</span> intToNat (n <span class=fu>-</span> <span class=dv>1</span>)

<span class=ot>sNatToInt ::</span> <span class=dt>Num</span> n <span class=ot>=&gt;</span> <span class=dt>SNat</span> x <span class=ot>-&gt;</span> n
sNatToInt <span class=dt>SZ</span>     <span class=fu>=</span> <span class=dv>0</span>
sNatToInt (<span class=dt>SS</span> n) <span class=fu>=</span> sNatToInt n <span class=fu>+</span> <span class=dv>1</span>

index<span class=ot> ::</span> <span class=dt>Fin</span> n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> a
index <span class=dt>FZ</span> (<span class=dt>Cons</span> x _)      <span class=fu>=</span> x
index (<span class=dt>FS</span> n) (<span class=dt>Cons</span> _ xs) <span class=fu>=</span> index n xs


<span class=ot>test1 ::</span> <span class=dt>Fin</span> (<span class=dt>S</span> (<span class=dt>S</span> (<span class=dt>S</span> <span class=dt>Z</span>)))
test1 <span class=fu>=</span> <span class=dt>FS</span> (<span class=dt>FS</span> <span class=dt>FZ</span>)

<span class=ot>test2 ::</span> <span class=dt>Int</span>
test2 <span class=fu>=</span> index <span class=dt>FZ</span> (<span class=dv>1</span> <span class=ot>`Cons`</span> (<span class=dv>2</span> <span class=ot>`Cons`</span> <span class=dt>Nil</span>))

<span class=ot>test3 ::</span> <span class=dt>Sing</span> (<span class=ch>'Just ('</span><span class=dt>S</span> (<span class=ch>'S Z)))</span>
test3 <span class=fu>=</span> <span class=dt>SJust</span> (<span class=dt>SS</span> (<span class=dt>SS</span> <span class=dt>SZ</span>))

<span class=ot>test4 ::</span> <span class=dt>Sing</span> (<span class=ch>'S ('</span><span class=dt>S</span> <span class=dt>Z</span>))
test4 <span class=fu>=</span> <span class=dt>SS</span> (<span class=dt>SS</span> <span class=dt>SZ</span>)

<span class=co>-- polymorphic constructor SingI</span>
<span class=ot>test5 ::</span> <span class=dt>Sing</span> (<span class=ch>'S ('</span><span class=dt>S</span> <span class=dt>Z</span>))
test5 <span class=fu>=</span> sing</code></pre></div>
<p><font>The builtin singleton types provided in </font><code>GHC.TypeLits</code><font> have the useful implementation that type-level values can be reflected to the value-level and back up to the type-level, albeit under an existential.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.TypeLits 中提供的内置单例类型具有有用的实现，类型级别的值可以反映到值级别并备份到类型级别，尽管是在存在的情况下。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>someNatVal ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>SomeNat</span>
<span class=ot>someSymbolVal ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>SomeSymbol</span>

<span class=ot>natVal ::</span> <span class=dt>KnownNat</span> n <span class=ot>=&gt;</span> proxy n <span class=ot>-&gt;</span> <span class=dt>Integer</span>
<span class=ot>symbolVal ::</span> <span class=dt>KnownSymbol</span> n <span class=ot>=&gt;</span> proxy n <span class=ot>-&gt;</span> <span class=dt>String</span></code></pre></div>
<div class=sourceCode include=src/17-promotion/singleton.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>

<span class=kw>import </span><span class=dt>Data.Proxy</span>
<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=ot>a ::</span> <span class=dt>Integer</span>
a <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> <span class=dv>1</span>)
<span class=co>-- 1</span>

<span class=ot>b ::</span> <span class=dt>String</span>
b <span class=fu>=</span> symbolVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> <span class=st>"foo"</span>)
<span class=co>-- "foo"</span>

<span class=ot>c ::</span> <span class=dt>Integer</span>
c <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dv>2</span> <span class=fu>+</span> <span class=dv>3</span>))
<span class=co>-- 5</span></code></pre></div>
<h2 id=closed-type-families><font>Closed Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>封闭式家庭</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>In the type families we've used so far (called open type families) there is no notion of ordering of the equations involved in the type-level function. The type family can be extended at any point in the code resolution simply proceeds sequentially through the available definitions. Closed type-families allow an alternative declaration that allows for a base case for the resolution allowing us to actually write recursive functions over types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>到目前为止，在我们使用的类型族（称为开放类型族）中，没有类型级函数中涉及的方程式的排序概念。类型族可以在代码解析中的任何时候扩展，只需按顺序通过可用定义进行。封闭类型族允许替代声明，该声明允许解决方案的基本情况允许我们实际编写类型的递归函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example consider if we wanted to write a function which counts the arguments in the type of a function and reifies at the value-level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，考虑一下我们是否想编写一个函数来计算函数类型中的参数并在值级别具体化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/countargs.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>Data.Proxy</span>
<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=kw>type</span> family <span class=dt>Count</span> (<span class=ot>f ::</span> <span class=fu>*</span>)<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>Count</span> (a <span class=ot>-&gt;</span> b) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> (<span class=dt>Count</span> b)
  <span class=dt>Count</span> x <span class=fu>=</span> <span class=dv>1</span>

<span class=kw>type</span> <span class=dt>Fn1</span> <span class=fu>=</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
<span class=kw>type</span> <span class=dt>Fn2</span> <span class=fu>=</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>

<span class=ot>fn1 ::</span> <span class=dt>Integer</span>
fn1 <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dt>Count</span> <span class=dt>Fn1</span>))
<span class=co>-- 2</span>

<span class=ot>fn2 ::</span> <span class=dt>Integer</span>
fn2 <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dt>Count</span> <span class=dt>Fn2</span>))
<span class=co>-- 4</span></code></pre></div>
<p><font>The variety of functions we can now write down are rather remarkable, allowing us to write meaningful logic at the type level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们现在可以写下的各种函数相当了不起，使我们能够在类型级别编写有意义的逻辑。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/closed_typefamily.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>
<span class=kw>import </span><span class=dt>Data.Proxy</span>
<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=co>-- Type-level functions over type-level lists.</span>

<span class=kw>type</span> family <span class=dt>Reverse</span> (<span class=ot>xs ::</span> [k])<span class=ot> ::</span> [k] <span class=kw>where</span>
  <span class=dt>Reverse</span> <span class=ch>'[] = '</span>[]
  <span class=dt>Reverse</span> xs <span class=fu>=</span> <span class=dt>Rev</span> xs <span class=ch>'[]</span>

<span class=kw>type</span> family <span class=dt>Rev</span> (<span class=ot>xs ::</span> [k]) (<span class=ot>ys ::</span> [k])<span class=ot> ::</span> [k] <span class=kw>where</span>
  <span class=dt>Rev</span> <span class=ch>'[] i = i</span>
  <span class=dt>Rev</span> (x <span class=ch>': xs) i = Rev xs (x '</span><span class=fu>:</span> i)

<span class=kw>type</span> family <span class=dt>Length</span> (<span class=ot>as ::</span> [k])<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>Length</span> <span class=ch>'[] = 0</span>
  <span class=dt>Length</span> (x <span class=ch>': xs) = 1 + Length xs</span>

<span class=kw>type</span> family <span class=dt>If</span> (<span class=ot>p ::</span> <span class=dt>Bool</span>) (<span class=ot>a ::</span> k) (<span class=ot>b ::</span> k)<span class=ot> ::</span> k <span class=kw>where</span>
  <span class=dt>If</span> <span class=dt>True</span> a b <span class=fu>=</span> a
  <span class=dt>If</span> <span class=dt>False</span> a b <span class=fu>=</span> b

<span class=kw>type</span> family <span class=dt>Concat</span> (<span class=ot>as ::</span> [k]) (<span class=ot>bs ::</span> [k])<span class=ot> ::</span> [k] <span class=kw>where</span>
  <span class=dt>Concat</span> a <span class=ch>'[] = a</span>
  <span class=dt>Concat</span> <span class=ch>'[] b = b</span>
  <span class=dt>Concat</span> (a <span class=ch>': as) bs = a '</span><span class=fu>:</span> <span class=dt>Concat</span> as bs

<span class=kw>type</span> family <span class=dt>Map</span> (<span class=ot>f ::</span> a <span class=ot>-&gt;</span> b) (<span class=ot>as ::</span> [a])<span class=ot> ::</span> [b] <span class=kw>where</span>
  <span class=dt>Map</span> f <span class=ch>'[] = '</span>[]
  <span class=dt>Map</span> f (x <span class=ch>': xs) = f x '</span><span class=fu>:</span> <span class=dt>Map</span> f xs

<span class=kw>type</span> family <span class=dt>Sum</span> (<span class=ot>xs ::</span> [<span class=dt>Nat</span>])<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>Sum</span> <span class=ch>'[] = 0</span>
  <span class=dt>Sum</span> (x <span class=ch>': xs) = x + Sum xs</span>

<span class=ot>ex1 ::</span> <span class=dt>Reverse</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] <span class=fu>~</span> [<span class=dv>3</span>,<span class=dv>2</span>,<span class=dv>1</span>] <span class=ot>=&gt;</span> <span class=dt>Proxy</span> a
ex1 <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=ot>ex2 ::</span> <span class=dt>Length</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] <span class=fu>~</span> <span class=dv>3</span> <span class=ot>=&gt;</span> <span class=dt>Proxy</span> a
ex2 <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=ot>ex3 ::</span> (<span class=dt>Length</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]) <span class=fu>~</span> (<span class=dt>Length</span> (<span class=dt>Reverse</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>])) <span class=ot>=&gt;</span> <span class=dt>Proxy</span> a
ex3 <span class=fu>=</span> <span class=dt>Proxy</span>

<span class=co>-- Reflecting type level computations back to the value level.</span>
<span class=ot>ex4 ::</span> <span class=dt>Integer</span>
ex4 <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dt>Length</span> (<span class=dt>Concat</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] [<span class=dv>4</span>,<span class=dv>5</span>,<span class=dv>6</span>])))
<span class=co>-- 6</span>

<span class=ot>ex5 ::</span> <span class=dt>Integer</span>
ex5 <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dt>Sum</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]))
<span class=co>-- 6</span>

<span class=co>-- Couldn't match type ‘2’ with ‘1’</span>
<span class=ot>ex6 ::</span> <span class=dt>Reverse</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] <span class=fu>~</span> [<span class=dv>3</span>,<span class=dv>1</span>,<span class=dv>2</span>] <span class=ot>=&gt;</span> <span class=dt>Proxy</span> a
ex6 <span class=fu>=</span> <span class=dt>Proxy</span></code></pre></div>
<p><font>The results of type family functions need not necessarily be kinded as </font><code>(*)</code><font> either. For example using Nat or Constraint is permitted.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型族函数的结果也不一定要被分类为 (*)。例如，允许使用 Nat 或 Constraint。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> family <span class=dt>Elem</span> (<span class=ot>a ::</span> k) (<span class=ot>bs ::</span> [k])<span class=ot> ::</span> <span class=dt>Constraint</span> <span class=kw>where</span>
  <span class=dt>Elem</span> a (a <span class=ch>': bs) = (() :: Constraint)</span>
  <span class=dt>Elem</span> a (b <span class=ch>': bs) = a `Elem` bs</span>

<span class=kw>type</span> family <span class=dt>Sum</span> (<span class=ot>ns ::</span> [<span class=dt>Nat</span>])<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>Sum</span> <span class=ch>'[] = 0</span>
  <span class=dt>Sum</span> (n <span class=ch>': ns) = n + Sum ns</span></code></pre></div>
<h2 id=kind-indexed-type-families><font>Kind Indexed Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>种类索引类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Just as typeclasses are normally indexed on types, type families can also be indexed on kinds with the kinds given as explicit kind signatures on type variables.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>正如类型类通常在类型上进行索引一样，类型族也可以在种类上进行索引，其中种类作为类型变量的显式种类签名给出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> family (<span class=ot>a ::</span> k) <span class=fu>==</span> (<span class=ot>b ::</span> k)<span class=ot> ::</span> <span class=dt>Bool</span>
<span class=kw>type</span> <span class=kw>instance</span> a <span class=fu>==</span> b <span class=fu>=</span> <span class=dt>EqStar</span> a b
<span class=kw>type</span> <span class=kw>instance</span> a <span class=fu>==</span> b <span class=fu>=</span> <span class=dt>EqArrow</span> a b
<span class=kw>type</span> <span class=kw>instance</span> a <span class=fu>==</span> b <span class=fu>=</span> <span class=dt>EqBool</span> a b

<span class=kw>type</span> family <span class=dt>EqStar</span> (<span class=ot>a ::</span> <span class=fu>*</span>) (<span class=ot>b ::</span> <span class=fu>*</span>) <span class=kw>where</span>
  <span class=dt>EqStar</span> a a <span class=fu>=</span> <span class=dt>True</span>
  <span class=dt>EqStar</span> a b <span class=fu>=</span> <span class=dt>False</span>

<span class=kw>type</span> family <span class=dt>EqArrow</span> (<span class=ot>a ::</span> k1 <span class=ot>-&gt;</span> k2) (<span class=ot>b ::</span> k1 <span class=ot>-&gt;</span> k2) <span class=kw>where</span>
  <span class=dt>EqArrow</span> a a <span class=fu>=</span> <span class=dt>True</span>
  <span class=dt>EqArrow</span> a b <span class=fu>=</span> <span class=dt>False</span>

<span class=kw>type</span> family <span class=dt>EqBool</span> a b <span class=kw>where</span>
  <span class=dt>EqBool</span> <span class=dt>True</span>  <span class=dt>True</span>  <span class=fu>=</span> <span class=dt>True</span>
  <span class=dt>EqBool</span> <span class=dt>False</span> <span class=dt>False</span> <span class=fu>=</span> <span class=dt>True</span>
  <span class=dt>EqBool</span> a     b     <span class=fu>=</span> <span class=dt>False</span>

<span class=kw>type</span> family <span class=dt>EqList</span> a b <span class=kw>where</span>
  <span class=dt>EqList</span> <span class=ch>'[]        '</span>[]        <span class=fu>=</span> <span class=dt>True</span>
  <span class=dt>EqList</span> (h1 <span class=ch>': t1) (h2 '</span><span class=fu>:</span> t2) <span class=fu>=</span> (h1 <span class=fu>==</span> h2) <span class=fu>&amp;&amp;</span> (t1 <span class=fu>==</span> t2)
  <span class=dt>EqList</span> a          b          <span class=fu>=</span> <span class=dt>False</span>

<span class=kw>type</span> family a <span class=fu>&amp;&amp;</span> b <span class=kw>where</span>
  <span class=dt>True</span> <span class=fu>&amp;&amp;</span> <span class=dt>True</span> <span class=fu>=</span> <span class=dt>True</span>
  a    <span class=fu>&amp;&amp;</span> a    <span class=fu>=</span> <span class=dt>False</span></code></pre></div>
<h2 id=promoted-symbols><font>Promoted Symbols</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>推广符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode include=src/17-promotion/hasfield.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE FunctionalDependencies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>


<span class=kw>import </span><span class=dt>GHC.TypeLits</span>
<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=kw>data</span> <span class=dt>Label</span> (<span class=ot>l ::</span> <span class=dt>Symbol</span>) <span class=fu>=</span> <span class=dt>Get</span>

<span class=kw>class</span> <span class=dt>Has</span> a l b <span class=fu>|</span> a l <span class=ot>-&gt;</span> b <span class=kw>where</span>
<span class=ot>  from ::</span> a <span class=ot>-&gt;</span> <span class=dt>Label</span> l <span class=ot>-&gt;</span> b

<span class=kw>data</span> <span class=dt>Point2D</span> <span class=fu>=</span> <span class=dt>Point2</span> <span class=dt>Double</span> <span class=dt>Double</span> <span class=kw>deriving</span> <span class=dt>Show</span>
<span class=kw>data</span> <span class=dt>Point3D</span> <span class=fu>=</span> <span class=dt>Point3</span> <span class=dt>Double</span> <span class=dt>Double</span> <span class=dt>Double</span> <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Point2D</span> <span class=st>"x"</span> <span class=dt>Double</span> <span class=kw>where</span>
  from (<span class=dt>Point2</span> x _) _ <span class=fu>=</span> x

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Point2D</span> <span class=st>"y"</span> <span class=dt>Double</span> <span class=kw>where</span>
  from (<span class=dt>Point2</span> _ y) _ <span class=fu>=</span> y


<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Point3D</span> <span class=st>"x"</span> <span class=dt>Double</span> <span class=kw>where</span>
  from (<span class=dt>Point3</span> x _ _) _ <span class=fu>=</span> x

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Point3D</span> <span class=st>"y"</span> <span class=dt>Double</span> <span class=kw>where</span>
  from (<span class=dt>Point3</span> _ y _) _ <span class=fu>=</span> y

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Point3D</span> <span class=st>"z"</span> <span class=dt>Double</span> <span class=kw>where</span>
  from (<span class=dt>Point3</span> _ _ z) _ <span class=fu>=</span> z


<span class=kw>infixl</span> <span class=dv>6</span> <span class=fu>#</span>

<span class=ot>(#) ::</span> a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> b
(<span class=fu>#</span>) <span class=fu>=</span> flip (<span class=fu>$</span>)

_<span class=ot>x ::</span> <span class=dt>Has</span> a <span class=st>"x"</span> b <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b
_x pnt <span class=fu>=</span> from pnt (<span class=dt>Get</span><span class=ot> ::</span> <span class=dt>Label</span> <span class=st>"x"</span>)

_<span class=ot>y ::</span> <span class=dt>Has</span> a <span class=st>"y"</span> b <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b
_y pnt <span class=fu>=</span> from pnt (<span class=dt>Get</span><span class=ot> ::</span> <span class=dt>Label</span> <span class=st>"y"</span>)

_<span class=ot>z ::</span> <span class=dt>Has</span> a <span class=st>"z"</span> b <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b
_z pnt <span class=fu>=</span> from pnt (<span class=dt>Get</span><span class=ot> ::</span> <span class=dt>Label</span> <span class=st>"z"</span>)

<span class=kw>type</span> <span class=dt>Point</span> a r <span class=fu>=</span> (<span class=dt>Has</span> a <span class=st>"x"</span> r, <span class=dt>Has</span> a <span class=st>"y"</span> r)

<span class=ot>distance ::</span> (<span class=dt>Point</span> a r, <span class=dt>Point</span> b r, <span class=dt>Floating</span> r) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> r
distance p1 p2 <span class=fu>=</span> sqrt (d1<span class=fu>^</span><span class=dv>2</span> <span class=fu>+</span> d2<span class=fu>^</span><span class=dv>2</span>)
  <span class=kw>where</span>
    d1 <span class=fu>=</span> (p1 <span class=fu>#</span> _x) <span class=fu>+</span> (p1 <span class=fu>#</span> _y)
    d2 <span class=fu>=</span> (p2 <span class=fu>#</span> _x) <span class=fu>+</span> (p2 <span class=fu>#</span> _y)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> (<span class=dt>Point2</span> <span class=dv>10</span> <span class=dv>20</span>) <span class=fu>#</span> _x

  <span class=co>-- Fails with: No instance for (Has Point2D "z" a0)</span>
  <span class=co>-- print $ (Point2 10 20) # _z</span>

  print <span class=fu>$</span> (<span class=dt>Point3</span> <span class=dv>10</span> <span class=dv>20</span> <span class=dv>30</span>) <span class=fu>#</span> _x
  print <span class=fu>$</span> (<span class=dt>Point3</span> <span class=dv>10</span> <span class=dv>20</span> <span class=dv>30</span>) <span class=fu>#</span> _z

  print <span class=fu>$</span> distance (<span class=dt>Point2</span> <span class=dv>1</span> <span class=dv>3</span>) (<span class=dt>Point2</span> <span class=dv>2</span> <span class=dv>7</span>)
  print <span class=fu>$</span> distance (<span class=dt>Point2</span> <span class=dv>1</span> <span class=dv>3</span>) (<span class=dt>Point3</span> <span class=dv>2</span> <span class=dv>7</span> <span class=dv>4</span>)
  print <span class=fu>$</span> distance (<span class=dt>Point3</span> <span class=dv>1</span> <span class=dv>3</span> <span class=dv>5</span>) (<span class=dt>Point3</span> <span class=dv>2</span> <span class=dv>7</span> <span class=dv>3</span>)</code></pre></div>
<p><font>Since record is fundamentally no different from the tuple we can also do the same kind of construction over record field names.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>由于记录从根本上与元组没有什么不同，我们也可以对记录字段名称进行相同类型的构造。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/typelevel_fields.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE FunctionalDependencies #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=ot>{-# LANGUAGE ExistentialQuantification #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>


<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=kw>newtype</span> <span class=dt>Field</span> (<span class=ot>n ::</span> <span class=dt>Symbol</span>) v <span class=fu>=</span> <span class=dt>Field</span> {<span class=ot> unField ::</span> v }
  <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>data</span> <span class=dt>Person1</span> <span class=fu>=</span> <span class=dt>Person1</span>
  { _<span class=ot>age      ::</span> <span class=dt>Field</span> <span class=st>"age"</span> <span class=dt>Int</span>
  , _<span class=ot>name     ::</span> <span class=dt>Field</span> <span class=st>"name"</span> <span class=dt>String</span>
  }

<span class=kw>data</span> <span class=dt>Person2</span> <span class=fu>=</span> <span class=dt>Person2</span>
  { _<span class=ot>age'  ::</span> <span class=dt>Field</span> <span class=st>"age"</span> <span class=dt>Int</span>
  , _<span class=ot>name' ::</span> <span class=dt>Field</span> <span class=st>"name"</span> <span class=dt>String</span>
  , _<span class=ot>lib'  ::</span> <span class=dt>Field</span> <span class=st>"lib"</span> <span class=dt>String</span>
  }

<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> <span class=dt>Person1</span>
<span class=kw>deriving</span> <span class=kw>instance</span> <span class=dt>Show</span> <span class=dt>Person2</span>

<span class=kw>data</span> <span class=dt>Label</span> (<span class=ot>l ::</span> <span class=dt>Symbol</span>) <span class=fu>=</span> <span class=dt>Get</span>

<span class=kw>class</span> <span class=dt>Has</span> a l b <span class=fu>|</span> a l <span class=ot>-&gt;</span> b <span class=kw>where</span>
<span class=ot>  from ::</span> a <span class=ot>-&gt;</span> <span class=dt>Label</span> l <span class=ot>-&gt;</span> b

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Person1</span> <span class=st>"age"</span> <span class=dt>Int</span> <span class=kw>where</span>
  from (<span class=dt>Person1</span> a _) _ <span class=fu>=</span> unField a

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Person1</span> <span class=st>"name"</span> <span class=dt>String</span> <span class=kw>where</span>
  from (<span class=dt>Person1</span> _ a) _ <span class=fu>=</span> unField a

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Person2</span> <span class=st>"age"</span> <span class=dt>Int</span> <span class=kw>where</span>
  from (<span class=dt>Person2</span> a _ _) _ <span class=fu>=</span> unField a

<span class=kw>instance</span> <span class=dt>Has</span> <span class=dt>Person2</span> <span class=st>"name"</span> <span class=dt>String</span> <span class=kw>where</span>
  from (<span class=dt>Person2</span> _ a _) _ <span class=fu>=</span> unField a

<span class=ot>age ::</span> <span class=dt>Has</span> a <span class=st>"age"</span> b <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b
age pnt <span class=fu>=</span> from pnt (<span class=dt>Get</span><span class=ot> ::</span> <span class=dt>Label</span> <span class=st>"age"</span>)

<span class=ot>name ::</span> <span class=dt>Has</span> a <span class=st>"name"</span> b <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b
name pnt <span class=fu>=</span> from pnt (<span class=dt>Get</span><span class=ot> ::</span> <span class=dt>Label</span> <span class=st>"name"</span>)

<span class=co>-- Parameterized constraint kind for "Simon-ness" of a record.</span>
<span class=kw>type</span> <span class=dt>Simon</span> a <span class=fu>=</span> (<span class=dt>Has</span> a <span class=st>"name"</span> <span class=dt>String</span>, <span class=dt>Has</span> a <span class=st>"age"</span> <span class=dt>Int</span>)

<span class=ot>spj ::</span> <span class=dt>Person1</span>
spj <span class=fu>=</span> <span class=dt>Person1</span> (<span class=dt>Field</span> <span class=dv>56</span>) (<span class=dt>Field</span> <span class=st>"Simon Peyton Jones"</span>)

<span class=ot>smarlow ::</span> <span class=dt>Person2</span>
smarlow <span class=fu>=</span> <span class=dt>Person2</span> (<span class=dt>Field</span> <span class=dv>38</span>) (<span class=dt>Field</span> <span class=st>"Simon Marlow"</span>) (<span class=dt>Field</span> <span class=st>"rts"</span>)


<span class=ot>catNames ::</span> (<span class=dt>Simon</span> a, <span class=dt>Simon</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> <span class=dt>String</span>
catNames a b <span class=fu>=</span> name a <span class=fu>++</span> name b

<span class=ot>addAges ::</span> (<span class=dt>Simon</span> a, <span class=dt>Simon</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> <span class=dt>Int</span>
addAges a b <span class=fu>=</span> age a <span class=fu>+</span> age b


<span class=ot>names ::</span> <span class=dt>String</span>
names <span class=fu>=</span> name smarlow <span class=fu>++</span> <span class=st>","</span> <span class=fu>++</span> name spj
<span class=co>-- "Simon Marlow,Simon Peyton Jones"</span>

<span class=ot>ages ::</span> <span class=dt>Int</span>
ages <span class=fu>=</span> age spj <span class=fu>+</span> age smarlow
<span class=co>-- 94</span></code></pre></div>
<p><font>Notably this approach is mostly just all boilerplate class instantiation which could be abstracted away using TemplateHaskell or a Generic deriving.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>值得注意的是，这种方法主要是所有样板类实例化，可以使用 TemplateHaskell 或通用派生将其抽象化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=hlists><font>HLists</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>H列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>A heterogeneous list is a cons list whose type statically encodes the ordered types of its values.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>异构列表是一个缺点列表，其类型静态编码其值的有序类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/hlist.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>

<span class=kw>infixr</span> <span class=dv>5</span> <span class=ot>::</span><span class=fu>:</span>

<span class=kw>data</span> <span class=dt>HList</span> (<span class=ot>ts ::</span> [ <span class=fu>*</span> ]) <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>HList</span> <span class=ch>'[]</span>
<span class=ot>  (:::) ::</span> t <span class=ot>-&gt;</span> <span class=dt>HList</span> ts <span class=ot>-&gt;</span> <span class=dt>HList</span> (t <span class=ch>': ts)</span>

<span class=co>-- Take the head of a non-empty list with the first value as Bool type.</span>
<span class=ot>headBool ::</span> <span class=dt>HList</span> (<span class=dt>Bool</span> <span class=ch>': xs) -&gt; Bool</span>
headBool hlist <span class=fu>=</span> <span class=kw>case</span> hlist <span class=kw>of</span>
  (a <span class=ot>::</span><span class=fu>:</span> _) <span class=ot>-&gt;</span> a

<span class=ot>hlength ::</span> <span class=dt>HList</span> x <span class=ot>-&gt;</span> <span class=dt>Int</span>
hlength <span class=dt>Nil</span> <span class=fu>=</span> <span class=dv>0</span>
hlength (_ <span class=ot>::</span><span class=fu>:</span> b) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> (hlength b)


<span class=ot>tuple ::</span> (<span class=dt>Bool</span>, (<span class=dt>String</span>, (<span class=dt>Double</span>, ())))
tuple <span class=fu>=</span> (<span class=dt>True</span>, (<span class=st>"foo"</span>, (<span class=fl>3.14</span>, ())))

<span class=ot>hlist ::</span> <span class=dt>HList</span> <span class=ch>'[Bool, String , Double , ()]</span>
hlist <span class=fu>=</span> <span class=dt>True</span> <span class=ot>::</span><span class=fu>:</span> <span class=st>"foo"</span> <span class=ot>::</span><span class=fu>:</span> <span class=fl>3.14</span> <span class=ot>::</span><span class=fu>:</span> () <span class=ot>::</span><span class=fu>:</span> <span class=dt>Nil</span></code></pre></div>
<p><font>Of course this immediately begs the question of how to print such a list out to a string in the presence of type-heterogeneity. In this case we can use type-families combined with constraint kinds to apply the Show over the HLists parameters to generate the aggregate constraint that all types in the HList are Showable, and then derive the Show instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，这立即引出了一个问题，即如何在存在类型异质性的情况下将这样的列表打印成字符串。在这种情况下，我们可以使用类型族结合约束类型，将 Show 应用于 HLists 参数，以生成 HList 中所有类型都是 Showable 的聚合约束，然后派生 Show 实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/constraint_list.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>GHC.Exts</span> (<span class=dt>Constraint</span>)

<span class=kw>infixr</span> <span class=dv>5</span> <span class=ot>::</span><span class=fu>:</span>

<span class=kw>data</span> <span class=dt>HList</span> (<span class=ot>ts ::</span> [ <span class=fu>*</span> ]) <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>HList</span> <span class=ch>'[]</span>
<span class=ot>  (:::) ::</span> t <span class=ot>-&gt;</span> <span class=dt>HList</span> ts <span class=ot>-&gt;</span> <span class=dt>HList</span> (t <span class=ch>': ts)</span>

<span class=kw>type</span> family <span class=dt>Map</span> (<span class=ot>f ::</span> a <span class=ot>-&gt;</span> b) (<span class=ot>xs ::</span> [a])<span class=ot> ::</span> [b]
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Map</span> f <span class=ch>'[] = '</span>[]
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Map</span> f (x <span class=ch>': xs) = f x '</span><span class=fu>:</span> <span class=dt>Map</span> f xs

<span class=kw>type</span> family <span class=dt>Constraints</span> (<span class=ot>cs ::</span> [<span class=dt>Constraint</span>])<span class=ot> ::</span> <span class=dt>Constraint</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Constraints</span> <span class=ch>'[] = ()</span>
<span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Constraints</span> (c <span class=ch>': cs) = (c, Constraints cs)</span>

<span class=kw>type</span> <span class=dt>AllHave</span> (<span class=ot>c ::</span> k <span class=ot>-&gt;</span> <span class=dt>Constraint</span>) (<span class=ot>xs ::</span> [k]) <span class=fu>=</span> <span class=dt>Constraints</span> (<span class=dt>Map</span> c xs)

<span class=ot>showHList ::</span> <span class=dt>AllHave</span> <span class=dt>Show</span> xs <span class=ot>=&gt;</span> <span class=dt>HList</span> xs <span class=ot>-&gt;</span> [<span class=dt>String</span>]
showHList <span class=dt>Nil</span> <span class=fu>=</span> []
showHList (x <span class=ot>::</span><span class=fu>:</span> xs) <span class=fu>=</span> (show x) <span class=fu>:</span> showHList xs

<span class=kw>instance</span> <span class=dt>AllHave</span> <span class=dt>Show</span> xs <span class=ot>=&gt;</span> <span class=dt>Show</span> (<span class=dt>HList</span> xs) <span class=kw>where</span>
  show <span class=fu>=</span> show <span class=fu>.</span> showHList

<span class=ot>example1 ::</span> <span class=dt>HList</span> <span class=ch>'[Bool, String , Double , ()]</span>
example1 <span class=fu>=</span> <span class=dt>True</span> <span class=ot>::</span><span class=fu>:</span> <span class=st>"foo"</span> <span class=ot>::</span><span class=fu>:</span> <span class=fl>3.14</span> <span class=ot>::</span><span class=fu>:</span> () <span class=ot>::</span><span class=fu>:</span> <span class=dt>Nil</span>
<span class=co>-- ["True","\"foo\"","3.14","()"]</span></code></pre></div>
<h2 id=typelevel-dictionaries><font>Typelevel Dictionaries</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类型级词典</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Much of this discussion of promotion begs the question whether we can create data structures at the type-level to store information at compile-time. For example a type-level association list can be used to model a map between type-level symbols and any other promotable types. Together with type-families we can write down type-level traversal and lookup functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>大部分关于提升的讨论都回避了我们是否可以在类型级别创建数据结构以在编译时存储信息的问题。例如，类型级关联列表可用于对类型级符号与任何其他可提升类型之间的映射进行建模。与类型族一起，我们可以写下类型级别的遍历和查找函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/typemap.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE RankNTypes #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE ConstraintKinds #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>GHC.TypeLits</span>
<span class=kw>import </span><span class=dt>Data.Proxy</span>
<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=kw>type</span> family <span class=dt>If</span> (<span class=ot>p ::</span> <span class=dt>Bool</span>) (<span class=ot>a ::</span> k) (<span class=ot>b ::</span> k)<span class=ot> ::</span> k <span class=kw>where</span>
  <span class=dt>If</span> <span class=dt>True</span> a b <span class=fu>=</span> a
  <span class=dt>If</span> <span class=dt>False</span> a b <span class=fu>=</span> b

<span class=kw>type</span> family <span class=dt>Lookup</span> (<span class=ot>k ::</span> a) (<span class=ot>ls ::</span> [(a, b)])<span class=ot> ::</span> <span class=dt>Maybe</span> b <span class=kw>where</span>
  <span class=dt>Lookup</span> k <span class=ch>'[] = '</span><span class=dt>Nothing</span>
  <span class=dt>Lookup</span> k (<span class=ch>'(a, b) '</span><span class=fu>:</span> xs) <span class=fu>=</span> <span class=dt>If</span> (a <span class=fu>==</span> k) (<span class=ch>'Just b) (Lookup k xs)</span>

<span class=kw>type</span> <span class=dt>M</span> <span class=fu>=</span> [
    <span class=ch>'("a", 1)</span>
  , <span class=ch>'("b", 2)</span>
  , <span class=ch>'("c", 3)</span>
  , <span class=ch>'("d", 4)</span>
  ]

<span class=kw>type</span> <span class=dt>K</span> <span class=fu>=</span> <span class=st>"a"</span>
<span class=kw>type</span> (<span class=fu>!!</span>) m (<span class=ot>k ::</span> <span class=dt>Symbol</span>) a <span class=fu>=</span> (<span class=dt>Lookup</span> k m) <span class=fu>~</span> <span class=dt>Just</span> a

<span class=ot>value ::</span> <span class=dt>Integer</span>
value <span class=fu>=</span> natVal ( <span class=dt>Proxy</span><span class=ot> ::</span> (<span class=dt>M</span> <span class=fu>!!</span> <span class=st>"a"</span>) a <span class=ot>=&gt;</span> <span class=dt>Proxy</span> a )</code></pre></div>
<p><font>If we ask GHC to expand out the type signature we can view the explicit implementation of the type-level map lookup function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果我们要求 GHC 扩展类型签名，我们可以查看类型级映射查找函数的显式实现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class=fu>!!</span>)
<span class=ot>  ::</span> <span class=dt>If</span>
       (<span class=dt>GHC.TypeLits.EqSymbol</span> <span class=st>"a"</span> k)
       (<span class=ch>'Just 1)</span>
       (<span class=dt>If</span>
          (<span class=dt>GHC.TypeLits.EqSymbol</span> <span class=st>"b"</span> k)
          (<span class=ch>'Just 2)</span>
          (<span class=dt>If</span>
             (<span class=dt>GHC.TypeLits.EqSymbol</span> <span class=st>"c"</span> k)
             (<span class=ch>'Just 3)</span>
             (<span class=dt>If</span> (<span class=dt>GHC.TypeLits.EqSymbol</span> <span class=st>"d"</span> k) (<span class=ch>'Just 4) '</span><span class=dt>Nothing</span>)))
     <span class=fu>~</span> <span class=ch>'Just v =&gt;</span>
     <span class=dt>Proxy</span> k <span class=ot>-&gt;</span> <span class=dt>Proxy</span> v</code></pre></div>
<h2 id=advanced-proofs><font>Advanced Proofs</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高级证明</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, and is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Now that we have the length-indexed vector let's go write the reverse function, how hard could it be?</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在我们有了长度索引向量，让我们开始编写反向函数，这有多难？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>So we go and write down something like this:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以我们去写下这样的东西：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>reverseNaive ::</span> forall n a<span class=fu>.</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a n
reverseNaive xs <span class=fu>=</span> go <span class=dt>Nil</span> xs <span class=co>-- Error: n + 0 != n</span>
  <span class=kw>where</span>
<span class=ot>    go ::</span> <span class=dt>Vec</span> a m <span class=ot>-&gt;</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a (n <span class=fu>:+</span> m)
    go acc <span class=dt>Nil</span> <span class=fu>=</span> acc
    go acc (<span class=dt>Cons</span> x xs) <span class=fu>=</span> go (<span class=dt>Cons</span> x acc) xs <span class=co>-- Error: n + succ m != succ (n + m)</span></code></pre></div>
<p><font>Running this we find that GHC is unhappy about two lines in the code:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>运行这个我们发现 GHC 对代码中的两行不满意：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Couldn't</span> match <span class=kw>type</span> ‘n’ with ‘n <span class=fu>:+</span> <span class=ch>'Z’</span>
    <span class=dt>Expected</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Vec</span> a n
      <span class=dt>Actual</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Vec</span> a (n <span class=fu>:+</span> <span class=ch>'Z)</span>

<span class=dt>Could</span> not deduce ((n1 <span class=fu>:+</span> <span class=ch>'S m) ~ '</span><span class=dt>S</span> (n1 <span class=fu>:+</span> m))
    <span class=dt>Expected</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Vec</span> a1 (k <span class=fu>:+</span> m)
      <span class=dt>Actual</span> <span class=kw>type</span><span class=fu>:</span> <span class=dt>Vec</span> a1 (n1 <span class=fu>:+</span> <span class=ch>'S m)</span></code></pre></div>
<p><font>As we unfold elements out of the vector we'll end up doing a lot of type-level arithmetic over indices as we combine the subparts of the vector backwards, but as a consequence we find that GHC will run into some unification errors because it doesn't know about basic arithmetic properties of the natural numbers. Namely that </font><code>forall n. n + 0 = 0</code><font> and </font><code>forall n m. n + (1 + m) = 1 + (n + m)</code><font>. Which of course it really shouldn't be given that we've constructed a system at the type-level which intuitively </font><em>models</em><font> arithmetic but GHC is just a dumb compiler, it can't automatically deduce the isomorphism between natural numbers and Peano numbers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当我们从向量中展开元素时，我们最终会在向后组合向量的子部分时对索引进行大量类型级算术运算，但结果我们发现 GHC 会遇到一些统一错误，因为它没有了解自然数的基本算术性质。即forall n。 n + 0 = 0 和所有 n m。 n + (1 + m) = 1 + (n + m)。当然，我们真的不应该认为我们已经在类型级别构建了一个系统，它可以直观地模拟算术，但 GHC 只是一个愚蠢的编译器，它不能自动推断出自然数和 Peano 数之间的同构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>So at each of these call sites we now have a proof obligation to construct proof terms. Recall from our discussion of propositional equality from GADTs that we actually have such machinery to construct this now.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，在每个调用站点，我们现在都有构建证明项的证明义务。回想一下我们对 GADT 命题相等性的讨论，我们现在实际上有这样的机制来构建它。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/reverse.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>

<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=kw>data</span> <span class=dt>Nat</span> <span class=fu>=</span> <span class=dt>Z</span> <span class=fu>|</span> <span class=dt>S</span> <span class=dt>Nat</span>

<span class=kw>data</span> <span class=dt>SNat</span> n <span class=kw>where</span>
  <span class=dt>Zero</span><span class=ot> ::</span> <span class=dt>SNat</span> <span class=dt>Z</span>
  <span class=dt>Succ</span><span class=ot> ::</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> <span class=dt>SNat</span> (<span class=dt>S</span> n)

<span class=kw>data</span> <span class=dt>Vec</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=dt>Nat</span> <span class=ot>-&gt;</span> <span class=fu>*</span> <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>Vec</span> a <span class=dt>Z</span>
  <span class=dt>Cons</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a (<span class=dt>S</span> n)

<span class=kw>instance</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> <span class=dt>Show</span> (<span class=dt>Vec</span> a n) <span class=kw>where</span>
  show <span class=dt>Nil</span>         <span class=fu>=</span> <span class=st>"Nil"</span>
  show (<span class=dt>Cons</span> x xs) <span class=fu>=</span> <span class=st>"Cons "</span> <span class=fu>++</span> show x <span class=fu>++</span> <span class=st>" ("</span> <span class=fu>++</span> show xs <span class=fu>++</span> <span class=st>")"</span>

<span class=kw>type</span> family (<span class=ot>m ::</span> <span class=dt>Nat</span>) <span class=fu>:+</span> (<span class=ot>n ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>Z</span> <span class=fu>:+</span> n <span class=fu>=</span> n
  <span class=dt>S</span> m <span class=fu>:+</span> n <span class=fu>=</span> <span class=dt>S</span> (m <span class=fu>:+</span> n)

<span class=co>-- (a ~ b) implies (f a ~ f b)</span>
<span class=ot>cong ::</span> a <span class=fu>:~:</span> b <span class=ot>-&gt;</span> f a <span class=fu>:~:</span> f b
cong <span class=dt>Refl</span> <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- (a ~ b) implies (f a) implies (f b)</span>
<span class=ot>subst ::</span> a <span class=fu>:~:</span> b <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b
subst <span class=dt>Refl</span> <span class=fu>=</span> id

<span class=ot>plus_zero ::</span> forall n<span class=fu>.</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> (n <span class=fu>:+</span> <span class=dt>Z</span>) <span class=fu>:~:</span> n
plus_zero <span class=dt>Zero</span> <span class=fu>=</span> <span class=dt>Refl</span>
plus_zero (<span class=dt>Succ</span> n) <span class=fu>=</span> cong (plus_zero n)

<span class=ot>plus_suc ::</span> forall n m<span class=fu>.</span> <span class=dt>SNat</span> n <span class=ot>-&gt;</span> <span class=dt>SNat</span> m <span class=ot>-&gt;</span> (n <span class=fu>:+</span> (<span class=dt>S</span> m)) <span class=fu>:~:</span> (<span class=dt>S</span> (n <span class=fu>:+</span> m))
plus_suc <span class=dt>Zero</span> m <span class=fu>=</span> <span class=dt>Refl</span>
plus_suc (<span class=dt>Succ</span> n) m <span class=fu>=</span> cong (plus_suc n m)

<span class=ot>size ::</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>SNat</span> n
size <span class=dt>Nil</span>         <span class=fu>=</span> <span class=dt>Zero</span>
size (<span class=dt>Cons</span> _ xs) <span class=fu>=</span> <span class=dt>Succ</span> <span class=fu>$</span> size xs

reverse<span class=ot> ::</span> forall n a<span class=fu>.</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a n
reverse xs <span class=fu>=</span> subst (plus_zero (size xs)) <span class=fu>$</span> go <span class=dt>Nil</span> xs
  <span class=kw>where</span>
<span class=ot>    go ::</span> <span class=dt>Vec</span> a m <span class=ot>-&gt;</span> <span class=dt>Vec</span> a k <span class=ot>-&gt;</span> <span class=dt>Vec</span> a (k <span class=fu>:+</span> m)
    go acc <span class=dt>Nil</span> <span class=fu>=</span> acc
    go acc (<span class=dt>Cons</span> x xs) <span class=fu>=</span> subst (plus_suc (size xs) (size acc)) <span class=fu>$</span> go (<span class=dt>Cons</span> x acc) xs

<span class=ot>append ::</span> <span class=dt>Vec</span> a n <span class=ot>-&gt;</span> <span class=dt>Vec</span> a m <span class=ot>-&gt;</span> <span class=dt>Vec</span> a (n <span class=fu>:+</span> m)
append (<span class=dt>Cons</span> x xs) ys <span class=fu>=</span> <span class=dt>Cons</span> x (append xs ys)
append <span class=dt>Nil</span>         ys <span class=fu>=</span> ys

<span class=ot>vec ::</span> <span class=dt>Vec</span> <span class=dt>Int</span> (<span class=dt>S</span> (<span class=dt>S</span> (<span class=dt>S</span> <span class=dt>Z</span>)))
vec <span class=fu>=</span> <span class=dv>1</span> <span class=ot>`Cons`</span> (<span class=dv>2</span> <span class=ot>`Cons`</span> (<span class=dv>3</span> <span class=ot>`Cons`</span> <span class=dt>Nil</span>))

<span class=ot>test ::</span> <span class=dt>Vec</span> <span class=dt>Int</span> (<span class=dt>S</span> (<span class=dt>S</span> (<span class=dt>S</span> <span class=dt>Z</span>)))
test <span class=fu>=</span> Main.reverse vec</code></pre></div>
<p><font>One might consider whether we could avoid using the singleton trick and just use type-level natural numbers, and technically this approach should be feasible although it seems that the natural number solver in GHC 7.8 can decide some properties but not the ones needed to complete the natural number proofs for the reverse functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有人可能会考虑我们是否可以避免使用单例技巧而只使用类型级别的自然数，从技术上讲，这种方法应该是可行的，尽管 GHC 7.8 中的自然数求解器似乎可以决定一些属性，但不能决定完成反函数的自然数证明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>

<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (<span class=dt>Eq</span>)
<span class=kw>import </span><span class=dt>GHC.TypeLits</span>
<span class=kw>import </span><span class=dt>Data.Type.Equality</span>

<span class=kw>type</span> <span class=dt>Z</span> <span class=fu>=</span> <span class=dv>0</span>

<span class=kw>type</span> family <span class=dt>S</span> (<span class=ot>n ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span> <span class=kw>where</span>
  <span class=dt>S</span> n <span class=fu>=</span> n <span class=fu>+</span> <span class=dv>1</span>

<span class=co>-- Yes!</span>
<span class=ot>eq_zero ::</span> <span class=dt>Z</span> <span class=fu>:~:</span> <span class=dt>Z</span>
eq_zero <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- Yes!</span>
<span class=ot>zero_plus_one ::</span> (<span class=dt>Z</span> <span class=fu>+</span> <span class=dv>1</span>) <span class=fu>:~:</span> (<span class=dv>1</span> <span class=fu>+</span> <span class=dt>Z</span>)
zero_plus_one <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- Yes!</span>
<span class=ot>plus_zero ::</span> forall n<span class=fu>.</span> (n <span class=fu>+</span> <span class=dt>Z</span>) <span class=fu>:~:</span> n
plus_zero <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- Yes!</span>
<span class=ot>plus_one ::</span> forall n<span class=fu>.</span> (n <span class=fu>+</span> <span class=dt>S</span> <span class=dt>Z</span>) <span class=fu>:~:</span> <span class=dt>S</span> n
plus_one <span class=fu>=</span> <span class=dt>Refl</span>

<span class=co>-- No.</span>
<span class=ot>plus_suc ::</span> forall n m<span class=fu>.</span> (n <span class=fu>+</span> (<span class=dt>S</span> m)) <span class=fu>:~:</span> (<span class=dt>S</span> (n <span class=fu>+</span> m))
plus_suc <span class=fu>=</span> <span class=dt>Refl</span></code></pre></div>
<p><font>Caveat should be that there might be a way to do this in GHC 7.6 that I'm not aware of. In GHC 7.10 there are some planned changes to solver that should be able to resolve these issues. In particular there are plans to allow pluggable type system extensions that could outsource these kind of problems to third party SMT solvers which can solve these kind of numeric relations and return this information back to GHC's typechecker.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>需要注意的是，在 GHC 7.6 中可能有一种我不知道的方法可以做到这一点。在 GHC 7.10 中，有一些计划中的求解器更改应该能够解决这些问题。特别是有计划允许可插入类型系统扩展，可以将此类问题外包给第三方 SMT 求解器，第三方 SMT 求解器可以解决这些数字关系并将此信息返回给 GHC 的类型检查器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>As an aside this is a direct transliteration of the equivalent proof in Agda, which is accomplished via the same method but without the song and dance to get around the lack of dependent types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>顺便说一句，这是 Agda 中等效证明的直接音译，它是通过相同的方法完成的，但没有为了解决依赖类型的缺乏而费尽心思。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/17-promotion/Vector.agda><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Vector</span> <span class=kw>where</span>

<span class=kw>infixr</span> <span class=dv>10</span> _<span class=ot>∷</span>_

<span class=kw>data</span> ℕ <span class=fu>:</span> <span class=dt>Set</span> <span class=kw>where</span>
  zero <span class=fu>:</span> ℕ
  suc  <span class=fu>:</span> ℕ <span class=ot>→</span> ℕ

<span class=ot>{-# BUILTIN NATURAL ℕ    #-}</span>
<span class=ot>{-# BUILTIN ZERO    zero #-}</span>
<span class=ot>{-# BUILTIN SUC     suc  #-}</span>

<span class=kw>infixl</span> <span class=dv>6</span> _<span class=fu>+</span>_

_<span class=fu>+</span>_ <span class=fu>:</span> ℕ <span class=ot>→</span> ℕ <span class=ot>→</span> ℕ
<span class=dv>0</span> <span class=fu>+</span> n <span class=fu>=</span> n
suc m <span class=fu>+</span> n <span class=fu>=</span> suc (m <span class=fu>+</span> n)

<span class=kw>data</span> <span class=dt>Vec</span> (<span class=dt>A</span> <span class=fu>:</span> <span class=dt>Set</span>) <span class=fu>:</span> ℕ <span class=ot>→</span> <span class=dt>Set</span> <span class=kw>where</span>
  []  <span class=fu>:</span> <span class=dt>Vec</span> <span class=dt>A</span> <span class=dv>0</span>
  _<span class=ot>∷</span>_ <span class=fu>:</span> <span class=ot>∀</span> {n} <span class=ot>→</span> <span class=dt>A</span> <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> n <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> (suc n)

_<span class=fu>++</span>_ <span class=fu>:</span> <span class=ot>∀</span> {<span class=dt>A</span> n m} <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> n <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> m <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> (n <span class=fu>+</span> m)
[] <span class=fu>++</span> ys <span class=fu>=</span> ys
(x <span class=ot>∷</span> xs) <span class=fu>++</span> ys <span class=fu>=</span> x <span class=ot>∷</span> (xs <span class=fu>++</span> ys)

infix <span class=dv>4</span> _≡_

<span class=kw>data</span> _≡_ {<span class=dt>A</span> <span class=fu>:</span> <span class=dt>Set</span>} (x <span class=fu>:</span> <span class=dt>A</span>) <span class=fu>:</span> <span class=dt>A</span> <span class=ot>→</span> <span class=dt>Set</span> <span class=kw>where</span>
  refl <span class=fu>:</span> x ≡ x

subst <span class=fu>:</span> {<span class=dt>A</span> <span class=fu>:</span> <span class=dt>Set</span>} <span class=ot>→</span> (<span class=dt>P</span> <span class=fu>:</span> <span class=dt>A</span> <span class=ot>→</span> <span class=dt>Set</span>) <span class=ot>→</span> <span class=ot>∀</span>{x y} <span class=ot>→</span> x ≡ y <span class=ot>→</span> <span class=dt>P</span> x <span class=ot>→</span> <span class=dt>P</span> y
subst <span class=dt>P</span> refl p <span class=fu>=</span> p

cong <span class=fu>:</span> {<span class=dt>A</span> <span class=dt>B</span> <span class=fu>:</span> <span class=dt>Set</span>} (f <span class=fu>:</span> <span class=dt>A</span> <span class=ot>→</span> <span class=dt>B</span>) <span class=ot>→</span> {x y <span class=fu>:</span> <span class=dt>A</span>} <span class=ot>→</span> x ≡ y <span class=ot>→</span> f x ≡ f y
cong f refl <span class=fu>=</span> refl

vec <span class=fu>:</span> <span class=ot>∀</span> {<span class=dt>A</span>} (k <span class=fu>:</span> ℕ) <span class=ot>→</span> <span class=dt>Set</span>
vec {<span class=dt>A</span>} k <span class=fu>=</span> <span class=dt>Vec</span> <span class=dt>A</span> k

plus_zero <span class=fu>:</span> {n <span class=fu>:</span> ℕ} <span class=ot>→</span> n <span class=fu>+</span> <span class=dv>0</span> ≡ n 
plus_zero {zero}  <span class=fu>=</span> refl
plus_zero {suc n} <span class=fu>=</span> cong suc plus_zero

plus_suc <span class=fu>:</span> {n <span class=fu>:</span> ℕ} <span class=ot>→</span> n <span class=fu>+</span> (suc <span class=dv>0</span>) ≡ suc n 
plus_suc {zero}  <span class=fu>=</span> refl
plus_suc {suc n} <span class=fu>=</span> cong suc (plus_suc {n})

reverse <span class=fu>:</span> <span class=ot>∀</span> {<span class=dt>A</span> n} <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> n <span class=ot>→</span> <span class=dt>Vec</span> <span class=dt>A</span> n
reverse []       <span class=fu>=</span> []
reverse {<span class=dt>A</span>} {suc n} (x <span class=ot>∷</span> xs) <span class=fu>=</span> subst vec (plus_suc {n}) (reverse xs <span class=fu>++</span> (x  <span class=ot>∷</span> []))</code></pre></div>
<h2 id=liquid-haskell><font>Liquid Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Liquid Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of LiquidHaskell is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，LiquidHaskell 的知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>LiquidHaskell is an extension to GHC's typesystem that adds the capactity for refinement types using the annotation syntax. The type signatures of functions can be checked by the external for richer type semantics than default GHC provides, including non-exhaustive patterns and complex arithemtic properties that require external SMT solvers to verify. For instance LiquidHaskell can statically verify that a function that operates over a </font><code>Maybe a</code><font> is always given a </font><code>Just</code><font> or that an arithmetic functions always yields an Int that is even positive number.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>LiquidHaskell 是 GHC 类型系统的扩展，它使用注释语法增加了细化类型的能力。外部可以检查函数的类型签名，以获得比默认 GHC 提供的更丰富的类型语义，包括非详尽模式和需要外部 SMT 求解器验证的复杂算术属性。例如，LiquidHaskell 可以静态验证对 Maybe a 进行操作的函数是否始终被赋予 Just 或算术函数始终产生为偶数正数的 Int。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To Install LiquidHaskell in Ubuntu add the following line to your </font><code>/etc/sources.list</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要在 Ubuntu 中安装 LiquidHaskell，请将以下行添加到您的 /etc/sources.list 中：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>deb</span> http://ppa.launchpad.net/hvr/z3/ubuntu trusty main</code></pre></div>
<p><font>And then install the external SMT solver.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>然后安装外部 SMT 解算器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F6F88286
$ <span class=kw>sudo</span> apt-get install z3</code></pre></div>
<p><font>Then clone the repo and build it using stack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>然后克隆 repo 并使用堆栈构建它。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>git</span> clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git
$ <span class=kw>cd</span> liquidhaskell
$ <span class=kw>stack</span> install</code></pre></div>
<p><font>Ensure that </font><code>$HOME/.local/bin</code><font> is on your </font><code>$PATH</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>确保 $HOME/.local/bin 在您的 $PATH 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (mod, gcd)

<span class=co>{-@ mod :: a:Nat -&gt; b:{v:Nat| 0 &lt; v} -&gt; {v:Nat | v &lt; b} @-}</span>
mod<span class=ot> ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
mod a b
  <span class=fu>|</span> a <span class=fu>&lt;</span> b <span class=fu>=</span> a
  <span class=fu>|</span> otherwise <span class=fu>=</span> mod (a <span class=fu>-</span> b) b

<span class=co>{-@ gcd :: a:Nat -&gt; b:{v:Nat | v &lt; a} -&gt; Int @-}</span>
gcd<span class=ot> ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
gcd a <span class=dv>0</span> <span class=fu>=</span> a
gcd a b <span class=fu>=</span> gcd b (a <span class=ot>`mod`</span> b)</code></pre></div>
<p><font>The module can be run through the solver using the </font><code>liquid</code><font> command line tool.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>该模块可以使用 liquid 命令行工具通过求解器运行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>liquid</span> example.hs
<span class=kw>Done</span> solving.

<span class=kw>****</span> DONE:  solve **************************************************************


<span class=kw>****</span> DONE:  annotate ***********************************************************


<span class=kw>****</span> RESULT: SAFE **************************************************************</code></pre></div>
<p><font>For more extensive documentation and further use cases see the official documentation:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有关更广泛的文档和更多用例，请参阅官方文档：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://ucsd-progsys.github.io/liquidhaskell-tutorial/01-intro.html>Liquid Haskell Documentation<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Liquid Haskell 文档</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h1 id=generics><font>Generics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>Haskell has several techniques for automatic generation of type classes for a variety of tasks that consist largely of boilerplate code generation such as:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 有多种自动生成类型类的技术，适用于主要由样板代码生成组成的各种任务，例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Pretty Printing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂亮的印刷</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Equality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>平等</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Serialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>连载</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Ordering</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>订购</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>These are achieved through several tools and techniques outlined in the next few sections:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些是通过接下来几节中概述的几种工具和技术实现的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Typeable / Dynamic</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可输入/动态</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Scrap Your Boilerplate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>报废你的样板</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>GHC.Generics</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>generics-sop</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>仿制药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<h2 id=typeable><font>Typeable</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可打字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><code>Typeable</code><font> class be used to create runtime type information for arbitrary types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Typeable 类用于为任意类型创建运行时类型信息。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>typeOf ::</span> <span class=dt>Typeable</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>TypeRep</span></code></pre></div>
<div class=sourceCode include=src/18-generics/typeable.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Data.Typeable</span>

<span class=kw>data</span> <span class=dt>Animal</span> <span class=fu>=</span> <span class=dt>Cat</span> <span class=fu>|</span> <span class=dt>Dog</span> <span class=kw>deriving</span> <span class=dt>Typeable</span>
<span class=kw>data</span> <span class=dt>Zoo</span> a <span class=fu>=</span> <span class=dt>Zoo</span> [a] <span class=kw>deriving</span> <span class=dt>Typeable</span>

<span class=ot>equal ::</span> (<span class=dt>Typeable</span> a, <span class=dt>Typeable</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> <span class=dt>Bool</span>
equal a b <span class=fu>=</span> typeOf a <span class=fu>==</span> typeOf b

<span class=ot>example1 ::</span> <span class=dt>TypeRep</span>
example1 <span class=fu>=</span> typeOf <span class=dt>Cat</span>
<span class=co>-- Animal</span>

<span class=ot>example2 ::</span> <span class=dt>TypeRep</span>
example2 <span class=fu>=</span> typeOf (<span class=dt>Zoo</span> [<span class=dt>Cat</span>, <span class=dt>Dog</span>])
<span class=co>-- Zoo Animal</span>

<span class=ot>example3 ::</span> <span class=dt>TypeRep</span>
example3 <span class=fu>=</span> typeOf ((<span class=dv>1</span>, <span class=fl>6.636e-34</span>, <span class=st>"foo"</span>)<span class=ot> ::</span> (<span class=dt>Int</span>, <span class=dt>Double</span>, <span class=dt>String</span>))
<span class=co>-- (Int,Double,[Char])</span>

<span class=ot>example4 ::</span> <span class=dt>Bool</span>
example4 <span class=fu>=</span> equal <span class=dt>False</span> ()
<span class=co>-- False</span></code></pre></div>
<p><font>Using the Typeable instance allows us to write down a type safe cast function which can safely use </font><code>unsafeCast</code><font> and provide a proof that the resulting type matches the input.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 Typeable 实例允许我们写下一个类型安全的转换函数，它可以安全地使用 unsafeCast 并提供结果类型与输入匹配的证明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>cast ::</span> (<span class=dt>Typeable</span> a, <span class=dt>Typeable</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> b
cast x
  <span class=fu>|</span> typeOf x <span class=fu>==</span> typeOf ret <span class=fu>=</span> <span class=dt>Just</span> ret
  <span class=fu>|</span> otherwise <span class=fu>=</span> <span class=dt>Nothing</span>
  <span class=kw>where</span>
    ret <span class=fu>=</span> unsafeCast x</code></pre></div>
<p><font>Of historical note is that writing our own Typeable classes is currently possible of GHC 7.6 but allows us to introduce dangerous behavior that can cause crashes, and shouldn't be done except by GHC itself. As of 7.8 GHC forbids hand-written Typeable instances. As of 7.10 </font><code>-XAutoDeriveDataTypeable</code><font> is enabled by default.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>值得注意的是，编写我们自己的 Typeable 类目前在 GHC 7.6 中是可能的，但允许我们引入可能导致崩溃的危险行为，并且除了 GHC 本身之外不应这样做。从 7.8 开始，GHC 禁止手写 Typeable 实例。从 7.10 开始，-XAutoDeriveDataTypeable 默认启用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://chrisdone.com/posts/data-typeable>Typeable and Data in Haskell</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Haskell 中的类型化和数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=dynamic><font>Dynamic</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>动态的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Since we have a way of querying runtime type information we can use this machinery to implement a </font><code>Dynamic</code><font> type. This allows us to box up any monotype into a uniform type that can be passed to any function taking a Dynamic type which can then unpack the underlying value in a type-safe way.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>由于我们有一种查询运行时类型信息的方法，因此我们可以使用这种机制来实现动态类型。这允许我们将任何单型包装成一个统一类型，该类型可以传递给任何采用 Dynamic 类型的函数，然后可以以类型安全的方式解压缩基础值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>toDyn ::</span> <span class=dt>Typeable</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Dynamic</span>
<span class=ot>fromDyn ::</span> <span class=dt>Typeable</span> a <span class=ot>=&gt;</span> <span class=dt>Dynamic</span> <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
<span class=ot>fromDynamic ::</span> <span class=dt>Typeable</span> a <span class=ot>=&gt;</span> <span class=dt>Dynamic</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
<span class=ot>cast ::</span> (<span class=dt>Typeable</span> a, <span class=dt>Typeable</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> b</code></pre></div>
<div class=sourceCode include=src/18-generics/dynamic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Dynamic</span>
<span class=kw>import </span><span class=dt>Data.Maybe</span>

<span class=ot>dynamicBox ::</span> <span class=dt>Dynamic</span>
dynamicBox <span class=fu>=</span> toDyn (<span class=fl>6.62</span><span class=ot> ::</span> <span class=dt>Double</span>)

<span class=ot>example1 ::</span> <span class=dt>Maybe</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> fromDynamic dynamicBox
<span class=co>-- Nothing</span>

<span class=ot>example2 ::</span> <span class=dt>Maybe</span> <span class=dt>Double</span>
example2 <span class=fu>=</span> fromDynamic dynamicBox
<span class=co>-- Just 6.62</span>

<span class=ot>example3 ::</span> <span class=dt>Int</span>
example3 <span class=fu>=</span> fromDyn dynamicBox <span class=dv>0</span>
<span class=co>-- 0</span>

<span class=ot>example4 ::</span> <span class=dt>Double</span>
example4 <span class=fu>=</span> fromDyn dynamicBox <span class=fl>0.0</span>
<span class=co>-- 6.62</span></code></pre></div>
<p><font>In GHC 7.8 the Typeable class is poly-kinded so polymorphic functions can be applied over functions and higher kinded types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 GHC 7.8 中，Typeable 类是多种类的，因此多态函数可以应用于函数和更高种类的类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class="alert alert-danger">
<p><font>Use of Dynamic is somewhat rare, except in odd cases that have to deal with foreign memory and FFI interfaces. Using it for business logic is considered a code smell. Consider a more idiomatic solution.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Dynamic 的使用很少见，除非在必须处理外部内存和 FFI 接口的奇怪情况下。将它用于业务逻辑被认为是一种代码味道。考虑一个更惯用的解决方案。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h2 id=data><font>Data</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Just as Typeable lets us create runtime type information, the Data class allows us to reflect information about the structure of datatypes to runtime as needed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>正如 Typeable 让我们创建运行时类型信息一样，Data 类让我们可以根据需要将有关数据类型结构的信息反映到运行时。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Typeable</span> a <span class=ot>=&gt;</span> <span class=dt>Data</span> a <span class=kw>where</span>
<span class=ot>  gfoldl  ::</span> (forall d b<span class=fu>.</span> <span class=dt>Data</span> d <span class=ot>=&gt;</span> c (d <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> d <span class=ot>-&gt;</span> c b)
          <span class=ot>-&gt;</span> (forall g<span class=fu>.</span> g <span class=ot>-&gt;</span> c g)
          <span class=ot>-&gt;</span> a
          <span class=ot>-&gt;</span> c a

<span class=ot>  gunfold ::</span> (forall b r<span class=fu>.</span> <span class=dt>Data</span> b <span class=ot>=&gt;</span> c (b <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> c r)
          <span class=ot>-&gt;</span> (forall r<span class=fu>.</span> r <span class=ot>-&gt;</span> c r)
          <span class=ot>-&gt;</span> <span class=dt>Constr</span>
          <span class=ot>-&gt;</span> c a

<span class=ot>  toConstr ::</span> a <span class=ot>-&gt;</span> <span class=dt>Constr</span>
<span class=ot>  dataTypeOf ::</span> a <span class=ot>-&gt;</span> <span class=dt>DataType</span>
<span class=ot>  gmapQl ::</span> (r <span class=ot>-&gt;</span> r' <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> (forall d<span class=fu>.</span> <span class=dt>Data</span> d <span class=ot>=&gt;</span> d <span class=ot>-&gt;</span> r') <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> r</code></pre></div>
<p><font>The types for </font><code>gfoldl</code><font> and </font><code>gunfold</code><font> are a little intimidating ( and depend on </font><code>RankNTypes</code><font> ), the best way to understand is to look at some examples. First the most trivial case a simple sum type </font><code>Animal</code><font> would produce the following code:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>gfoldl 和 gunfold 的类型有点吓人（并且取决于 RankNTypes ），最好的理解方法是看一些例子。首先是最简单的情况，一个简单的求和类型 Animal 会产生以下代码：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Animal</span> <span class=fu>=</span> <span class=dt>Cat</span> <span class=fu>|</span> <span class=dt>Dog</span> <span class=kw>deriving</span> <span class=dt>Typeable</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Data</span> <span class=dt>Animal</span> <span class=kw>where</span>
  gfoldl k z <span class=dt>Cat</span> <span class=fu>=</span> z <span class=dt>Cat</span>
  gfoldl k z <span class=dt>Dog</span> <span class=fu>=</span> z <span class=dt>Dog</span>

  gunfold k z c
    <span class=fu>=</span> <span class=kw>case</span> constrIndex c <span class=kw>of</span>
        <span class=dv>1</span> <span class=ot>-&gt;</span> z <span class=dt>Cat</span>
        <span class=dv>2</span> <span class=ot>-&gt;</span> z <span class=dt>Dog</span>

  toConstr <span class=dt>Cat</span> <span class=fu>=</span> cCat
  toConstr <span class=dt>Dog</span> <span class=fu>=</span> cDog

  dataTypeOf _ <span class=fu>=</span> tAnimal

<span class=ot>tAnimal ::</span> <span class=dt>DataType</span>
tAnimal <span class=fu>=</span> mkDataType <span class=st>"Main.Animal"</span> [cCat, cDog]

<span class=ot>cCat ::</span> <span class=dt>Constr</span>
cCat <span class=fu>=</span> mkConstr tAnimal <span class=st>"Cat"</span> [] <span class=dt>Prefix</span>

<span class=ot>cDog ::</span> <span class=dt>Constr</span>
cDog <span class=fu>=</span> mkConstr tAnimal <span class=st>"Dog"</span> [] <span class=dt>Prefix</span></code></pre></div>
<p><font>For a type with non-empty containers we get something a little more interesting. Consider the list type:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于具有非空容器的类型，我们会得到一些更有趣的东西。考虑列表类型：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> <span class=dt>Data</span> a <span class=ot>=&gt;</span> <span class=dt>Data</span> [a] <span class=kw>where</span>
  gfoldl _ z []     <span class=fu>=</span> z []
  gfoldl k z (x<span class=fu>:</span>xs) <span class=fu>=</span> z (<span class=fu>:</span>) <span class=ot>`k`</span> x <span class=ot>`k`</span> xs

  toConstr []    <span class=fu>=</span> nilConstr
  toConstr (_<span class=fu>:</span>_) <span class=fu>=</span> consConstr

  gunfold k z c
    <span class=fu>=</span> <span class=kw>case</span> constrIndex c <span class=kw>of</span>
        <span class=dv>1</span> <span class=ot>-&gt;</span> z []
        <span class=dv>2</span> <span class=ot>-&gt;</span> k (k (z (<span class=fu>:</span>)))

  dataTypeOf _ <span class=fu>=</span> listDataType

<span class=ot>nilConstr ::</span> <span class=dt>Constr</span>
nilConstr <span class=fu>=</span> mkConstr listDataType <span class=st>"[]"</span> [] <span class=dt>Prefix</span>

<span class=ot>consConstr ::</span> <span class=dt>Constr</span>
consConstr <span class=fu>=</span> mkConstr listDataType <span class=st>"(:)"</span> [] <span class=dt>Infix</span>

<span class=ot>listDataType ::</span> <span class=dt>DataType</span>
listDataType <span class=fu>=</span> mkDataType <span class=st>"Prelude.[]"</span> [nilConstr,consConstr]</code></pre></div>
<p><font>Looking at </font><code>gfoldl</code><font> we see the Data has an implementation of a function for us to walk an applicative over the elements of the constructor by applying a function </font><code>k</code><font> over each element and applying </font><code>z</code><font> at the spine. For example look at the instance for a 2-tuple as well:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>查看 gfoldl，我们看到 Data 有一个函数的实现，我们可以通过在每个元素上应用函数 k 并在 spine 上应用 z 来在构造函数的元素上遍历应用程序。例如，还要查看 2 元组的实例：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>instance</span> (<span class=dt>Data</span> a, <span class=dt>Data</span> b) <span class=ot>=&gt;</span> <span class=dt>Data</span> (a,b) <span class=kw>where</span>
  gfoldl k z (a,b) <span class=fu>=</span> z (,) <span class=ot>`k`</span> a <span class=ot>`k`</span> b

  toConstr (_,_) <span class=fu>=</span> tuple2Constr

  gunfold k z c
    <span class=fu>=</span> <span class=kw>case</span> constrIndex c <span class=kw>of</span>
      <span class=dv>1</span> <span class=ot>-&gt;</span> k (k (z (,)))

  dataTypeOf _  <span class=fu>=</span> tuple2DataType

<span class=ot>tuple2Constr ::</span> <span class=dt>Constr</span>
tuple2Constr <span class=fu>=</span> mkConstr tuple2DataType <span class=st>"(,)"</span> [] <span class=dt>Infix</span>

<span class=ot>tuple2DataType ::</span> <span class=dt>DataType</span>
tuple2DataType <span class=fu>=</span> mkDataType <span class=st>"Prelude.(,)"</span> [tuple2Constr]</code></pre></div>
<p><font>This is pretty neat, now within the same typeclass we have a generic way to introspect any </font><code>Data</code><font> instance and write logic that depends on the structure and types of its subterms. We can now write a function which allows us to traverse an arbitrary instance of Data and twiddle values based on pattern matching on the runtime types. So let's write down a function </font><code>over</code><font> which increments a </font><code>Value</code><font> type for both for n-tuples and lists.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这非常简洁，现在在同一个类型类中，我们有一种通用的方法来内省任何 Data 实例并编写依赖于其子项的结构和类型的逻辑。我们现在可以编写一个函数，它允许我们遍历 Data 的任意实例并根据运行时类型的模式匹配来旋转值。因此，让我们写下一个函数，通过它递增 n 元组和列表的值类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/data.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Data.Data</span>
<span class=kw>import </span><span class=dt>Control.Monad.Identity</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=kw>data</span> <span class=dt>Animal</span> <span class=fu>=</span> <span class=dt>Cat</span> <span class=fu>|</span> <span class=dt>Dog</span> <span class=kw>deriving</span> (<span class=dt>Data</span>, <span class=dt>Typeable</span>)

<span class=kw>newtype</span> <span class=dt>Val</span> <span class=fu>=</span> <span class=dt>Val</span> <span class=dt>Int</span> <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Data</span>, <span class=dt>Typeable</span>)

<span class=ot>incr ::</span> <span class=dt>Typeable</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
incr <span class=fu>=</span> maybe id id (cast f)
  <span class=kw>where</span> f (<span class=dt>Val</span> x) <span class=fu>=</span> <span class=dt>Val</span> (x <span class=fu>*</span> <span class=dv>100</span>)

<span class=ot>over ::</span> <span class=dt>Data</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
over x <span class=fu>=</span> runIdentity <span class=fu>$</span> gfoldl cont base (incr x)
  <span class=kw>where</span>
    cont k d <span class=fu>=</span> k <span class=fu>&lt;*&gt;</span> (pure <span class=fu>$</span> over d)
    base <span class=fu>=</span> pure


<span class=ot>example1 ::</span> <span class=dt>Constr</span>
example1 <span class=fu>=</span> toConstr <span class=dt>Dog</span>
<span class=co>-- Dog</span>

<span class=ot>example2 ::</span> <span class=dt>DataType</span>
example2 <span class=fu>=</span> dataTypeOf <span class=dt>Cat</span>
<span class=co>-- DataType {tycon = "Main.Animal", datarep = AlgRep [Cat,Dog]}</span>

<span class=ot>example3 ::</span> [<span class=dt>Val</span>]
example3 <span class=fu>=</span> over [<span class=dt>Val</span> <span class=dv>1</span>, <span class=dt>Val</span> <span class=dv>2</span>, <span class=dt>Val</span> <span class=dv>3</span>]
<span class=co>-- [Val 100,Val 200,Val 300]</span>

<span class=ot>example4 ::</span> (<span class=dt>Val</span>, <span class=dt>Val</span>, <span class=dt>Val</span>)
example4 <span class=fu>=</span> over (<span class=dt>Val</span> <span class=dv>1</span>, <span class=dt>Val</span> <span class=dv>2</span>, <span class=dt>Val</span> <span class=dv>3</span>)
<span class=co>-- (Val 100,Val 200,Val 300)</span></code></pre></div>
<p><font>We can also write generic operations, for example to count the number of parameters in a data type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们还可以编写通用操作，例如计算数据类型中参数的数量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>numHoles ::</span> <span class=dt>Data</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>
numHoles <span class=fu>=</span> gmapQl (<span class=fu>+</span>) <span class=dv>0</span> (const <span class=dv>1</span>)

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> numHoles (<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>,<span class=dv>5</span>,<span class=dv>6</span>,<span class=dv>7</span>)
<span class=co>-- 7</span>

<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> numHoles (<span class=dt>Just</span> <span class=dv>3</span>)
<span class=co>-- 1</span></code></pre></div>
<h2 id=syb><font>Syb</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>赛博</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using the interface provided by the Data we can retrieve the information we need to, at runtime, inspect the types of expressions and rewrite them, collect terms, and find subterms matching specific predicates.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 Data 提供的接口，我们可以在运行时检索我们需要的信息，检查表达式的类型并重写它们，收集术语，并找到与特定谓词匹配的子术语。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>everywhere ::</span> (forall a<span class=fu>.</span> <span class=dt>Data</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> forall a<span class=fu>.</span> <span class=dt>Data</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
<span class=ot>everywhereM ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>GenericM</span> m <span class=ot>-&gt;</span> <span class=dt>GenericM</span> m
<span class=ot>somewhere ::</span> <span class=dt>MonadPlus</span> m <span class=ot>=&gt;</span> <span class=dt>GenericM</span> m <span class=ot>-&gt;</span> <span class=dt>GenericM</span> m
<span class=ot>listify ::</span> <span class=dt>Typeable</span> r <span class=ot>=&gt;</span> (r <span class=ot>-&gt;</span> <span class=dt>Bool</span>) <span class=ot>-&gt;</span> <span class=dt>GenericQ</span> [r]
<span class=ot>everything ::</span> (r <span class=ot>-&gt;</span> r <span class=ot>-&gt;</span> r) <span class=ot>-&gt;</span> <span class=dt>GenericQ</span> r <span class=ot>-&gt;</span> <span class=dt>GenericQ</span> r</code></pre></div>
<p><font>For example consider we have some custom collection of datatypes for which we want to write generic transformations that transform numerical subexpressions according to set of rewrite rules. We can use </font><code>syb</code><font> to write the transformation rules quite succinctly.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，考虑我们有一些自定义的数据类型集合，我们想为其编写通用转换，根据一组重写规则转换数字子表达式。我们可以使用 syb 非常简洁地编写转换规则。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/syb.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Data.Data</span>
<span class=kw>import </span><span class=dt>Data.Typeable</span>
<span class=kw>import </span><span class=dt>Data.Generics.Schemes</span>
<span class=kw>import </span><span class=dt>Data.Generics.Aliases</span> (mkT)

<span class=kw>data</span> <span class=dt>MyTuple</span> a <span class=fu>=</span> <span class=dt>MyTuple</span> a <span class=dt>Float</span>
  <span class=kw>deriving</span> (<span class=dt>Data</span>, <span class=dt>Typeable</span>, <span class=dt>Show</span>)

<span class=ot>exampleT ::</span> <span class=dt>Data</span> a <span class=ot>=&gt;</span> <span class=dt>MyTuple</span> a <span class=ot>-&gt;</span> <span class=dt>MyTuple</span> a
exampleT <span class=fu>=</span> everywhere (mkT go1) <span class=fu>.</span> everywhere (mkT go2)
  <span class=kw>where</span>
<span class=ot>    go1 ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
    go1 x <span class=fu>=</span> succ x

<span class=ot>    go2 ::</span> <span class=dt>Float</span> <span class=ot>-&gt;</span> <span class=dt>Float</span>
    go2 x <span class=fu>=</span> succ x

<span class=ot>findFloat ::</span> <span class=dt>Data</span> x <span class=ot>=&gt;</span> x <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Float</span>
findFloat <span class=fu>=</span> gfindtype

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> term <span class=fu>=</span> <span class=dt>MyTuple</span> (<span class=dt>MyTuple</span> (<span class=dv>1</span><span class=ot> ::</span> <span class=dt>Int</span>) <span class=fl>2.0</span>) <span class=fl>3.0</span>
  print (exampleT term)
  print (gsize term)
  print (findFloat term)
  print (listify ((<span class=fu>&gt;</span><span class=dv>0</span>)<span class=ot> ::</span> (<span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>)) term)</code></pre></div>
<ul>
<li><a href=https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html>Data.Generics.Schemes<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据.泛型.方案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=generic><font>Generic</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The most modern method of doing generic programming uses type families to achieve a better method of deriving the structural properties of arbitrary type classes. Generic implements a typeclass with an associated type </font><code>Rep</code><font> ( Representation ) together with a pair of functions that form a 2-sided inverse ( isomorphism ) for converting to and from the associated type and the derived type in question.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>进行泛型编程的最现代方法使用类型族来实现派生任意类型类的结构属性的更好方法。 Generic 实现了一个类型类，它有一个关联类型 Rep (Representation) 以及一对函数，这些函数形成一个双向逆函数 (同构)，用于在关联类型和相关派生类型之间进行转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Generic</span> a <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Rep</span> a
<span class=ot>  from ::</span> a <span class=ot>-&gt;</span> <span class=dt>Rep</span> a
<span class=ot>  to ::</span> <span class=dt>Rep</span> a <span class=ot>-&gt;</span> a

<span class=kw>class</span> <span class=dt>Datatype</span> d <span class=kw>where</span>
<span class=ot>  datatypeName ::</span> t d f a <span class=ot>-&gt;</span> <span class=dt>String</span>
<span class=ot>  moduleName ::</span> t d f a <span class=ot>-&gt;</span> <span class=dt>String</span>

<span class=kw>class</span> <span class=dt>Constructor</span> c <span class=kw>where</span>
<span class=ot>  conName ::</span> t c f a <span class=ot>-&gt;</span> <span class=dt>String</span></code></pre></div>
<p><a href=https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html>GHC.Generics</a><font> defines a set of named types for modeling the various structural properties of types in available in Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Generics 定义了一组命名类型，用于对 Haskell 中可用类型的各种结构属性进行建模。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Sums: encode choice between constructors</span>
<span class=kw>infixr</span> <span class=dv>5</span> <span class=fu>:+:</span>
<span class=kw>data</span> (<span class=fu>:+:</span>) f g p <span class=fu>=</span> <span class=dt>L1</span> (f p) <span class=fu>|</span> <span class=dt>R1</span> (g p)

<span class=co>-- | Products: encode multiple arguments to constructors</span>
<span class=kw>infixr</span> <span class=dv>6</span> <span class=fu>:*:</span>
<span class=kw>data</span> (<span class=fu>:*:</span>) f g p <span class=fu>=</span> f p <span class=fu>:*:</span> g p

<span class=co>-- | Tag for M1: datatype</span>
<span class=kw>data</span> <span class=dt>D</span>
<span class=co>-- | Tag for M1: constructor</span>
<span class=kw>data</span> <span class=dt>C</span>

<span class=co>-- | Constants, additional parameters and recursion of kind *</span>
<span class=kw>newtype</span> <span class=dt>K1</span> i c p <span class=fu>=</span> <span class=dt>K1</span> {<span class=ot> unK1 ::</span> c }

<span class=co>-- | Meta-information (constructor names, etc.)</span>
<span class=kw>newtype</span> <span class=dt>M1</span> i c f p <span class=fu>=</span> <span class=dt>M1</span> {<span class=ot> unM1 ::</span> f p }

<span class=co>-- | Type synonym for encoding meta-information for datatypes</span>
<span class=kw>type</span> <span class=dt>D1</span> <span class=fu>=</span> <span class=dt>M1</span> <span class=dt>D</span>

<span class=co>-- | Type synonym for encoding meta-information for constructors</span>
<span class=kw>type</span> <span class=dt>C1</span> <span class=fu>=</span> <span class=dt>M1</span> <span class=dt>C</span></code></pre></div>
<p><font>Using the deriving mechanics GHC can generate this Generic instance for us mechanically, if we were to write it by hand for a simple type it might look like this:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用派生机制 GHC 可以机械地为我们生成这个 Generic 实例，如果我们要为一个简单类型手动编写它，它可能看起来像这样：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/generics.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>

<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=kw>data</span> <span class=dt>Animal</span>
  <span class=fu>=</span> <span class=dt>Dog</span>
  <span class=fu>|</span> <span class=dt>Cat</span>

<span class=kw>instance</span> <span class=dt>Generic</span> <span class=dt>Animal</span> <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Rep</span> <span class=dt>Animal</span> <span class=fu>=</span> <span class=dt>D1</span> <span class=dt>T_Animal</span> ((<span class=dt>C1</span> <span class=dt>C_Dog</span> <span class=dt>U1</span>) <span class=fu>:+:</span> (<span class=dt>C1</span> <span class=dt>C_Cat</span> <span class=dt>U1</span>))

  from <span class=dt>Dog</span> <span class=fu>=</span> <span class=dt>M1</span> (<span class=dt>L1</span> (<span class=dt>M1</span> <span class=dt>U1</span>))
  from <span class=dt>Cat</span> <span class=fu>=</span> <span class=dt>M1</span> (<span class=dt>R1</span> (<span class=dt>M1</span> <span class=dt>U1</span>))

  to (<span class=dt>M1</span> (<span class=dt>L1</span> (<span class=dt>M1</span> <span class=dt>U1</span>))) <span class=fu>=</span> <span class=dt>Dog</span>
  to (<span class=dt>M1</span> (<span class=dt>R1</span> (<span class=dt>M1</span> <span class=dt>U1</span>))) <span class=fu>=</span> <span class=dt>Cat</span>

<span class=kw>data</span> <span class=dt>T_Animal</span>
<span class=kw>data</span> <span class=dt>C_Dog</span>
<span class=kw>data</span> <span class=dt>C_Cat</span>

<span class=kw>instance</span> <span class=dt>Datatype</span> <span class=dt>T_Animal</span> <span class=kw>where</span>
  datatypeName _ <span class=fu>=</span> <span class=st>"Animal"</span>
  moduleName _ <span class=fu>=</span> <span class=st>"Main"</span>

<span class=kw>instance</span> <span class=dt>Constructor</span> <span class=dt>C_Dog</span> <span class=kw>where</span>
  conName _ <span class=fu>=</span> <span class=st>"Dog"</span>

<span class=kw>instance</span> <span class=dt>Constructor</span> <span class=dt>C_Cat</span> <span class=kw>where</span>
  conName _ <span class=fu>=</span> <span class=st>"Cat"</span></code></pre></div>
<p><font>Use </font><code>kind!</code><font> in GHCi we can look at the type family </font><code>Rep</code><font> associated with a Generic instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>用实物！在 GHCi 中，我们可以查看与通用实例关联的类型族 Rep。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>:</span>kind<span class=fu>!</span> <span class=dt>Rep</span> <span class=dt>Animal</span>
<span class=dt>Rep</span> <span class=dt>Animal</span><span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=fu>=</span> <span class=dt>M1</span> <span class=dt>D</span> <span class=dt>T_Animal</span> (<span class=dt>M1</span> <span class=dt>C</span> <span class=dt>C_Dog</span> <span class=dt>U1</span> <span class=fu>:+:</span> <span class=dt>M1</span> <span class=dt>C</span> <span class=dt>C_Cat</span> <span class=dt>U1</span>)

λ<span class=fu>:</span> <span class=fu>:</span>kind<span class=fu>!</span> <span class=dt>Rep</span> ()
<span class=dt>Rep</span><span class=ot> () ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=fu>=</span> <span class=dt>M1</span> <span class=dt>D</span> <span class=dt>GHC.Generics.D1</span>() (<span class=dt>M1</span> <span class=dt>C</span> <span class=dt>GHC.Generics.C1_0</span>() <span class=dt>U1</span>)

λ<span class=fu>:</span> <span class=fu>:</span>kind<span class=fu>!</span> <span class=dt>Rep</span> [()]
<span class=dt>Rep</span> [()]<span class=ot> ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=fu>=</span> <span class=dt>M1</span>
    <span class=dt>D</span>
    <span class=dt>GHC.Generics.D1</span>[]
    (<span class=dt>M1</span> <span class=dt>C</span> <span class=dt>GHC.Generics.C1_0</span>[] <span class=dt>U1</span>
     <span class=fu>:+:</span> <span class=dt>M1</span>
           <span class=dt>C</span>
           <span class=dt>GHC.Generics.C1_1</span>[]
           (<span class=dt>M1</span> <span class=dt>S</span> <span class=dt>NoSelector</span> (<span class=dt>K1</span> <span class=dt>R</span> ()) <span class=fu>:*:</span> <span class=dt>M1</span> <span class=dt>S</span> <span class=dt>NoSelector</span> (<span class=dt>K1</span> <span class=dt>R</span> [()])))</code></pre></div>
<p><font>Now the clever bit, instead writing our generic function over the datatype we instead write it over the Rep and then reify the result using </font><code>from</code><font>. So for an equivalent version of Haskell's default </font><code>Eq</code><font> that instead uses generic deriving we could write:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在聪明的一点是，我们将泛型函数写在数据类型上，而不是写在 Rep 上，然后使用 from 来具体化结果。因此，对于 Haskell 的默认 Eq 的等效版本，我们可以这样写：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>GEq'</span> f <span class=kw>where</span>
<span class=ot>  geq' ::</span> f a <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> <span class=dt>Bool</span>

<span class=kw>instance</span> <span class=dt>GEq'</span> <span class=dt>U1</span> <span class=kw>where</span>
  geq' _ _ <span class=fu>=</span> <span class=dt>True</span>

<span class=kw>instance</span> (<span class=dt>GEq</span> c) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (<span class=dt>K1</span> i c) <span class=kw>where</span>
  geq' (<span class=dt>K1</span> a) (<span class=dt>K1</span> b) <span class=fu>=</span> geq a b

<span class=kw>instance</span> (<span class=dt>GEq'</span> a) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (<span class=dt>M1</span> i c a) <span class=kw>where</span>
  geq' (<span class=dt>M1</span> a) (<span class=dt>M1</span> b) <span class=fu>=</span> geq' a b

<span class=co>-- Equality for sums.</span>
<span class=kw>instance</span> (<span class=dt>GEq'</span> a, <span class=dt>GEq'</span> b) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (a <span class=fu>:+:</span> b) <span class=kw>where</span>
  geq' (<span class=dt>L1</span> a) (<span class=dt>L1</span> b) <span class=fu>=</span> geq' a b
  geq' (<span class=dt>R1</span> a) (<span class=dt>R1</span> b) <span class=fu>=</span> geq' a b
  geq' _      _      <span class=fu>=</span> <span class=dt>False</span>

<span class=co>-- Equality for products.</span>
<span class=kw>instance</span> (<span class=dt>GEq'</span> a, <span class=dt>GEq'</span> b) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (a <span class=fu>:*:</span> b) <span class=kw>where</span>
  geq' (a1 <span class=fu>:*:</span> b1) (a2 <span class=fu>:*:</span> b2) <span class=fu>=</span> geq' a1 a2 <span class=fu>&amp;&amp;</span> geq' b1 b2</code></pre></div>
<p><font>To accommodate the two methods of writing classes (generic-deriving or custom implementations) we can use the </font><code>DefaultSignatures</code><font> extension to allow the user to leave typeclass functions blank and defer to Generic or to define their own.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了适应编写类的两种方法（泛型派生或自定义实现），我们可以使用 DefaultSignatures 扩展来允许用户将类型类函数留空并遵从泛型或定义它们自己的函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DefaultSignatures #-}</span>

<span class=kw>class</span> <span class=dt>GEq</span> a <span class=kw>where</span>
<span class=ot>  geq ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>

  default<span class=ot> geq ::</span> (<span class=dt>Generic</span> a, <span class=dt>GEq'</span> (<span class=dt>Rep</span> a)) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
  geq x y <span class=fu>=</span> geq' (from x) (from y)</code></pre></div>
<p><font>Now anyone using our library need only derive Generic and create an empty instance of our typeclass instance without writing any boilerplate for </font><code>GEq</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在任何使用我们库的人只需要派生 Generic 并创建我们类型类实例的空实例，而无需为 GEq 编写任何样板。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Here is a complete example for deriving equality generics:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>下面是派生等式泛型的完整示例：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/generic_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE DefaultSignatures #-}</span>

<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=co>-- Auxiliary class</span>
<span class=kw>class</span> <span class=dt>GEq'</span> f <span class=kw>where</span>
<span class=ot>  geq' ::</span> f a <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> <span class=dt>Bool</span>

<span class=kw>instance</span> <span class=dt>GEq'</span> <span class=dt>U1</span> <span class=kw>where</span>
  geq' _ _ <span class=fu>=</span> <span class=dt>True</span>

<span class=kw>instance</span> (<span class=dt>GEq</span> c) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (<span class=dt>K1</span> i c) <span class=kw>where</span>
  geq' (<span class=dt>K1</span> a) (<span class=dt>K1</span> b) <span class=fu>=</span> geq a b

<span class=kw>instance</span> (<span class=dt>GEq'</span> a) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (<span class=dt>M1</span> i c a) <span class=kw>where</span>
  geq' (<span class=dt>M1</span> a) (<span class=dt>M1</span> b) <span class=fu>=</span> geq' a b

<span class=kw>instance</span> (<span class=dt>GEq'</span> a, <span class=dt>GEq'</span> b) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (a <span class=fu>:+:</span> b) <span class=kw>where</span>
  geq' (<span class=dt>L1</span> a) (<span class=dt>L1</span> b) <span class=fu>=</span> geq' a b
  geq' (<span class=dt>R1</span> a) (<span class=dt>R1</span> b) <span class=fu>=</span> geq' a b
  geq' _      _      <span class=fu>=</span> <span class=dt>False</span>

<span class=kw>instance</span> (<span class=dt>GEq'</span> a, <span class=dt>GEq'</span> b) <span class=ot>=&gt;</span> <span class=dt>GEq'</span> (a <span class=fu>:*:</span> b) <span class=kw>where</span>
  geq' (a1 <span class=fu>:*:</span> b1) (a2 <span class=fu>:*:</span> b2) <span class=fu>=</span> geq' a1 a2 <span class=fu>&amp;&amp;</span> geq' b1 b2

<span class=fu>--</span>
<span class=kw>class</span> <span class=dt>GEq</span> a <span class=kw>where</span>
<span class=ot>  geq ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
  default<span class=ot> geq ::</span> (<span class=dt>Generic</span> a, <span class=dt>GEq'</span> (<span class=dt>Rep</span> a)) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span>
  geq x y <span class=fu>=</span> geq' (from x) (from y)

<span class=co>-- Base equalities</span>
<span class=kw>instance</span> <span class=dt>GEq</span> <span class=dt>Char</span> <span class=kw>where</span> geq <span class=fu>=</span> (<span class=fu>==</span>)
<span class=kw>instance</span> <span class=dt>GEq</span> <span class=dt>Int</span> <span class=kw>where</span> geq <span class=fu>=</span> (<span class=fu>==</span>)
<span class=kw>instance</span> <span class=dt>GEq</span> <span class=dt>Float</span> <span class=kw>where</span> geq <span class=fu>=</span> (<span class=fu>==</span>)

<span class=co>-- Equalities derived from structure of (:+:) and (:*:)</span>
<span class=kw>instance</span> <span class=dt>GEq</span> a <span class=ot>=&gt;</span> <span class=dt>GEq</span> (<span class=dt>Maybe</span> a)
<span class=kw>instance</span> (<span class=dt>GEq</span> a, <span class=dt>GEq</span> b) <span class=ot>=&gt;</span> <span class=dt>GEq</span> (a,b)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> geq <span class=dv>2</span> (<span class=dv>3</span><span class=ot> ::</span> <span class=dt>Int</span>)
  print <span class=fu>$</span> geq <span class=ch>'a'</span> <span class=ch>'b'</span>
  print <span class=fu>$</span> geq (<span class=dt>Just</span> <span class=ch>'a'</span>) (<span class=dt>Just</span> <span class=ch>'a'</span>)
  print <span class=fu>$</span> geq (<span class=ch>'a'</span>,<span class=ch>'b'</span>) (<span class=ch>'a'</span>, <span class=ch>'b'</span>)</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://smunix.github.io/www.stephendiehl.com/posts/generics.html>Cooking Classes with Datatype Generic Programming<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>使用数据类型泛型编程的烹饪类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://www.andres-loeh.de/DGP-Intro.pdf>Datatype-generic Programming in Haskell<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Haskell 中的数据类型泛型编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://hackage.haskell.org/package/generic-deriving-1.6.3>generic-deriving<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=generic-deriving><font>Generic Deriving</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用派生</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using Generics many common libraries provide a mechanisms to derive common typeclass instances. Some real world examples:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用泛型，许多公共库提供了一种机制来派生公共类型类实例。一些现实世界的例子：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><a href=http://hackage.haskell.org/package/hashable>hashable</a><font> library allows us to derive hashing functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>hashable 库允许我们导出哈希函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/hashable.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>

<span class=kw>import </span><span class=dt>GHC.Generics</span> (<span class=dt>Generic</span>)
<span class=kw>import </span><span class=dt>Data.Hashable</span>

<span class=kw>data</span> <span class=dt>Color</span> <span class=fu>=</span> <span class=dt>Red</span> <span class=fu>|</span> <span class=dt>Green</span> <span class=fu>|</span> <span class=dt>Blue</span> <span class=kw>deriving</span> (<span class=dt>Generic</span>, <span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Hashable</span> <span class=dt>Color</span> <span class=kw>where</span>

<span class=ot>example1 ::</span> <span class=dt>Int</span>
example1 <span class=fu>=</span> hash <span class=dt>Red</span>
<span class=co>-- 839657738087498284</span>

<span class=ot>example2 ::</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> hashWithSalt <span class=bn>0xDEADBEEF</span> <span class=dt>Red</span>
<span class=co>-- 62679985974121021</span></code></pre></div>
<p><font>The </font><a href=http://hackage.haskell.org/package/cereal-0.4.0.1>cereal</a><font> library allows us to automatically derive a binary representation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>谷物库允许我们自动导出二进制表示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/cereal.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>

<span class=kw>import </span><span class=dt>Data.Word</span>
<span class=kw>import </span><span class=dt>Data.ByteString</span>
<span class=kw>import </span><span class=dt>Data.Serialize</span>

<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=kw>data</span> <span class=dt>Val</span> <span class=fu>=</span> <span class=dt>A</span> [<span class=dt>Val</span>] <span class=fu>|</span> <span class=dt>B</span> [(<span class=dt>Val</span>, <span class=dt>Val</span>)] <span class=fu>|</span> <span class=dt>C</span>
  <span class=kw>deriving</span> (<span class=dt>Generic</span>, <span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Serialize</span> <span class=dt>Val</span> <span class=kw>where</span>

<span class=ot>encoded ::</span> <span class=dt>ByteString</span>
encoded <span class=fu>=</span> encode (<span class=dt>A</span> [<span class=dt>B</span> [(<span class=dt>C</span>, <span class=dt>C</span>)]])
<span class=co>-- "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\STX\STX"</span>

<span class=ot>bytes ::</span> [<span class=dt>Word8</span>]
bytes <span class=fu>=</span> unpack encoded
<span class=co>-- [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,2,2]</span>

<span class=ot>decoded ::</span> <span class=dt>Either</span> <span class=dt>String</span> <span class=dt>Val</span>
decoded <span class=fu>=</span> decode encoded</code></pre></div>
<p><font>The </font><a href=http://hackage.haskell.org/package/aeson>aeson</a><font> library allows us to derive JSON representations for JSON instances.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>aeson 库允许我们为 JSON 实例派生 JSON 表示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/derive_aeson.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.Aeson</span>
<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=kw>data</span> <span class=dt>Point</span> <span class=fu>=</span> <span class=dt>Point</span> { _<span class=ot>x ::</span> <span class=dt>Double</span>, _<span class=ot>y ::</span> <span class=dt>Double</span> }
   <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Generic</span>)

<span class=kw>instance</span> <span class=dt>FromJSON</span> <span class=dt>Point</span>
<span class=kw>instance</span> <span class=dt>ToJSON</span> <span class=dt>Point</span>

<span class=ot>example1 ::</span> <span class=dt>Maybe</span> <span class=dt>Point</span>
example1 <span class=fu>=</span> decode <span class=st>"{\"x\":3.0,\"y\":-1.0}"</span>

example2 <span class=fu>=</span> encode <span class=fu>$</span> <span class=dt>Point</span> <span class=fl>123.4</span> <span class=dv>20</span></code></pre></div>
<p><font>See: </font><a href=http://dreixel.net/research/pdf/gdmh.pdf>A Generic Deriving Mechanism for Haskell</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Haskell 的通用派生机制</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h5 id=higher-kinded-generics><font>Higher Kinded Generics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>高级泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h5>
<p><font>Using the same interface GHC.Generics provides a separate typeclass for higher-kinded generics.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用相同的接口 GHC.Generics 为更高种类的泛型提供了一个单独的类型类。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Generic1</span> f <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>Rep1</span><span class=ot> f ::</span> <span class=fu>*</span> <span class=ot>-&gt;</span> <span class=fu>*</span>
<span class=ot>  from1  ::</span> f a <span class=ot>-&gt;</span> (<span class=dt>Rep1</span> f) a
<span class=ot>  to1    ::</span> (<span class=dt>Rep1</span> f) a <span class=ot>-&gt;</span> f a</code></pre></div>
<p><font>So for instance </font><code>Maybe</code><font> has </font><code>Rep1</code><font> of the form:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，例如 Maybe 具有以下形式的 Rep1：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=kw>instance</span> <span class=dt>Rep1</span> <span class=dt>Maybe</span>
  <span class=fu>=</span> <span class=dt>D1</span>
      <span class=dt>GHC.Generics.D1Maybe</span>
      (<span class=dt>C1</span> <span class=dt>C1_0Maybe</span> <span class=dt>U1</span>
       <span class=fu>:+:</span> <span class=dt>C1</span> <span class=dt>C1_1Maybe</span> (<span class=dt>S1</span> <span class=dt>NoSelector</span> <span class=dt>Par1</span>))</code></pre></div>
<h2 id=generics-sop><font>generics-sop</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>仿制药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=uniplate><font>Uniplate</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单板</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Uniplate is a generics library for writing traversals and transformation for arbitrary data structures. It is extremely useful for writing AST transformations and rewriting systems.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Uniplate 是一个泛型库，用于为任意数据结构编写遍历和转换。它对于编写 AST 转换和重写系统非常有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>plate ::</span> from <span class=ot>-&gt;</span> <span class=dt>Type</span> from to
<span class=ot>(|*)  ::</span> <span class=dt>Type</span> (to <span class=ot>-&gt;</span> from) to <span class=ot>-&gt;</span> to <span class=ot>-&gt;</span> <span class=dt>Type</span> from to
<span class=ot>(|-)  ::</span> <span class=dt>Type</span> (item <span class=ot>-&gt;</span> from) to <span class=ot>-&gt;</span> item <span class=ot>-&gt;</span> <span class=dt>Type</span> from to

<span class=ot>descend   ::</span> <span class=dt>Uniplate</span> on <span class=ot>=&gt;</span> (on <span class=ot>-&gt;</span> on) <span class=ot>-&gt;</span> on <span class=ot>-&gt;</span> on
<span class=ot>transform ::</span> <span class=dt>Uniplate</span> on <span class=ot>=&gt;</span> (on <span class=ot>-&gt;</span> on) <span class=ot>-&gt;</span> on <span class=ot>-&gt;</span> on
<span class=ot>rewrite   ::</span> <span class=dt>Uniplate</span> on <span class=ot>=&gt;</span> (on <span class=ot>-&gt;</span> <span class=dt>Maybe</span> on) <span class=ot>-&gt;</span> on <span class=ot>-&gt;</span> on</code></pre></div>
<p><font>The </font><code>descend</code><font> function will apply a function to each immediate descendant of an expression and then combines them up into the parent expression.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>descend 函数将一个函数应用于表达式的每个直接后代，然后将它们组合到父表达式中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><code>transform</code><font> function will perform a single pass bottom-up transformation of all terms in the expression.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>transform 函数将对表达式中的所有项执行单次自下而上的转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><code>rewrite</code><font> function will perform an exhaustive transformation of all terms in the expression to fixed point, using Maybe to signify termination.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重写函数将表达式中的所有项彻底转换为定点，使用 Maybe 表示终止。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/18-generics/uniplate.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Generics.Uniplate.Direct</span>

<span class=kw>data</span> <span class=dt>Expr</span> a
  <span class=fu>=</span> <span class=dt>Fls</span>
  <span class=fu>|</span> <span class=dt>Tru</span>
  <span class=fu>|</span> <span class=dt>Var</span> a
  <span class=fu>|</span> <span class=dt>Not</span> (<span class=dt>Expr</span> a)
  <span class=fu>|</span> <span class=dt>And</span> (<span class=dt>Expr</span> a) (<span class=dt>Expr</span> a)
  <span class=fu>|</span> <span class=dt>Or</span>  (<span class=dt>Expr</span> a) (<span class=dt>Expr</span> a)
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Eq</span>)

<span class=kw>instance</span> <span class=dt>Uniplate</span> (<span class=dt>Expr</span> a) <span class=kw>where</span>
  uniplate (<span class=dt>Not</span> f)     <span class=fu>=</span> plate <span class=dt>Not</span> <span class=fu>|*</span> f
  uniplate (<span class=dt>And</span> f1 f2) <span class=fu>=</span> plate <span class=dt>And</span> <span class=fu>|*</span> f1 <span class=fu>|*</span> f2
  uniplate (<span class=dt>Or</span> f1 f2)  <span class=fu>=</span> plate <span class=dt>Or</span> <span class=fu>|*</span> f1 <span class=fu>|*</span> f2
  uniplate x           <span class=fu>=</span> plate x

<span class=ot>simplify ::</span> <span class=dt>Expr</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span> a
simplify <span class=fu>=</span> transform simp
 <span class=kw>where</span>
   simp (<span class=dt>Not</span> (<span class=dt>Not</span> f)) <span class=fu>=</span> f
   simp (<span class=dt>Not</span> <span class=dt>Fls</span>) <span class=fu>=</span> <span class=dt>Tru</span>
   simp (<span class=dt>Not</span> <span class=dt>Tru</span>) <span class=fu>=</span> <span class=dt>Fls</span>
   simp x <span class=fu>=</span> x

<span class=ot>reduce ::</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> <span class=dt>Expr</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span> a
reduce <span class=fu>=</span> rewrite cnf
  <span class=kw>where</span>
    <span class=co>-- double negation</span>
    cnf (<span class=dt>Not</span> (<span class=dt>Not</span> p)) <span class=fu>=</span> <span class=dt>Just</span> p

    <span class=co>-- de Morgan</span>
    cnf (<span class=dt>Not</span> (p <span class=ot>`Or`</span> q))  <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> (<span class=dt>Not</span> p) <span class=ot>`And`</span> (<span class=dt>Not</span> q)
    cnf (<span class=dt>Not</span> (p <span class=ot>`And`</span> q)) <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> (<span class=dt>Not</span> p) <span class=ot>`Or`</span> (<span class=dt>Not</span> q)

    <span class=co>-- distribute conjunctions</span>
    cnf (p <span class=ot>`Or`</span> (q <span class=ot>`And`</span> r)) <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> (p <span class=ot>`Or`</span> q) <span class=ot>`And`</span> (p <span class=ot>`Or`</span> r)
    cnf ((p <span class=ot>`And`</span> q) <span class=ot>`Or`</span> r) <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> (p <span class=ot>`Or`</span> q) <span class=ot>`And`</span> (p <span class=ot>`Or`</span> r)
    cnf _ <span class=fu>=</span> <span class=dt>Nothing</span>


<span class=ot>example1 ::</span> <span class=dt>Expr</span> <span class=dt>String</span>
example1 <span class=fu>=</span> simplify (<span class=dt>Not</span> (<span class=dt>Not</span> (<span class=dt>Not</span> (<span class=dt>Not</span> (<span class=dt>Var</span> <span class=st>"a"</span>)))))
<span class=co>-- Var "a"</span>

<span class=ot>example2 ::</span> [<span class=dt>String</span>]
example2 <span class=fu>=</span> [a <span class=fu>|</span> <span class=dt>Var</span> a <span class=ot>&lt;-</span> universe ex]
  <span class=kw>where</span>
    ex <span class=fu>=</span> <span class=dt>Or</span> (<span class=dt>And</span> (<span class=dt>Var</span> <span class=st>"a"</span>) (<span class=dt>Var</span> <span class=st>"b"</span>)) (<span class=dt>Not</span> (<span class=dt>And</span> (<span class=dt>Var</span> <span class=st>"c"</span>) (<span class=dt>Var</span> <span class=st>"d"</span>)))
<span class=co>-- ["a","b","c","d"]</span>

<span class=ot>example3 ::</span> <span class=dt>Expr</span> <span class=dt>String</span>
example3 <span class=fu>=</span> reduce <span class=fu>$</span> ((a <span class=ot>`And`</span> b) <span class=ot>`Or`</span> (c <span class=ot>`And`</span> d)) <span class=ot>`Or`</span> e
  <span class=kw>where</span>
    a <span class=fu>=</span> <span class=dt>Var</span> <span class=st>"a"</span>
    b <span class=fu>=</span> <span class=dt>Var</span> <span class=st>"b"</span>
    c <span class=fu>=</span> <span class=dt>Var</span> <span class=st>"c"</span>
    d <span class=fu>=</span> <span class=dt>Var</span> <span class=st>"d"</span>
    e <span class=fu>=</span> <span class=dt>Var</span> <span class=st>"e"</span></code></pre></div>
<p><font>Alternatively Uniplate instances can be derived automatically from instances of Data without the need to explicitly write a Uniplate instance. This approach carries a slight amount of overhead over an explicit hand-written instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者，Uniplate 实例可以从 Data 实例自动派生，而无需显式编写 Uniplate 实例。与显式手写实例相比，此方法会带来少量开销。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Data</span>
<span class=kw>import </span><span class=dt>Data.Typeable</span>
<span class=kw>import </span><span class=dt>Data.Generics.Uniplate.Data</span>

<span class=kw>data</span> <span class=dt>Expr</span> a
  <span class=fu>=</span> <span class=dt>Fls</span>
  <span class=fu>|</span> <span class=dt>Tru</span>
  <span class=fu>|</span> <span class=dt>Lit</span> a
  <span class=fu>|</span> <span class=dt>Not</span> (<span class=dt>Expr</span> a)
  <span class=fu>|</span> <span class=dt>And</span> (<span class=dt>Expr</span> a) (<span class=dt>Expr</span> a)
  <span class=fu>|</span> <span class=dt>Or</span> (<span class=dt>Expr</span> a) (<span class=dt>Expr</span> a)
  <span class=kw>deriving</span> (<span class=dt>Data</span>, <span class=dt>Typeable</span>, <span class=dt>Show</span>, <span class=dt>Eq</span>)</code></pre></div>
<p><strong>Biplate<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双板</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>Biplates generalize plates where the target type isn't necessarily the same as the source, it uses multiparameter typeclasses to indicate the type sub of the sub-target. The Uniplate functions all have an equivalent generalized biplate form.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Biplates 泛化目标类型不一定与源相同的板，它使用多参数类型类来指示子目标的类型 sub。 Uniplate 函数都具有等效的广义双板形式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>descendBi   ::</span> <span class=dt>Biplate</span> from to <span class=ot>=&gt;</span> (to <span class=ot>-&gt;</span> to) <span class=ot>-&gt;</span> from <span class=ot>-&gt;</span> from
<span class=ot>transformBi ::</span> <span class=dt>Biplate</span> from to <span class=ot>=&gt;</span> (to <span class=ot>-&gt;</span> to) <span class=ot>-&gt;</span> from <span class=ot>-&gt;</span> from
<span class=ot>rewriteBi   ::</span> <span class=dt>Biplate</span> from to <span class=ot>=&gt;</span> (to <span class=ot>-&gt;</span> <span class=dt>Maybe</span> to) <span class=ot>-&gt;</span> from <span class=ot>-&gt;</span> from

<span class=ot>descendBiM   ::</span> (<span class=dt>Monad</span> m, <span class=dt>Biplate</span> from to) <span class=ot>=&gt;</span> (to <span class=ot>-&gt;</span> m to) <span class=ot>-&gt;</span> from <span class=ot>-&gt;</span> m from
<span class=ot>transformBiM ::</span> (<span class=dt>Monad</span> m, <span class=dt>Biplate</span> from to) <span class=ot>=&gt;</span> (to <span class=ot>-&gt;</span> m to) <span class=ot>-&gt;</span> from <span class=ot>-&gt;</span> m from
<span class=ot>rewriteBiM   ::</span> (<span class=dt>Monad</span> m, <span class=dt>Biplate</span> from to) <span class=ot>=&gt;</span> (to <span class=ot>-&gt;</span> m (<span class=dt>Maybe</span> to)) <span class=ot>-&gt;</span> from <span class=ot>-&gt;</span> m from</code></pre></div>
<div class=sourceCode include=src/18-generics/biplate.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>

<span class=kw>import </span><span class=dt>Data.Generics.Uniplate.Direct</span>

<span class=kw>type</span> <span class=dt>Name</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>Name</span>
  <span class=fu>|</span> <span class=dt>Lam</span> <span class=dt>Name</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>data</span> <span class=dt>Stmt</span>
  <span class=fu>=</span> <span class=dt>Decl</span> [<span class=dt>Stmt</span>]
  <span class=fu>|</span> <span class=dt>Let</span> <span class=dt>Name</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>instance</span> <span class=dt>Uniplate</span> <span class=dt>Expr</span> <span class=kw>where</span>
  uniplate (<span class=dt>Var</span> x  ) <span class=fu>=</span> plate <span class=dt>Var</span> <span class=fu>|-</span> x
  uniplate (<span class=dt>App</span> x y) <span class=fu>=</span> plate <span class=dt>App</span> <span class=fu>|*</span> x <span class=fu>|*</span> y
  uniplate (<span class=dt>Lam</span> x y) <span class=fu>=</span> plate <span class=dt>Lam</span> <span class=fu>|-</span> x <span class=fu>|*</span> y

<span class=kw>instance</span> <span class=dt>Biplate</span> <span class=dt>Expr</span> <span class=dt>Expr</span> <span class=kw>where</span>
  biplate <span class=fu>=</span> plateSelf

<span class=kw>instance</span> <span class=dt>Uniplate</span> <span class=dt>Stmt</span> <span class=kw>where</span>
  uniplate (<span class=dt>Decl</span> x  ) <span class=fu>=</span> plate <span class=dt>Decl</span> <span class=fu>||*</span> x
  uniplate (<span class=dt>Let</span> x y) <span class=fu>=</span> plate <span class=dt>Let</span> <span class=fu>|-</span>  x <span class=fu>|-</span> y

<span class=kw>instance</span> <span class=dt>Biplate</span> <span class=dt>Stmt</span> <span class=dt>Stmt</span> <span class=kw>where</span>
  biplate <span class=fu>=</span> plateSelf

<span class=kw>instance</span> <span class=dt>Biplate</span> <span class=dt>Stmt</span> <span class=dt>Expr</span> <span class=kw>where</span>
  biplate (<span class=dt>Decl</span> x) <span class=fu>=</span> plate <span class=dt>Decl</span> <span class=fu>||+</span> x
  biplate (<span class=dt>Let</span> x y) <span class=fu>=</span> plate <span class=dt>Let</span> <span class=fu>|-</span> x <span class=fu>|*</span> y

<span class=ot>rename ::</span> <span class=dt>Name</span> <span class=ot>-&gt;</span> <span class=dt>Name</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
rename from to <span class=fu>=</span> rewrite f
  <span class=kw>where</span>
    f (<span class=dt>Var</span> a) <span class=fu>|</span> a <span class=fu>==</span> from <span class=fu>=</span> <span class=dt>Just</span> (<span class=dt>Var</span> to)
    f (<span class=dt>Lam</span> a b) <span class=fu>|</span> a <span class=fu>==</span> from <span class=fu>=</span> <span class=dt>Just</span> (<span class=dt>Lam</span> to b)
    f _ <span class=fu>=</span> <span class=dt>Nothing</span>

s, k,<span class=ot> sk ::</span> <span class=dt>Expr</span>
s <span class=fu>=</span> <span class=dt>Lam</span> <span class=st>"x"</span> (<span class=dt>Lam</span> <span class=st>"y"</span> (<span class=dt>Lam</span> <span class=st>"z"</span> (<span class=dt>App</span> (<span class=dt>App</span> (<span class=dt>Var</span> <span class=st>"x"</span>) (<span class=dt>Var</span> <span class=st>"z"</span>)) (<span class=dt>App</span> (<span class=dt>Var</span> <span class=st>"y"</span>) (<span class=dt>Var</span> <span class=st>"z"</span>)))))
k <span class=fu>=</span> <span class=dt>Lam</span> <span class=st>"x"</span> (<span class=dt>Lam</span> <span class=st>"y"</span> (<span class=dt>Var</span> <span class=st>"x"</span>))
sk <span class=fu>=</span> <span class=dt>App</span> s k

<span class=ot>m ::</span> <span class=dt>Stmt</span>
m <span class=fu>=</span> descendBi f <span class=fu>$</span> <span class=dt>Decl</span> [ (<span class=dt>Let</span> <span class=st>"s"</span> s) , <span class=dt>Let</span> <span class=st>"k"</span> k , <span class=dt>Let</span> <span class=st>"sk"</span> sk ]
  <span class=kw>where</span>
    f <span class=fu>=</span> rename <span class=st>"x"</span> <span class=st>"a"</span>
      <span class=fu>.</span> rename <span class=st>"y"</span> <span class=st>"b"</span>
      <span class=fu>.</span> rename <span class=st>"z"</span> <span class=st>"c"</span></code></pre></div>
<h1 id=mathematics><font>Mathematics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数学</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=numeric-tower><font>Numeric Tower</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数字塔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell's numeric tower is unusual and the source of some confusion for novices. Haskell is one of the few languages to incorporate statically typed overloaded literals without a mechanism for "coercions" often found in other languages.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 的数字塔很不寻常，是新手困惑的根源。 Haskell 是为数不多的包含静态类型重载文字而没有其他语言中常见的“强制”机制的语言之一。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To add to the confusion numerical literals in Haskell are desugared into a function from a numeric typeclass which yields a polymorphic value that can be instantiated to any instance of the </font><code>Num</code><font> or </font><code>Fractional</code><font> typeclass at the call-site, depending on the inferred type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>更令人困惑的是，Haskell 中的数字文字被脱糖成一个来自数字类型类的函数，该函数产生一个多态值，该值可以在调用站点实例化为 Num 或 Fractional 类型类的任何实例，具体取决于推断的类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To use a blunt metaphor, we're effectively placing an object in a hole and the size and shape of the hole defines the object you place there. This is very different than in other languages where a numeric literal like </font><code>2.718</code><font> is hard coded in the compiler to be a specific type ( double or something ) and you cast the value at runtime to be something smaller or larger as needed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>打个直白的比喻，我们实际上是在一个洞里放了一个物体，洞的大小和形状决定了你放在那里的物体。这与其他语言非常不同，在其他语言中，像 2.718 这样的数字文字在编译器中被硬编码为特定类型（double 或其他），并且您可以在运行时根据需要将值转换为更小或更大的值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dv>42</span><span class=ot> ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a
fromInteger (<span class=dv>42</span><span class=ot> ::</span> <span class=dt>Integer</span>)

<span class=fl>2.71</span><span class=ot> ::</span> <span class=dt>Fractional</span> a <span class=ot>=&gt;</span> a
fromRational (<span class=fl>2.71</span><span class=ot> ::</span> <span class=dt>Rational</span>)</code></pre></div>
<p><font>The numeric typeclass hierarchy is defined as such:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数字类型类层次结构定义如下：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Num</span> a
<span class=kw>class</span> (<span class=dt>Num</span> a, <span class=dt>Ord</span> a) <span class=ot>=&gt;</span> <span class=dt>Real</span> a
<span class=kw>class</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>Fractional</span> a
<span class=kw>class</span> (<span class=dt>Real</span> a, <span class=dt>Enum</span> a) <span class=ot>=&gt;</span> <span class=dt>Integral</span> a
<span class=kw>class</span> (<span class=dt>Real</span> a, <span class=dt>Fractional</span> a) <span class=ot>=&gt;</span> <span class=dt>RealFrac</span> a
<span class=kw>class</span> <span class=dt>Fractional</span> a <span class=ot>=&gt;</span> <span class=dt>Floating</span> a
<span class=kw>class</span> (<span class=dt>RealFrac</span> a, <span class=dt>Floating</span> a) <span class=ot>=&gt;</span> <span class=dt>RealFloat</span> a</code></pre></div>
<div class=figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAFbCAIAAAB08k/sAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOydd1wUx/vHZ68BR0d6P3qRKlWKCCgIKNgxii0q0WgwiVGjJppoEo09GjXRRBR7L4gaQKUXaUrvvdxR5CgHXP39sd9c+KEiXNs73Pcfvrw9duaze7ufnZmdeR6Iw+EAFBQUFEkAg7QAFBQUlLGCGhYKCorEgBoWCgqKxIBDWgCKuDAwMNDQ0NDa2spkMqlUKpvNBgBgMBhFRUUcDqelpaWvry8jI4O0TEmir6+vsbGRTCYzmcy+vj4Gg8HhcCAIkpWVJRAIRCJRT09PQ0ODQCAgrVRiQA3rI4VCoeTk5BQVFRUWFhYXFzc0NHR2dn5wL1VVVT09vcn/4uzsrKamJgK14s/g4OCrV6+Ki4vLyspKS0urqqqampr6+vrGsq+GhoaOjo6FhYWVlZWFhYWNjY2ZmZmwBUsoEPqW8OOhp6fn8ePHz58/T05OLi0txWKxhoaGZmZmlpaWhoaGBgYGurq6Ojo6bz/wh4aGmpubm5ub6+vr6+rqSktLy8vL6+vr2Wy2paWlt7e3j49PUFCQvLw8IseFFH19ffHx8cnJyZmZmXl5eXQ6XUVFxeRfdHV1tbW1dXR0NDU1paSk3t69p6enubm5paWlpaWlvr6+srKyqqqqpqZmaGhIVVXVzc3N1dV1xowZzs7OGAw6dPM/UMOa+DAYjNu3b8fExCQmJrJYLA8Pj2nTpnl7e7u5ucnKyvJcbH9/f0ZGRkpKSlJSUlpaGhaL9ff3j4iImDdvHh6PF6B+cYNMJl+9evXRo0fJycksFsvZ2Xnq1KlTp051c3PT0dHhs3AWi1VUVJSRkQGf29raWjU1tVmzZoWGhs6ePXtin9gxwUGZuNTU1Hz77beampoEAiE0NPTChQudnZ3CqKizszM6OnrOnDl4PF5LS2vnzp21tbXCqAhBmEzmo0ePYDtWVFRcunTplStXhHQ+uZSUlBw8eHDatGkYDEZdXf2bb74pLS0Vao1iDmpYE5OqqqoVK1bgcDgSifTzzz+3tbWJpt7W1taffvrJ0NAQh8OtWrWqpqZGNPUKlZ6enmPHjhkZGWGx2ICAgMuXL9NoNBFrqK+v37dvn5mZGQRBM2fOfPLkCZvNFrEGcQA1rIkGmUz+9NNPcTiciYnJhQsXmEym6DUwGIzz588bGxvj8fi1a9e2t7eLXoNAGBoaOnLkiJKSkrS09GeffVZZWYmsHjab/ejRI29vbwCAo6PjixcvkNUjelDDmjiw2ezTp08rKyvr6elduHABfomOIHQ6/fz58zo6OioqKmfOnJG4FsHt27eNjY2JROKOHTtE1kQdIxkZGcHBwQCA2bNnI26jogQ1rAkChUIJCQnB4XDbtm3r6+tDWs5/9Pb2bt26FYfDzZkzR1KaWhQKZdGiRRAELV68uL6+Hmk57+XJkydWVlaysrLHjx9nsVhIyxEFqGFNBFJTUzU1NUkkUlpaGtJa3k1qaqqhoaG2tnZGRgbSWj7Aw4cP1dTUDAwMnj17hrSWD8NgMPbu3YvH4728vJqbm5GWI3RQw5J47t+/LyMjM2fOHCqVirSW0eju7g4ODiYSibGxsUhreTdsNnvv3r0YDGblypVifjJHkJeXZ2VlpaWlJbZPLEGBGpZkc+7cOSwWu2bNGsRHrMYCg8FYtWoVDoc7f/480lpGwmAwwsPDcTjcyZMnkdbCCz09PSEhIQQC4erVq0hrESKoYUkwt27dwmKx27ZtQ1rIOGCz2V9//TUWi7137x7SWv6DyWQuWbJEVlY2Pj4eaS28w2KxoqKicDjczZs3kdYiLFDDklTS09OlpaXXrFkjcW/f2Gz2ypUrZWRksrOzkdbyP1avXk0kEiVi0OqDREVF4fH4x48fIy1EKKCGJZG8efPG0NBwxowZiEyz4h8Gg+Hr62tsbCwOQ0W//fYbFoudMHc4/DxQUlKqqKhAWovgQQ1LIgkPD9fQ0BC3yUHjoqWlRV1dffny5cjKSEtLw+Pxv/76K7IyBMvAwICjo6O1tbXoZ+QLG9SwJI/k5GQAwP3795EWwklNTV2wYEFwcDBvu9+5cweDweTm5gpW1dih0+mTJ08OCQmRuG71B6mtrVVQUNi9ezfSQgQMaliSh6urq6+vLz8lMBiMP//809/f38/Pz9PT093d/fjx43Q6fVyFlJSUfPPNNwCAgIAAnpV4eXnxeSz8cPjwYRkZmfEueLxw4YKmpiYcO2Dr1q0jvl2+fLmysjIAQFlZOTIyUnBix83hw4elpaWrq6sR1CBwUMOSMDIyMgAAmZmZPJfQ1dXl5eX12Wef9fT0wFu6u7vXrFnj5ubW0dExrqJoNBqfhgW3Fl++fMlzCTwzODiorq6+fft2HvZlMpk7duyAPSsmJmbEtxUVFQCAsrIyQcjkHTqdbmJisn79emRlCBbUsCSMlStXTpkyhefd2Wz29OnTZ8+e/fZXgYGBPj4+41rhAYdR5sewOByOra3tmjVr+CmBNy5evIjH41taWnguATYsaWnpEc8PFosFABCHtTLHjx8nEoldXV1ICxEYqGFJEkwmU1FR8dixYzyXcPnyZQBAXl7e21/BbbdLly6Nq0D+DevAgQPKysqiv71nzpw5Z84cfkoAAGzevBkAoKWl1dTUNOIr/tQJhq6uLmlp6b///htpIQJDLE4ryhjJzc0FABQVFfFcQkBAgIaGxju/YrPZioqKM2fO5HA4fX19MTExAQEBwcHBT5480dLS8vPzg/+MSqWuX7/e0dHR3d199+7d/BvWq1evAAAFBQX8FDJeBgcHZWRkzp07x08hcDNqzpw5AAAnJ6fhr+Rgw7px44aWlhb3FL18+RIOSQp/rKmp+fHHH6dMmRIUFPT69eutW7eqqam5uLjU1tampqauW7cOjjXa29vLj0h/f/9PPvmEnxLECjRWtCSRmZmpqKhoaWnJcwm5ubnGxsbv/AqCIDMzM9gTe3t7iUTi06dP6+vrS0tLN2zYYGBgAABgMBiBgYG9vb3Z2dlpaWkUCoVnJVysra3l5eUzMzP5L2rs5OXlDQwMeHl58VkOBoO5cuWKo6NjTk7O6tWrR3y7cOHCgoIC7kcnJ6fhH0kkUkRERG5ublVVFY1GO3DgQHR0dHZ29sKFC3t7e//444/bt28/fvz4999/50ehl5dXWloaPyWIFWjWHEmioaHBxMSEn5QE3d3dRCLxfd8qKCj09PQAADQ1NUNDQwEAHA4nKioKgiD4D06dOpWfn3///n0sFgsA2LJly+nTp3kWA4PFYk1MTBoaGvgsZ1zU1tbi8XhTU1P+i5KVlY2NjXV1db127Zq1tfWuXbuGf6uurj78o6qq6vCPurq6AAASieTq6goAmD59OgBg0qRJgYGBAAAXFxcAwMuXL/mRZ21t3dDQwGQycbiJcLOjLSxJorOzc9KkSfyUoKSkBFvSOxkYGOCWD1uSrq4u160AANHR0SYmJtzUXkZGRvyI4aKqqtrR0SGQosZIR0eHqqrq8EPjBy0trdjYWHl5+e+///7evXtj33GEiYxI+wjn2unv7+dHm7q6OofDEfHpFR6oYUkSNBptlPbRWHB0dIRft7/z27q6Omdn51F2Ly0t5dMx3wmRSOTzthwv/f39/GQMehtbW9vr169jMJiIiIjXr18LsOT3/VhjBD5MEZ9e4YEaliShrKzc1dXFTwmffPJJT08PPPtpBKWlpS0tLStXrhxldwKB0NzczI+Ad8J/y3G8TJo0SeCNjlmzZp04caKvrw8ehhcT2tvbwVtdUckFNSxJgv/bbOnSpS4uLvCKjRFfff/99wEBAXPnzh1l96lTp1ZXV5eUlAzfCM/G4of29nYRG5aqqiqVSh0aGuK5BPioRxz7+vXrv/rqq/r6+uEbiUQilUqF/w9PtWUymTzXO17IZDKBQFBQUBBZjUIFNSxJwtbWtry8vLe3l+cScDjcvXv3uru7V65c2d3dDW/s6upatWoVmUy+du0ad1gHvqlGDHjt2bMHh8OtXbsWbuilp6cDAOrr6wcHB3nuuVCp1MrKSltbW54Pigfs7e05HE52djbPJVRVVQEAamtrR2w/ePBgWFjY8C02NjY5OTm3b9+Oi4vbt28fAKCsrCw9PZ1Opw8MDAAAGAwG/JfwOefaGTwBlU6n8ywSAJCVlWVnZyeo0TrkQW5GBcq4aWpqAgDwH7ZpYGDg4MGDU6dO9fHx8fb29vLyOn369PBINfX19Rs2bAAAYLHYH374obu7m/tVQkKCnZ2dqqrqsmXLoqOjiUTi3LlzL1++PN6liFzi4+MBAK2trXwe1HjR1dX96aefeNs3MjISXjCooqLydsCJ/v5+Jycn7seMjAxjY2N5eflNmzYNDg7Ky8uvWrUqKSmpubl548aNAAA5ObmzZ8+SyeRNmzbBH0+dOkUmk9evXw8AkJWV5ScIqo2NzZYtW3jeXdxAU9VLGGZmZoGBgb/99hvSQgTGhg0bnj9/XlpaKuJ6165dm5WVJdgBcnGjqKjIxsYmISHBz88PaS2CAe0SShirV6++ePEi3JWYANBotMuXL3/66aeir3rjxo2FhYVJSUmir1pknDx50sbGZsK4FUANS+KIiIig0WjXrl1DWohguHTp0tDQ0LJly0RftZ2dnbu7OzyoNCGpq6uLiYlZu3Yt0kIECtJ9UpRx89VXX6mrq3ODw0guVCpVTU3t7ZBSIiM1NRWCoLfjw0wMAgICzM3Nh4aGkBYiSFDDkjza29sVFRV37tyJtBB+2bZtm5KS0niDcAmWJUuWaGtrUygUBDUIg1u3bgHxCEsrWFDDkkj++usvLBb7/PlzpIXwTkJCAgaDiY6ORlZGe3u7gYGBn5+fhKbzeCfl5eUKCgqrV69GWojgQd8SSirz58/PzMzMyMjQ19dHWsu4qaurc3d3nzZtmjgMxuXl5Xl6eq5du/b48eNIaxEA7e3t06ZNU1BQSEpKglcjTiRQw5JU4EjHAICUlBQVFRWk5YyDjo4OT09PAoGQnJyspKSEtBwAALh169aSJUu+/PLLX3/9FWktfNHZ2enr60uj0ZKSkrS1tZGWI3jQt4SSioqKyj///DMwMBAQECCQuFSigUwmBwQEMJnMp0+fiolbAQAWLFhw8eLFI0eOfP7556JcNyNY6urqpk+f3tvbm5iYOCHdCqCGJdHo6OjEx8d3dXV5eHjU1NQgLefDVFVVTZ06taenJz4+Hg7FKT4sWbLk7t27MTExgYGBfK4wR4SUlBQXFxdpaemUlBRJHCUYI6hhSTbGxsZpaWkKCgouLi4PHjxAWs5o3Lt3z8XFRUVFJS0tjUQiIS3nHcyePTs9Pb22ttbe3h5eMCQRMBiM77//3s/Pz9/fPykpCY7CPGFBeNAfRRD09/evWbMGgqDNmzf39/cjLWckfX19X3zxBQRBkZGR4p+LuL29fcGCBRAEbdiwobOzE2k5HyA3N9fR0ZFIJB49enTipYN9G9SwJg6XL1+Wk5MzNDSMi4tDWst/PHz40MDAQF5e/urVq0hrGQc3b95UU1NTVlY+dOgQHItC3Kirq1u6dCkGg/Hy8qqsrERajohADWtCUVdXBwe0CgkJyc7ORlZMZmbmrFmzAADz58+vr69HVgwPdHZ2fvXVVwQCgUQinT17Vnxsq7Gx8csvv5SWltbX17948aI4JEAUGahhTUCePn0K5y8ICQnhJ0c0z6SnpwcFBQEA3Nzc4uPjRS9AgFRXV69du1ZKSkpVVfXAgQPt7e0IiikoKFi5ciWBQNDX1z969OjAwACCYhABNawJS2xsrJubGwDAwcHhzJkzZDJZ2DW2tbWdPn3a3t4eADB16lSx6pnyA51Oj4iIwGAwysrKBAIhLCzszp07VCpVZAJqamqOHj1qZ2cHALC3t79w4QLP0cckHdSwJjh5eXmRkZHy8vJYLNbPz++PP/6oqakRbBXV1dVnzpzx9fXFYrEKCgrr168XcVZUodLa2urm5qagoPDo0aOhoaG7d++Ghobi8XgCgRAQEHD69OmSkhJhdMr6+vpSU1N37tw5efJkAICGhsbmzZsn0onlDXSm+0fBwMBAXFzc9evXHz16RKPR4NVzrq6uFhYWNjY2cPDMsdPV1VVYWFheXp6ZmZmYmNjQ0EAkEkNCQhYvXjxr1qwRuaokmpcvX86dO5dAINy/f9/Gxoa7vbW19eHDh48ePUpMTOzv71dQUHBzc3N3d7e1tbWysjI2Nsbj8eOti0qllpeXFxcX5+bmpqenFxYWMplMfX39oKCg4ODgGTNmTLx1NjyAGtbHBY1Gy8jISE5OTk5OzsnJ6evrAwDo6OgYGRkZGBjo6urq6OgQCIQRew0NDTU3Nzc3N9fX11dXV7e0tAAA5OXlnZycvL29vb293dzc+Mw/JoZcunRp7dq17u7uN2/efF+OjKGhodzcXHhRZ3Z2NpwOFo/HGxsb6+npaWtr6+joaGpqvtNrenp6mpubW1paWlpaamtr4XREBALBysrK3d3dzc3Nzc3NzMxMqMcocaCG9fHC4XDq6uoKCwtLSkrq6+ubmpoaGhra2toYDAaVSoXzwWAwGEVFRTwer6mpqa+vr6enp6+vb21tPXnyZENDw4mT2uD/w2azd+zY8euvv27cuPHIkSNjz5nc29tbVlZWWlpaVVXV1NTU1tbW2NhIoVAYDEZfXx832YSsrCyLxYK9SVNTU1dXV1dX19zc3MrKysjIaGKkaBYSqGGhvJtFixYBAG7cuIG0EFHT09PzySef/PPPPydPnly3bp2Qavnss89KS0sndoBmYYB6OQrKf9TV1YWGhra2tiYkJHh7ewuvIgsLi7t37wqv/IkKupYQBeV/vHjxwtnZmclkZmRkCNWtAAAWFhYUCqWzs1OotUw8UMNCQQEAgL///jsgIMDDwyMzM9PY2FjY1VlYWAAAysvLhV3RBAM1LJSPHSaTGRkZ+emnn3777bd3796Vl5cXQaX6+vpEIrGsrEwEdU0k0DEslI+aN2/ehIeHp6SkXL16NTw8XGT1YjAYMzMz1LDGC2pYKB8vpaWlc+bM6e/vf/bsGbyMSZRYWlqihjVe0C4hykcKvNZSWVk5JydH9G4FADA3N0cNa7yghoXyMXLgwIGwsLDQ0NDk5GSkwp9bWFjU1NQMDQ0hUruEghoWyscFnU5fs2bNjh07fvrppwsXLkhLSyOlxMLCgsViVVVVISVAEkHHsFA+Ishk8rx584qLix8+fAhH7EIQc3NzLBZbVlZmbW2NrBIJAjUslI+F3NzcsLAwPB6fkpIyPPQCUkhLSxsYGJSWliItRJJAu4QoHwV37tyZNm2aqanpy5cvxcGtYCwsLNC5o+MCNSyUCQ6bzd6+ffuCBQtWr179zz//vC9QDCJYWFigLwrHBWpYKBMZGo0WHh5+5MiRM2fO/Pbbb+IWuQU2LDRiytgRr98PBUWA1NfXh4aGtrS0JCYmenl5IS3nHVhYWPT19TU1Nenp6SGtRTJAW1goE5Pk5GQnJyc49IJ4uhX4dwk02iscO6hhoUxAoqOjZ86c6eHhkZGRIYLQCzyjpqY2adIk1LDGDmpYKBMKFosVFRW1atWq7du3iyz0Aj+gLwrHBTqGhTJx6O7uXrJkSVJSkohDL/CDhYUFOhVr7KCGhTJBKCsrCw0NHRgYSEtLc3BwQFrOWLGwsHj8+DHSKiQGtEuIMhFITEz08PBQUlLKzMyUILcCAFhYWLS0tFCpVKSFSAaoYaFIPAcOHAgMDAwJCUlKSkIq9ALPoLGSxwVqWCgSDJ1OX7du3Y4dO/bt2xcdHY1g6AWeIZFIUlJS6IvCMYKOYaFIKhQKZf78+YWFheIQeoFnsFisqakpalhjBDUsFImkqKgoNDSUw+GISegFfkBjJY8dtEuIInncu3fP3d3d0NBQrEIv8Ay6BHrsoIaFIklwOJw9e/bMmzdv1apVT58+FavQCzxjbm5eVVXFYDCQFiIBoF1CFImBRqOtXr36zp07Z86cWbduHdJyBIalpSWDwaipqTE3N0dai7iDGhaKZNDQ0BAWFtbU1CS2oRd4xtzcHIKg0tJS1LA+CNolRJEAsrOz3d3d6XS6OIde4BlZWVk9PT10GGssoIaFIu5cvHjR29vb2dk5MzNTnEMv8AO6BHqMoF1CFPGFzWZ/+eWXJ06c+P7773fv3g1BENKKhIWFhUV2dnZ3d3dFRUV5eXllZWVYWJijoyPSusQO1LBQ/geZTPby8qLRaPDHnp4eAICuri78kUgkpqSkaGhoiEwPlUpdsmTJixcvrly5IimhF8YFhULJzMwsLy+vqKhIT0+vra1VVlYGAODxeCaTCUEQalhvgxoWyv948+ZNZWXliI29vb3c/3d3d4vMsGpra+fMmUOlUiUr9MK4WLJkybNnzwgEAofDGT6ngcFgQBA0efJkBLWJLegYFsr/sLCwsLe3x2DecUlAEOTg4CCyd1jPnj1zdnYmEokSF3phXLi4uBAIBDqd/vYMLA6HY2dnh4gqMQc1LJT/iIiIeKdhYbHYiIgI0Wg4ceJEQEBAcHCwJIZeGBc7duyQlZV951cyMjImJiYi1iMRoIaF8h/h4eFsNvvt7Ww2WwSjSAwGIzIycvPmzZIbemFcyMvLf/fdd1gs9u2vLC0t3/nkQEFPCsp/aGtre3h4jLiFsFisl5eXlpaWUKtub2/38/O7fv36w4cPt23bNoFfCA7n888/19bWHuFNeDze2dkZKUliDmpYKP+Pd3b9li1bJqjy09PTd+7c2d/fP3xjcXGxu7t7U1NTamqq5AaK4QECgbBv374RiVQ5HI6trS1SksQdDgrKMLq6uvB4/PArBI/Hd3V1CaTwgYEBOGNoaGgom82GN967d09eXt7X17ejo0MgtUgWLBbL2tp6RKs2NTUVaV1iCtrCQvl/KCsrBwQEcFO643C4wMBAeH4Q/+zdu7e1tRUAEBsb++233wIA9uzZM3fu3IkUemG8YDCY/fv3s1gs7hYIgtAW1ntB2jFRxI6rV69yh5AgCLp27ZpAii0pKeH6IFyyv78/Fos9dOiQQMqXaDw9PbknR1dXF2k54gvE+f/9ZxQUGo2mqqo6MDAAAJCRkeno6CASifwX6+Pjk56ePnzOEexWmzdv5r9wSScrK8vd3Z3D4WAwmJCQkPv37yOtSExBu4QoIyESiWFhYXg8Ho/Hz507VyBude3ateTk5LdnSO7bt6+pqYn/8iUdV1fXgIAAAoGAw+Hs7e2RliO+oIaF8g4WL17MYDAYDMbixYv5L41KpW7cuPHt7SwWq6enJygoiLuA8WPm2LFjTCaTTqejhjUKYr2WsLOzs62trb29nclkDgwMDA4OcjgcCIIwGIyioiIAQEVFRVNTU11dffjgCApv9Pf3NzQ0tLW1sViswcFBGRkZAMDAwEBCQgIWi9XU1NTX13/fzOzR+emnn6hU6jsHHxgMRlFR0ebNm//8809+D0DSYLFYVCq1u7v7zZs3VCqVzWb7+Pg8e/asqanp5s2bw/+SSCRKSUkBADAYjNK/KCoqvnPS6cRGLMawmExmcXExHFWjsrKyoqKisbGRQqHQ6fSx7A5BkLq6uoaGhum/mJmZ2dnZycvLC1u55FJfX5+bm1tSUlJYWFhaWtrY2Njd3f3BvZSUlPT09KysrGxsbKysrKZMmaKvrz/6LiUlJba2tsPfgnGB7zcIgrZu3frTTz/xdiBiy+DgYG1tbUNDA5lMJpPJra2tFAqlpaWFTCZTqVQqldrX18dnFXJyckpKSgoKChoaGtra2urq6tra2hoaGhoaGnp6eiQSaeKtFkDMsFpbWxMSErKzs3Nycl69ejUwMCAjI0P6F319fU1NTU1NTS0tLTU1NQKB8M5CKBQKhUJpa2trbW1taWmp/ZeOjg4MBmNmZjZlyhQnJ6fp06fb2tp+JJOnR6G5uTk2NjYlJSU5ObmxsZFAIBgZGVlYWJibmxsYGOjq6urp6Wlra4+YhwUAoNPpLS0tTU1NjY2N9fX1FRUVZWVl1dXVDAZDX1/fy8vL29s7JCTk7aV/HA7Hzc0tLy+PyWRyN0IQhMPhWCxWYGDgypUrQ0JC4Nac5DIwMFBaWlpcXFxZWQlfgTU1NfAEDgCAqqqqmpoa/K+GhoaamhrcPoJRVlZWVFRUUlIaS3OJyWTCZgc3yrq7u+GP7e3tbW1tHR0dHR0d7e3tHR0d8N9ra2uTSCQjIyMSiWRiYjJ58mRLS0uJdjGRGhaDwUhMTHz8+HFCQkJJSYmMjIyVlZWbm5urq6ubm5upqamgKuro6MjKysrMzMzMzCwoKOjo6FBXV/fz85sxY0ZoaKiKioqgKpIIurq6zp8/f+PGjZcvX8rJyU2fPt3Ly8vT03PKlClve9PYYTAYOTk5qampKSkpz58/7+/vd3FxWbRo0apVq7jzts6fP79mzRru+kQ4OIGlpWVkZOT8+fO5wbYkjpaWlqysrLy8PLiJWlNTw2Kx8Hi8kZER3MY3+Rd9fX3Rj1cwmcz6+vqqf6msrKyqqqqurmYymVgs1tjYGG4gOzo6urq6CnvRlWARkWGlpKTExMTcuXOns7NzypQpM2fO9Pf3nzp1qmjMvqioKCEhIT4+/tmzZywWa8aMGYsXL168eDE8LjCBSUpKOnv27O3bt2VlZefNmxcWFubn5yeMox4cHExMTLx3796dO3doNNrChQvXrFljZ2dnbGzc2dlJIBAYDIasrOzChQtXrFjh5eUlcSt7mUxmdnZ25r80NjYCAIyMjGxsbKytreH738LC4n1dAXGATqeXlpbCDltcXFxYWFhbWwsAMDAw4DYanJ2dxX04WKizvLq7u3///Xd42q6Dg8Mvv/xSXV0t1BpHh0qlxsTEhISEEAgEVVXVLVu2VFRUIKhHeMTGxrq4uEAQNG3atEuXLg0MDIim3oGBgZiYGDhPBNxDxGAwM2fOvHz5Mo1GE40GAVJRUYq7OPMAACAASURBVHHy5MnQ0FAFBQUAgKKi4owZM7777rvY2Nj29nak1fELhUJ58ODBzp07/fz8uAcYFhZ26tSpyspKpNW9G2EZVmdn565du2RlZWVkZFavXp2XlyekiniDTCbv27dPV1cXgqC5c+e+fv0aaUUCIykpycnJCYKgkJCQ7OxspGRkZWW5uLgAAOzt7VNSUpCSwQNMJvPFixdffPGFoaEhAEBeXj44OPjw4cP5+fksFgtpdcKCxWLl5eUdOnQoKChITk4OAEAikTZv3pycnCxWRy14w+rq6vr+++8VFRU1NTUPHTokzitaGQzGnTt33NzcMBjMggULJN22yGTyJ598AkFQUFBQTk4O0nI4HA7n5cuX/v7+EAQtXbqUTCYjLecDpKSkrFu3Tl1dHQBgbW393XffwVPzkdYlahgMRmpq6s6dOy0tLQEAmpqakZGRYrIeW8CGdfnyZQ0NDRUVlZ9//rmvr0+whQuP+/fv29ra4nC4r776qre3F2k5vBAXF6epqUkikR48eIC0lpFcuXJFS0tLS0vryZMnSGt5BxQK5ciRI9bW1gAAR0fHn376qaysDGlR4kJJScm+ffvgQNWTJ08+evQosn1hgRlWTU2Nv78/BoNZv379mzdvBFWsyGCz2efOnVNRUdHX13/48CHScsYBk8n88ssvIQhavHhxd3c30nLeDZVKjYiIgCBoy5Yt4tPFSElJmT9/PoFAUFRU3LBhw6tXr5BWJL4UFBSsX79eQUFBSkpq4cKF6enpiMgQjGHdu3dPWVnZxsYmIyNDIAUiBZlMXrZsGXxf0el0pOV8GBqNNm/ePGlp6XPnziGt5cNcunRJSkpqwYIFInsJ8D4SExN9fHwAAO7u7ufOnZOg3gCy9Pb2nj171tXVFQDg6+v7/PlzEQvg17DYbPauXbsgCFqzZo0kvgZ6JxcuXJCVlfXy8urs7ERay2h0d3e7u7urqKgkJycjrWWsvHjxQklJydPTE16sI3oKCgq8vb0BAP7+/i9evEBEwwTg2bNnvr6+AAAfHx9RDv7yZVgMBmP16tU4HO7s2bOCEiQmFBYW6urqWllZNTQ0IK3l3dBoNG9vb01NzZKSEqS1jI+ioiJ1dfXp06eLuJ1FoVAiIyOxWOzUqVMlvSsgJqSlpbm5uWGx2A0bNojm9RrvhsVkMuHYI2I4yisQGhoarKysdHV16+vrkdYyEjabPW/ePEVFxYKCAqS18EJubq6CgsKiRYu4gZKFzdWrV5WUlHR1dS9fviyySj8G2Gx2TEyMjo6OiorKjRs3hF0d74b15ZdfysjISNYUm/HS2dlpa2trY2ODVP/lfRw5cgSLxT579gxpIbwTHx+PxWJ/++03YVfU39+/Zs0aCII2bdqEjlUJib6+vg0bNgAAIiMjhTo0xKNhnTt3ToDBc8WZ+vp6LS2toKAg8Xks5+bmEgiEvXv3Ii2EX3bv3i0lJZWfny+8Kurr662trVVUVO7duye8WlBgbt++raysPHnyZOENpPBiWDU1NXJyctu3bxe4GvEkIyMDh8OdPn0aaSH/w8vLy93dXUwmB7DZ7Pj4+LCwsODg4PHuy2QyXV1dfXx8hCGMw+HU1NQYGho6ODiI7UDkWHBwcBDqvcbPL/g2dXV1dnZ2JBKptraW/9LeZtyGxWaz/fz8rK2t4XB642LNmjWjZEYZb2miZOvWrQoKCuJw3d+5cweCoPGOGQ+PoAAAIBAI2tra8+fPLyws5FNPdXX1kSNHAAABAQE87J6amgpB0P379/mU8TZ1dXV6enrOzs585ih79OjRggULAABqamrBwcHBwcGzZs2Cg4Lu3r1bQGJHY/r06XDuQiHB5y/4Nh0dHY6OjgYGBsK4X8ZtE0+ePOHhhuFSXV0Nvwpt/Je6urp//vlHT0+PtwJFA41GMzExWbduHdJCOF5eXnPnzuVhx7KyMgCAs7Pzq1evCgsLT58+raKioqCgwP/ybzjOIs+X++zZs6dPn86nhhEwGIypU6fa29sLZCYtHGlvxAGePHlSSIa1detWYRQ7Cnz+gm/T1dVlY2Pj5eXFZDIFVSbMuA1r+vTp/DQd4ciTb5+aM2fO8FymaPjrr7+kpKRaWloQ1FBYWAgA+Oeff3jYFw6hN/zMP3jwAADw+eef8y+Mn8v98ePHAIDi4mL+ZXDZunWrvLy8AEODvPMAb9++LajyuVy/fl2AxjF2BGtYHA6nsrJSTk7u22+/FWCZnPEmUq2oqHj+/PmmTZvGtddw3hcIKTIykucyRcMnn3wiLy9/4cIFBDXcunVLV1cXnrA3Xt4OaAlP9SaTyfwL44cZM2Zoa2vfunVLUAUWFhYePnx4//79RkZGgirzncybN0+wBebl5X366aeCLRMpTExMfv75519//bWkpESAxY7PsOLi4pSUlPz8/ASooLe3lxu8uLGx8cyZM1OmTAkODn758uWmTZs0NDSCgoL6+/tv3rypra0NQVBgYCAAICcnBw4OA3+sra3du3evk5NTcHBwYWHhtm3b1NXVXV1d6+rq0tLSIiMj1dXVg4KC+ImiLS0tHRQUFBcXJ5Cj5o0XL17MnDlTUKkHMjMzAQBubm7DN+bl5fn7+7u7u5uamh46dIi7ncVi7dq1y83NzczMzMnJKT09XSAaAABYLHbGjBlJSUmCKvDgwYNWVlbr168XVIEj6Ovr416x/f39ly5dCgwMDAkJefr0qba2tr+/P/jQ6Wpubl62bJmHh4eNjc2iRYvgYMrl5eW7du3q6+vLzs728fGBM2MnJibOnj07KCiIu29bW9vy5cv9/PwMDQ3DwsLgMRYw6r0D/4HwfsH38fnnn5ubmx88eFCQhY6rPTZnzhzeBlCGA/5/4/PSpUvDZVAoFACAoaFhQkICh8NJSEgAABw8eJDD4cBtAe6+7e3twz/C4RPNzMwyMzM5HM6jR48AAE5OTo8fP+ZwOMnJyQCA/fv386M8JiaGQCD09/fzUwjPMBgMIpHIz6IC7ukaGhq6du2ahoaGt7f38MMpKyuTk5OLiYnhcDj5+flSUlJXr16Fv4Ivu+bm5t7eXiUlJSsrq3eWzBtnzpyRk5MTyHgHjUaTlZU9ceIE/0UNZ/gBXr16lXvFtra23r59G/wbyWDv3r2rV6/mjHq62tradHV19+zZw+Fw+vr6FBQUPD0931lRZ2fn77//PnxLT08PiUS6dOkSh8Pp7e11c3PT0NBoa2uDvx3l3hldEkcIXUKYY8eOycvL8/CC7n2Mz7AsLS3hE81XlQAoKytPmzZt2rRpDg4O8MOK++2IoRa4TbRgwQLuvsNP6/CPcJJO7kc41R334+DgIABg/vz5/Ch/9eoVAACppTDwc5ifmbrwmXdzc4NDuf/9998jgj0tXbqURCJxP3p5ebm4uMD/j4iIUFRUhP/v6elJIBBGlMzP5f7ixQsAgEACZqWlpQEABB7YlnvRenh4wCkzuF/BV6y1tfXwmXqjnK7IyEgVFRXuPbxs2TJHR8fhFQ0/kyOGw3ft2jU8kT38GOaOQo5+7wj1F3wfFRUVAAABLoQaX5eQQqFoaGiMa5d34uLi8uLFixcvXuTl5V28eHH4VyP6O3AivLF05UbEoh6RiAUOZM5tHvOGpqYmQG7Qp7OzEwAwyryQseDi4pKRkQF3N9LT00ectGfPnr1588bnX9rb2+GE9QCA/fv3p6SkwH/T0tIyxgxsY0RVVRUAwM31wg+VlZVEIlEYo1fwRZuamgo/t7jAVyw8QMHdOMrpevjwoYWFBTeyfkxMTG5u7vsqHZEl5ObNm8NztXh5eWloaMBvLcCH7h2h/oLvw8TEREpKqrKyUlAFjs+w+vr64PCpAiQ8PPyDuVs4AsqUwWc5cKLD3t5egYgZL7DbCiRx/K5du+zs7M6dOxcbGzt8e3t7u6Gh4Yt/KS0tff36NfyVtrZ2Y2Pj9OnTKyoq4NjBAgQ+KD4fJzBwvjj+yxkFU1PTD15Io5wuCoUC9wZ4oL6+fsRZMjAwaGlpGWUXrlSh/oLvA4IgIpEowMze4zMsNTU1uJ8sQHA4nGjMnn/gY4dD6IoeODtZV1cX/0Xh8fjo6Gg8Hr927drh7RpFRcXS0tKGhgbuFrhJDwD47bffFixYcPr06c8++4yf5GDvBD4oPhuPMMrKylQqFfErapTTpaKiUlFRMTQ0xN3S399PpVLHUqyOjg48g5y7RU5OjkQi8SlJeAwNDfX09Ajkl4UZn2Gpq6u3tbUJqu4RjCX3L5FI5P60sG0Pz9ApbOBRJIF0inkANiz4VQMPwMkBuRmY7e3td+zY0dbWBg8Swxu9vb2HhobCw8PhNFbNzc0nT56Ev9q9e7ezs7OFhQWfR/FO4CeBQC5rOzs7JpOZn5/Pf1Fc3pm2enRGOV3Tp0+Hszdxt0RHRw9vFY5SXUhISHt7OzzkB1NbW7tw4UI+JQmPvLw8FosF580SCOMzLCcnJ3icj2fgHjV3ZASGyWT+8MMPw/+A22aG/8N9HNnY2OTk5Ny+fTsuLm7fvn0AgLKysvT0dDqdDpfJ3RE2Mq6dwRcBnw/e5ORkdXV1AwMDfgrhGRUVFV1d3VHGO0anvLwcAACn/IS37Ny5087O7uHDh59//jl89nbv3i0tLZ2RkWFgYKCvr29iYrJ06VL4j2VlZaurq4eGhlpbW6uqqgAANBqtpqYGAAC/0BjeZBgvubm5+vr6ioqKPJfABc5iDb+5ExTw8TY3N7+zJwhfYz09PcM3jnK6vv/+eyKR+NVXX/311195eXl79+4lEAjchIaTJk0qKioqKCj47bffwL9XLPeq3r59u7q6+rZt2+BxiVu3bmEwmC1btsDfjn7vCPUXfB83b96Ek8sKrMRxDdFfv34di8XyvDjr2rVrAQEBAAAIgtzd3eEXhR4eHpqamhAE1dXVNTc3f/755wAAIpF4+vTp5ubmzZs3wx9PnTrFZrMzMjKMjY3l5eU3bdo0ODgoLy+/atWqpKSk5ubmjRs3AgDk5OTOnj1LJpPh2a1ycnKnTp0ik8nwrBxZWdmTJ0/yJp7D4fj7+y9atIjn3fln0aJFISEhPOy4atUqJSUl+Bc3NDQ8fPgwvL2goADuHSgoKMDBjNLS0lxdXQkEgqmp6d27d7klXLt2bdKkSb6+vqdOndqyZYuysvLu3bs7OjrIZPIXX3wBAJCWlj5+/DhvMfmCgoKWLFnCw47vZO/evcrKynwuIeSyZs0a7qkzMTEZEV2zvr4eDquCxWJ/+OEH7kqg950u+NusrKypU6dKSUlZWlpGR0cPL/DPP/9UUVFxdXWtrq7u6+vbunUrfBlzI6OUl5cHBQUZGBj4+/uvWrWKO6fhg/eOUH/Bd9LZ2amoqPjLL78IqkDOeKc1dHV1EYlEEcQwEkPq6urwePyVK1cQ1HDmzBkZGRlJzPExCp2dndLS0gIMWtvT06OpqSlAB0ThjUWLFmlpaQk2DdW41xJGRUXp6uoODQ0JUIREsGHDBmNjY4Ev5hwXPT098vLyAp8ViSxHjx5VUFAQ7GUNL9GHJ1iiIEJ0dDQGg4mPjxdsseM2rKqqKhwON8HumQ9SWVkpIyNz5MgRpIVwVq1aZW1tjaxvChAGg2FhYbF27VqBl/z1119LS0vD6xxQRExsbKyUlJQwwk7wEoVq9+7dRCKR/7AkkgKTyXRzc3NychKHJMBNTU1EIpGfkTix4vjx47KysvB4tmBhMpkrVqzA4/G3bt0SeOEooxATE4PFYleuXCmMxyovhjU4OGhlZeXp6SnAJULizP79+3E43MuXL5EW8j+++eYbeH4J0kL4pbW1VU1NTXjhNBkMxpIlSwgEwvnz54VUBcoIzp07RyAQli1bJqROAI9xPouKipSUlJYsWSI+kc6FxLVr1zAYjDh0Brn09vaamZnNmDFDTKIk8waLxfLz87OwsBBqYggmk7l161YIgpYuXdrT0yO8ilCoVGp4eDgGg9m+fbvwhix4D0ycmJhIIBC+/vrrCexZ8fHxUlJSn332GdJCRpKTk0MgEHbs2IG0EN7ZunWrsDNQcHn8+LG6ujqJRBo+UQNFgNy6dcvAwEBTU5O36JJjh69I6jdv3iQQCKtWrRKHwR2Bc+XKFQKBsHr1avE8urNnz0IQJKFTTI4cOQJBkCh7ai0tLXPnzgUAzJo16+MZfhUB5eXlM2fOBADMnz+/tbVV2NXxm/rhyZMnsrKys2bNEk3eV9HAYrF+/vlnDAYj5u3Hw4cPYzAYiXtje/ToUQiCjh8/LvqqExISJk+eLCUlFRUVJQ4pRSSaurq6TZs2EQgEW1tbkaXIFECumszMTH19fR0dnefPn/NfGuK0tLT4+/sTCISjR48ireXDHDhwAIKgb775RpyNlQuLxfrqq68gCOJOtRc9DAbj5MmTenp6eDx+xYoVgo0l/5FQWFgYERGBx+P19fVPnTolykk2gkmu1dXVNW/ePCwW+/XXX0t0ct0rV65oaGiYmJiIzzvBDwLHQQ0MDBRIADzh0dbWNnPmTCkpKWRXC8DQ6fTz589bWlpiMJiAgIA7d+6IZ8dfrKDT6bdu3Zo5cyYGg7G2tr5w4QKdThexBkFmAzx79qyysrKBgcGtW7ck7gVWUVFRQEAABoOJjIwUt8T0HyQ7O9vY2FhTUzMuLg5pLe8mNjZWQ0PD1NQ0JycHaS3/wWKxuHegtrb2rl27qqqqkBYljlRWVu7cuVNLSwuDwQQGBt65cwepFr2A05eSyeRly5ZhMBgbG5vbt29LRD+lqKho0aJFGAzGzs4uLS0NaTk8QqVSlyxZAo99NjU1IS3nPxobG+HsMp988onYTiyor6/fs2ePnp4eAMDe3n7v3r1oV5HD4RQWFv7www92dnYAAH19/R9++AHxgT+h5Ft+/fr1/PnzIQiys7OLjo4W4PpvwZKcnLxgwQK4fXv9+nWJaxW+zd27d0kkkpyc3Pbt2ykUCrJiyGTy1q1b5eTkjIyMhJHbWeAwGIz4+Pj169fDsbAtLCy+/PLLhw8fiq3PCoPu7u4HDx5ERUWZmZkBALS1tTds2JCQkCAmq8GEmCC+oKBg5cqV0tLSampq27Zty87OFl5d46KpqenEiRPwc8Pb2/vmzZsTwKq4XLlyRVpaWkFBQU5ObuvWrcJY9fJBmpqatmzZIisrq66ufvDgQbF9Yr0PFouVkpLyzTff2NvbQxCEw+Hc3Nx27Njx+PFjQUWtESs6Ozvj4uK+/fZbV1dXLBYLQZCDg8O2bdvS0tLE7dYQomHBtLe3//LLL8bGxgAAEom0ffv23NxcRLqKzc3NJ06c8PLywmAwCgoKa9euffXqlehlCA8ajRYREQFB0LZt27q7uw8ePKitrY3D4UJDQx88eECj0YQtoL+///79+3PmzMFisTo6OocPH0YqJZoAaWtru3Tp0vLly3V0dOBQbhYWFitWrDh16lRubq4IzqowoNFoL1++/P3335cvX25ubg6nz9DT01u5cuXly5fF+e0NxBFQfocPkpOTc+PGjRs3btTX12tpaQUGBgYGBjo6OhobGw9PNyJYOjo6Xr16lZCQ8OTJk1evXsnKys6ePXvx4sUBAQHS0tJCqhQRampqFi5cWF1dHR0dHRYWBm9kMpmPHj06e/bskydPZGRkQkJCFixY4OXlJdiw9GQyOSUl5datW7GxsYODg7NmzVq3bl1QUJCgEr6KD42NjVlZWRkZGVlZWXl5eQMDA1gs1sjIyMbGxsrKysbGxsLCgkQiwclKxIfe3t6ampqysrLCwsKSkpLCwsKamho2m00kEh0dHd3+BXZkMUd0hgXD4XDS0tISEhISExMzMzOZTKaSkpKjo6OTk5OdnZ2pqamJiYmysjJvhQ8NDVVXV1dUVJSWlubm5ubk5NTX1wMATE1N/f39/f39Z8yYIW4Xk0CIi4uLiIjQ0dG5desWPPQwAjKZfOfOnZs3byYnJ7PZbGtra19fXwcHBysrK0tLy/Gek97e3pKSktLS0vz8/MTExJKSEgwGM23atIULF86bNw+pJB0ihsFglJaWwvd/cXFxUVFRbW0tHDhfTU2NRCKRSCQjIyN9fX0tLS11dXVtbW0NDQ3hPSYHBwfJZHJLSwuFQmlpaWloaKitra2pqamtrYXzjGAwGCMjo8mTJ1tbW9vY2FhbW1tYWIzI8yb+iNqwhtPX15eXl5eTk5Obm5ubm1tdXQ2Hx1ZVVSWRSJqampqamlpaWmpqatyI1yOgUCgUCqWtra21tbW5ubm+vh6+YrS0tOzt7Z2cnKZMmeLs7KytrS3SAxMhLBZr586dv/766+rVq0+cOPHBDFednZ2pqanJyclpaWkFBQVDQ0MQBBkaGhoaGurq6urp6Wlra7+dUoVOp7e0tDQ1NTU2NtbV1dXV1QEApKSkHBwcPDw8vLy8PD09BZgZRRJpbW2dPXt2dXX10aNHqVQq7BS1tbWNjY3DM+IoKSlpaWkpKSkp/ouysrKioqKSktJYGqRMJpNKpVKp1Ddv3lCp1O7ubvhjS0vL8FoUFRX19PSMjIy4vkkikYyNjYWdAE0EIGlYI2AwGLW1tZWVlZWVlQ0NDRQKpbW1ta2trb29nclkDgwMwKHyAQAYDAZOWDBp0iQNDQ0NDQ1tbW1NTU0TExNTU1NTU9MJ2Yx6m7a2tiVLlmRlZZ05c2b58uXj3Z3JZFZXVxcWFpaVlTU0NDQ3Nzc0NJDJZPiugK0fPtVsNpvFYnl7e+vo6Ojr61taWtrY2BgbG0+8Th9vZGdnh4aG6ujo3L9//+2O1cDAAJlMbm1thds+FAqFazSw6bx586anpwdODjI0NPR2Fj8ikQgnXmWxWHQ63drammt58H/gFpwI2nHIg+D4GQ8AAK5fv460CrEgNTVVR0fHyMgoNzdX2HXBeaUQeeEo/ly6dElKSio0NFQEazzy8vIAAOLzwl30jC/NF4o4wOFwDhw44OPj4+LikpeX5+joKOwa7ezsIAgqKCgQdkWSBYfD2bNnT0RExPbt2+/evQunhhcqDg4OJBLp3r17wq5IbEENS8Lo7u6eO3fuzp079+3bd/v2bYHk8vsgSkpKBgYGqGENZ2BgIDw8/Jdffjl37tyePXuE96Z7BHPmzPmYDUvC3hF85Lx+/XrBggW9vb2JiYnTpk0TZdV2dnavXr0SZY3iDJlMDgsLq66uTkxM9PT0FGXVYWFhx48fLy8vNzc3F2W9YgLawpIY/vrrL1dXV3V19ZycHBG7FQDA3t4eNSyY/Px8Jyen7u7ujIwMEbsVAMDLy0tNTe3+/fsirldMQA1LAhgYGFi+fPnatWujoqJevHiByAQ/Ozu7yspKOBn6x8zDhw+9vb3NzMzS09Ph9RsiBovFhoSEfLS9QtSwxJ2amhoPD4+HDx/evXsXzt+DiAw7Ozs2m11UVIRI7WLCgQMH5s6du2LFiqdPn/I8vZl/QkNDs7KyWltbkRKAIKhhiTV37txxcHBgsVjwTB8ElZBIJEVFxY923J3BYKxbt27nzp2HDx8+efIkshPEZ86cKSMj8+DBAwQ1IAVqWGIKk8mMiopasGDBokWLsrKyTE1NkdUDQZCtre3HOYzV3d0dFBR0/fr12NjYqKgopOUAGRmZgICAj7NXiL4lFEfa2trCw8Ozs7Ojo6N5mMIuJOzt7XNycpBWIWrKy8tnz55Np9NTU1NtbGyQlvM/QkND16xZ093draSkhLQWkYK2sMSOtLQ0JyenxsbGtLQ08XErAICdnd3r16/hJTsfCS9evJg6daqysnJmZqb4uBUAICQkhMPhPH78GGkhogY1LDGCO4Xd1dU1Pz/fwcEBaUX/Dzs7u/7+/qqqKqSFiIjo6OiAgIBZs2YlJyfDMUjFBxUVlWnTpn2EkxtQwxIXuru7w8LCvvvuu0OHDt26dUtBQQFpRSOxsbHB4XAfw7g7m82OiopavXr1t99+GxMTAy88FjdCQ0MfPXrEjQjwkYAalljw+vVrFxeXly9fxsfHR0VFiWydx7iQkpIyNzef8OPu/f39CxcuPHv27LVr10S55ma8zJs3r7+//9mzZ0gLESmoYSHPuXPnXF1d9fT0CgoKRD+FfVzY2dlN7BZWQ0ODh4dHWlras2fPFi1ahLSc0dDR0ZkyZcrH1itEDQtJaDTa8uXL161bFxUV9fTpU/GP1TmxVxTm5OS4u7tjMJicnBw3Nzek5XyYsLCw+/fvw4G0PhJQw0KM6upqT0/Phw8f3rt3D8Ep7OPC3t6+ubmZQqEgLUTw3L1718fHZ8qUKcnJybq6ukjLGRNhYWFkMjkzMxNpIaIDNSxkuH37tqOjI5vNfvny5Zw5c5CWM1bs7e0BAK9fv0ZaiIDZs2fP/PnzN27cePfuXTk5OaTljBVra2szM7OPqleIGpaoYTAYUVFRCxcuXLx4cWZmpomJCdKKxoG6urqmpuZEGsYaHBxcsmTJzz///Mcff+zfv1/igj6HhobevXsXaRWiAzUskdLa2urv73/u3Lno6Og///xTEmNvT6Q4MxQKxc/P78mTJ3FxcWvXrkVaDi+EhYVVVVV9PIvSUcMSHYmJifAYkLhNYR8XE8awSkpK3N3dOzs7s7Oz/f39kZbDI25ublpaWh/PukLUsEQBm83es2dPYGCgl5dXXl4ePBIkodjZ2ZWWlkr6fMVHjx65ubnp6+unp6cjvrCcHzAYzOzZs1HDQhEYb968CQsL+/nnnw8dOnTz5k0xnMI+Luzs7JhMZklJCdJCeOfEiROhoaHz589/+vSpiooK0nL4JSwsLC8vr6GhAWkhogA1LOHy6tUrFxeXnJychIQEsZ3CPi7MzMyIRKKEjrszmczIyMjNmzcfPnz4/Pnz70vQK1n4+vrKy8t/JO8KUcMSImfPnnVzc4PzzXh7eyMtRzBgsdjJkydL4jAWlUoNDg6+fPnyzZs3xSGslaCQkpKaNWvWR9IrRA1LKMBT2D/7MWEouQAAIABJREFU7LNt27Y9efJE/KewjwtJXKBTV1fn6elZVlaWlpY2b948pOUImLCwsKSkpI6ODqSFCB3UsARPdXW1h4dHbGzsvXv39uzZIxFT2McFHBiLw+EgLWSsJCcnOzk5SUtLZ2Rk2NnZIS1H8AQHB+Px+Li4OKSFCB3UsATMrVu3HB0d8Xh8fn7+7NmzkZYjFOzt7bu7u+vr65EWMiZiYmJmzpw5c+bMlJQUbW1tpOUIBXl5+enTp38MvULUsAQGPIV90aJF4eHhycnJBgYGSCsSFra2thgMRvx7hWw2e/v27StWrNi+ffvly5clcZru2AkNDX369CmNRkNaiHBBDUswDJ/C/scff0zse0NeXp5EIom5YdFotMWLFx8/fvzKlSviHNZKUISFhQ0ODsbHxyMtRLighiUAEhIS7OzsWlpaJHoK+7gQ8/nubW1tvr6+ycnJiYmJ4eHhSMsRBRoaGm5ubhO+V4gaFl9wp7BPmzYtNzdXoqewjwtxDoyVm5vr5OTU29ubkZExdepUpOWIjtDQ0IcPHzKZTKSFCBHUsHjnzZs3oaGhP//88+HDh2/cuCHpU9jHhZ2dXV1dXXt7e0lJyfXr17/99ts//vgDaVEAAHD//n0fHx97e/vMzEwjIyOk5YiUefPmdXZ2pqSkAAAKCgr27Nkza9as7u5upHUJFI54c/XqVZ1h4PF4VVVV7sfw8HCkhGVlZenr62tpaSUnJyOlQfR0dnYmJiYeO3YsPDxcXV0dj8cDALBYLDybFGl1nN27d0MQtGnTJiaTibQWBGAymSQSafr06XCOHwwGAwDIy8tDWpcgEXfD+vHHH99ntRAEWVtbI6Lq2LFj0tLS/v7+FAoFEQGIwF38gcfjYavigsFgEHx4cDgcOp3+6aef4nC4P/74A0EZiEClUi9cuDBr1iw4u8+IeX8lJSVICxQk4m5Y1dXV73u/g8Phfv31VxHr6e/vj4iIwGAwu3fv/tge46Ok7ZSSktqzZw9SwigUiqenp6Ki4tOnT5HSgCAmJiYQBL1vfnJNTQ3SAgWJuBsWh8NxcnKCG7dvt7AaGhpEqaSystLOzk5ZWfnhw4eirFd8CAkJGdG24v4W169fF3btRUVFb1tSaWmpiYmJoaFhYWGhsAWIJ1u2bBllNUVLSwvSAgWJBBjW8ePH3w5ci8Fgpk6dKozq+vv74+PjaTTaiO03btyQl5d3cXGpr68XRr0SQXV19TsNCwBQUFAg1KoHBgb09PQAAH/99Rd3Y2JiorKysre3d0dHh1BrF2eYTKa3t/f7fpc3b94gLVCQSIBhkcnktw0Li8WePn1aGNXB6/hXrFjB3UKn07/44gsIgr744ovBwUFhVCpBvPN5DkHQ2xYvWPbu3Qs3tHE43PPnzzkczu+//47D4SIiItAfpampSUlJ6Z0dkYGBAaTVCRIJMCwOh+Pr6zvCs7BYbHt7u8ArSk9Ph4fMIAg6e/Ysh8Npbm728vIiEokXL14UeHWSSE9Pz6RJk0YMLGppaQm10pqaGm4LAoIgIpG4dOlSDAazf/9+Npst1Kolhbi4uLdHeyEImmDnRzIM6++//x7+9MDhcIGBgQKvhUajGRgYcCvCYrHHjh1TU1OztLScYK9a+OSPP/4YcW/4+/sLtcbZs2cPb9ZhsVhpaenffvtNqJVKHFu3bh3RyCIQCEiLEjCSYVhUKnV4cEgIgmJiYgRey9dffz18IACLxUpJSfn7+3/M4yPvhMVi2dractu8BAIhKipKeNW98+0kHo93dXVFO4PDYTAYrq6uw69hOTk5pEUJGMmY6a6goBAUFMT9JaSkpObOnSvYKtLT048cOcJgMLhbWCwWm81mMBhKSkqCrUvSwWAwx48f52ZIZ7PZ5ubmQqqLwWBs2rTp7UFMBoORm5v76aefCqleSQSHw926dYtIJHLbWfDMrImEZBgWAGDp0qXwIik8Hj9nzhxZWVkBFj44OLh8+fK3xywZDEZqaupPP/0kwLomBj4+PnPmzIEfIUwm08LCQkgVnT59uqamhmuOw2EymZcvXz5+/LiQqpZEdHV1L1++zPk3tuLEMyzJ6BJyOJyBgQGuSd27d0+whf/444+jpPzFYDDwaymU4ZSXl3PHlZqamoRRBYVCGSVxPDxKsGHDBmFULdF8/vnn8E9jZGSEtBYBIzGGxeFwli5dCgCQlZUV7JvaoqKiUebdYTAYCIKCg4MFWOOEYevWrfAvIqTyIyIi3p5eBPuUrq7u/v37P+Y5caMwODhoY2MDALCyskJai4AR03DjNBqts7Ozq6urs7OTzWaz2Wwqlaqvrw8AcHZ2fvjwIZFIhJu78vLykyZNUlNTU1RU5KEiFosVERHBeSs8OXyfsNns6dOnL168eP78+Xwf08Shr6/vzZs3b9688fLy+v3339XV1e/duzd8+A8AICsrCzsLkUhUVlZWUVFRVlYeV1qtlJSUS5cucX8a+MmBw+EWLly4YsUKX1/fd047QgEASElJXb9+fcqUKRAEpaWlDQwMAABoNNrQ0NDwP5OXl4cf1QoKCpMmTZo0aZL4D9dCb9+rIuPNmzdlZWX19fWNjY2NjY3wf9rb2zs7O+FTPC5wONykSZNUVFT09PR0dXX19fUNDAx0dXVNTU319fXftyDxl19++e6777hDJDgcjsPh4PH4efPmhYeH+/n5EYlEvg5SMqFSqRUVFc3NzY2NjS0tLc3NzU1NTa2trbBP0el03oqVk5ODzUtPT09bW1tHR0dXV1dLS8vIyIhEIg23Mw6H4+zsnJ+fz2azpaWlBwcHLSws1q5du2zZsgmWgogfyGRyRUVFY2Mj/AM1NDQ0NzdTKJSurq7e3l4eCsRgMCoqKioqKpqamvr6+nBMFAMDAz09PTMzM8EOHPOG6AyLTqcXFBTk5OQUFxeXlZWVlJS0tbUBAGRlZfX09DQ1NeFrV0NDY9L/Z5TRJQAAlUrt6OjoHEZTU1NbW1tjY2NbWxuFQgEAyMnJWVhYWFpaWlpaOjg4uLi4wPl+q6qqJk+ePDQ0hMfj4QYn3J6aO3fupEmTRHNaxIGWlpb8/PzCwsLKysqKioqKigr4vElLS6urq+vo6Kirq8M/DXw1c1tMY2k0cZtjXV1d8L8dHR1tbW1kMrmlpYVCoVAoFDabjcPhDAwMTE1NzczMzM3NW1tb9+3bBwBQUFBYtmzZqlWrnJycRHEuxBgymZybm/vq1avy8vKysrLy8nI41pW8vLyOjo6Ghoaurq66urqmpib85ObywYdud3c33KGB+zRdXV1kMrmpqYlCoTQ1NZHJZDqdDkGQnp6eubm5ubm5paWlo6OjnZ2djIyMSA79P4RrWGQyOTExMSMjIzs7u6CggE6ny8rK2tra2tjY2NjYWFtb29raCtUaBgcHS0pKCgsLi4uLX716VVhY2NraCgAwNTV1cXF5+fJlRUUFFov92HzqzZs3qampmZmZ+fn5+fn58JNDW1vbysoKtnULCwsrKysNDQ0RiGEymbW1tSUlJWVlZaWlpaWlpSUlJX19fRAEaWtre3p6Ojs7e3h4ODk5TbyEaaMzNDSUmZmZkpKSm5ubm5vb2NgIANDW1p48efLkyZMtLS0nT55sZWUlgsiRjY2NJSUlxcXFJSUlRUVFxcXFfX19OBzO2traycnJycnJx8dHeG+KhyN4w6LT6S9evIiPj4+Pj3/9+jWBQLC0tHRycnJ1dXVxcbG2th69xSRsGhsbs7Ozs7KysrOzc3Jy+vv7NTU1AwIC/P39AwMDVVVVEdQmVLq7u58/f56UlJSUlPT69Ws2m00ikaZMmeLo6Ojg4ODg4CAaexoLbDa7oqIiPz8/Ly8vPz8/JyeHSqXKycl5eHh4e3tPmzbNzc0N2atIeHA4nJcvXyYmJj5//jwtLY1Go+nr69va2k6ZMgW2Bjg4H7KwWKzy8vKcnJycnJzc3Nzi4mIqlaqtre3r6+vr6+vv7w8vUxcKghq9p9PpcXFxK1euVFZWBgCQSKT169c/ePCgr69PUFUIHBaLlZWVtWfPHldXVwwGg8PhZs6cee7cuc7OTqSlCYz6+voTJ074+/vDrxHMzc3Xrl176dIlIU1EEAZMJjM3N/fo0aOhoaFwX15VVXXlypV37twR56trXDCZzGfPnm3cuFFHRwcAoKKisnDhwrNnz9bV1SEt7cMwmcyMjIwff/zRy8sLh8NBEOTi4rJ///7KykqB1yUAwyotLd20aZOKigos9NChQ5IYM6y7u/vq1atz586VlpbG4/EhISFxcXEsFgtpXTzS0dFx7NgxR0dHAICiomJ4ePjVq1cnwBojFotVVlZ28OBBLy8vLBYrIyMzd+7cBw8eMBgMpKXxyOvXrzdu3AiPRdja2u7Zs+fVq1eSGxuyv7//0aNHn376KdxZsbW1PXbsWFdXl6DK592wmEzm7du3/f39IQgyNDTct29fbW2toGQhSE9Pz8WLF729vQEAJiYmhw4dkqAGF4vFio2NXbBgAYFAUFBQWLVq1T///DM0NIS0LqFAoVDOnTvn4+ODwWC0tLS2bt0qQWvU+/v7//77b3d3dwCAsbHx3r17hdEeQRC4zbhq1So5OTlpaelly5YlJSXxXywvhjU0NHTu3DkTExMsFhsWFibRLZFRKCkp2bx5s4qKipyc3JYt/9feecc1ka3/f0IooabQIgEJHQVDMRQVEBAsyLqs4qpX17tYrgV313Wx4KK44q5l7bLqqlexUlR2cRX12pAmIgGCSFM6oReBhE7y+2O+5hdBI5BJJonn/QevyczwnCdncj5zzpkzzxNSV1eHtkfCaG9vP3LkiKmpqYKCwpw5c65evSruAFXSQ2Vl5a+//mptbY3BYGbOnJmYmCjNMVUaGxvDw8N1dHTU1NSWL1+elJQkzd6KTmdn5/nz593c3CAImjx5cnR0tCjd4dEJFpfLvXjxopGRkbKy8sqVK0tKSsZcsKzQ0dFx4MABMpmMw+E2bdrU0dGBtkdDaWtr27p1q5aWlpqa2vr169+8eYO2R+jA5XITExO9vb3hqbro6GhpE4KWlpYffvhBVVVVV1d3165d4gjoJs1kZWUtXrxYUVGRSqVevHhxbL2cUQjWy5cvPTw8sFjsunXrJBxMHXW6u7sjIyN1dHQMDAyuXbuGtjv/B4fD2bdvH5FI1NfX37179+fWAD5GVlbW0qVLsViso6PjvXv30HaHx+Pxenp6Dh06RCQSx40bd/Lkyc+n8zuc8vLydevWKSoqTp48+fHjx6P99xEJVk9Pz6ZNmxQVFadMmSJnac5GRUtLy9q1axUUFDw9PVF/sHDr1i0DAwN1dfUdO3Z0dnai64wU8urVK39/fwiCZs6cie6ztrS0NDMzMxwOt23bNinsoaNCfn6+r68vBEGBgYGjmiP+tGCVlJQ4ODjg8fj//ve/0tbHRoUXL17AFXL9+nVUHGhqalqyZAkGg1mxYgWLxULFB1nhyZMndnZ2GhoakZGRkp9p7e/v37lzp6Ki4rx580pLSyVcuvTzzz//UKlUCoXy4MGDEf7LJwQrNjZWU1PTyckJVLcg3d3dwcHBGAxm3bp1En4C/fTpU11dXUNDQykZ7Eg/vb29YWFhioqKM2bMQPD5+ieprq52cnJSV1c/c+aMxAqVOd6+fbt06VIMBvPTTz+NpCkJE6wzZ85gsdi1a9fK63NxEYmLi8PhcAsWLJBYoN4rV66oqKgsXLhQznI3SYDMzEwqlWplZSWZhxL5+flGRkY2Njafw4Mp0bly5QoOh5s/f/4nI0d9VLBOnDiBwWC2b9+OtG9yxePHjzU1NWfNmtXX1yfusvbt24fBYEJDQ8HAfGzU19c7Ozvr6OhkZWWJtaDMzEwikeju7i7JDp2sk5ycDKeY5HA4Qk77sGDduXMHi8X+8ssv4vFNWuByuQ8ePAgICBAlPl9GRoa6uvqaNWsQdGw4p0+fxmAwp0+fFmspYwCROpQYXV1dfn5+enp64lulWVZWpq+vP2fOHDElBBR3hTs4OGzbtk0clj9Jfn6+jo5OQECAkNnGDwhWQUEBHNNjbKWuXLmSH9bW2Nj4zz//HJsdCVBaWnr48GEIgmbNmiWKnevXr2MwmD/++AMpx4YQHx+PxWL37ds3ZgtBQUHwO54wysrKBgYGCxYsED29+5A6vHPnTmBgIARBurq6c+fOnTt37pw5c+zt7SEICg8PF7EsROBwOFOmTDE1Na2vr0fceFtbGxzCSJTntsLrEKkf7cfw8vLas2ePOCyPhNTUVBwO9+OPP37shKGCxeVy3dzc6HS6KPeHN2/ewO+1jGpJ65YtW8Zc4piBY9GJfu3DwsJUVVXFEbG3rq6OQCCsXbtWRDtFRUUQBDk5OcFhdk6dOkUikbS0tESfZBlSh2w2e3iVRkZGSolg8Xi85uZmU1PT+fPnI255zZo1BgYGoj+6FV6HSP1oYVBpd0K4du0aBEEfy6IwVLCuXr2KxWJzc3NFKZLL5UIQ5OvrO/J/iY2NFdMd45Mgcu37+/ttbGwCAwMRcUmQwMBAa2tr0ef14ZxDgt/01q1bEAQFBweLaJk3rA4/WKU3b94UvSCkePr0KQaDuXHjBoI2nz17hqBN4XWIlGCh2O6EEBgYaGFh8cHf/FDBsrW1hWOci8ioKpTBYGhoaMi0YPF4vPj4eAwGU1RUJLopPhkZGRAEIbWCYcg37ejogFfuIW5ZfAMWBPn2229NTU0RXJzl6+s7ffp0pKwJr0NEahjddieEsrIyFRWVc+fODT/0Xhj/7Ozs/Pz87777TtQgW+9TXV19+vTpyZMnz50798WLF999952+vr6fnx+Hw4EgqLi4OCwsjM1mZ2Zmenp6hoaG8p3x8fGZMmWKhYXFwYMH+dYGBgb27t3r7Ozs4OCAwWAwGIyjo2NQUBAEQRwO58qVK7Nnz/b3979//76BgYGPjw8EQYODg2FhYa6urpaWlnQ6PT09HdkvCBMQEDB+/PgrV64gaPPs2bP29vazZs1C0CYfWA1dXV0Fd36s2sdch3DsUHh7bBeIxWItW7Zs2rRpkyZN+vrrr+GYsaITGhpaXl7++PFjRKxVVFQ8fPhw48aNiFgbgmAdfpD6+vrly5fPmDGDSqUGBASUlpbyD32sbj/Y7h49evTFF1/4+flBn2q2kNCWKCImJiYBAQEXLlz4wDFB9QoNDTU2NkbkqTn0/h0AjhFOpVIfPnzI4/EePnwIQdDvv//+sfOLioo0NDTgfPQ5OTkqKirR0dHwoS1btuDxeHjGdPv27ZDAbG5dXd3NmzchCLK1tT1y5EhERMSKFSt4PN7vv/8OQRCLxers7CQQCENyH0HIdQc2btxobW2NiCkej9fb20sgEA4ePIiUQf437e3tjYmJ0dfXH/IUWUi1j6oOBT9GR0fzf2ZjuED19fWGhoa7du3i8XhsNltLS8vNzQ2pCqHT6UFBQYiYOnz4MIFAQPDJ4MfqcPjRjo4OExMTOMNQZ2enq6urvr4+/5HCyC9cS0vLH3/8IbhHeLMV0hJF56+//lJQUBgeZvK9Wvjiiy8WL16MSHlDfsFDJlDgOUXBwciQ85cuXWpiYsL/6O7u7uzsDG/r6uryO941NTUQBAnOnsIF2djYCMruN998g8fj4W03NzdlZWUhropCXFycgoICUutIs7OzIQh69eoVItZ4PB4EQUQi0dXVFY4+ev78+SFPRYRU+6jqEC5o+vTp06ZNg/MU8A+N9gKtWbOGRCLxq3TZsmWOjo4i1MF77Nixw8rKChFTQUFBo5q0/SRC6pD3foWHhYUZGhryDyUnJ0MCU5OjunBDpvOFN1vhLVFEWltboQ9Nhrw3JKyqqoJz/yHOkAjccL4g+Pt/kMePH7e1tXm+o6mpiZ/4S1VVFU6aAEEQ/KheMIA0XJChoaFgF3rfvn0pKSmw2dra2jFnqfokcP8UThYgOpWVlRAEmZubI2INxtnZ+dmzZ3D/Pz09fUhaByHVPto6dHZ2TkpKSk1NZTKZgvtHe4H++ecfa2trfsr1y5cvMxiMsX77oVhaWlZUVCBiqrKy0tjYGBFTfD5Wh0O4fv26hYUF/6O7u7u+vv7du3fhj6O6cEPS1gpvtsJboogQiUQ8Hj/86rwnWB0dHWNLRzo2eB/Pf9HU1ESlUpPeUVhYmJeXBx/6/fffS0tL4ZFFdHS0qqrqhg0bhBdkYGBQXV3t5eVVUlJCpVKR+wZDgfNQtre3I2Ktp6dHUVFxVMlHR0hYWJidnd25c+du374tuF9ItY+5Di0sLIRc6E8ab2xsHJKiFUFUVVV7e3v5WSlFob29XXxZSIXXYWVlJX9eCcbY2Li2thbeRvzHz/dkDC1xVBAIhOFN6T3BolAo/O+JLng8vrCwsKqqir+npKQE3li4cOGqVasuXrzo4eGRmJiYkZHxyT7I8ePHAwMDT506tXbt2uGpzxEE7hgbGhoiYg2Pxw8MDCAlf4IoKSlFRUUpKSmtXr26ublZsMSPVbtY61CIcRKJVFJSIpiymMPhIFUnzc3NWlpaiCTgMTQ0ZLFYotsZAxQKBY5Ozt+joaFhYmICb4vvwo2hJY6cwcHB2tra4U3pPcEyMjJCpIcMr8P65H11CII3Og8Pj97e3sWLF8PDKxaLFRkZCR8KDQ3F4XC3bt1KTk6+efMmjUb7pOXw8HAnJycJ5E2rqKiAk48iYg12ODc3FxFr8EXhV7K9vf327dvr6+vhaW94p5BqH3kdjqHDIsS4l5dXe3v75cuX+XuioqKQyt/JZDInTJiAiKnx48eXl5cjYgoaZR36+/s3NTUlJSXx95SXly9cuBDe/uSFG3MHcwwtceTU1NT09/d/YJQtOKF17tw5NTU10aPBwbdlKysr/pwunDjb29sb/ggPpD09Pfn/oq2tTSaTc3Jyjh07xuPxcnNzcTgcBEFwvlkcDpeRkcE/E4vFmpqaWltbw3kcV65cyV9bDA8fpkyZIugPnHG7p6entrbWzMwMgiAOhwMHzIHnaAQ9EYWAgAA/Pz9ETMFMmDBh/fr1iJgqKCiAIMjU1JQfxKOvr8/Ozg6CoHXr1sExMIVU+8jrEF5Sb2tr+8HHzaO9QK9evVJTU9PU1Dx37hyDwdi9ezdS0Vr6+vr09fXh54+ic/36dSwWi1R4MuF1OKTC6+rq9PT0nJyc4OiA169fNzMz40cKFFK3vGHtDu7J8tup8GYrvCWKyLFjxzQ1NYe/CP2eYDU1NSkpKcXGxopS0qpVq/ivrVEolD///JPFYgUHB0MQpKamdurUKRaLBS9XUVNTO3nyJHxJzpw5QyKRXFxc+FWZlpbm4uKirKxsYWHx119/8e0nJCQYGhoaGxurqakpKPxfD3Hq1Kk8Hq+ysnL9+vUQBMFvbr99+xb+l5iYGG1tbW9v75MnT4aEhBCJxPDw8Obm5oaGhu+//x6CIBwOd+zYMRGfSbe3t6uqqp4/f14UI0M4cOAAgUAQPaJuUFAQf4aFSqUeOnQI3p+bmwsPE7S0tOLi4ngfr/YR1uGyZcv4BZmbm+fl5Qm6MdoLBB99/vz51KlTVVRUJkyYEBUVJWJV8IEfnCMVjLS7u5tIJPIrVhRWrVolpA4/+KMtLi728/MzNjb28fEJCgoSfE1SeN0Ktjs2m71lyxYIgjQ0NGJiYj7ZbIW0RNFxcnL64IqToSvdAwICaDSaNKdFW716dXFxMf9jZ2dnXFyclpYWii7BhIWF4fF4ZCNV1dfXa2hoREREIGgTwHvXu/ziiy8QtPnDDz+MGzeOr8Jyj/haYkJCAgaDSU9PH35oqGCVlpbicLgjR46IXqo4SExMdHd3H7KzoqJCHC+yjoqioiJlZeXjx48jbvnEiRPKysqih1UACLJr1y4NDQ1kX1Zvb28fN26c6K+pywTia4lv374dN27cv//97w8e/UB4mZCQEDwej+w7cUgRFxenoaGRkJDAH9uzWCwER85jo6+vz8PDY8KECeII49ff3+/o6Ghvb9/e3o648c+TpKQkFRUVUcL1fAw4SO+dO3cQtyxtiK8lfvvtt1paWh+z8wHBgpsflUptbGwUsWxxkJiYOHPmTBqN5u7uHhAQsHPnTtTjOsKLiQsLC8Vkn8ViUalUFxcXNpstpiI+HxgMhqam5ooVK8QUuHXDhg2qqqrPnj0Th3GpQhwtMSwsTEVFJSkp6WMnfDjiaE1NjYGBgbu7O7irf5Jdu3ZhMBhxZ9DJz88nEolz5swBV0QUnj9/TiaTfXx8xJemoK+vz8fHh0wmMxgMMRUhrxw8eBCDwZw6dUrIOR+N6Z6Xlzdu3Dg6nQ7Sc34MLpf7448/YrFY4VWMFFlZWePGjbOxsQEZjMbGtWvXcDicn5+fuNM4tre3+/r6amho3L59W6wFyQ0DAwPBwcEKCgqffMwqLGtOWVmZhYWFlZUVk8lE1D15oL29/euvv1ZRUZFkdsLKykpbW1tdXd1bt25JrFA5oLu7OyQkBIPBBAcHS+YJeF9fX1BQkKKi4sGDByWfD1G2aGhomDt3rqqq6khiH34iL2FDQ4OnpycOh5NMJ0JWyMrKMjc3J5PJQgbbYqK9vX3VqlUYDOZf//oX6PyOhNTUVCsrKwKBcPHiRQkXfeDAAWVlZQ8PD9TzhEst8fHxenp6JiYm/CXKwvl05ueBgYHw8HAsFjt79myQZI3NZm/btk1FRcXX11ccWQxGSGJiIoVC0dPTO3v2rDQvmkOXhoaGdevWKSgozJ49e3hkJcnAYDAmTJigqal59OhRCeSCkyFqamqWLl0KQdDy5ctHPjP7acGCSUtLs7e3V1FRCQsLE544TI65ceOGkZERkUj8448/UO/nt7W1bd68GYfD2djYfA7P0UcFh8OJiIjQ1NSkUqnXrl1DN5Mjh8MJDw9XU1OztrZOTExE0RMpoaurKyIiQl1d3dLScrSTGyMVLB6PNzAwcOLECQKBoKMhLYGrAAAdF0lEQVSjs2/fPnHPXEoPXC7377//dnR0xGAwK1askKrVHhUVFXCm70mTJkVFRYEc3SwWa+vWrQQCgUQiHTx4UGJJuT9JVVXVkiVLMBjM5MmTb9y4gfoNDxVaW1t3796to6MDh9Idw891FIIF09TUFBoaqqmpqaOjs3fvXvl+EWFgYCA+Ph4OWR0QEJCTk4O2Rx8mMzMzMDAQi8VSKJT9+/fz3xT7rGAymUFBQcrKyjo6Oj///LN0VgKDwVi4cKGCgoK1tfWFCxfElGxVCqmpqdm8ebOmpiaJRBJ8mXG0jFqwYJqbm7dv347H49XU1IKCgkY4YSZD1NTU7N69e/z48Vgsdv78+SLmPZMMFRUVISEhJBJJWVk5ICAgPj7+c+hw1dXVHT58GM4zSqPRzp49K/q74uKmuLh4xYoVOByOSCQGBwfL8Yqtnp6euLi4OXPmYLFYQ0PDgwcPijgyG6NgwXA4nPPnz8NpV2g02t69e6XzhZ6R09LSEhUV5e/vr6ioSKFQdu7cKY7cqGKlp6cnNjZ29uzZWCyWRCKtXLny5s2b8jd+Lysri4yMnDlzJhaLJRAI69evf/HiBdpOjY7m5ubDhw/DAbloNFpERIRM3BdHQnd39507d9asWQOHoPH397916xYiT4dEEiw+ubm5//nPf3R1dSEIsrGx2bFjR0ZGhgw9vSotLT158qSvr6+SkpKKioqfn198fPyo0lZLIdXV1Xv37nVxcVFQUFBWVvbx8Tl8+DCTyZTd2RM2m/3gwYPNmzdPnDgRjoKyYMGCa9euyfrAKjk5+T//+Q8c95FKpX7//ff37t2TxdewqqqqLly4sGDBAg0NDQiCHBwc9uzZU11djWARGN4o44IKYXBwMCUlJT4+Pi4urqGhgUgkent7+/r6enp6WlpaCk+sJnkaGxtTU1MfPHjw4MGD0tJSZWXlefPmzZ8/f+7cuVpaWmh7hyR1dXX//PPPrVu3njx50tXVRSKR3N3dPT093dzcaDSaOGLGI0hra+vz58+Tk5OTk5NfvHjR399PoVDmzp375Zdfent7w+EG5YPBwcG0tLSbN28mJCRUVlYqKSm5uLh4e3t7eXnR6XRYAqQQFouVmpr65MmTx48fv379GovFuri4fPXVV/Pnzzc1NUW8OCQFi8/g4GB2djasBenp6X19fQQCwfkdNBoN8fwiI6GtrS0/P//FixeZmZnPnz+Hg0FPnDjR19cXztkrtb8JpOjr63vx4sXTp0+Tk5PT0tLYbLaSkpKtra2Dg4ODg4O9vb21tbWOjg6KHg4ODlZVVRUUFGRnZ+fk5GRnZ8Opg4yMjDw9PadPn+7h4SGYIUZeefPmDSwBT548aWhowGKxVlZWdDqdTqc7OjpOmDCBRCKh4hiPx6usrMzPz2cwGFlZWVlZWfX19RgMxtbW1tvb29vbe/r06WJNZCMWwRKEw+EwGIzMd8C/Pw0NDWtr6wkTJkycONHExMTIyMjY2JhMJiOSDgCCoJaWlurq6urq6oqKiqKioqKiooKCAjglER6Pd3JygqXTxcWFTCYjUqLMMTAw8OrVK74uMJlMOH0TiUSysLCwtLS0tLQ0NjY2NDQcN27c+PHj1dTUkHWgsbGxrq6uurqaxWKVlZWVlJSUlJSUlpbCUXopFIqDg4OjoyP8V0zZ56QfHo/3+vXrrKwsWCBycnLgsMW6urrW1tbW1tYWFhZUKpVCoRgbG+vr6w/J2yYK3d3dVVVVLBarpqbmzZs3xcXFJSUlxcXFcIBmIyOjyZMn09+hra2NVLnCEbtgDaG5uTk/Px9WkMLCwuLiYhaLBedHUFJSMjAwIJPJ2u8jXMXa29ubm5tbBKioqOjq6oKPkkgkc3NzGxsbQX3kh3MF8OFyueXl5a9fv4aF4/Xr169fv2axWPw0dng8nkKhkEgkEolEJBLhv0Qi8ZMjSjab3dbW1tbW1traCv9tamqqra3lJ8LB4XCWlpYW77C0tES9oye1cLncsrKy4uLioqKi4uLivLw8BoMBT0pCEITFYslk8rhx47S1tUkCfPJm8/bt25aWltbW1tbWVniDxWLBqUwhCFJRUTEyMrKysrK2traysrKyspo4cSJaF0jSgjWc/v5+FotVXV1dWVlZXV3d1NTElx64+rhcLpfLHZLZSU1NDU6uqaWlRSKRdHV1YXUjkUiGhoZGRkbjx483NjaGUz8CxgaPx2toaKitrYVvs/X19XzRaXsHnFSCzWYPyR6orq4Oa5m6ujq8jJMvc9ra2oaGhgYGBhQK5cqVK0eOHHn+/PmkSZPQ+ZIyS3d395QpU7BYbFJSUktLS01NTVVVVW1tbUNDQ+v7wH2irq4uwWxpEARpamrCPTI8Hk8ikQRlTl9f39jYGE5gIVWjEPQFC/A5w+VyZ82aVVFRwWAw5OxZh7gJDg6+evUqg8GAc+F8JoDBEQBNFBQUrly5wmazV69ejbYvssSVK1dOnTp16dKlz0qtICBYANTR19ePioq6cePGuXPn0PZFNigsLFy3bt133303b948tH2RNGBICJAKQkNDjx49mpGRAed2BXyMrq4uFxcXLS2tpKQkZFPPywRAsABSwcDAgKenZ1tb24sXLxBfQiFPrFq16u+//87JyTEyMkLbFxQAQ0KAVKCoqBgTE9PQ0PDdd9+h7Yv0cvHixfPnz1+8ePHzVCsICBZAejA0NLx48eKFCxcuX76Mti/SyKtXr4KDg0NCQubOnYu2L6gBhoQA6eLHH388e/ZsVlaWtbU12r5IEZ2dnXQ6XV9f//HjxwguZ5c5gGABpIv+/n4PDw8Oh/P8+XNVVVW03ZEWlixZ8ujRo+zsbENDQ7R9QRMwJARIF0pKSlevXq2qqgoJCUHbF2nh7Nmz169fj46O/szVCgKCBZBCTE1Nz507d/LkyejoaLR9QZ/s7Ozvv/8+NDR0xowZaPuCPmBICJBS1q1bFx0dnZ2dLY6wSrJCe3s7nU43MTG5d+8eeGkfAoIFkFp6enqmTp2KxWLT0tKkPMqg+Pj6669TU1NzcnL09fXR9kUqAJoNkFJwOFxsbGxxcXFoaCjavqBDZGRkfHz8tWvXgFrxAYIFkF4sLCzOnDlz5MiRhIQEtH2RNM+ePdu0aVN4eLinpyfavkgRYEgIkHaCgoISEhJycnJQiayNCi0tLY6OjhMnTrxz5w6YuhIECBZA2uFwOM7OzpqamikpKZ/D6748Hm/evHkvX77Mzs5GK3a71ALEGyDtqKurx8XFvXz5cteuXWj7IgkOHz58//79mJgYoFbDAYIFkAFsbGyOHDmyb9++//3vf2j7Il5SU1O3bdu2Z88eOD8xYAhgSAiQGZYtW/bgwYOcnBwDAwO0fRELzc3NDg4OdDo9Pj5e2vJ4SglAsAAyA5vNptPpZDL50aNHSGWEkx64XK6/v39RURGDwSASiWi7I6WAISFAZtDQ0IiLi3v+/Pmvv/6Kti/Is2/fvkePHsXGxgK1EgIQLIAsQaPR9u/f/8svvzx69AhtX5Dk4cOHO3bsOHDggJOTE9q+SDVgSAiQPebPn5+enp6bmytVKfPGTF1dnYODg5ub240bN9D2RdoBggWQPd6+fevo6GhlZSUH6yoHBwd9fX1ra2tfvHihqamJtjvSjmxfbMDnCYFAiImJefz48cGDB9H2RVQiIiIyMjLi4uKAWo0EIFgAmcTZ2TkiIuLnn39OS0tD25exc//+/YiIiMOHD9NoNLR9kQ3AkBAgq/B4vICAgJycnJycHG1tbbTdGTUsFsvBwWH27NmXLl1C2xeZAQgWQIZpampycHBwcHC4deuWbK207O/vnz59+tu3bzMzMzU0NNB2R2YAQ0KADKOrq3vt2rW7d++eOHECbV9Gx86dO5lMZlxcHFCrUQEECyDbeHh47Ny5c8uWLQwGA21fRkpCQsL+/fsjIyNtbW3R9kXGAENCgMzD5XJnz55dVlbGYDDweDza7nyCiooKR0fHL7/88sKFC2j7InsAwQLIAw0NDfDay7i4OLR9EUZfX5+7u3tfX9+zZ89wOBza7sgeYEgIkAf09fWvXr0aHx9/5swZtH35/5SXl3d0dAju2bZtW1FRUVxcHFCrsQEECyAneHl5bd269YcffsjNzYX3VFVVubq6Ojg4oOJPf3+/g4ODra1tdnY2vOfmzZtHjx49c+aMhYUFKi7JAWBICJAfBgYGvLy8GhoaGAzG48ePv/nmGw6Hw+Vy37x5Y2ZmJmFn7t+/P3v2bAUFBSwWe+LECV9f38mTJy9atOj06dMS9kSeAIIFkCsqKirs7e2trKwyMzPhPUpKSnv27NmyZYuEPVm1atWlS5f6+/shCFJQUCCTyXg8PisrS01NTcKeyBNgSAiQKzo7OwkEAn8UBkHQwMCA5KMgwIXCagVBEJfLbWpq6ujoKCkpkbAncgYQLID8cOzYMTqdzmKxBgYG+Dt5PF5WVlZdXZ0kPUlJSWlvbxfc09/f39DQ4OzsfOzYMUl6ImcAwQLICcHBwRs3buzr6xNUKxgMBpOYmChJZxISEoZnJBsYGOjv79+4cePWrVsl6Yw8AQQLICcwGIyPxcbCYDDx8fES84TH48XGxvLHg4LAHg6XVMAIAYIFkBNSU1N/++03JSUlZWXlIYcGBwcfPHgwZEmU+MjMzKyvrx++H4vFGhkZpaSkHDp0SDKeyB9AsABygqKi4tatW7OzsydMmDA8p87AwMC9e/ck40l8fPwQ0VRQUMBgMJs2bSooKHBzc5OMG3IJECyAXGFra5uVlfXrr78qKioqKiry92Ox2L/++ksyPsTExPT19QkWbWxsnJKScuDAAbCmQUTAOiyAfPLy5culS5cWFBQMDg7Ce9TV1VtbW4cPGJElLy/Pzs4O3sZisTweLyQkZNeuXaqqqmIt9zMB9LAA8smkSZMYDMavv/6KxWLhB3YcDicpKUnc5cbHx8PF8TtW+/fvB2qFFKCHBZBzUlNTv/nmG3hx1oYNG44fPz7khLfvaGtrg7tjXV1dvb29gucoKCjwA9fg8XgCgUAgEIhEouCoE8bGxqagoACDwaxZs+bAgQMgtQSyDK1uAEDOsLe3j4mJ2bNnz+3bt6OiogYGBlgsVn19fXNzc1tbW1tbmyjGNTQ0YPGiUChkMplAIBQUFGhra4eHhy9atAioFeKAHhZAfoDfc2YymUVFRaWlpW/evCktLYVXGCgqKuLxeCUlJTs7Oz09PV1dXV1dXSKRyO8rwRvDV3sOh98dE9yoq6trbGxsamoqLS1ls9nd3d0QBGlqapqZmZmZmZmbm5ubm9vZ2dna2oLhoSgAwQLIMIODg0wm89mzZ0wmk8lk5ufnd3V1YTAYExMTS0tLKysry3cYGRlJMktFW1tbSUlJcXFxcXHx69evS0pKioqKent7sVishYUFjUazs7NzcnJydXUFvbBRAQQLIGN0d3enpqampaWlpaVlZGSw2Wx1dXU7OztYBWg02qRJk6RQBQYGBoqLi/Py8mBtzc3Nra+vx2KxNBrNzc1t6tSpnp6eZDIZbTelHSBYANmgrKzs7t27iYmJT5486e7uHjdu3LR3ODg4DJ/8ln5KS0vT0tLS09NTU1MLCwt5PJ6jo+OcOXP8/PycnZ2Hr30FQECwAFLOq1evYmJibty4UVRURCAQZs6c6efn5+PjQ6FQ0HYNSTo7O9PS0hITExMTE0tLS7W1tefNm7do0aIZM2bIohaLDyBYAGmksbHx7NmzMTEx+fn5FApl4cKFX3311dSpUz+H1ltSUnLr1q3Y2NisrCwdHZ3AwMCVK1fS6XS0/ZIKgGABpIvU1NRTp07dvHlTU1MzMDBw8eLF7u7uHwvDIN+UlpbGxMTAqu3q6rpu3bqvv/76c89ewQMApIC+vr4///wTTixKp9MvXrzY09ODtlPSQkpKyqJFi5SUlLS1tUNCQurr69H2CDVADwuAMoODg1evXv3ll1+qq6sXLVq0fv36KVOmoO2UNMJisf78888zZ86w2ewNGzZs3rxZW1sbbackDtqKCfisSU5OnjhxIhaL/fe//11aWoq2OzIAm83et2+ftra2lpbWsWPHBgYG0PZIogDBAqBDY2NjUFAQBoOZPXs2/FAfMHLa29tDQ0OVlJQcHR0zMzPRdkdyfI5zmQDUuX37trW19f/+97/Y2Ni7d+9aW1uj7ZGMoaWl9dtvv+Xm5mpqarq6um7bto0fRUe+AYIFkChcLjc8PHzevHl+fn6FhYULFy5E2yMZZuLEiU+ePDl58uTRo0dnzpzZ2NiItkdiB0y6AyRHT09PYGDggwcPDh06tGHDBrTdkR+ysrIWLFjA5XLv3btnY2ODtjtiBPSwABKir69vwYIF6enpT548kUK14vF4Dx8+/Oqrr/z9/ZE9WQLQ6XQGg2FsbOzj4/P69Wu03REjQLAAkoDH4/3rX/9KSUm5e/fu1KlTx2xnxYoVJBIJ8w4VFRUKhRIYGJifny+ih+Xl5S9fvvz777/hHFyJiYkLFy7EYDB6enr+/v7+/v5+fn4ODg4YDGbXrl1DTpYGdHR0EhMTjYyMZsyYwWKx0HZHbKA75w/4TIiMjFRUVExKShLdVFFREQRBTk5OTCbz5cuXp06dIpFIWlpaJSUlIlqGM0fMmjUL/shmswU/wkRGRoaHhw8/WUS2bNmCiJ2WlhYrK6uZM2dyuVxEDEoboIcFEDuvXr366aefwsPDp0+fLro1c3NzCIJIJBKNRrO1tV27dm1UVFRHR4foKeCHRO9TV1cffk5wcDCNRht+sijExcUxmUxETJFIpJiYmKSkJNFrQzoBggUQO+Hh4VZWVkjlZx8ed8XT0xOCoIaGBkTsf5L58+cjaC07O3vlypUIGrS3t9+8eXN4eDjcQ5QzgGABxAuLxUpISNi2bRuCXZIhZGRkQBDk6uoquDM7O9vHx2fKlCkWFhYHDx7k7x8cHAwLC3N1dbW0tKTT6enp6SMshc1mC49ZWl9fv3z58hkzZlCp1ICAgNLS0k8WWlxcHBYWxmazMzMzPT09Q0NDR+iMcEJCQgYGBi5fvoyINekC7TEpQM7Zv3+/jo5Od3c3gjahd5NHvb29MTEx+vr6Hh4eHA6Hf0JRUZGGhsbly5d5PF5OTo6Kikp0dDR86Pfff4cgiMVidXZ2EgiEiRMnftDy8I/R0dFD2ovg0Y6ODhMTkytXrvB4vM7OTldXV319ff5byqMqFBGWL1/u4uKCrE1pAAgWQLz4+fktWbIEWZsQBBGJRFdXV7jXdv78+f7+fsETli5damJiwv/o7u7u7OwMb3/zzTd4PB7ednNzU1ZWHmJ5iGARicTp06dPmzYNTh7xsZPDwsIMDQ35h5KTkyEICg4OHkOhiHD9+nUsFstms5E1izpgSAgQL2VlZRMmTEDcrLOz87Nnz+AxVHp6+pDAfo8fP25ra/N8R1NTE5zGBoKgffv2paSkwOfU1tYK5pT/WEFJSUmpqanC58WvX79uYWHB/+ju7q6vr3/37t2xFSo61tbWg4ODFRUV4i5IwgDBAoiX7u5u8SW2CgsLs7OzO3fu3O3btwX3NzU1UanUpHcUFhbm5eXBhwwMDKqrq728vEpKSqhU6sjLsrCw4H38tZDKykoOhyO4x9jYuLa2VsRCxwz8iJMv03IDECyAeCEQCM3NzWIyrqSkFBUVpaSktHr1asFS8Hh8YWFhVVUVf09JSQm8cfz48cDAwFOnTq1duxbB5wAUCqW8vFxQ0TQ0NExMTMRaqBCampogCCISiRIoS5IAwQKIl0mTJuXk5CBokMvlQhDED05gb2+/ffv2+vr6FStW8PXCw8Ojt7d38eLF1dXVEASxWKzIyEj4UHh4uJOT00jiQ4wq/oG/v39TU1NSUhJ/T3l5Of/V7k8WinishezsbEHFlB/QnUIDyD2XLl1SUVFpbW1FymBBQQEEQaampvzYdX19fXZ2dhAErVu3rquri8fj5ebmwrHPMRiMkZERDofLyMiAT6ZQKBQKpaenp7a21szMDIIgDocDxw6EB1Cenp7wmfCSeltb2w+uGh9ycl1dnZ6enpOTU0dHB4/Hu379upmZGbwtvFAej6etrU0mk3Nyco4dO4ZULc2aNeurr75Cypr0AAQLIF46OjoIBMJvv/2GiLWgoCACgQDfa6lU6qFDh+D9ubm58FBLS0srLi6Ox+OlpaW5uLgoKytbWFj89ddffAsxMTHa2tre3t4nT54MCQkhEonh4eHNzc0NDQ3ff/89BEE4HO7YsWPLli3jF2Rubp6XlyfoxpCT4UUbxcXFfn5+8BvIQUFBgpHXP1YofPTMmTMkEsnFxQWpmKsFBQUKCgoJCQmIWJMqQHgZgNjZsWPH0aNH8/Ly5HCEIn1wuVwvL6/W1lYmkyl/2YaAYAHETm9vr7Ozs7q6ekpKCkhoLG4OHjz4888/Z2ZmwsNkOUPeBBgghaioqJw7d47BYOzYsQNtX+Scp0+f7ty58+eff5ZLtYIgSP7z6AKkAScnp1u3bn355ZdYLDYiIgJtd+STp0+f+vn5BQUFyfGNAbtr1y60fQB8Fpibm5uYmGzatInD4Xh5ecnf9Aq63L59e9GiRXPnzj179qwc163cfjGAFLJ06dKYmJiTJ09+JhkTJAOXy925c+e8efOWLFly6dIl+Z4lBJPuAEmTl5cXEBDQ09Nz7NgxkDVHRMrLy9esWZOcnBwZGblq1Sq03RE7oIcFkDQ0Gi0rK2v27NmLFi2aN28evBgdMFr6+vr27t1ra2vb0tKSnp7+OagVBAQLgAokEun8+fOPHj0qKiqysbH57bff5DI8ppjg8Xh///23vb39nj17du/e/fz5c0dHR7SdkhBAsACo4eXllZeX9+OPP+7fv9/U1PTIkSPyF10Ace7evevs7LxgwYKJEye+fPnyp59+GhJaR74Bc1gA9GltbT169Ojx48cxGExQUFBwcDD8wh2AT2dn56VLlyIjI0tKShYsWLBjx45Jkyah7RQKAMECSAutra2RkZFnz56tra318/MLDg729fWV72deI6GwsPD06dNRUVH9/f2LFi3auHGjvC4KHQlAsADSxeDg4D///HP69OmHDx/q6OgEBgYuXrx46tSpcry26IOUl5fHxsbGxMQwmUxra+vVq1d/++23JBIJbb9QBggWQEqpra2NiYm5cuVKTk6OkZHRF198MXPmTG9vb01NTbRdExeDg4MvXry4f/9+YmJiZmYmmUxetGjR0qVLnZyc0HZNWgCCBZB2CgoKYmNj79y5k52draioOGXKlJkzZ06fPp1Op8NBr2QaHo9XVFSUkpLy4MGDR48etbW1GRkZzZkzZ/78+T4+PmBEPAQgWACZoaGh4e7du4mJiY8ePWptbVVRUZk8efK0adPc3NwmT55MoVDQdnCkdHR0MJnM9PT0tLS09PT0lpYWZWVlV1dXPz+/OXPmwJmlAR8ECBZA9uDxeAUFBWnvgFOWamtr29nZ0Wg0Go02adIkc3NzfgQ+dOnt7S0vLy8oKMjLy8vLy2MymXD0dxKJNHXq1GnTpk2bNo1Op4svVYc8AQQLIPM0NjYymUwmkwkrQmFhIZxHS1tb28zMzNzc3MzMjEqlkslkQ0NDfX19PT094Tmcx0ZnZ2dNTU1DQwOLxaqpqSl9R3V1NRyHnkql0mg0WFXt7OzMzc3F4YZ8AwQLIG/09/fDSvHmzRv4b1lZWVVVFX9VqpKSkp6enr6+PpFIJBAIBAKBvzGSlDZv3759+/ZtW1sbf6Otra2mpqarqws+QVFRkUwmmwlgbm5ubm6Ox+PF+LU/D4BgAT4X2tvba2tr6+vrWSxWfX19c3MzrDVvBRgYGIAgqKurq7e3V/B/FRQU+HKDx+OHyByRSDQwMCCTyRQKhUwm6+npfW6LMCQGECwAACAzgPsAAACQGYBgAQAAmQEIFgAAkBmAYAEAAJnh/wH6YjTDFTMmXQAAAABJRU5ErkJggg==" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/numerics.png>
</div>
<p><font>Conversions between concrete numeric types ( from : left column, to : top row ) is accomplished with several generic functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>具体数字类型之间的转换（从：左列，到：顶行）是通过几个通用函数完成的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left></th>
<th align=left><font>Double</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双倍的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Float</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂浮</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Int</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>诠释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Word</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Integer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Rational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>合理的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Double</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双倍的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromRational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自理性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>toRational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>到理性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Float</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂浮</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromRational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自理性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>toRational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>到理性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Int</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>诠释</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Word</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Integer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromIntegral</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自积分</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Rational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>合理的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromRatoinal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自Ratoinal</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>fromRational</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>来自理性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>truncate</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>截短</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>id</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ID</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<h2 id=integer><font>Integer</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><code>Integer</code><font> type in GHC is implemented by the GMP (</font><code>libgmp</code><font>) arbitrary precision arithmetic library. Unlike the </font><code>Int</code><font> type the size of Integer values is bounded only by the available memory. Most notably </font><code>libgmp</code><font> is one of the few libraries that compiled Haskell binaries are dynamically linked against.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC中的Integer类型是由GMP（libgmp）任意精度算法库实现的。与 Int 类型不同，Integer 值的大小仅受可用内存的限制。最值得注意的是 libgmp 是为数不多的编译 Haskell 二进制文件动态链接的库之一。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>An alternative library </font><code>integer-simple</code><font> can be linked in place of libgmp.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以链接替代库 integer-simple 来代替 libgmp。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://www.well-typed.com/blog/32/>GHC, primops and exorcising GMP</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：GHC、primops 和驱魔 GMP</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=complex><font>Complex</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>复杂的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell supports arithmetic with complex numbers via a Complex datatype from the </font><code>Data.Complex</code><font> module. The first argument is the real part, while the second is the imaginary part. The type has a single parameter and inherits it's numerical typeclass components (Num, Fractional, Floating) from the type of this paramater.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 通过 Data.Complex 模块中的 Complex 数据类型支持复数算术。第一个参数是实部，第二个是虚部。该类型有一个参数，并从该参数的类型继承其数值类型类组件（Num、Fractional、Floating）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- 1 + 2i</span>
<span class=kw>let</span> complex <span class=fu>=</span> <span class=dv>1</span> <span class=fu>:+</span> <span class=dv>2</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Complex</span> a <span class=fu>=</span> a <span class=fu>:+</span> a
<span class=ot>mkPolar ::</span> <span class=dt>RealFloat</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Complex</span> a</code></pre></div>
<p><font>The </font><code>Num</code><font> instance for </font><code>Complex</code><font> is only defined if parameter of </font><code>Complex</code><font> is an instance of </font><code>RealFloat</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>只有当 Complex 的参数是 RealFloat 的实例时，才会定义 Complex 的 Num 实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=dv>0</span> <span class=fu>:+</span> <span class=dv>1</span>
<span class=dv>0</span> <span class=fu>:+</span> <span class=dv>1</span><span class=ot> ::</span> <span class=dt>Complex</span> <span class=dt>Integer</span>

λ<span class=fu>:</span> (<span class=dv>0</span> <span class=fu>:+</span> <span class=dv>1</span>) <span class=fu>+</span> (<span class=dv>1</span> <span class=fu>:+</span> <span class=dv>0</span>)
<span class=fl>1.0</span> <span class=fu>:+</span> <span class=fl>1.0</span><span class=ot> ::</span> <span class=dt>Complex</span> <span class=dt>Integer</span>

λ<span class=fu>:</span> exp (<span class=dv>0</span> <span class=fu>:+</span> <span class=dv>2</span> <span class=fu>*</span> pi)
<span class=fl>1.0</span> <span class=fu>:+</span> (<span class=fu>-</span><span class=fl>2.4492935982947064e-16</span>)<span class=ot> ::</span> <span class=dt>Complex</span> <span class=dt>Double</span>

λ<span class=fu>:</span> mkPolar <span class=dv>1</span> (<span class=dv>2</span><span class=fu>*</span>pi)
<span class=fl>1.0</span> <span class=fu>:+</span> (<span class=fu>-</span><span class=fl>2.4492935982947064e-16</span>)<span class=ot> ::</span> <span class=dt>Complex</span> <span class=dt>Double</span>

λ<span class=fu>:</span> <span class=kw>let</span> f x n <span class=fu>=</span> (cos x <span class=fu>:+</span> sin x)<span class=fu>^</span>n
λ<span class=fu>:</span> <span class=kw>let</span> g x n <span class=fu>=</span> cos (n<span class=fu>*</span>x) <span class=fu>:+</span> sin (n<span class=fu>*</span>x)</code></pre></div>
<h2 id=scientific><font>Scientific</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>科学的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Scientific provides arbitrary-precision numbers represented using scientific notation. The constructor takes an arbitrarily sized Integer argument for the digits and an Int for the exponent. Alternatively the value can be parsed from a String or coerced from either Double/Float.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scientific 提供使用科学记数法表示的任意精度数字。构造函数采用任意大小的 Integer 参数作为数字，并采用 Int 作为指数。或者，该值可以从 String 解析或从 Double/Float 强制转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>scientific ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Scientific</span>
<span class=ot>fromFloatDigits ::</span> <span class=dt>RealFloat</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Scientific</span></code></pre></div>
<div class=sourceCode include=src/19-numbers/scientific.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Scientific</span>

c, h, g, a,<span class=ot> k ::</span> <span class=dt>Scientific</span>
c <span class=fu>=</span> scientific <span class=dv>299792458</span> (<span class=dv>0</span>)   <span class=co>-- Speed of light</span>
h <span class=fu>=</span> scientific <span class=dv>662606957</span> (<span class=fu>-</span><span class=dv>42</span>) <span class=co>-- Planck's constant</span>
g <span class=fu>=</span> scientific <span class=dv>667384</span>    (<span class=fu>-</span><span class=dv>16</span>) <span class=co>-- Gravitational constant</span>
a <span class=fu>=</span> scientific <span class=dv>729735257</span> (<span class=fu>-</span><span class=dv>11</span>) <span class=co>-- Fine structure constant</span>
k <span class=fu>=</span> scientific <span class=dv>268545200</span> (<span class=fu>-</span><span class=dv>9</span>)  <span class=co>-- Khinchin Constant</span>

<span class=ot>tau ::</span> <span class=dt>Scientific</span>
tau <span class=fu>=</span> fromFloatDigits (<span class=dv>2</span><span class=fu>*</span>pi)

<span class=ot>maxDouble64 ::</span> <span class=dt>Double</span>
maxDouble64 <span class=fu>=</span> read <span class=st>"1.7976931348623159e308"</span>
<span class=co>-- Infinity</span>

<span class=ot>maxScientific ::</span> <span class=dt>Scientific</span>
maxScientific <span class=fu>=</span> read <span class=st>"1.7976931348623159e308"</span>
<span class=co>-- 1.7976931348623159e308</span></code></pre></div>
<h2 id=statistics><font>Statistics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>统计数据</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode include=src/19-numbers/stats.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Vector</span>
<span class=kw>import </span><span class=dt>Statistics.Sample</span>

<span class=kw>import </span><span class=dt>Statistics.Distribution.Normal</span>
<span class=kw>import </span><span class=dt>Statistics.Distribution.Poisson</span>
<span class=kw>import qualified</span> <span class=dt>Statistics.Distribution</span> <span class=kw>as</span> <span class=dt>S</span>

<span class=ot>s1 ::</span> <span class=dt>Vector</span> <span class=dt>Double</span>
s1 <span class=fu>=</span> fromList [<span class=dv>1</span>, <span class=dv>2</span>, <span class=dv>3</span>, <span class=dv>4</span>, <span class=dv>5</span>, <span class=dv>6</span>, <span class=dv>7</span>, <span class=dv>8</span>, <span class=dv>9</span>, <span class=dv>10</span>]

<span class=ot>s2 ::</span> <span class=dt>PoissonDistribution</span>
s2 <span class=fu>=</span> poisson <span class=fl>2.5</span>

<span class=ot>s3 ::</span> <span class=dt>NormalDistribution</span>
s3 <span class=fu>=</span> normalDistr mean stdDev
  <span class=kw>where</span>
    mean   <span class=fu>=</span> <span class=dv>1</span>
    stdDev <span class=fu>=</span> <span class=dv>1</span>

descriptive <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> range s1
  <span class=co>-- 9.0</span>
  print <span class=fu>$</span> mean s1
  <span class=co>-- 5.5</span>
  print <span class=fu>$</span> stdDev s1
  <span class=co>-- 3.0276503540974917</span>
  print <span class=fu>$</span> variance s1
  <span class=co>-- 8.25</span>
  print <span class=fu>$</span> harmonicMean s1
  <span class=co>-- 3.414171521474055</span>
  print <span class=fu>$</span> geometricMean s1
  <span class=co>-- 4.5287286881167645</span>

discrete <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> S.cumulative s2 <span class=dv>0</span>
  <span class=co>-- 8.208499862389884e-2</span>
  print <span class=fu>$</span> S.mean s2
  <span class=co>-- 2.5</span>
  print <span class=fu>$</span> S.variance s2
  <span class=co>-- 2.5</span>
  print <span class=fu>$</span> S.stdDev s2
  <span class=co>-- 1.5811388300841898</span>

continuous <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> S.cumulative s3 <span class=dv>0</span>
  <span class=co>-- 0.15865525393145707</span>
  print <span class=fu>$</span> S.quantile s3 <span class=fl>0.5</span>
  <span class=co>-- 1.0</span>
  print <span class=fu>$</span> S.density s3 <span class=dv>0</span>
  <span class=co>-- 0.24197072451914334</span>
  print <span class=fu>$</span> S.mean s3
  <span class=co>-- 1.0</span>
  print <span class=fu>$</span> S.variance s3
  <span class=co>-- 1.0</span>
  print <span class=fu>$</span> S.stdDev s3
  <span class=co>-- 1.0</span></code></pre></div>
<h2 id=constructive-reals><font>Constructive Reals</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>构造实数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Instead of modeling the real numbers on finite precision floating point numbers we alternatively work with </font><code>Num</code><font> which internally manipulate the power series expansions for the expressions when performing operations like arithmetic or transcendental functions without losing precision when performing intermediate computations. Then we simply slice off a fixed number of terms and approximate the resulting number to a desired precision. This approach is not without its limitations and caveats ( notably that it may diverge ).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们不是在有限精度浮点数上对实数建模，而是使用 Num，它在执行算术或超越函数等操作时在内部操纵表达式的幂级数展开，而不会在执行中间计算时丢失精度。然后我们简单地切出固定数量的项并将结果数近似到所需的精度。这种方法并非没有限制和注意事项（特别是它可能会发散）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">exp(x)    <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> x <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>2</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>2</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>6</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>3</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>24</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>4</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>120</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>5</span> <span class=fu>...</span>
sqrt(<span class=dv>1</span><span class=fu>+</span>x) <span class=fu>=</span> <span class=dv>1</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>2</span><span class=fu>*</span>x <span class=fu>-</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>8</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>2</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>16</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>3</span> <span class=fu>-</span> <span class=dv>5</span><span class=fu>/</span><span class=dv>128</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>4</span> <span class=fu>+</span> <span class=dv>7</span><span class=fu>/</span><span class=dv>256</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>5</span> <span class=fu>...</span>
atan(x)   <span class=fu>=</span> x <span class=fu>-</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>3</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>3</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>5</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>5</span> <span class=fu>-</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>7</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>7</span> <span class=fu>+</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>9</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>9</span> <span class=fu>-</span> <span class=dv>1</span><span class=fu>/</span><span class=dv>11</span><span class=fu>*</span>x<span class=fu>^</span><span class=dv>11</span> <span class=fu>...</span>
pi        <span class=fu>=</span> <span class=dv>16</span> <span class=fu>*</span> atan (<span class=dv>1</span><span class=fu>/</span><span class=dv>5</span>) <span class=fu>-</span> <span class=dv>4</span> <span class=fu>*</span> atan (<span class=dv>1</span><span class=fu>/</span><span class=dv>239</span>)</code></pre></div>
<div class=sourceCode include=src/19-numbers/creal.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Number.CReal</span>

<span class=co>-- algebraic</span>
<span class=ot>phi ::</span> <span class=dt>CReal</span>
phi <span class=fu>=</span> (<span class=dv>1</span> <span class=fu>+</span> sqrt <span class=dv>5</span>) <span class=fu>/</span> <span class=dv>2</span>

<span class=co>-- transcendental</span>
<span class=ot>ramanujan ::</span> <span class=dt>CReal</span>
ramanujan <span class=fu>=</span> exp (pi <span class=fu>*</span> sqrt <span class=dv>163</span>)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  putStrLn <span class=fu>$</span> showCReal <span class=dv>30</span> pi
  <span class=co>-- 3.141592653589793238462643383279</span>
  putStrLn <span class=fu>$</span> showCReal <span class=dv>30</span> phi
  <span class=co>-- 1.618033988749894848204586834366</span>
  putStrLn <span class=fu>$</span> showCReal <span class=dv>15</span> ramanujan
  <span class=co>-- 262537412640768743.99999999999925</span></code></pre></div>
<h2 id=sat-solvers><font>SAT Solvers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>SAT 求解器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A collection of constraint problems known as satisfiability problems show up in a number of different disciplines from type checking to package management. Simply put a satisfiability problem attempts to find solutions to a statement of conjoined conjunctions and disjunctions in terms of a series of variables. For example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>称为可满足性问题的一组约束问题出现在从类型检查到包管理的许多不同学科中。简单地说，可满足性问题试图根据一系列变量找到联合连词和析取语句的解。例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<pre class=text><code>(A v ¬B v C) ∧ (B v D v E) ∧ (D v F)</code></pre>
<p><font>To use the picosat library to solve this, it can be written as zero-terminated lists of integers and fed to the solver according to a number-to-variable relation:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要使用 picosat 库来解决这个问题，它可以写成以零结尾的整数列表，并根据数字与变量的关系提供给求解器：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dv>1</span> <span class=fu>-</span><span class=dv>2</span> <span class=dv>3</span>  <span class=co>-- (A v ¬B v C)</span>
<span class=dv>2</span> <span class=dv>4</span> <span class=dv>5</span>   <span class=co>-- (B v D v E)</span>
<span class=dv>4</span> <span class=dv>6</span>     <span class=co>-- (D v F)</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Picosat</span>

<span class=ot>main ::</span> <span class=dt>IO</span> [<span class=dt>Int</span>]
main <span class=fu>=</span> <span class=kw>do</span>
  solve [[<span class=dv>1</span>, <span class=fu>-</span><span class=dv>2</span>, <span class=dv>3</span>], [<span class=dv>2</span>,<span class=dv>4</span>,<span class=dv>5</span>], [<span class=dv>4</span>,<span class=dv>6</span>]]
  <span class=co>-- Solution [1,-2,3,4,5,6]</span></code></pre></div>
<p><font>The SAT solver itself can be used to solve satisfiability problems with millions of variables in this form and is finely tuned.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SAT 求解器本身可用于解决具有数百万个这种形式的变量的可满足性问题，并且经过微调。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/package/picosat-0.1.1>picosat<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>皮卫星</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=smt-solvers><font>SMT Solvers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>SMT求解器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>A generalization of the SAT problem to include predicates other theories gives rise to the very sophisticated domain of "Satisfiability Modulo Theory" problems. The existing SMT solvers are very sophisticated projects ( usually bankrolled by large institutions ) and usually have to called out to via foreign function interface or via a common interface called SMT-lib. The two most common of use in Haskell are </font><code>cvc4</code><font> from Stanford and </font><code>z3</code><font> from Microsoft Research.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将 SAT 问题推广到包括其他理论的谓词会产生非常复杂的“可满足性模理论”问题领域。现有的 SMT 求解器是非常复杂的项目（通常由大型机构资助）并且通常必须通过外部函数接口或通过称为 SMT-lib 的通用接口调用。 Haskell 中最常用的两个是斯坦福大学的 cvc4 和微软研究院的 z3。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The SBV library can abstract over different SMT solvers to allow us to express the problem in an embedded domain language in Haskell and then offload the solving work to the third party library.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SBV 库可以抽象出不同的 SMT 求解器，使我们能够在 Haskell 中用嵌入式领域语言表达问题，然后将求解工作卸载给第三方库。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>As an example, here's how you can solve a simple </font><a href=https://smunix.github.io/en.wikipedia.org/wiki/Verbal_arithmetic.html>cryptarithm</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作为一个例子，这里是你如何解决一个简单的密码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<tbody>
<tr class=odd>
<td align=right><code>M</code> <code>O</code> <code>N</code> <code>A</code> <code>D</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>莫纳德</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=right><font>+ </font><code>B</code> <code>U</code> <code>R</code> <code>R</code> <code>I</code> <code>T</code> <code>O</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>+ B U R R I T O</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=right><font>= </font><code>B</code> <code>A</code> <code>N</code> <code>D</code> <code>A</code> <code>I</code> <code>D</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>= B A N D A I D</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>using SBV library:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 SBV 库：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/19-numbers/puzzle.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Foldable</span>
<span class=kw>import </span><span class=dt>Data.SBV</span>

<span class=co>-- | val [4,2] == 42</span>
<span class=ot>val ::</span> [<span class=dt>SInteger</span>] <span class=ot>-&gt;</span> <span class=dt>SInteger</span>
val <span class=fu>=</span> foldr1 (\d r <span class=ot>-&gt;</span> d <span class=fu>+</span> <span class=dv>10</span><span class=fu>*</span>r) <span class=fu>.</span> reverse

<span class=ot>puzzle ::</span> <span class=dt>Symbolic</span> <span class=dt>SBool</span>
puzzle <span class=fu>=</span> <span class=kw>do</span>
  ds<span class=fu>@</span>[b,u,r,i,t,o,m,n,a,d] <span class=ot>&lt;-</span> sequenceA [ sInteger [v] <span class=fu>|</span> v <span class=ot>&lt;-</span> <span class=st>"buritomnad"</span> ]
  constrain <span class=fu>$</span> allDifferent ds
  for_ ds <span class=fu>$</span> \d <span class=ot>-&gt;</span> constrain <span class=fu>$</span> inRange d (<span class=dv>0</span>,<span class=dv>9</span>)
  pure <span class=fu>$</span>    val [b,u,r,r,i,t,o]
          <span class=fu>+</span> val     [m,o,n,a,d]
        <span class=fu>.==</span> val [b,a,n,d,a,i,d]

</code></pre></div>
<p><font>Let's look at all possible solutions,</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>让我们看看所有可能的解决方案，</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> allSat puzzle
<span class=dt>Solution</span> <span class=fu>#</span><span class=dv>1</span><span class=fu>:</span>
  b <span class=fu>=</span> <span class=dv>4</span><span class=ot> ::</span> <span class=dt>Integer</span>
  u <span class=fu>=</span> <span class=dv>1</span><span class=ot> ::</span> <span class=dt>Integer</span>
  r <span class=fu>=</span> <span class=dv>5</span><span class=ot> ::</span> <span class=dt>Integer</span>
  i <span class=fu>=</span> <span class=dv>9</span><span class=ot> ::</span> <span class=dt>Integer</span>
  t <span class=fu>=</span> <span class=dv>7</span><span class=ot> ::</span> <span class=dt>Integer</span>
  o <span class=fu>=</span> <span class=dv>0</span><span class=ot> ::</span> <span class=dt>Integer</span>
  m <span class=fu>=</span> <span class=dv>8</span><span class=ot> ::</span> <span class=dt>Integer</span>
  n <span class=fu>=</span> <span class=dv>3</span><span class=ot> ::</span> <span class=dt>Integer</span>
  a <span class=fu>=</span> <span class=dv>2</span><span class=ot> ::</span> <span class=dt>Integer</span>
  d <span class=fu>=</span> <span class=dv>6</span><span class=ot> ::</span> <span class=dt>Integer</span>
<span class=dt>This</span> is the only solution<span class=fu>.</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://leventerkok.github.io/sbv/>sbv<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>sbv</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://cvc4.cs.nyu.edu/web/>cvc4<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>cvc4</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://z3.codeplex.com/>z3<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>z3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=z3><font>Z3</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Z3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>TODO</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>全部</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=https://hackage.haskell.org/package/z3>z3</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：z3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h1 id=data-structures><font>Data Structures</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据结构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=map><font>Map</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>地图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Insertion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>insert</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>A map is an associative array mapping any instance of </font><code>Ord</code><font> keys to values of any type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>映射是一个关联数组，将 Ord 键的任何实例映射到任何类型的值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/map.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>Map</span>

<span class=ot>kv ::</span> <span class=dt>Map.Map</span> <span class=dt>Integer</span> <span class=dt>String</span>
kv <span class=fu>=</span> Map.fromList [(<span class=dv>1</span>, <span class=st>"a"</span>), (<span class=dv>2</span>, <span class=st>"b"</span>)]

<span class=ot>lkup ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
lkup key def <span class=fu>=</span>
  <span class=kw>case</span> Map.lookup key kv <span class=kw>of</span>
    <span class=dt>Just</span> val <span class=ot>-&gt;</span> val
    <span class=dt>Nothing</span>  <span class=ot>-&gt;</span> def</code></pre></div>
<h2 id=tree><font>Tree</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>树</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Insertion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>insert</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<div class=sourceCode include=src/20-data-structures/tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Tree</span>

<span class=co>{-</span>

<span class=co>   A</span>
<span class=co>  / \</span>
<span class=co> B   C</span>
<span class=co>    / \</span>
<span class=co>   D   E</span>

<span class=co>-}</span>

<span class=ot>tree ::</span> <span class=dt>Tree</span> <span class=dt>String</span>
tree <span class=fu>=</span> <span class=dt>Node</span> <span class=st>"A"</span> [<span class=dt>Node</span> <span class=st>"B"</span> [], <span class=dt>Node</span> <span class=st>"C"</span> [<span class=dt>Node</span> <span class=st>"D"</span> [], <span class=dt>Node</span> <span class=st>"E"</span> []]]

<span class=ot>postorder ::</span> <span class=dt>Tree</span> a <span class=ot>-&gt;</span> [a]
postorder (<span class=dt>Node</span> a ts) <span class=fu>=</span> elts <span class=fu>++</span> [a]
  <span class=kw>where</span> elts <span class=fu>=</span> concat (map postorder ts)

<span class=ot>preorder ::</span> <span class=dt>Tree</span> a <span class=ot>-&gt;</span> [a]
preorder (<span class=dt>Node</span> a ts) <span class=fu>=</span> a <span class=fu>:</span> elts
  <span class=kw>where</span> elts <span class=fu>=</span> concat (map preorder ts)

ex1 <span class=fu>=</span> drawTree tree
ex2 <span class=fu>=</span> drawForest (subForest tree)
ex3 <span class=fu>=</span> flatten tree
ex4 <span class=fu>=</span> levels tree
ex5 <span class=fu>=</span> preorder tree
ex6 <span class=fu>=</span> postorder tree</code></pre></div>
<h2 id=set><font>Set</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>放</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Insertion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>insert</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Deletion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>删除</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>delete</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>删除</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Membership Test</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>会员测试</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>member</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>成员</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Sets are an unordered data structures allow </font><code>Ord</code><font> values of any type and guaranteeing uniqueness with in the structure. They are not identical to the mathematical notion of a Set even though they share the same namesake.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>集合是一种无序数据结构，允许任何类型的 Ord 值并保证结构中的唯一性。它们与 Set 的数学概念并不相同，即使它们共享相同的名称。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/set.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.Set</span> <span class=kw>as</span> <span class=dt>Set</span>

<span class=ot>set ::</span> <span class=dt>Set.Set</span> <span class=dt>Integer</span>
set <span class=fu>=</span> Set.fromList [<span class=dv>1</span><span class=fu>..</span><span class=dv>1000</span>]

<span class=ot>memtest ::</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
memtest elt <span class=fu>=</span> Set.member elt set</code></pre></div>
<h2 id=vector><font>Vector</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>length</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>长度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Indexing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>索引</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>(!)<hcfy-result style=display:none></hcfy-result></font></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Append</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>附加</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>append</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>附加</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Vectors are high performance single dimensional arrays that come come in six variants, two for each of the following types of a mutable and an immutable variant.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>向量是高性能的一维数组，有六种变体，以下每种类型的可变和不可变变体各有两种。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Data.Vector</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Data.Vector.Storable</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.向量.可存储</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Data.Vector.Unboxed</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据.矢量.拆箱</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>The most notable feature of vectors is constant time memory access with (</font><code>(!)</code><font>) as well as variety of efficient map, fold and scan operations on top of a fusion framework that generates surprisingly optimal code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>向量最显着的特征是使用 ((!)) 的恒定时间内存访问，以及在生成令人惊讶的最佳代码的融合框架之上的各种高效映射、折叠和扫描操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>fromList ::</span> [a] <span class=ot>-&gt;</span> <span class=dt>Vector</span> a
<span class=ot>toList ::</span> <span class=dt>Vector</span> a <span class=ot>-&gt;</span> [a]
<span class=ot>(!) ::</span> <span class=dt>Vector</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> a
map<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> <span class=dt>Vector</span> a <span class=ot>-&gt;</span> <span class=dt>Vector</span> b
foldl<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Vector</span> b <span class=ot>-&gt;</span> a
scanl<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Vector</span> b <span class=ot>-&gt;</span> <span class=dt>Vector</span> a
zipWith<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> <span class=dt>Vector</span> a <span class=ot>-&gt;</span> <span class=dt>Vector</span> b <span class=ot>-&gt;</span> <span class=dt>Vector</span> c
<span class=ot>iterateN ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Vector</span> a</code></pre></div>
<div class=sourceCode include=src/20-data-structures/vector.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Vector.Unboxed</span> <span class=kw>as</span> <span class=dt>V</span>

<span class=ot>norm ::</span>  <span class=dt>Vector</span> <span class=dt>Double</span> <span class=ot>-&gt;</span> <span class=dt>Double</span>
norm <span class=fu>=</span> sqrt <span class=fu>.</span> V.sum <span class=fu>.</span> V.map (\x <span class=ot>-&gt;</span> x<span class=fu>*</span>x)

<span class=ot>example1 ::</span> <span class=dt>Double</span>
example1 <span class=fu>=</span> norm <span class=fu>$</span> V.iterateN <span class=dv>100000000</span> (<span class=fu>+</span><span class=dv>1</span>) <span class=fl>0.0</span></code></pre></div>
<p><font>See: </font><a href=http://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial>Numerical Haskell: A Vector Tutorial</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Numerical Haskell：向量教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=mutable-vectors><font>Mutable Vectors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可变向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>length</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>长度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Indexing</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>索引</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>(!)<hcfy-result style=display:none></hcfy-result></font></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Append</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>附加</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>append</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>附加</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Update</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>更新</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>modify</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>调整</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Read</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>read</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>读</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Write</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>写</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>write</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>写</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>freeze ::</span> <span class=dt>MVector</span> (<span class=dt>PrimState</span> m) a <span class=ot>-&gt;</span> m (<span class=dt>Vector</span> a)
<span class=ot>thaw ::</span> <span class=dt>Vector</span> a <span class=ot>-&gt;</span> <span class=dt>MVector</span> (<span class=dt>PrimState</span> m) a</code></pre></div>
<p><font>Within the IO monad we can perform arbitrary read and writes on the mutable vector with constant time reads and writes. When needed a static Vector can be created to/from the </font><code>MVector</code><font> using the freeze/thaw functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 IO monad 中，我们可以对具有恒定时间读写的可变向量执行任意读写。当需要时，可以使用冻结/解冻功能向/从 MVector 创建静态 Vector。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/vector_mutable.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>GHC.Prim</span>
<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.ST</span>
<span class=kw>import </span><span class=dt>Control.Monad.Primitive</span>

<span class=kw>import </span><span class=dt>Data.Vector.Unboxed</span> (freeze)
<span class=kw>import </span><span class=dt>Data.Vector.Unboxed.Mutable</span>
<span class=kw>import qualified</span> <span class=dt>Data.Vector.Unboxed</span> <span class=kw>as</span> <span class=dt>V</span>

<span class=ot>example ::</span> <span class=dt>PrimMonad</span> m <span class=ot>=&gt;</span> m (<span class=dt>V.Vector</span> <span class=dt>Int</span>)
example <span class=fu>=</span> <span class=kw>do</span>
  v <span class=ot>&lt;-</span> new <span class=dv>10</span>
  forM_ [<span class=dv>0</span><span class=fu>..</span><span class=dv>9</span>] <span class=fu>$</span> \i <span class=ot>-&gt;</span>
     write v i (<span class=dv>2</span><span class=fu>*</span>i)
  freeze v

<span class=co>-- vector computation in IO</span>
<span class=ot>vecIO ::</span> <span class=dt>IO</span> (<span class=dt>V.Vector</span> <span class=dt>Int</span>)
vecIO <span class=fu>=</span> example

<span class=co>-- vector computation in ST</span>
<span class=ot>vecST ::</span> <span class=dt>ST</span> s (<span class=dt>V.Vector</span> <span class=dt>Int</span>)
vecST <span class=fu>=</span> example


<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  vecIO <span class=fu>&gt;&gt;=</span> print
  print <span class=fu>$</span> runST vecST</code></pre></div>
<p><font>The vector library itself normally does bounds checks on index operations to protect against memory corruption. This can be enabled or disabled on the library level by compiling with </font><code>boundschecks</code><font> cabal flag.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>矢量库本身通常会对索引操作进行边界检查以防止内存损坏。这可以通过使用 boundschecks cabal 标志进行编译在库级别启用或禁用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=unordered-containers><font>Unordered-Containers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>无序容器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Insertion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>insert</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>fromList ::</span> (<span class=dt>Eq</span> k, <span class=dt>Hashable</span> k) <span class=ot>=&gt;</span> [(k, v)] <span class=ot>-&gt;</span> <span class=dt>HashMap</span> k v
lookup<span class=ot> ::</span> (<span class=dt>Eq</span> k, <span class=dt>Hashable</span> k) <span class=ot>=&gt;</span> k <span class=ot>-&gt;</span> <span class=dt>HashMap</span> k v <span class=ot>-&gt;</span> <span class=dt>Maybe</span> v
<span class=ot>insert ::</span> (<span class=dt>Eq</span> k, <span class=dt>Hashable</span> k) <span class=ot>=&gt;</span> k <span class=ot>-&gt;</span> v <span class=ot>-&gt;</span> <span class=dt>HashMap</span> k v <span class=ot>-&gt;</span> <span class=dt>HashMap</span> k v</code></pre></div>
<p><font>Both the </font><code>HashMap</code><font> and </font><code>HashSet</code><font> are purely functional data structures that are drop in replacements for the </font><code>containers</code><font> equivalents but with more efficient space and time performance. Additionally all stored elements must have a </font><code>Hashable</code><font> instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>HashMap 和 HashSet 都是纯粹的函数式数据结构，它们是容器等价物的替代品，但具有更高效的空间和时间性能。此外，所有存储的元素都必须有一个 Hashable 实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/unordered.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.HashSet</span> <span class=kw>as</span> <span class=dt>S</span>
<span class=kw>import qualified</span> <span class=dt>Data.HashMap.Lazy</span> <span class=kw>as</span> <span class=dt>M</span>

<span class=ot>example1 ::</span> <span class=dt>M.HashMap</span> <span class=dt>Int</span> <span class=dt>Char</span>
example1 <span class=fu>=</span> M.fromList <span class=fu>$</span> zip [<span class=dv>1</span><span class=fu>..</span><span class=dv>10</span>] [<span class=ch>'a'</span><span class=fu>..</span>]

<span class=ot>example2 ::</span> <span class=dt>S.HashSet</span> <span class=dt>Int</span>
example2 <span class=fu>=</span> S.fromList [<span class=dv>1</span><span class=fu>..</span><span class=dv>10</span>]</code></pre></div>
<p><font>See: </font><a href=http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html>Announcing Unordered Containers</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：宣布无序容器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=hashtables><font>Hashtables</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哈希表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Insertion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>insert</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1) amortized</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1) 摊销</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Hashtables provides hashtables with efficient lookup within the ST or IO monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈希表为哈希表提供了在 ST 或 IO monad 中进行高效查找的功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/hashtables.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (lookup)

<span class=kw>import </span><span class=dt>Control.Monad.ST</span>
<span class=kw>import </span><span class=dt>Data.HashTable.ST.Basic</span>

<span class=co>-- Hashtable parameterized by ST "thread"</span>
<span class=kw>type</span> <span class=dt>HT</span> s <span class=fu>=</span> <span class=dt>HashTable</span> s <span class=dt>String</span> <span class=dt>String</span>

<span class=ot>set ::</span> <span class=dt>ST</span> s (<span class=dt>HT</span> s)
set <span class=fu>=</span> <span class=kw>do</span>
  ht <span class=ot>&lt;-</span> new
  insert ht <span class=st>"key"</span> <span class=st>"value1"</span>
  return ht

<span class=ot>get ::</span> <span class=dt>HT</span> s <span class=ot>-&gt;</span> <span class=dt>ST</span> s (<span class=dt>Maybe</span> <span class=dt>String</span>)
get ht <span class=fu>=</span> <span class=kw>do</span>
  val <span class=ot>&lt;-</span> lookup ht <span class=st>"key"</span>
  return val

<span class=ot>example ::</span> <span class=dt>Maybe</span> <span class=dt>String</span>
example <span class=fu>=</span> runST (set <span class=fu>&gt;&gt;=</span> get)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>new ::</span> <span class=dt>ST</span> s (<span class=dt>HashTable</span> s k v)
<span class=ot>insert ::</span> (<span class=dt>Eq</span> k, <span class=dt>Hashable</span> k) <span class=ot>=&gt;</span> <span class=dt>HashTable</span> s k v <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> v <span class=ot>-&gt;</span> <span class=dt>ST</span> s ()
lookup<span class=ot> ::</span> (<span class=dt>Eq</span> k, <span class=dt>Hashable</span> k) <span class=ot>=&gt;</span> <span class=dt>HashTable</span> s k v <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> <span class=dt>ST</span> s (<span class=dt>Maybe</span> v)</code></pre></div>
<h2 id=graphs><font>Graphs</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The Graph module in the containers library is a somewhat antiquated API for working with directed graphs. A little bit of data wrapping makes it a little more straightforward to use. The library is not necessarily well-suited for large graph-theoretic operations but is perfectly fine for example, to use in a typechecker which need to resolve strongly connected components of the module definition graph.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>容器库中的 Graph 模块是一个有点过时的 API，用于处理有向图。一点数据包装使它更易于使用。该库不一定非常适合大型图论操作，但非常适合例如在需要解析模块定义图的强连接组件的类型检查器中使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/graph.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Tree</span>
<span class=kw>import </span><span class=dt>Data.Graph</span>

<span class=kw>data</span> <span class=dt>Grph</span> node key <span class=fu>=</span> <span class=dt>Grph</span>
  { _<span class=ot>graph ::</span> <span class=dt>Graph</span>
  , _<span class=ot>vertices ::</span> <span class=dt>Vertex</span> <span class=ot>-&gt;</span> (node, key, [key])
  }

<span class=ot>fromList ::</span> <span class=dt>Ord</span> key <span class=ot>=&gt;</span> [(node, key, [key])] <span class=ot>-&gt;</span> <span class=dt>Grph</span> node key
fromList <span class=fu>=</span> uncurry <span class=dt>Grph</span> <span class=fu>.</span> graphFromEdges'

<span class=ot>vertexLabels ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> <span class=dt>Grph</span> b t <span class=ot>-&gt;</span> (f <span class=dt>Vertex</span>) <span class=ot>-&gt;</span> f b
vertexLabels g <span class=fu>=</span> fmap (vertexLabel g)

<span class=ot>vertexLabel ::</span> <span class=dt>Grph</span> b t <span class=ot>-&gt;</span> <span class=dt>Vertex</span> <span class=ot>-&gt;</span> b
vertexLabel g <span class=fu>=</span> (\(vi, _, _) <span class=ot>-&gt;</span> vi) <span class=fu>.</span> (_vertices g)

<span class=co>-- Topologically sort graph</span>
<span class=ot>topo' ::</span> <span class=dt>Grph</span> node key <span class=ot>-&gt;</span> [node]
topo' g <span class=fu>=</span> vertexLabels g <span class=fu>$</span> topSort (_graph g)

<span class=co>-- Strongly connected components of graph</span>
<span class=ot>scc' ::</span> <span class=dt>Grph</span> node key <span class=ot>-&gt;</span> [[node]]
scc' g <span class=fu>=</span> fmap (vertexLabels g <span class=fu>.</span> flatten) <span class=fu>$</span> scc (_graph g)</code></pre></div>
<p><font>So for example we can construct a simple graph:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，例如我们可以构造一个简单的图：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=figure>
<img src="data:image/png;base64,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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/graph1.png>
</div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>ex1 ::</span> [(<span class=dt>String</span>, <span class=dt>String</span>, [<span class=dt>String</span>])]
ex1 <span class=fu>=</span> [
    (<span class=st>"a"</span>,<span class=st>"a"</span>,[<span class=st>"b"</span>]),
    (<span class=st>"b"</span>,<span class=st>"b"</span>,[<span class=st>"c"</span>]),
    (<span class=st>"c"</span>,<span class=st>"c"</span>,[<span class=st>"a"</span>])
  ]

<span class=ot>ts1 ::</span> [<span class=dt>String</span>]
ts1 <span class=fu>=</span> topo' (fromList ex1)
<span class=co>-- ["a","b","c"]</span>

<span class=ot>sc1 ::</span> [[<span class=dt>String</span>]]
sc1 <span class=fu>=</span> scc' (fromList ex1)
<span class=co>-- [["a","b","c"]]</span></code></pre></div>
<p><font>Or with two strongly connected subgraphs:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者有两个强连接的子图：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=figure>
<img src="data:image/png;base64,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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/graph2.png>
</div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>ex2 ::</span> [(<span class=dt>String</span>, <span class=dt>String</span>, [<span class=dt>String</span>])]
ex2 <span class=fu>=</span> [
    (<span class=st>"a"</span>,<span class=st>"a"</span>,[<span class=st>"b"</span>]),
    (<span class=st>"b"</span>,<span class=st>"b"</span>,[<span class=st>"c"</span>]),
    (<span class=st>"c"</span>,<span class=st>"c"</span>,[<span class=st>"a"</span>]),

    (<span class=st>"d"</span>,<span class=st>"d"</span>,[<span class=st>"e"</span>]),
    (<span class=st>"e"</span>,<span class=st>"e"</span>,[<span class=st>"f"</span>, <span class=st>"e"</span>]),
    (<span class=st>"f"</span>,<span class=st>"f"</span>,[<span class=st>"d"</span>, <span class=st>"e"</span>])
  ]


<span class=ot>ts2 ::</span> [<span class=dt>String</span>]
ts2 <span class=fu>=</span> topo' (fromList ex2)
<span class=co>-- ["d","e","f","a","b","c"]</span>

<span class=ot>sc2 ::</span> [[<span class=dt>String</span>]]
sc2 <span class=fu>=</span> scc' (fromList ex2)
<span class=co>-- [["d","e","f"],["a","b","c"]]</span></code></pre></div>
<p><font>See: </font><a href=http://hackage.haskell.org/package/GraphSCC>GraphSCC</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：GraphSCC</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=graph-theory><font>Graph Theory</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图论</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The </font><code>fgl</code><font> library provides a more efficient graph structure and a wide variety of common graph-theoretic operations. For example calculating the dominance frontier of a graph shows up quite frequently in control flow analysis for compiler design.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>fgl 库提供了更高效的图结构和各种常见的图论操作。例如，计算图形的优势边界在编译器设计的控制流分析中经常出现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import qualified</span> <span class=dt>Data.Graph.Inductive</span> <span class=kw>as</span> <span class=dt>G</span>

<span class=ot>cyc3 ::</span> <span class=dt>G.Gr</span> <span class=dt>Char</span> <span class=dt>String</span>
cyc3 <span class=fu>=</span> G.buildGr
       [([(<span class=st>"ca"</span>,<span class=dv>3</span>)],<span class=dv>1</span>,<span class=ch>'a'</span>,[(<span class=st>"ab"</span>,<span class=dv>2</span>)]),
                ([],<span class=dv>2</span>,<span class=ch>'b'</span>,[(<span class=st>"bc"</span>,<span class=dv>3</span>)]),
                ([],<span class=dv>3</span>,<span class=ch>'c'</span>,[])]

<span class=co>-- Loop query</span>
<span class=ot>ex1 ::</span> <span class=dt>Bool</span>
ex1 <span class=fu>=</span> G.hasLoop x

<span class=co>-- Dominators</span>
<span class=ot>ex2 ::</span> [(<span class=dt>G.Node</span>, [<span class=dt>G.Node</span>])]
ex2 <span class=fu>=</span> G.dom x <span class=dv>0</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>x ::</span> <span class=dt>G.Gr</span> <span class=dt>Int</span> ()
x <span class=fu>=</span> G.insEdges edges gr
  <span class=kw>where</span>
  gr <span class=fu>=</span> G.insNodes nodes G.empty
  edges <span class=fu>=</span> [(<span class=dv>0</span>,<span class=dv>1</span>,()), (<span class=dv>0</span>,<span class=dv>2</span>,()), (<span class=dv>2</span>,<span class=dv>1</span>,()), (<span class=dv>2</span>,<span class=dv>3</span>,())]
  nodes <span class=fu>=</span> zip [<span class=dv>0</span>,<span class=dv>1</span> <span class=fu>..</span>] [<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>,<span class=dv>1</span>]</code></pre></div>
<div class=figure>
<img src="data:image/png;base64,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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/graphviz.png>
</div>
<h2 id=dlist><font>DList</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>列表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<table>
<thead>
<tr class=header>
<th align=left><font>Functionality</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Function</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>功能</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Time Complexity</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间复杂度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Initialization</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>初始化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>empty</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>size</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尺寸</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>lookup</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>抬头</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Insertion</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>insert</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>插入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(log(n))</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(日志(n))</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Traversal</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>traverse</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>遍历</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(n)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><font>Append</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>附加</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>(|&gt;)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(|&gt;)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><font>Prepend</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>前置</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>(&lt;|)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(&lt;|)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><font>O(1)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>O(1)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>A dlist is a list-like structure that is optimized for O(1) append operations, internally it uses a Church encoding of the list structure. It is specifically suited for operations which are append-only and need only access it when manifesting the entire structure. It is particularly well-suited for use in the Writer monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>dlist 是一种类似列表的结构，针对 O(1) 追加操作进行了优化，在内部它使用列表结构的 Church 编码。它特别适用于仅附加的操作，并且只需要在显示整个结构时访问它。它特别适合在 Writer monad 中使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/dlist.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.DList</span>
<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.Writer</span>

<span class=ot>logger ::</span> <span class=dt>Writer</span> (<span class=dt>DList</span> <span class=dt>Int</span>) ()
logger <span class=fu>=</span> replicateM_ <span class=dv>100000</span> <span class=fu>$</span> tell (singleton <span class=dv>0</span>)</code></pre></div>
<h2 id=sequence><font>Sequence</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>顺序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The sequence data structure behaves structurally similar to list but is optimized for append/prepend operations and traversal.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>序列数据结构的行为在结构上类似于列表，但针对追加/前置操作和遍历进行了优化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/20-data-structures/sequence.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Sequence</span>

<span class=ot>a ::</span> <span class=dt>Seq</span> <span class=dt>Int</span>
a <span class=fu>=</span> fromList [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]

<span class=ot>a0 ::</span> <span class=dt>Seq</span> <span class=dt>Int</span>
a0 <span class=fu>=</span> a <span class=fu>|&gt;</span> <span class=dv>4</span>
<span class=co>-- [1,2,3,4]</span>

<span class=ot>a1 ::</span> <span class=dt>Seq</span> <span class=dt>Int</span>
a1 <span class=fu>=</span> <span class=dv>0</span> <span class=fu>&lt;|</span> a
<span class=co>-- [0,1,2,3]</span></code></pre></div>
<hr>
<h1 id=ffi><font>FFI</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>外国金融机构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of FFI is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，编写 Haskell 通常不需要 FFI 知识。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h2 id=pure-functions><font>Pure Functions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>纯函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Wrapping pure C functions with primitive types is trivial.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>用基本类型包装纯 C 函数是微不足道的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/21-ffi/simple.html><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=co>/* $(CC) -c simple.c -o simple.o */</span>

<span class=dt>int</span> example(<span class=dt>int</span> a, <span class=dt>int</span> b)
{
  <span class=kw>return</span> a + b;
}</code></pre></div>
<div class=sourceCode include=src/21-ffi/simple_ffi.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- ghc simple.o simple_ffi.hs -o simple_ffi</span>
<span class=ot>{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class=kw>import </span><span class=dt>Foreign.C.Types</span>

foreign <span class=kw>import </span>ccall safe "example" example
<span class=ot>    ::</span> <span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>CInt</span>

main <span class=fu>=</span> print (example <span class=dv>42</span> <span class=dv>27</span>)</code></pre></div>
<h2 id=storable-arrays><font>Storable Arrays</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>可存储数组</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>There exists a </font><code>Storable</code><font> typeclass that can be used to provide low-level access to the memory underlying Haskell values. </font><code>Ptr</code><font> objects in Haskell behave much like C pointers although arithmetic with them is in terms of bytes only, not the size of the type associated with the pointer ( this differs from C).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在一个可存储类型类，可用于提供对底层 Haskell 值的内存的低级访问。 Haskell 中的 Ptr 对象的行为很像 C 指针，尽管与它们的算术运算仅以字节为单位，而不是与指针关联的类型的大小（这与 C 不同）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The Prelude defines Storable interfaces for most of the basic types as well as types in the </font><code>Foreign.C</code><font> library.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Prelude 为大多数基本类型以及 Foreign.C 库中的类型定义了 Storable 接口。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Storable</span> a <span class=kw>where</span>
<span class=ot>  sizeOf ::</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>
<span class=ot>  alignment ::</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span>
<span class=ot>  peek ::</span> <span class=dt>Ptr</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a
<span class=ot>  poke ::</span> <span class=dt>Ptr</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</code></pre></div>
<p><font>To pass arrays from Haskell to C we can again use Storable Vector and several unsafe operations to grab a foreign pointer to the underlying data that can be handed off to C. Once we're in C land, nothing will protect us from doing evil things to memory!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了将数组从 Haskell 传递到 C，我们可以再次使用 Storable Vector 和几个不安全的操作来获取指向可以传递给 C 的底层数据的外部指针。一旦我们进入 C 领域，就没有什么可以保护我们免于做坏事了记忆！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/21-ffi/qsort.html><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=co>/* $(CC) -c qsort.c -o qsort.o */</span>
<span class=dt>void</span> swap(<span class=dt>int</span> *a, <span class=dt>int</span> *b)
{
    <span class=dt>int</span> t = *a;
    *a = *b;
    *b = t;
}

<span class=dt>void</span> sort(<span class=dt>int</span> *xs, <span class=dt>int</span> beg, <span class=dt>int</span> end)
{
    <span class=kw>if</span> (end &gt; beg + <span class=dv>1</span>) {
        <span class=dt>int</span> piv = xs[beg], l = beg + <span class=dv>1</span>, r = end;

        <span class=kw>while</span> (l &lt; r) {
            <span class=kw>if</span> (xs[l] &lt;= piv) {
                l++;
            } <span class=kw>else</span> {
                swap(&amp;xs[l], &amp;xs[--r]);
            }
        }

        swap(&amp;xs[--l], &amp;xs[beg]);
        sort(xs, beg, l);
        sort(xs, r, end);
    }
}</code></pre></div>
<div class=sourceCode include=src/21-ffi/ffi.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- ghc qsort.o ffi.hs -o ffi</span>
<span class=ot>{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class=kw>import </span><span class=dt>Foreign.Ptr</span>
<span class=kw>import </span><span class=dt>Foreign.C.Types</span>

<span class=kw>import qualified</span> <span class=dt>Data.Vector.Storable</span> <span class=kw>as</span> <span class=dt>V</span>
<span class=kw>import qualified</span> <span class=dt>Data.Vector.Storable.Mutable</span> <span class=kw>as</span> <span class=dt>VM</span>

foreign <span class=kw>import </span>ccall safe "sort" qsort
<span class=ot>    ::</span> <span class=dt>Ptr</span> a <span class=ot>-&gt;</span> <span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> vs <span class=fu>=</span> V.fromList ([<span class=dv>1</span>,<span class=dv>3</span>,<span class=dv>5</span>,<span class=dv>2</span>,<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>5</span>,<span class=dv>9</span>,<span class=dv>6</span>]<span class=ot> ::</span> [<span class=dt>CInt</span>])
  v <span class=ot>&lt;-</span> V.thaw vs
  VM.unsafeWith v <span class=fu>$</span> \ptr <span class=ot>-&gt;</span> <span class=kw>do</span>
    qsort ptr <span class=dv>0</span> <span class=dv>9</span>
  out <span class=ot>&lt;-</span> V.freeze v
  print out</code></pre></div>
<p><font>The names of foreign functions from a C specific header file can be qualified.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以限定来自 C 特定头文件的外部函数的名称。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class=kw>import </span>ccall unsafe "stdlib.h malloc"
<span class=ot>    malloc ::</span> <span class=dt>CSize</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Ptr</span> a)</code></pre></div>
<p><font>Prepending the function name with a </font><code>&amp;</code><font> allows us to create a reference to the function pointer itself.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在函数名称前加上 &amp; 允许我们创建对函数指针本身的引用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class=kw>import </span>ccall unsafe "stdlib.h &amp;malloc"
<span class=ot>    malloc ::</span> <span class=dt>FunPtr</span> a</code></pre></div>
<h2 id=function-pointers><font>Function Pointers</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>函数指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using the above FFI functionality, it's trivial to pass C function pointers into Haskell, but what about the inverse passing a function pointer to a Haskell function into C using </font><code>foreign import ccall "wrapper"</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用上面的 FFI 功能，将 C 函数指针传递给 Haskell 是微不足道的，但是反过来使用 foreign import ccall“wrapper”将函数指针传递给 Haskell 函数又如何呢？</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/21-ffi/pointer.html><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=ot>#include &lt;stdio.h&gt;</span>

<span class=dt>void</span> invoke(<span class=dt>void</span> (*fn)(<span class=dt>int</span>))
{
  <span class=dt>int</span> n = <span class=dv>42</span>;
  printf(<span class=st>"Inside of C, now we'll call Haskell.</span><span class=ch>\n</span><span class=st>"</span>);
  fn(n);
  printf(<span class=st>"Back inside of C again.</span><span class=ch>\n</span><span class=st>"</span>);
}</code></pre></div>
<div class=sourceCode include=src/21-ffi/pointer_use.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class=kw>import </span><span class=dt>Foreign</span>
<span class=kw>import </span><span class=dt>System.IO</span>
<span class=kw>import </span><span class=dt>Foreign.C.Types</span>(<span class=dt>CInt</span>(..))

foreign <span class=kw>import </span>ccall "wrapper"
<span class=ot>  makeFunPtr ::</span> (<span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()) <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>FunPtr</span> (<span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()))

foreign <span class=kw>import </span>ccall "pointer.c invoke"
<span class=ot>  invoke ::</span> <span class=dt>FunPtr</span> (<span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()) <span class=ot>-&gt;</span> <span class=dt>IO</span> ()

<span class=ot>fn ::</span> <span class=dt>CInt</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
fn n <span class=fu>=</span> <span class=kw>do</span>
  putStrLn <span class=st>"Hello from Haskell, here's a number passed between runtimes:"</span>
  print n
  hFlush stdout

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  fptr <span class=ot>&lt;-</span> makeFunPtr fn
  invoke fptr</code></pre></div>
<p><font>Will yield the following output:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将产生以下输出：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>Inside</span> of C, now we<span class=st>'ll call Haskell</span>
<span class=st>Hello from Haskell, here'</span>s a number passed between runtimes:
<span class=kw>42</span>
<span class=kw>Back</span> inside of C again.</code></pre></div>
<h1 id=concurrency><font>Concurrency</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>并发</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>The definitive reference on concurrency and parallelism in Haskell is Simon Marlow's text. This will section will just gloss over these topics because they are far better explained in this book.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>关于 Haskell 中并发性和并行性的权威参考是 Simon Marlow 的著作。本节将只是掩盖这些主题，因为它们在本书中得到了更好的解释。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://chimera.labs.oreilly.com/books/1230000000929>Parallel and Concurrent Programming in Haskell</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Haskell 中的并行和并发编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>forkIO ::</span> <span class=dt>IO</span> () <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>ThreadId</span></code></pre></div>
<p><font>Haskell threads are extremely cheap to spawn, using only 1.5KB of RAM depending on the platform and are much cheaper than a pthread in C. Calling forkIO 10</font><sup>6</sup><font> times completes just short of a 1s. Additionally, functional purity in Haskell also guarantees that a thread can almost always be terminated even in the middle of a computation without concern.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 线程的生成成本非常低，仅使用 1.5KB 的 RAM，具体取决于平台，并且比 C 中的 pthread 便宜得多。调用 forkIO 106 次仅需不到 1 秒即可完成。此外，Haskell 中的函数纯度还保证了即使在计算过程中线程也几乎总是可以终止而无需担心。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=https://smunix.github.io/ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler.html#TheScheduler>The Scheduler</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：调度程序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=sparks><font>Sparks</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>火花</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The most basic "atom" of parallelism in Haskell is a spark. It is a hint to the GHC runtime that a computation can be evaluated to weak head normal form in parallel.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中最基本的并行性“原子”是火花。这是对 GHC 运行时的一个提示，即计算可以并行评估为弱头部范式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>rpar ::</span> a <span class=ot>-&gt;</span> <span class=dt>Eval</span> a
<span class=ot>rseq ::</span> <span class=dt>Strategy</span> a
<span class=ot>rdeepseq ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>Strategy</span> a

<span class=ot>runEval ::</span> <span class=dt>Eval</span> a <span class=ot>-&gt;</span> a</code></pre></div>
<p><code>rpar a</code><font> spins off a separate spark that evolutes a to weak head normal form and places the computation in the spark pool. When the runtime determines that there is an available CPU to evaluate the computation it will evaluate ( </font><em>convert</em><font> ) the spark. If the main thread of the program is the evaluator for the spark, the spark is said to have </font><em>fizzled</em><font>. Fizzling is generally bad and indicates that the logic or parallelism strategy is not well suited to the work that is being evaluated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>rpar a 分离出一个单独的火花，将 a 演化为弱头部范式，并将计算放入火花池中。当运行时确定有可用的 CPU 来评估计算时，它将评估（转换）spark。如果程序的主线程是火花的求值器，则称火花已经熄灭。 Fizzling 通常是不好的，表明逻辑或并行策略不太适合正在评估的工作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The spark pool is also limited ( but user-adjustable ) to a default of 8000 (as of GHC 7.8.3 ). Sparks that are created beyond that limit are said to </font><em>overflow</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>火花池也被限制（但用户可调整）为默认值 8000（从 GHC 7.8.3 开始）。超过该限制产生的火花被称为溢出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Evaluates the arguments to f in parallel before application.</span>
par2 f x y <span class=fu>=</span> x <span class=ot>`rpar`</span> y <span class=ot>`rpar`</span> f x y</code></pre></div>
<p><font>An argument to </font><code>rseq</code><font> forces the evaluation of a spark before evaluation continues.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>rseq 的参数强制在评估继续之前评估火花。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Action</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>行动</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Description</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>Fizzled<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>失败了</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The resulting value has already been evaluated by the main thread so the spark need not be converted.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>结果值已由主线程计算，因此不需要转换火花。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>Dud<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哑弹</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The expression has already been evaluated, the computed value is returned and the spark is not converted.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>表达式已经被求值，计算值被返回并且 spark 没有被转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>GC'd<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>气相色谱</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The spark is added to the spark pool but the result is not referenced, so it is garbage collected.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>spark 被添加到 spark pool 但结果没有被引用，所以它被垃圾回收了。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>Overflowed<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>溢出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Insufficient space in the spark pool when spawning.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>产卵时火花池空间不足。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>The parallel runtime is necessary to use sparks, and the resulting program must be compiled with </font><code>-threaded</code><font>. Additionally the program itself can be specified to take runtime options with </font><code>-rtsopts</code><font> such as the number of cores to use.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>parallel runtime是使用sparks所必需的，生成的程序必须用-threaded编译。此外，可以指定程序本身使用 -rtsopts 来获取运行时选项，例如要使用的内核数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">ghc <span class=fu>-</span>threaded <span class=fu>-</span>rtsopts program<span class=fu>.</span>hs
<span class=fu>./</span>program <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span>s <span class=dt>N8</span> <span class=co>-- use 8 cores</span></code></pre></div>
<p><font>The runtime can be asked to dump information about the spark evaluation by passing the </font><code>-s</code><font> flag.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以通过传递 -s 标志要求运行时转储有关 spark 评估的信息。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> <span class=fu>./</span>spark <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span><span class=dt>N4</span> <span class=fu>-</span>s

                                    <span class=dt>Tot</span> time (elapsed)  <span class=dt>Avg</span> pause  <span class=dt>Max</span> pause
  <span class=dt>Gen</span>  <span class=dv>0</span>         <span class=dv>5</span> colls,     <span class=dv>5</span> par    <span class=fl>0.02</span>s    <span class=fl>0.01</span>s     <span class=fl>0.0017</span>s    <span class=fl>0.0048</span>s
  <span class=dt>Gen</span>  <span class=dv>1</span>         <span class=dv>3</span> colls,     <span class=dv>2</span> par    <span class=fl>0.00</span>s    <span class=fl>0.00</span>s     <span class=fl>0.0004</span>s    <span class=fl>0.0007</span>s

  <span class=dt>Parallel</span> <span class=dt>GC</span> work balance<span class=fu>:</span> <span class=fl>1.83</span><span class=fu>%</span> (serial <span class=dv>0</span><span class=fu>%</span>, perfect <span class=dv>100</span><span class=fu>%</span>)

  <span class=dt>TASKS</span><span class=fu>:</span> <span class=dv>6</span> (<span class=dv>1</span> bound, <span class=dv>5</span> peak workers (<span class=dv>5</span> total), using <span class=fu>-</span><span class=dt>N4</span>)

  <span class=dt>SPARKS</span><span class=fu>:</span> <span class=dv>20000</span> (<span class=dv>20000</span> converted, <span class=dv>0</span> overflowed, <span class=dv>0</span> dud, <span class=dv>0</span> <span class=dt>GC'd</span>, <span class=dv>0</span> fizzled)</code></pre></div>
<p><font>The parallel computations themselves are sequenced in the </font><code>Eval</code><font> monad, whose evaluation with </font><code>runEval</code><font> is itself a pure computation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>并行计算本身在 Eval monad 中排序，其使用 runEval 的评估本身就是一个纯计算。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>example ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> (b, b)
example f x y <span class=fu>=</span> runEval <span class=fu>$</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> rpar <span class=fu>$</span> f x
  b <span class=ot>&lt;-</span> rpar <span class=fu>$</span> f y
  rseq a
  rseq b
  return (a, b)</code></pre></div>
<h2 id=threadscope><font>Threadscope</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>线程范围</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Passing the flag </font><code>-l</code><font> generates the eventlog which can be rendered with the threadscope library.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>传递标志 -l 会生成可以使用线程范围库呈现的事件日志。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> ghc <span class=fu>-</span><span class=dt>O2</span> <span class=fu>-</span>threaded <span class=fu>-</span>rtsopts <span class=fu>-</span>eventlog Example.hs
<span class=fu>$</span> <span class=fu>./</span>program <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span><span class=dt>N4</span> <span class=fu>-</span>l
<span class=fu>$</span> threadscope Example.eventlog</code></pre></div>
<div class=figure>
<img src="data:image/png;base64,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Z44dPwof1cQDdQywV0dQB3geBw3utWTQC9iWRI0pPIUEkAASQAJIAAmUPQG1RQsEcePa1bwxFfJb77zDVX0uJbOq3GnQvmH9uq5BAbu7V9Ogb74uFW862SGWXGBGhoanT57o1gOUbnSgLqltQIiE4gcJElt4KEbJeZGHXSK+IBcLytXY0NDXx9u1gQtVa07tTKc8wQ31CZC+hepn2OINtl6G9/INO/JdaWxAAkgACSABJIAEKigBdUULZRmycq1RlhHk82Vjazvjj/k9QkLYbE7uk0nELo983X80wD1wFXA68vhKNjAoCzl18mT3Hj1Mkt/7E+S5JOlentHexYtK1os88uL7gg1xYYc5uHsPHhkCmd1sIKplrrwDbGoh296NOkpjXmoWEp5CAkgACSABJIAEikOAlvDta3HG41gkADWsk6f8yuZw7GrWnDF9WqmWtZSlL7yySAAJIAEkgASQwE9NAGXuT335MHgkgASQABJAAkgACSAB5QQqStGC8uiwFQkgASSABJAAEkACSAAJFIlAAbegFckmDkICSAAJIAEkgASQABJAAuVMAPdIKucLgO6RABJAAkgACSABJIAESoMAytzSoIo2kQASQAJIAAkgASSABMqZAFPVvqHlHBe6RwJIAAkgASSABJAAEkACxSCA2dxiwMOhSAAJIAEkgASQABJAAhWVAPPjxw8VNTaMCwkgASSABJAAEkACSAAJFJEALSU5qYhDNR729P23k7fexsanazyiVDoy6HQbK6MeLZ2969UoFQdoFAkgASSABJAAEkACSKDCEGCWdiSgcXdeeN7Yx61NSwsGnVHa7tTYl0il3xJSdpx/lpmR0dzHUU1PPIUEkAASQAJIAAkgASTwsxModZl7Iuytp7uriZlFloAkCHH58jI2MfXycL306APK3PK9EOgdCSABJIAEkAASQAKlTYCSuYkJ8R8i3nPY7JJ1RqPRDI2MElLYDTxMuDxJyRovsjU9A9PEVM69O7dKfL5FDqmkBsqBOzrVs6pWvaRsoh0kgASQABJAAkgACfykBJgJ8fFvXr/09m1oaWVFp5fkxgtSqTQpMZF+53p89Gt4X3EA0QnS1d2zxOdb7hOUA3/2+CFEgkq33C8HBoAEkAASQAJIAAmULwFmZMS7+s4uOjraXE4JZ3NhYmCWySAWj+9IEFCxUFGO/rO2l9J8y32G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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/threadscope.png>
</div>
<p><font>See Simon Marlows's </font><em>Parallel and Concurrent Programming in Haskell</em><font> for a detailed guide on interpreting and profiling using Threadscope.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>有关使用 Threadscope 进行解释和分析的详细指南，请参阅 Simon Marlows 在 Haskell 中的并行和并发编程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://www.well-typed.com/blog/86/>Performance profiling with ghc-events-analyze<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>使用 ghc-events-analyze 进行性能分析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=strategies><font>Strategies</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>攻略</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>Strategy</span> a <span class=fu>=</span> a <span class=ot>-&gt;</span> <span class=dt>Eval</span> a
<span class=ot>using ::</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> a</code></pre></div>
<p><font>Sparks themselves form the foundation for higher level parallelism constructs known as </font><code>strategies</code><font> which adapt spark creation to fit the computation or data structure being evaluated. For instance if we wanted to evaluate both elements of a tuple in parallel we can create a strategy which uses sparks to evaluate both sides of the tuple.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Sparks 本身构成了更高级别的并行结构的基础，这些结构被称为策略，这些策略使 spark 的创建适应正在评估的计算或数据结构。例如，如果我们想并行评估元组的两个元素，我们可以创建一个策略，使用火花来评估元组的两边。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/22-concurrency/strategies.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Parallel.Strategies</span>

<span class=ot>parPair' ::</span> <span class=dt>Strategy</span> (a, b)
parPair' (a, b) <span class=fu>=</span> <span class=kw>do</span>
  a' <span class=ot>&lt;-</span> rpar a
  b' <span class=ot>&lt;-</span> rpar b
  return (a', b')

<span class=ot>fib ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
fib <span class=dv>0</span> <span class=fu>=</span> <span class=dv>0</span>
fib <span class=dv>1</span> <span class=fu>=</span> <span class=dv>1</span>
fib n <span class=fu>=</span> fib (n<span class=fu>-</span><span class=dv>1</span>) <span class=fu>+</span> fib (n<span class=fu>-</span><span class=dv>2</span>)

<span class=ot>serial ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
serial   <span class=fu>=</span> (fib <span class=dv>30</span>, fib <span class=dv>31</span>)

<span class=ot>parallel ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
parallel <span class=fu>=</span> runEval <span class=fu>.</span> parPair' <span class=fu>$</span> (fib <span class=dv>30</span>, fib <span class=dv>31</span>)</code></pre></div>
<p><font>This pattern occurs so frequently the combinator </font><code>using</code><font> can be used to write it equivalently in operator-like form that may be more visually appealing to some.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这种模式出现的频率如此之高，以至于组合子可以用来以类似于运算符的形式等效地编写它，这可能对某些人更具视觉吸引力。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>using ::</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> a
x <span class=ot>`using`</span> s <span class=fu>=</span> runEval (s x)

parallel <span class=ot>::</span><span class=fu>:</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
parallel <span class=fu>=</span> (fib <span class=dv>30</span>, fib <span class=dv>31</span>) <span class=ot>`using`</span> parPair</code></pre></div>
<p><font>For a less contrived example consider a parallel </font><code>parmap</code><font> which maps a pure function over a list of a values in parallel.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于一个不那么做作的例子，考虑一个并行 parmap，它将一个纯函数并行映射到一个值列表上。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/22-concurrency/spark.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Parallel.Strategies</span>

<span class=ot>parMap' ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> <span class=dt>Eval</span> [b]
parMap' f [] <span class=fu>=</span> return []
parMap' f (a<span class=fu>:</span>as) <span class=fu>=</span> <span class=kw>do</span>
  b  <span class=ot>&lt;-</span> rpar (f a)
  bs <span class=ot>&lt;-</span> parMap' f as
  return (b<span class=fu>:</span>bs)

<span class=ot>result ::</span> [<span class=dt>Int</span>]
result <span class=fu>=</span> runEval <span class=fu>$</span> parMap' (<span class=fu>+</span><span class=dv>1</span>) [<span class=dv>1</span><span class=fu>..</span><span class=dv>1000</span>]</code></pre></div>
<p><font>The functions above are quite useful, but will break down if evaluation of the arguments needs to be parallelized beyond simply weak head normal form. For instance if the arguments to </font><code>rpar</code><font> is a nested constructor we'd like to parallelize the entire section of work in evaluated the expression to normal form instead of just the outer layer. As such we'd like to generalize our strategies so the the evaluation strategy for the arguments can be passed as an argument to the strategy.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>上面的函数非常有用，但如果参数的计算需要并行化而不仅仅是弱头范式，那么它们就会崩溃。例如，如果 rpar 的参数是一个嵌套的构造函数，我们希望将整个工作部分并行化，将表达式计算为正常形式，而不仅仅是外层。因此，我们想概括我们的策略，以便参数的评估策略可以作为参数传递给策略。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><code>Control.Parallel.Strategies</code><font> contains a generalized version of </font><code>rpar</code><font> which embeds additional evaluation logic inside the </font><code>rpar</code><font> computation in Eval monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Control.Parallel.Strategies 包含 rpar 的通用版本，它在 Eval monad 的 rpar 计算中嵌入了额外的评估逻辑。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>rparWith ::</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> a</code></pre></div>
<p><font>Using the deepseq library we can now construct a Strategy variant of rseq that evaluates to full normal form.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 deepseq 库，我们现在可以构建 rseq 的 Strategy 变体，其计算结果为完全范式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>rdeepseq ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>Strategy</span> a
rdeepseq x <span class=fu>=</span> rseq (force x)</code></pre></div>
<p><font>We now can create a "higher order" strategy that takes two strategies and itself yields a a computation which when evaluated uses the passed strategies in its scheduling.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们现在可以创建一个“高阶”策略，该策略采用两种策略，它本身会产生一个计算，该计算在评估时会在其调度中使用传递的策略。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/22-concurrency/strategies_param.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.DeepSeq</span>
<span class=kw>import </span><span class=dt>Control.Parallel.Strategies</span>

<span class=ot>evalPair ::</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> b <span class=ot>-&gt;</span> <span class=dt>Strategy</span> (a, b)
evalPair sa sb (a, b) <span class=fu>=</span> <span class=kw>do</span>
  a' <span class=ot>&lt;-</span> sa a
  b' <span class=ot>&lt;-</span> sb b
  return (a', b')

<span class=ot>parPair ::</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> b <span class=ot>-&gt;</span> <span class=dt>Strategy</span> (a, b)
parPair sa sb <span class=fu>=</span> evalPair (rparWith sa) (rparWith sb)

<span class=ot>fib ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
fib <span class=dv>0</span> <span class=fu>=</span> <span class=dv>0</span>
fib <span class=dv>1</span> <span class=fu>=</span> <span class=dv>1</span>
fib n <span class=fu>=</span> fib (n<span class=fu>-</span><span class=dv>1</span>) <span class=fu>+</span> fib (n<span class=fu>-</span><span class=dv>2</span>)

<span class=ot>serial ::</span> ([<span class=dt>Int</span>], [<span class=dt>Int</span>])
serial <span class=fu>=</span> (a, b)
  <span class=kw>where</span>
    a <span class=fu>=</span> fmap fib [<span class=dv>0</span><span class=fu>..</span><span class=dv>30</span>]
    b <span class=fu>=</span> fmap fib [<span class=dv>1</span><span class=fu>..</span><span class=dv>30</span>]

<span class=ot>parallel ::</span> ([<span class=dt>Int</span>], [<span class=dt>Int</span>])
parallel <span class=fu>=</span> (a, b) <span class=ot>`using`</span> evalPair rdeepseq rdeepseq
  <span class=kw>where</span>
    a <span class=fu>=</span> fmap fib [<span class=dv>0</span><span class=fu>..</span><span class=dv>30</span>]
    b <span class=fu>=</span> fmap fib [<span class=dv>1</span><span class=fu>..</span><span class=dv>30</span>]</code></pre></div>
<p><font>These patterns are implemented in the Strategies library along with several other general forms and combinators for combining strategies to fit many different parallel computations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些模式与其他几种通用形式和组合器一起在 Strategies 库中实现，用于组合策略以适应许多不同的并行计算。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>parTraverse ::</span> <span class=dt>Traversable</span> t <span class=ot>=&gt;</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> (t a)
<span class=ot>dot ::</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> <span class=dt>Strategy</span> a
<span class=ot>($||) ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> <span class=dt>Strategy</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
<span class=ot>(.||) ::</span> (b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> <span class=dt>Strategy</span> b <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> c</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html>Control.Concurent.Strategies<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>控制.并发.策略</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=stm><font>STM</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>STM</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>atomically ::</span> <span class=dt>STM</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a
<span class=ot>orElse ::</span> <span class=dt>STM</span> a <span class=ot>-&gt;</span> <span class=dt>STM</span> a <span class=ot>-&gt;</span> <span class=dt>STM</span> a
<span class=ot>retry ::</span> <span class=dt>STM</span> a

<span class=ot>newTVar ::</span> a <span class=ot>-&gt;</span> <span class=dt>STM</span> (<span class=dt>TVar</span> a)
<span class=ot>newTVarIO ::</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>TVar</span> a)
<span class=ot>writeTVar ::</span> <span class=dt>TVar</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>STM</span> ()
<span class=ot>readTVar ::</span> <span class=dt>TVar</span> a <span class=ot>-&gt;</span> <span class=dt>STM</span> a

<span class=ot>modifyTVar ::</span> <span class=dt>TVar</span> a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>STM</span> ()
<span class=ot>modifyTVar' ::</span> <span class=dt>TVar</span> a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>STM</span> ()</code></pre></div>
<p><font>Software Transactional Memory is a technique for guaranteeing atomicity of values in parallel computations, such that all contexts view the same data when read and writes are guaranteed never to result in inconsistent states.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>软件事务内存是一种用于保证并行计算中值的原子性的技术，这样在保证读写时所有上下文都查看相同的数据永远不会导致不一致的状态。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The strength of Haskell's purity guarantees that transactions within STM are pure and can always be rolled back if a commit fails.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 纯度的优势保证了 STM 中的事务是纯净的，并且在提交失败时总是可以回滚。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/22-concurrency/stm.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Concurrent</span>
<span class=kw>import </span><span class=dt>Control.Concurrent.STM</span>

<span class=kw>type</span> <span class=dt>Account</span> <span class=fu>=</span> <span class=dt>TVar</span> <span class=dt>Double</span>

<span class=ot>transfer ::</span> <span class=dt>Account</span> <span class=ot>-&gt;</span> <span class=dt>Account</span> <span class=ot>-&gt;</span> <span class=dt>Double</span> <span class=ot>-&gt;</span> <span class=dt>STM</span> ()
transfer from to amount <span class=fu>=</span> <span class=kw>do</span>
  available <span class=ot>&lt;-</span> readTVar from
  when (amount <span class=fu>&gt;</span> available) retry

  modifyTVar from (<span class=fu>+</span> (<span class=fu>-</span>amount))
  modifyTVar to   (<span class=fu>+</span> amount)

<span class=co>-- Threads are scheduled non-deterministically.</span>
<span class=ot>actions ::</span> <span class=dt>Account</span> <span class=ot>-&gt;</span> <span class=dt>Account</span> <span class=ot>-&gt;</span> [<span class=dt>IO</span> <span class=dt>ThreadId</span>]
actions a b <span class=fu>=</span> map forkIO [
     <span class=co>-- transfer to</span>
       atomically (transfer a b <span class=dv>10</span>)
     , atomically (transfer a b (<span class=fu>-</span><span class=dv>20</span>))
     , atomically (transfer a b <span class=dv>30</span>)

     <span class=co>-- transfer back</span>
     , atomically (transfer a b (<span class=fu>-</span><span class=dv>30</span>))
     , atomically (transfer a b <span class=dv>20</span>)
     , atomically (transfer a b (<span class=fu>-</span><span class=dv>10</span>))
   ]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  accountA <span class=ot>&lt;-</span> atomically <span class=fu>$</span> newTVar <span class=dv>60</span>
  accountB <span class=ot>&lt;-</span> atomically <span class=fu>$</span> newTVar <span class=dv>0</span>

  sequence_ (actions accountA accountB)

  balanceA <span class=ot>&lt;-</span> atomically <span class=fu>$</span> readTVar accountA
  balanceB <span class=ot>&lt;-</span> atomically <span class=fu>$</span> readTVar accountB

  print <span class=fu>$</span> balanceA <span class=fu>==</span> <span class=dv>60</span>
  print <span class=fu>$</span> balanceB <span class=fu>==</span> <span class=dv>0</span></code></pre></div>
<p><font>See: </font><a href=https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency>Beautiful Concurrency</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：美丽的并发</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=monad-par><font>Monad Par</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单价单价</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Using the Par monad we express our computation as a data flow graph which is scheduled in order of the connections between forked computations which exchange resulting computations with </font><code>IVar</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 Par monad，我们将计算表达为数据流图，该数据流图按分叉计算之间的连接顺序进行调度，这些分叉计算与 IVar 交换计算结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>new ::</span> <span class=dt>Par</span> (<span class=dt>IVar</span> a)
<span class=ot>put ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>IVar</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Par</span> ()
<span class=ot>get ::</span> <span class=dt>IVar</span> a <span class=ot>-&gt;</span> <span class=dt>Par</span> a
<span class=ot>fork ::</span> <span class=dt>Par</span> () <span class=ot>-&gt;</span> <span class=dt>Par</span> ()
<span class=ot>spawn ::</span> <span class=dt>NFData</span> a <span class=ot>=&gt;</span> <span class=dt>Par</span> a <span class=ot>-&gt;</span> <span class=dt>Par</span> (<span class=dt>IVar</span> a)</code></pre></div>
<div class=figure>
<img src="data:image/png;base64,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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/par.png>
</div>
<div class=sourceCode include=src/22-concurrency/par.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.Par</span>

f,<span class=ot> g ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
f x <span class=fu>=</span> x <span class=fu>+</span> <span class=dv>10</span>
g x <span class=fu>=</span> x <span class=fu>*</span> <span class=dv>10</span>

<span class=co>--   f x      g x</span>
<span class=co>--     \     /</span>
<span class=co>--      a + b</span>
<span class=co>--      /   \</span>
<span class=co>-- f (a+b)  g (a+b)</span>
<span class=co>--      \   /</span>
<span class=co>--      (d,e)</span>

<span class=ot>example1 ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
example1 x <span class=fu>=</span> runPar <span class=fu>$</span> <span class=kw>do</span>
  [a,b,c,d,e] <span class=ot>&lt;-</span> replicateM <span class=dv>5</span> new
  fork (put a (f x))
  fork (put b (g x))
  a' <span class=ot>&lt;-</span> get a
  b' <span class=ot>&lt;-</span> get b
  fork (put c (a' <span class=fu>+</span> b'))
  c' <span class=ot>&lt;-</span> get c
  fork (put d (f c'))
  fork (put e (g c'))
  d' <span class=ot>&lt;-</span> get d
  e' <span class=ot>&lt;-</span> get e
  return (d', e')

<span class=ot>example2 ::</span> [<span class=dt>Int</span>]
example2 <span class=fu>=</span> runPar <span class=fu>$</span> <span class=kw>do</span>
  xs <span class=ot>&lt;-</span> parMap (<span class=fu>+</span><span class=dv>1</span>) [<span class=dv>1</span><span class=fu>..</span><span class=dv>25</span>]
  return xs

<span class=co>-- foldr (+) 0 (map (^2) [1..xs])</span>
<span class=ot>example3 ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
example3 n <span class=fu>=</span> runPar <span class=fu>$</span> <span class=kw>do</span>
  <span class=kw>let</span> range <span class=fu>=</span> (<span class=dt>InclusiveRange</span> <span class=dv>1</span> n)
  <span class=kw>let</span> mapper x <span class=fu>=</span> return (x<span class=fu>^</span><span class=dv>2</span>)
  <span class=kw>let</span> reducer x y <span class=fu>=</span> return (x<span class=fu>+</span>y)
  parMapReduceRangeThresh <span class=dv>10</span> range mapper reducer <span class=dv>0</span></code></pre></div>
<h2 id=async><font>async</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>异步</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Async is a higher level set of functions that work on top of Control.Concurrent and STM.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>异步是在 Control.Concurrent 和 STM 之上工作的一组更高级别的函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>async ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Async</span> a)
<span class=ot>wait ::</span> <span class=dt>Async</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a
<span class=ot>cancel ::</span> <span class=dt>Async</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
<span class=ot>concurrently ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> b <span class=ot>-&gt;</span> <span class=dt>IO</span> (a, b)
<span class=ot>race ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> b <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Either</span> a b)</code></pre></div>
<div class=sourceCode include=src/22-concurrency/async.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import </span><span class=dt>Control.Concurrent</span>
<span class=kw>import </span><span class=dt>Control.Concurrent.Async</span>
<span class=kw>import </span><span class=dt>Data.Time</span>

<span class=ot>timeit ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> (a,<span class=dt>Double</span>)
timeit io <span class=fu>=</span> <span class=kw>do</span>
  t0 <span class=ot>&lt;-</span> getCurrentTime
  a <span class=ot>&lt;-</span> io
  t1 <span class=ot>&lt;-</span> getCurrentTime
  return (a, realToFrac (t1 <span class=ot>`diffUTCTime`</span> t0))

<span class=ot>worker ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>Int</span>
worker n <span class=fu>=</span> <span class=kw>do</span>
  <span class=co>-- simulate some work</span>
  threadDelay (<span class=dv>10</span><span class=fu>^</span><span class=dv>2</span> <span class=fu>*</span> n)
  return (n <span class=fu>*</span> n)

<span class=co>-- Spawn 2 threads in parallel, halt on both finished.</span>
<span class=ot>test1 ::</span> <span class=dt>IO</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
test1 <span class=fu>=</span> <span class=kw>do</span>
  val1 <span class=ot>&lt;-</span> async <span class=fu>$</span> worker <span class=dv>1000</span>
  val2 <span class=ot>&lt;-</span> async <span class=fu>$</span> worker <span class=dv>2000</span>
  (,) <span class=fu>&lt;$&gt;</span> wait val1 <span class=fu>&lt;*&gt;</span> wait val2

<span class=co>-- Spawn 2 threads in parallel, halt on first finished.</span>
<span class=ot>test2 ::</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>Int</span> <span class=dt>Int</span>)
test2 <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> val1 <span class=fu>=</span> worker <span class=dv>1000</span>
  <span class=kw>let</span> val2 <span class=fu>=</span> worker <span class=dv>2000</span>
  race val1 val2

<span class=co>-- Spawn 10000 threads in parallel, halt on all finished.</span>
<span class=ot>test3 ::</span> <span class=dt>IO</span> [<span class=dt>Int</span>]
test3 <span class=fu>=</span> mapConcurrently worker [<span class=dv>0</span><span class=fu>..</span><span class=dv>10000</span>]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>=&lt;&lt;</span> timeit test1
  print <span class=fu>=&lt;&lt;</span> timeit test2
  print <span class=fu>=&lt;&lt;</span> timeit test3</code></pre></div>
<hr>
<h1 id=graphics><font>Graphics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图形</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=diagrams><font>Diagrams</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>图表</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Diagrams is a a parser combinator library for generating vector images to SVG and a variety of other formats.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Diagrams 是一个解析器组合器库，用于将矢量图像生成为 SVG 和各种其他格式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/23-graphics/diagrams.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Diagrams.Prelude</span>
<span class=kw>import </span><span class=dt>Diagrams.Backend.SVG.CmdLine</span>

<span class=ot>sierpinski ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Diagram</span> <span class=dt>SVG</span>
sierpinski <span class=dv>1</span> <span class=fu>=</span> eqTriangle <span class=dv>1</span>
sierpinski n <span class=fu>=</span>
      s
     <span class=fu>===</span>
  (s <span class=fu>|||</span> s) <span class=fu>#</span> centerX
  <span class=kw>where</span>
    s <span class=fu>=</span> sierpinski (n <span class=fu>-</span> <span class=dv>1</span>)

<span class=ot>example ::</span> <span class=dt>Diagram</span> <span class=dt>SVG</span>
example <span class=fu>=</span> sierpinski <span class=dv>5</span> <span class=fu>#</span> fc black

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> defaultMain example</code></pre></div>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>runhaskell</span> diagram1.hs -w 256 -h 256 -o diagram1.svg</code></pre></div>
<div class=figure>
<img src="data:image/png;base64,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" alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/diagram1.png>
</div>
<p><font>See: </font><a href=http://projects.haskell.org/diagrams/doc/quickstart.html>Diagrams Quick Start Tutorial</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：图表快速入门教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<hr>
<h1 id=parsing><font>Parsing</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=parsec><font>Parsec</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>秒差距</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>For parsing in Haskell it is quite common to use a family of libraries known as </font><em>Parser Combinators</em><font> which let us write code to generate parsers which themselves looks very similar to the parser grammar itself!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Haskell 中进行解析时，使用称为解析器组合器的库家族是很常见的，它让我们编写代码来生成解析器，这些解析器本身看起来与解析器语法本身非常相似！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left></th>
<th align=left><font>Combinators</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>组合器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>&lt;|&gt;<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>&lt;|&gt;</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The choice operator tries to parse the first argument before proceeding to the second. Can be chained sequentially to generate a sequence of options.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>选择运算符在继续处理第二个参数之前尝试解析第一个参数。可以按顺序链接以生成一系列选项。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>many<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>许多</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Consumes an arbitrary number of patterns matching the given pattern and returns them as a list.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用与给定模式匹配的任意数量的模式并将它们作为列表返回。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>many1<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>很多1</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Like many but requires at least one match.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>像许多人一样，但至少需要一场比赛。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>optional<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>选修的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Optionally parses a given pattern returning its value as a Maybe.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可选地解析给定模式，将其值作为 Maybe 返回。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>try<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尝试</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Backtracking operator will let us parse ambiguous matching expressions and restart with a different pattern.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>回溯运算符会让我们解析不明确的匹配表达式并以不同的模式重新开始。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>There are two styles of writing Parsec, one can choose to write with monads or with applicatives.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Parsec有两种写法，一种可以选择用monads写，也可以用applicatives写。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>parseM ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
parseM <span class=fu>=</span> <span class=kw>do</span>
  a <span class=ot>&lt;-</span> identifier
  char <span class=ch>'+'</span>
  b <span class=ot>&lt;-</span> identifier
  return <span class=fu>$</span> <span class=dt>Add</span> a b</code></pre></div>
<p><font>The same code written with applicatives uses the applicative combinators:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 applicatives 编写的相同代码使用 applicative 组合器：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- | Sequential application.</span>
<span class=ot>(&lt;*&gt;) ::</span> f (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f a <span class=ot>-&gt;</span> f b

<span class=co>-- | Sequence actions, discarding the value of the first argument.</span>
<span class=ot>(*&gt;) ::</span> f a <span class=ot>-&gt;</span> f b <span class=ot>-&gt;</span> f b
(<span class=fu>*&gt;</span>) <span class=fu>=</span> liftA2 (const id)

<span class=co>-- | Sequence actions, discarding the value of the second argument.</span>
<span class=ot>(&lt;*) ::</span> f a <span class=ot>-&gt;</span> f b <span class=ot>-&gt;</span> f a
(<span class=fu>&lt;*</span>) <span class=fu>=</span> liftA2 const</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>parseA ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
parseA <span class=fu>=</span> <span class=dt>Add</span> <span class=fu>&lt;$&gt;</span> identifier <span class=fu>&lt;*</span> char <span class=ch>'+'</span> <span class=fu>&lt;*&gt;</span> identifier</code></pre></div>
<p><font>Now for instance if we want to parse simple lambda expressions we can encode the parser logic as compositions of these combinators which yield the string parser when evaluated under with the </font><code>parse</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在，例如，如果我们想要解析简单的 lambda 表达式，我们可以将解析器逻辑编码为这些组合器的组合，这些组合器在使用解析器进行评估时产生字符串解析器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/simple_parser.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Text.Parsec</span>
<span class=kw>import </span><span class=dt>Text.Parsec.String</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>Char</span>
  <span class=fu>|</span> <span class=dt>Lam</span> <span class=dt>Char</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=ot>lam ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
lam <span class=fu>=</span> <span class=kw>do</span>
  char <span class=ch>'\\'</span>
  n <span class=ot>&lt;-</span> letter
  string <span class=st>"-&gt;"</span>
  e <span class=ot>&lt;-</span> expr
  return <span class=fu>$</span> <span class=dt>Lam</span> n e

<span class=ot>app ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
app <span class=fu>=</span> <span class=kw>do</span>
  apps <span class=ot>&lt;-</span> many1 term
  return <span class=fu>$</span> foldl1 <span class=dt>App</span> apps

<span class=ot>var ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
var <span class=fu>=</span> <span class=kw>do</span>
  n <span class=ot>&lt;-</span> letter
  return <span class=fu>$</span> <span class=dt>Var</span> n

<span class=ot>parens ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
parens p <span class=fu>=</span> <span class=kw>do</span>
  char <span class=ch>'('</span>
  e <span class=ot>&lt;-</span> p
  char <span class=ch>')'</span>
  return e

<span class=ot>term ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
term <span class=fu>=</span> var <span class=fu>&lt;|&gt;</span> parens expr

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> lam <span class=fu>&lt;|&gt;</span> app

<span class=ot>decl ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
decl <span class=fu>=</span> <span class=kw>do</span>
  e <span class=ot>&lt;-</span> expr
  eof
  return e

<span class=ot>test ::</span> <span class=dt>IO</span> ()
test <span class=fu>=</span> parseTest decl <span class=st>"\\y-&gt;y(\\x-&gt;x)y"</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> test <span class=fu>&gt;&gt;=</span> print</code></pre></div>
<h2 id=custom-lexer><font>Custom Lexer</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自定义词法分析器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>In our previous example lexing pass was not necessary because each lexeme mapped to a sequential collection of characters in the stream type. If we wanted to extend this parser with a non-trivial set of tokens, then Parsec provides us with a set of functions for defining lexers and integrating these with the parser combinators. The simplest example builds on top of the builtin Parsec language definitions which define a set of most common lexical schemes.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在我们之前的示例中，lexing pass 不是必需的，因为每个 lexeme 都映射到流类型中的连续字符集合。如果我们想用一组不平凡的标记扩展这个解析器，那么 Parsec 为我们提供了一组函数来定义词法分析器并将它们与解析器组合器集成。最简单的示例建立在内置的 Parsec 语言定义之上，这些定义定义了一组最常见的词法方案。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For instance we'll build on top of the empty language grammar on top of the haskellDef grammer that uses the Text token instead of string.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们将在使用文本标记而不是字符串的 haskellDef 语法器之上构建空语言语法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/lexer_text.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Text.Parsec</span>
<span class=kw>import </span><span class=dt>Text.Parsec.Text</span>
<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Token</span> <span class=kw>as</span> <span class=dt>Tok</span>
<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Language</span> <span class=kw>as</span> <span class=dt>Lang</span>

<span class=kw>import </span><span class=dt>Data.Functor.Identity</span> (<span class=dt>Identity</span>)
<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.IO</span> <span class=kw>as</span> <span class=dt>TIO</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>T.Text</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Lam</span> <span class=dt>T.Text</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=ot>lexer ::</span> <span class=dt>Tok.GenTokenParser</span> <span class=dt>T.Text</span> () <span class=dt>Identity</span>
lexer <span class=fu>=</span> Tok.makeTokenParser style

<span class=ot>style ::</span> <span class=dt>Tok.GenLanguageDef</span> <span class=dt>T.Text</span> () <span class=dt>Identity</span>
style <span class=fu>=</span> Lang.emptyDef
  { Tok.commentStart    <span class=fu>=</span> <span class=st>"{-"</span>
  , Tok.commentEnd      <span class=fu>=</span> <span class=st>"-}"</span>
  , Tok.commentLine     <span class=fu>=</span> <span class=st>"--"</span>
  , Tok.nestedComments  <span class=fu>=</span> <span class=dt>True</span>
  , Tok.identStart      <span class=fu>=</span> letter
  , Tok.identLetter     <span class=fu>=</span> alphaNum <span class=fu>&lt;|&gt;</span> oneOf <span class=st>"_'"</span>
  , Tok.opStart         <span class=fu>=</span> Tok.opLetter style
  , Tok.opLetter        <span class=fu>=</span> oneOf <span class=st>":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</span>
  , Tok.reservedOpNames <span class=fu>=</span> []
  , Tok.reservedNames   <span class=fu>=</span> []
  , Tok.caseSensitive   <span class=fu>=</span> <span class=dt>True</span>
  }

<span class=ot>parens ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
parens <span class=fu>=</span> Tok.parens lexer

<span class=ot>reservedOp ::</span> <span class=dt>T.Text</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> ()
reservedOp op <span class=fu>=</span> Tok.reservedOp lexer (T.unpack op)

<span class=ot>ident ::</span> <span class=dt>Parser</span> <span class=dt>T.Text</span>
ident <span class=fu>=</span> T.pack <span class=fu>&lt;$&gt;</span> Tok.identifier lexer

<span class=ot>contents ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
contents p <span class=fu>=</span> <span class=kw>do</span>
  Tok.whiteSpace lexer
  r <span class=ot>&lt;-</span> p
  eof
  return r

<span class=ot>var ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
var <span class=fu>=</span> <span class=kw>do</span>
  var <span class=ot>&lt;-</span> ident
  return (<span class=dt>Var</span> var )

<span class=ot>app ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
app <span class=fu>=</span> <span class=kw>do</span>
  e1 <span class=ot>&lt;-</span> expr
  e2 <span class=ot>&lt;-</span> expr
  return (<span class=dt>App</span> e1 e2)

<span class=ot>fun ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
fun <span class=fu>=</span> <span class=kw>do</span>
  reservedOp <span class=st>"\\"</span>
  binder <span class=ot>&lt;-</span> ident
  reservedOp <span class=st>"."</span>
  rhs <span class=ot>&lt;-</span> expr
  return (<span class=dt>Lam</span> binder rhs)

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> <span class=kw>do</span>
  es <span class=ot>&lt;-</span> many1 aexp
  return (foldl1 <span class=dt>App</span> es)

<span class=ot>aexp ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
aexp <span class=fu>=</span> fun <span class=fu>&lt;|&gt;</span> var <span class=fu>&lt;|&gt;</span> (parens expr)

<span class=ot>test ::</span> <span class=dt>T.Text</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>ParseError</span> <span class=dt>Expr</span>
test <span class=fu>=</span> parse (contents expr) <span class=st>"&lt;stdin&gt;"</span>

<span class=ot>repl ::</span> <span class=dt>IO</span> ()
repl <span class=fu>=</span> <span class=kw>do</span>
  str <span class=ot>&lt;-</span> TIO.getLine
  print (test str)
  repl

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> repl</code></pre></div>
<p><font>See: </font><a href=https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html>Text.Parsec.Language</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：Text.Parsec.Language</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=simple-parsing><font>Simple Parsing</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>简单解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Putting our lexer and parser together we can write down a more robust parser for our little lambda calculus syntax.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将我们的词法分析器和解析器放在一起，我们可以为我们的小 lambda 演算语法编写一个更健壮的解析器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/parser.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Parser</span> (parseExpr) <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Text.Parsec</span>
<span class=kw>import </span><span class=dt>Text.Parsec.String</span> (<span class=dt>Parser</span>)
<span class=kw>import </span><span class=dt>Text.Parsec.Language</span> (haskellStyle)

<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Expr</span> <span class=kw>as</span> <span class=dt>Ex</span>
<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Token</span> <span class=kw>as</span> <span class=dt>Tok</span>

<span class=kw>type</span> <span class=dt>Id</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Lam</span> <span class=dt>Id</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Var</span> <span class=dt>Id</span>
  <span class=fu>|</span> <span class=dt>Num</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>Op</span>  <span class=dt>Binop</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>Binop</span> <span class=fu>=</span> <span class=dt>Add</span> <span class=fu>|</span> <span class=dt>Sub</span> <span class=fu>|</span> <span class=dt>Mul</span> <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=ot>lexer ::</span> <span class=dt>Tok.TokenParser</span> ()
lexer <span class=fu>=</span> Tok.makeTokenParser style
  <span class=kw>where</span> ops <span class=fu>=</span> [<span class=st>"-&gt;"</span>,<span class=st>"\\"</span>,<span class=st>"+"</span>,<span class=st>"*"</span>,<span class=st>"-"</span>,<span class=st>"="</span>]
        style <span class=fu>=</span> haskellStyle {Tok.reservedOpNames <span class=fu>=</span> ops }

<span class=ot>reservedOp ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> ()
reservedOp <span class=fu>=</span> Tok.reservedOp lexer

<span class=ot>identifier ::</span> <span class=dt>Parser</span> <span class=dt>String</span>
identifier <span class=fu>=</span> Tok.identifier lexer

<span class=ot>parens ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
parens <span class=fu>=</span> Tok.parens lexer

<span class=ot>contents ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
contents p <span class=fu>=</span> <span class=kw>do</span>
  Tok.whiteSpace lexer
  r <span class=ot>&lt;-</span> p
  eof
  return r

<span class=ot>natural ::</span> <span class=dt>Parser</span> <span class=dt>Integer</span>
natural <span class=fu>=</span> Tok.natural lexer

<span class=ot>variable ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
variable <span class=fu>=</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> identifier
  return (<span class=dt>Var</span> x)

<span class=ot>number ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
number <span class=fu>=</span> <span class=kw>do</span>
  n <span class=ot>&lt;-</span> natural
  return (<span class=dt>Num</span> (fromIntegral n))

<span class=ot>lambda ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
lambda <span class=fu>=</span> <span class=kw>do</span>
  reservedOp <span class=st>"\\"</span>
  x <span class=ot>&lt;-</span> identifier
  reservedOp <span class=st>"-&gt;"</span>
  e <span class=ot>&lt;-</span> expr
  return (<span class=dt>Lam</span> x e)

<span class=ot>aexp ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
aexp <span class=fu>=</span>  parens expr
    <span class=fu>&lt;|&gt;</span> variable
    <span class=fu>&lt;|&gt;</span> number
    <span class=fu>&lt;|&gt;</span> lambda

<span class=ot>term ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
term <span class=fu>=</span> Ex.buildExpressionParser table aexp
  <span class=kw>where</span> infixOp x f <span class=fu>=</span> <span class=dt>Ex.Infix</span> (reservedOp x <span class=fu>&gt;&gt;</span> return f)
        table <span class=fu>=</span> [[infixOp <span class=st>"*"</span> (<span class=dt>Op</span> <span class=dt>Mul</span>) <span class=dt>Ex.AssocLeft</span>],
                 [infixOp <span class=st>"+"</span> (<span class=dt>Op</span> <span class=dt>Add</span>) <span class=dt>Ex.AssocLeft</span>]]

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> <span class=kw>do</span>
  es <span class=ot>&lt;-</span> many1 term
  return (foldl1 <span class=dt>App</span> es)

<span class=ot>parseExpr ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
parseExpr input <span class=fu>=</span>
  <span class=kw>case</span> parse (contents expr) <span class=st>"&lt;stdin&gt;"</span> input <span class=kw>of</span>
    <span class=dt>Left</span> err <span class=ot>-&gt;</span> error (show err)
    <span class=dt>Right</span> ast <span class=ot>-&gt;</span> ast

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> getLine <span class=fu>&gt;&gt;=</span> print <span class=fu>.</span> parseExpr <span class=fu>&gt;&gt;</span> main</code></pre></div>
<p><font>Trying it out:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尝试一下：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">λ: <span class=kw>runhaskell</span> simpleparser.hs
<span class=kw>1+2</span>
<span class=kw>Op</span> Add (Num 1) <span class=kw>(Num</span> 2<span class=kw>)</span>

\<span class=kw>i</span> -<span class=kw>&gt;</span> \x -<span class=kw>&gt;</span> x
<span class=kw>Lam</span> <span class=st>"i"</span> (Lam <span class=st>"x"</span> (Var <span class=st>"x"</span>))

\<span class=kw>s</span> -<span class=kw>&gt;</span> \f -<span class=kw>&gt;</span> \g -<span class=kw>&gt;</span> \x -<span class=kw>&gt;</span> f x (g x)
<span class=kw>Lam</span> <span class=st>"s"</span> (Lam <span class=st>"f"</span> (Lam <span class=st>"g"</span> (Lam <span class=st>"x"</span> (App (App (Var <span class=st>"f"</span>) <span class=kw>(Var</span> <span class=st>"x"</span><span class=kw>)</span>) <span class=kw>(App</span> (Var <span class=st>"g"</span><span class=kw>)</span> <span class=kw>(Var</span> <span class=st>"x"</span><span class=kw>)</span>)))))</code></pre></div>
<h2 id=generic-parsing><font>Generic Parsing</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>通用解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Previously we defined generic operations for pretty printing and this begs the question of whether we can write a parser on top of Generics. The answer is generally yes, so long as there is a direct mapping between the specific lexemes and sum and products types. Consider the simplest case where we just read off the names of the constructors using the regular Generics machinery and then build a Parsec parser terms of them.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>之前我们为漂亮的打印定义了泛型操作，这就引出了我们是否可以在泛型之上编写解析器的问题。答案通常是肯定的，只要在特定的词素和求和与乘积类型之间存在直接映射即可。考虑最简单的情况，我们只是使用常规泛型机制读取构造函数的名称，然后构建它们的 Parsec 解析器术语。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/generics.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>import </span><span class=dt>Text.Parsec</span>
<span class=kw>import </span><span class=dt>Text.Parsec.Text.Lazy</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span> ((&lt;*), (&lt;*&gt;), (&lt;$&gt;))
<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=kw>class</span> <span class=dt>GParse</span> f <span class=kw>where</span>
<span class=ot>  gParse ::</span> <span class=dt>Parser</span> (f a)

<span class=co>-- Type synonym metadata for constructors</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> f, <span class=dt>Constructor</span> c) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (<span class=dt>C1</span> c f) <span class=kw>where</span>
  gParse <span class=fu>=</span>
    <span class=kw>let</span> con <span class=fu>=</span> conName (undefined<span class=ot> ::</span> t c f a) <span class=kw>in</span>
    (fmap <span class=dt>M1</span> gParse) <span class=fu>&lt;*</span> string con

<span class=co>-- Constructor names</span>
<span class=kw>instance</span> <span class=dt>GParse</span> f <span class=ot>=&gt;</span> <span class=dt>GParse</span> (<span class=dt>D1</span> c f) <span class=kw>where</span>
  gParse <span class=fu>=</span> fmap <span class=dt>M1</span> gParse

<span class=co>-- Sum types</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> a, <span class=dt>GParse</span> b) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (a <span class=fu>:+:</span> b) <span class=kw>where</span>
  gParse <span class=fu>=</span> try (fmap <span class=dt>L1</span> gParse <span class=fu>&lt;|&gt;</span> fmap <span class=dt>R1</span> gParse)

<span class=co>-- Product types</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> f, <span class=dt>GParse</span> g) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (f <span class=fu>:*:</span> g) <span class=kw>where</span>
  gParse <span class=fu>=</span> (<span class=fu>:*:</span>) <span class=fu>&lt;$&gt;</span> gParse <span class=fu>&lt;*&gt;</span> gParse

<span class=co>-- Nullary constructors</span>
<span class=kw>instance</span> <span class=dt>GParse</span> <span class=dt>U1</span> <span class=kw>where</span>
  gParse <span class=fu>=</span> return <span class=dt>U1</span>

<span class=kw>data</span> <span class=dt>Scientist</span>
  <span class=fu>=</span> <span class=dt>Newton</span>
  <span class=fu>|</span> <span class=dt>Einstein</span>
  <span class=fu>|</span> <span class=dt>Schrodinger</span>
  <span class=fu>|</span> <span class=dt>Feynman</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Generic</span>)

<span class=kw>data</span> <span class=dt>Musician</span>
  <span class=fu>=</span> <span class=dt>Vivaldi</span>
  <span class=fu>|</span> <span class=dt>Bach</span>
  <span class=fu>|</span> <span class=dt>Mozart</span>
  <span class=fu>|</span> <span class=dt>Beethoven</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Generic</span>)

<span class=ot>gparse ::</span> (<span class=dt>Generic</span> g, <span class=dt>GParse</span> (<span class=dt>Rep</span> g)) <span class=ot>=&gt;</span> <span class=dt>Parser</span> g
gparse <span class=fu>=</span> fmap to gParse

<span class=ot>scientist ::</span> <span class=dt>Parser</span> <span class=dt>Scientist</span>
scientist <span class=fu>=</span> gparse

<span class=ot>musician ::</span> <span class=dt>Parser</span> <span class=dt>Musician</span>
musician <span class=fu>=</span> gparse</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> parseTest parseMusician <span class=st>"Bach"</span>
<span class=dt>Bach</span>

λ<span class=fu>:</span> parseTest parseScientist <span class=st>"Feynman"</span>
<span class=dt>Feynman</span></code></pre></div>
<p><font>With a little more work and an outer wrapper, this example an easily be extended to automate parsing of a simple recursive type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通过更多的工作和外部包装器，可以轻松扩展此示例以自动解析简单的递归类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/recursive-generics.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class=ot>{-# LANGUAGE DeriveAnyClass #-}</span>
<span class=ot>{-# LANGUAGE DefaultSignatures #-}</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>    ((&lt;*), (*&gt;), (&lt;*&gt;), (&lt;$&gt;), pure)
<span class=kw>import </span><span class=dt>GHC.Generics</span>
<span class=kw>import </span><span class=dt>Text.Parsec</span>            ((&lt;|&gt;), string, try, many1, digit, char, letter, spaces)
<span class=kw>import </span><span class=dt>Text.Parsec.Text.Lazy</span>  (<span class=dt>Parser</span>)

<span class=kw>class</span> <span class=dt>GParse</span> f <span class=kw>where</span>
<span class=ot>  gParse ::</span> <span class=dt>Parser</span> (f a)

<span class=co>-- Types</span>
<span class=kw>instance</span> (<span class=dt>Parse</span> a) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (<span class=dt>K1</span> <span class=dt>R</span> a) <span class=kw>where</span>
  gParse <span class=fu>=</span> fmap <span class=dt>K1</span> parse

<span class=co>-- Selector names</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> f, <span class=dt>Selector</span> s) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (<span class=dt>M1</span> <span class=dt>S</span> s f) <span class=kw>where</span>
  gParse <span class=fu>=</span> fmap <span class=dt>M1</span> gParse

<span class=co>-- Type synonym metadata for constructors</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> f, <span class=dt>Constructor</span> c) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (<span class=dt>C1</span> c f) <span class=kw>where</span>
  gParse <span class=fu>=</span>
    <span class=kw>let</span> con <span class=fu>=</span> conName (undefined<span class=ot> ::</span> t c f a) <span class=kw>in</span>
      (spaces <span class=fu>&gt;&gt;</span> string con <span class=fu>&gt;&gt;</span> spaces) <span class=fu>*&gt;</span> fmap <span class=dt>M1</span> gParse

<span class=co>-- Constructor names</span>
<span class=kw>instance</span> (<span class=dt>Datatype</span> d, <span class=dt>GParse</span> f) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (<span class=dt>D1</span> d f) <span class=kw>where</span>
  gParse <span class=fu>=</span> fmap <span class=dt>M1</span> gParse

<span class=co>-- Sum types</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> a, <span class=dt>GParse</span> b) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (a <span class=fu>:+:</span> b) <span class=kw>where</span>
  gParse <span class=fu>=</span> try (fmap <span class=dt>L1</span> gParse) <span class=fu>&lt;|&gt;</span> try (fmap <span class=dt>R1</span> gParse)

<span class=co>-- Product types</span>
<span class=kw>instance</span> (<span class=dt>GParse</span> f, <span class=dt>GParse</span> g) <span class=ot>=&gt;</span> <span class=dt>GParse</span> (f <span class=fu>:*:</span> g) <span class=kw>where</span>
  gParse <span class=fu>=</span> (<span class=fu>:*:</span>) <span class=fu>&lt;$&gt;</span> try gParse <span class=fu>&lt;*&gt;</span> try gParse

<span class=co>-- Nullary constructors</span>
<span class=kw>instance</span> <span class=dt>GParse</span> <span class=dt>U1</span> <span class=kw>where</span>
  gParse <span class=fu>=</span> return <span class=dt>U1</span>

<span class=ot>gparse ::</span> (<span class=dt>Generic</span> g, <span class=dt>GParse</span> (<span class=dt>Rep</span> g)) <span class=ot>=&gt;</span> <span class=dt>Parser</span> g
gparse <span class=fu>=</span> fmap to gParse

<span class=kw>class</span> <span class=dt>Parse</span> a <span class=kw>where</span>
<span class=ot>  parse ::</span> <span class=dt>Parser</span> a
  default<span class=ot> parse ::</span> (<span class=dt>Generic</span> a, <span class=dt>GParse</span> (<span class=dt>Rep</span> a)) <span class=ot>=&gt;</span> <span class=dt>Parser</span> a
  parse <span class=fu>=</span> spaces <span class=fu>&gt;&gt;</span> char <span class=ch>'('</span> <span class=fu>&gt;&gt;</span> gparse <span class=fu>&gt;&gt;=</span> \e <span class=ot>-&gt;</span> char <span class=ch>')'</span> <span class=fu>&gt;&gt;</span> return e

<span class=kw>instance</span> <span class=dt>Parse</span> <span class=dt>Integer</span> <span class=kw>where</span>
  parse <span class=fu>=</span> rd <span class=fu>&lt;$&gt;</span> (plus <span class=fu>&lt;|&gt;</span> minus <span class=fu>&lt;|&gt;</span> number)
    <span class=kw>where</span> rd     <span class=fu>=</span><span class=ot> read ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Integer</span>
          plus   <span class=fu>=</span> char <span class=ch>'+'</span> <span class=fu>*&gt;</span> number
          minus  <span class=fu>=</span> (<span class=fu>:</span>) <span class=fu>&lt;$&gt;</span> char <span class=ch>'-'</span> <span class=fu>&lt;*&gt;</span> number
          number <span class=fu>=</span> many1 digit

<span class=kw>instance</span> <span class=dt>Parse</span> <span class=dt>String</span> <span class=kw>where</span>
   parse <span class=fu>=</span> many1 letter

<span class=kw>type</span> <span class=dt>Name</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Exp</span> 
  <span class=fu>=</span> <span class=dt>Lit</span> <span class=dt>Integer</span>
  <span class=fu>|</span> <span class=dt>Var</span> <span class=dt>Name</span>
  <span class=fu>|</span> <span class=dt>Plus</span> <span class=dt>Exp</span> <span class=dt>Exp</span> 
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Exp</span> <span class=dt>Exp</span> 
  <span class=fu>|</span> <span class=dt>Abs</span> <span class=dt>Name</span> <span class=dt>Exp</span> <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Generic</span>, <span class=dt>Parse</span>)

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Exp</span>
expr <span class=fu>=</span> parse</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> parseTest expr <span class=st>"(App (Plus (Lit 1) (Var n)) (App (Plus (Lit 5) (Lit 5)) (Plus (Lit 6) (Lit 6))))"</span>
<span class=dt>App</span> (<span class=dt>Plus</span> (<span class=dt>Lit</span> <span class=dv>1</span>) (<span class=dt>Var</span> <span class=st>"n"</span>)) (<span class=dt>App</span> (<span class=dt>Plus</span> (<span class=dt>Lit</span> <span class=dv>5</span>) (<span class=dt>Lit</span> <span class=dv>5</span>)) (<span class=dt>Plus</span> (<span class=dt>Lit</span> <span class=dv>6</span>) (<span class=dt>Lit</span> <span class=dv>6</span>)))</code></pre></div>
<h2 id=attoparsec><font>Attoparsec</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>阿托秒差距</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Attoparsec is a parser combinator like Parsec but more suited for bulk parsing of large text and binary files instead of parsing language syntax to ASTs. When written properly Attoparsec parsers can be </font><a href=http://www.serpentine.com/blog/2014/05/31/attoparsec/>efficient</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Attoparsec 是一个类似于 Parsec 的解析器组合器，但更适合大文本和二进制文件的批量解析，而不是将语言语法解析为 AST。如果编写得当，Attoparsec 解析器会非常高效。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>One notable distinction between Parsec and Attoparsec is that backtracking operator (</font><code>try</code><font>) is not present and reflects on attoparsec's different underlying parser model.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Parsec 和 Attoparsec 之间的一个显着区别是回溯运算符 (try) 不存在并且反映在 attoparsec 不同的底层解析器模型上。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For a simple little lambda calculus language we can use attoparsec much in the same we used parsec:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于一个简单的小 lambda 演算语言，我们可以像使用 parsec 一样使用 attoparsec：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/attoparsec_lang.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import </span><span class=dt>Data.Attoparsec.Text</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.IO</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import </span><span class=dt>Data.List</span> (foldl1')

<span class=kw>data</span> <span class=dt>Name</span>
  <span class=fu>=</span> <span class=dt>Gen</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>Name</span> <span class=dt>T.Text</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>, <span class=dt>Ord</span>)

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>Name</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Lam</span> [<span class=dt>Name</span>] <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Lit</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>Prim</span> <span class=dt>PrimOp</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>PrimOp</span>
  <span class=fu>=</span> <span class=dt>Add</span>
  <span class=fu>|</span> <span class=dt>Sub</span>
  <span class=fu>|</span> <span class=dt>Mul</span>
  <span class=fu>|</span> <span class=dt>Div</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>Defn</span> <span class=fu>=</span> <span class=dt>Defn</span> <span class=dt>Name</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=ot>name ::</span> <span class=dt>Parser</span> <span class=dt>Name</span>
name <span class=fu>=</span> <span class=dt>Name</span> <span class=fu>.</span> T.pack <span class=fu>&lt;$&gt;</span> many1 letter

<span class=ot>num ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
num <span class=fu>=</span> <span class=dt>Lit</span> <span class=fu>&lt;$&gt;</span> signed decimal

<span class=ot>var ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
var <span class=fu>=</span> <span class=dt>Var</span> <span class=fu>&lt;$&gt;</span> name

<span class=ot>lam ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
lam <span class=fu>=</span> <span class=kw>do</span>
  string <span class=st>"\\"</span>
  vars <span class=ot>&lt;-</span> many1 (skipSpace <span class=fu>*&gt;</span> name)
  skipSpace <span class=fu>*&gt;</span> string <span class=st>"-&gt;"</span>
  body <span class=ot>&lt;-</span> expr
  return (<span class=dt>Lam</span> vars body)

<span class=ot>eparen ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
eparen <span class=fu>=</span> char <span class=ch>'('</span> <span class=fu>*&gt;</span> expr <span class=fu>&lt;*</span> skipSpace <span class=fu>&lt;*</span> char <span class=ch>')'</span>

<span class=ot>prim ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
prim <span class=fu>=</span> <span class=dt>Prim</span> <span class=fu>&lt;$&gt;</span> (
      char <span class=ch>'+'</span> <span class=fu>*&gt;</span> return <span class=dt>Add</span>
  <span class=fu>&lt;|&gt;</span> char <span class=ch>'-'</span> <span class=fu>*&gt;</span> return <span class=dt>Sub</span>
  <span class=fu>&lt;|&gt;</span> char <span class=ch>'*'</span> <span class=fu>*&gt;</span> return <span class=dt>Mul</span>
  <span class=fu>&lt;|&gt;</span> char <span class=ch>'/'</span> <span class=fu>*&gt;</span> return <span class=dt>Div</span>)

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> foldl1' <span class=dt>App</span> <span class=fu>&lt;$&gt;</span> many1 (skipSpace <span class=fu>*&gt;</span> atom)

<span class=ot>atom ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
atom <span class=fu>=</span> try lam
    <span class=fu>&lt;|&gt;</span> eparen
    <span class=fu>&lt;|&gt;</span> prim
    <span class=fu>&lt;|&gt;</span> var
    <span class=fu>&lt;|&gt;</span> num

<span class=ot>def ::</span> <span class=dt>Parser</span> <span class=dt>Defn</span>
def <span class=fu>=</span> <span class=kw>do</span>
  skipSpace
  nm <span class=ot>&lt;-</span> name
  skipSpace <span class=fu>*&gt;</span> char <span class=ch>'='</span> <span class=fu>*&gt;</span> skipSpace
  ex <span class=ot>&lt;-</span> expr
  skipSpace <span class=fu>&lt;*</span> char <span class=ch>';'</span>
  return <span class=fu>$</span> <span class=dt>Defn</span> nm ex

<span class=ot>file ::</span> <span class=dt>T.Text</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>String</span> [<span class=dt>Defn</span>]
file <span class=fu>=</span> parseOnly (many def <span class=fu>&lt;*</span> skipSpace)

<span class=ot>parseFile ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>T.Text</span> [<span class=dt>Defn</span>])
parseFile path <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> T.readFile path
  <span class=kw>case</span> file contents <span class=kw>of</span>
    <span class=dt>Left</span> a <span class=ot>-&gt;</span> return <span class=fu>$</span> <span class=dt>Left</span> (T.pack a)
    <span class=dt>Right</span> b <span class=ot>-&gt;</span> return <span class=fu>$</span> <span class=dt>Right</span> b

<span class=ot>main ::</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>T.Text</span> [<span class=dt>Defn</span>])
main <span class=fu>=</span> parseFile <span class=st>"simple.ml"</span></code></pre></div>
<p><font>For an example try the above parser with the following simple lambda expression.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，使用以下简单的 lambda 表达式尝试上面的解析器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/simple.ml><pre class="sourceCode ocaml"><code class="sourceCode ocaml">f = g (x - <span class=dv>1</span>);
g = f (x + <span class=dv>1</span>);
h = \x y -&gt; (f x) + (g y);</code></pre></div>
<p><font>Attoparsec adapts very well to binary and network protocol style parsing as well, this is extracted from a small implementation of a distributed consensus network protocol:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Attoparsec 也非常适合二进制和网络协议样式的解析，这是从分布式共识网络协议的一个小实现中提取的：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/attoparsec.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Control.Monad</span>

<span class=kw>import </span><span class=dt>Data.Attoparsec</span>
<span class=kw>import </span><span class=dt>Data.Attoparsec.Char8</span> <span class=kw>as</span> <span class=dt>A</span>
<span class=kw>import </span><span class=dt>Data.ByteString.Char8</span>

<span class=kw>data</span> <span class=dt>Action</span>
  <span class=fu>=</span> <span class=dt>Success</span>
  <span class=fu>|</span> <span class=dt>KeepAlive</span>
  <span class=fu>|</span> <span class=dt>NoResource</span>
  <span class=fu>|</span> <span class=dt>Hangup</span>
  <span class=fu>|</span> <span class=dt>NewLeader</span>
  <span class=fu>|</span> <span class=dt>Election</span>
  <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=kw>type</span> <span class=dt>Sender</span> <span class=fu>=</span> <span class=dt>ByteString</span>
<span class=kw>type</span> <span class=dt>Payload</span> <span class=fu>=</span> <span class=dt>ByteString</span>

<span class=kw>data</span> <span class=dt>Message</span> <span class=fu>=</span> <span class=dt>Message</span>
  {<span class=ot> action ::</span> <span class=dt>Action</span>
  ,<span class=ot> sender ::</span> <span class=dt>Sender</span>
  ,<span class=ot> payload ::</span> <span class=dt>Payload</span>
  } <span class=kw>deriving</span> <span class=dt>Show</span>

<span class=ot>proto ::</span> <span class=dt>Parser</span> <span class=dt>Message</span>
proto <span class=fu>=</span> <span class=kw>do</span>
  act  <span class=ot>&lt;-</span> paction
  send <span class=ot>&lt;-</span> A.takeTill (<span class=fu>==</span> <span class=ch>'.'</span>)
  body <span class=ot>&lt;-</span> A.takeTill (A.isSpace)
  endOfLine
  return <span class=fu>$</span> <span class=dt>Message</span> act send body

<span class=ot>paction ::</span> <span class=dt>Parser</span> <span class=dt>Action</span>
paction <span class=fu>=</span> <span class=kw>do</span>
  c <span class=ot>&lt;-</span> anyWord8
  <span class=kw>case</span> c <span class=kw>of</span>
    <span class=dv>1</span>  <span class=ot>-&gt;</span> return <span class=dt>Success</span>
    <span class=dv>2</span>  <span class=ot>-&gt;</span> return <span class=dt>KeepAlive</span>
    <span class=dv>3</span>  <span class=ot>-&gt;</span> return <span class=dt>NoResource</span>
    <span class=dv>4</span>  <span class=ot>-&gt;</span> return <span class=dt>Hangup</span>
    <span class=dv>5</span>  <span class=ot>-&gt;</span> return <span class=dt>NewLeader</span>
    <span class=dv>6</span>  <span class=ot>-&gt;</span> return <span class=dt>Election</span>
    _  <span class=ot>-&gt;</span> mzero

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> msgtext <span class=fu>=</span> <span class=st>"\x01\x6c\x61\x70\x74\x6f\x70\x2e\x33\x2e\x31\x34\x31\x35\x39\x32\x36\x35\x33\x35\x0A"</span>
  <span class=kw>let</span> msg <span class=fu>=</span> parseOnly proto msgtext
  print msg</code></pre></div>
<p><font>See: </font><a href=https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec>Text Parsing Tutorial</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：文本解析教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=optparse-applicative><font>Optparse Applicative</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Optparse 应用程序</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Optparse-applicative is a combinator library for building command line interfaces that take in various user flags, commmands and switches and map them into Haskell data structures that can handle the input. The main interface is through the applicative functor </font><code>Parser</code><font> and various combinators such as </font><code>strArgument</code><font> and </font><code>flag</code><font> which populate the option parsing table with some monadic action which returns a Haskell value. The resulting sequence of values can be combined applicatively into a larger Config data structure that holds all the given options. The </font><code>--help</code><font> header is also automatically generated from the combinators.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Optparse-applicative 是一个用于构建命令行界面的组合器库，该界面接受各种用户标志、命令和开关，并将它们映射到可以处理输入的 Haskell 数据结构中。主要接口是通过应用仿函数 Parser 和各种组合器，例如 strArgument 和 flag，它们用一些返回 Haskell 值的单子操作填充选项解析表。生成的值序列可以应用性地组合成一个更大的 Config 数据结构，该结构包含所有给定的选项。 --help 标头也是从组合器自动生成的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>./optparse</span>
<span class=kw>Usage</span>: optparse.hs [filename...] [--quiet] [--cheetah]

<span class=kw>Available</span> options:
  <span class=kw>-h</span>,--help                Show this help text
  <span class=kw>filename...</span>              Input files
  <span class=kw>--quiet</span>                  Whether to shut up.
  <span class=kw>--cheetah</span>                Perform task quickly.</code></pre></div>
<div class=sourceCode include=src/24-parsing/optparse_applicative.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.List</span>
<span class=kw>import </span><span class=dt>Data.Monoid</span>
<span class=kw>import </span><span class=dt>Options.Applicative</span>

<span class=kw>data</span> <span class=dt>Opts</span> <span class=fu>=</span> <span class=dt>Opts</span>
  { _<span class=ot>files ::</span> [<span class=dt>String</span>]
  , _<span class=ot>quiet ::</span> <span class=dt>Bool</span>
  , _<span class=ot>fast ::</span> <span class=dt>Speed</span>
  }

<span class=kw>data</span> <span class=dt>Speed</span> <span class=fu>=</span> <span class=dt>Slow</span> <span class=fu>|</span> <span class=dt>Fast</span>

<span class=ot>options ::</span> <span class=dt>Parser</span> <span class=dt>Opts</span>
options <span class=fu>=</span> <span class=dt>Opts</span> <span class=fu>&lt;$&gt;</span> filename <span class=fu>&lt;*&gt;</span> quiet <span class=fu>&lt;*&gt;</span> fast
  <span class=kw>where</span>
<span class=ot>    filename ::</span> <span class=dt>Parser</span> [<span class=dt>String</span>]
    filename <span class=fu>=</span> many <span class=fu>$</span> argument str <span class=fu>$</span>
         metavar <span class=st>"filename..."</span>
      <span class=fu>&lt;&gt;</span> help <span class=st>"Input files"</span>

<span class=ot>    fast ::</span> <span class=dt>Parser</span> <span class=dt>Speed</span>
    fast <span class=fu>=</span> flag <span class=dt>Slow</span> <span class=dt>Fast</span> <span class=fu>$</span>
         long <span class=st>"cheetah"</span>
      <span class=fu>&lt;&gt;</span> help <span class=st>"Perform task quickly."</span>

<span class=ot>    quiet ::</span> <span class=dt>Parser</span> <span class=dt>Bool</span>
    quiet <span class=fu>=</span> switch <span class=fu>$</span>
         long <span class=st>"quiet"</span>
      <span class=fu>&lt;&gt;</span> help <span class=st>"Whether to shut up."</span>

<span class=ot>greet ::</span> <span class=dt>Opts</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
greet (<span class=dt>Opts</span> files quiet fast) <span class=fu>=</span> <span class=kw>do</span>
  putStrLn <span class=st>"reading these files:"</span>
  mapM_ print files

  <span class=kw>case</span> fast <span class=kw>of</span>
    <span class=dt>Fast</span> <span class=ot>-&gt;</span> putStrLn <span class=st>"quickly"</span>
    <span class=dt>Slow</span> <span class=ot>-&gt;</span> putStrLn <span class=st>"slowly"</span>

  <span class=kw>case</span> quiet <span class=kw>of</span>
    <span class=dt>True</span>  <span class=ot>-&gt;</span> putStrLn <span class=st>"quietly"</span>
    <span class=dt>False</span> <span class=ot>-&gt;</span> putStrLn <span class=st>"loudly"</span>

<span class=ot>opts ::</span> <span class=dt>ParserInfo</span> <span class=dt>Opts</span>
opts <span class=fu>=</span> info (helper <span class=fu>&lt;*&gt;</span> options) fullDesc

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> execParser opts <span class=fu>&gt;&gt;=</span> greet</code></pre></div>
<p><font>See: </font><a href=https://github.com/pcapriotti/optparse-applicative>Optparse Applicative Tutorial</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Optparse 应用教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=happy-alex><font>Happy &amp; Alex</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>快乐 &amp; 亚历克斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Happy is a parser generator system for Haskell, similar to the tool `yacc' for C. It works as a preprocessor with it's own syntax that generates a parse table from two specifications, a lexer file and parser file. Happy does not have the same underlying parser implementation as parser combinators and can effectively work with left-recursive grammars without explicit factorization. It can also easily be modified to track position information for tokens and handle offside parsing rules for indentation-sensitive grammars. Happy is used in GHC itself for Haskell's grammar.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Happy 是 Haskell 的解析器生成器系统，类似于 C 的工具“yacc”。它作为预处理器使用它自己的语法从两个规范生成解析表，一个词法分析器文件和一个解析器文件。 Happy 没有与解析器组合器相同的底层解析器实现，并且可以在没有显式分解的情况下有效地处理左递归语法。它还可以轻松修改以跟踪标记的位置信息并处理缩进敏感语法的越位解析规则。 Happy 在 GHC 本身中用于 Haskell 的语法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ol style=list-style-type:decimal>
<li><font>Lexer.x</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>词法分析器.x</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Parser.y</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解析器.y</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ol>
<p><font>Running the standalone commands will generate the Haskell source for the modules.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>运行独立命令将为模块生成 Haskell 源代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>alex</span> Lexer.x -o Lexer.hs
$ <span class=kw>happy</span> Parser.y -o Parser.hs</code></pre></div>
<p><font>The generated modules are not human readable generally and unfortunatly error messages are given in the Haskell source, not the Happy source.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生成的模块通常不是人类可读的，不幸的是错误消息在 Haskell 源代码中给出，而不是 Happy 源代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=lexer><font>Lexer</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>词法分析器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>For instance we could define a little toy lexer with a custom set of tokens.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们可以使用一组自定义标记定义一个小玩具词法分析器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/happy/Lexer.x><pre class="sourceCode haskell"><code class="sourceCode haskell">{
<span class=kw>module</span> <span class=dt>Lexer</span> (
  <span class=dt>Token</span>(<span class=fu>..</span>),
  scanTokens
) <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Syntax</span>
}

<span class=fu>%</span>wrapper <span class=st>"basic"</span>

<span class=fu>$</span>digit <span class=fu>=</span> <span class=dv>0</span><span class=fu>-</span><span class=dv>9</span>
<span class=fu>$</span>alpha <span class=fu>=</span> [a<span class=fu>-</span>zA<span class=fu>-</span><span class=dt>Z</span>]
<span class=fu>$</span>eol   <span class=fu>=</span> [\n]

tokens <span class=fu>:-</span>

  <span class=co>-- Whitespace insensitive</span>
  <span class=fu>$</span>eol                          ;
  <span class=fu>$</span>white<span class=fu>+</span>                       ;
  print                         { \s <span class=ot>-&gt;</span> <span class=dt>TokenPrint</span> }
  <span class=fu>$</span>digit<span class=fu>+</span>                       { \s <span class=ot>-&gt;</span> <span class=dt>TokenNum</span> (read s) }
  \<span class=fu>=</span>                            { \s <span class=ot>-&gt;</span> <span class=dt>TokenEq</span> }
  <span class=fu>$</span>alpha [<span class=fu>$</span>alpha <span class=fu>$</span>digit \_ \<span class=ch>']* { \s -&gt; TokenSym s }</span>

{

<span class=kw>data</span> <span class=dt>Token</span> 
  <span class=fu>=</span> <span class=dt>TokenNum</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>TokenSym</span> <span class=dt>String</span>
  <span class=fu>|</span> <span class=dt>TokenPrint</span>
  <span class=fu>|</span> <span class=dt>TokenEq</span>
  <span class=fu>|</span> <span class=dt>TokenEOF</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>,<span class=dt>Show</span>)

scanTokens <span class=fu>=</span> alexScanTokens

}</code></pre></div>
<h4 id=parser><font>Parser</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>解析器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>The associated parser is list of a production rules and a monad to running the parser in. Production rules consist of a set of options on the left and generating Haskell expressions on the right with indexed metavariables (</font><code>$1</code><font>, </font><code>$2</code><font>, ...) mapping to the ordered terms on the left (i.e. in the second term </font><code>term</code><font> ~ </font><code>$1</code><font>, </font><code>term</code><font> ~ </font><code>$2</code><font>).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>关联的解析器是一个生产规则列表和一个运行解析器的 monad。生产规则由左侧的一组选项和右侧的生成 Haskell 表达式组成，索引元变量 ($1, $2, ...) 映射到左边的有序术语（即在第二个术语中 term ~ $1，term ~ $2）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode perl"><code class="sourceCode perl">terms
    : term                   { [<span class=dt>$1</span>] }
    | term terms             { <span class=dt>$1</span> : <span class=dt>$2</span> }</code></pre></div>
<div class=sourceCode include=src/24-parsing/happy/Parser.y><pre class="sourceCode haskell"><code class="sourceCode haskell">{
<span class=ot>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class=kw>module</span> <span class=dt>Parser</span> (
  parseExpr,
) <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Lexer</span>
<span class=kw>import </span><span class=dt>Syntax</span>

<span class=kw>import </span><span class=dt>Control.Monad.Except</span>
}

<span class=fu>%</span>name expr
<span class=fu>%</span>tokentype { <span class=dt>Token</span> }
<span class=fu>%</span>monad { <span class=dt>Except</span> <span class=dt>String</span> } { (<span class=fu>&gt;&gt;=</span>) } { return }
<span class=fu>%</span>error { parseError }

<span class=fu>%</span>token
    int   { <span class=dt>TokenNum</span> <span class=fu>$$</span> }
    var   { <span class=dt>TokenSym</span> <span class=fu>$$</span> }
    print { <span class=dt>TokenPrint</span> }
    <span class=ch>'='</span>   { <span class=dt>TokenEq</span> }

<span class=fu>%%</span>

terms 
    <span class=fu>:</span> term                   { [<span class=fu>$</span><span class=dv>1</span>] }
    <span class=fu>|</span> term terms             { <span class=fu>$</span><span class=dv>1</span> <span class=fu>:</span> <span class=fu>$</span><span class=dv>2</span> }

term 
   <span class=fu>:</span> var                     { <span class=dt>Var</span> <span class=fu>$</span><span class=dv>1</span> }
   <span class=fu>|</span> var <span class=ch>'='</span> int             { <span class=dt>Assign</span> <span class=fu>$</span><span class=dv>1</span> <span class=fu>$</span><span class=dv>3</span> }
   <span class=fu>|</span> print term              { <span class=dt>Print</span> <span class=fu>$</span><span class=dv>2</span> }

{

<span class=ot>parseError ::</span> [<span class=dt>Token</span>] <span class=ot>-&gt;</span> <span class=dt>Except</span> <span class=dt>String</span> a
parseError (l<span class=fu>:</span>ls) <span class=fu>=</span> throwError (show l)
parseError [] <span class=fu>=</span> throwError <span class=st>"Unexpected end of Input"</span>

<span class=ot>parseExpr ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>String</span> [<span class=dt>Expr</span>]
parseExpr input <span class=fu>=</span> 
  <span class=kw>let</span> tokenStream <span class=fu>=</span> scanTokens input <span class=kw>in</span>
  runExcept (expr tokenStream)
}</code></pre></div>
<p><font>As a simple input consider the following simple program.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作为一个简单的输入，请考虑以下简单程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/24-parsing/happy/input.test><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class=fu>=</span> <span class=dv>4</span>
print x
y <span class=fu>=</span> <span class=dv>5</span>
print y
y <span class=fu>=</span> <span class=dv>6</span>
print y</code></pre></div>
<h2 id=configurator><font>Configurator</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>配置器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode include=src/24-parsing/configurator.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import qualified</span> <span class=dt>Data.Configurator</span> <span class=kw>as</span> <span class=dt>C</span>

<span class=kw>data</span> <span class=dt>Config</span> <span class=fu>=</span> <span class=dt>Config</span>
  {<span class=ot> verbose      ::</span> <span class=dt>Bool</span>
  ,<span class=ot> loggingLevel ::</span> <span class=dt>Int</span>
  ,<span class=ot> logfile      ::</span> FilePath
  ,<span class=ot> dbHost       ::</span> <span class=dt>Text</span>
  ,<span class=ot> dbUser       ::</span> <span class=dt>Text</span>
  ,<span class=ot> dbDatabase   ::</span> <span class=dt>Text</span>
  ,<span class=ot> dbpassword   ::</span> <span class=dt>Maybe</span> <span class=dt>Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=ot>readConfig ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>Config</span>
readConfig cfgFile <span class=fu>=</span> <span class=kw>do</span>
  cfg          <span class=ot>&lt;-</span> C.load [<span class=dt>C.Required</span> cfgFile]
  verbose      <span class=ot>&lt;-</span> C.require cfg <span class=st>"logging.verbose"</span>
  loggingLevel <span class=ot>&lt;-</span> C.require cfg <span class=st>"logging.loggingLevel"</span>
  logFile      <span class=ot>&lt;-</span> C.require cfg <span class=st>"logging.logfile"</span>
  hostname     <span class=ot>&lt;-</span> C.require cfg <span class=st>"database.hostname"</span>
  username     <span class=ot>&lt;-</span> C.require cfg <span class=st>"database.username"</span>
  database     <span class=ot>&lt;-</span> C.require cfg <span class=st>"database.database"</span>
  password     <span class=ot>&lt;-</span> C.lookup cfg <span class=st>"database.password"</span>
  return <span class=fu>$</span> <span class=dt>Config</span> verbose loggingLevel logFile hostname username database password

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  cfg <span class=ot>&lt;-</span>readConfig <span class=st>"example.config"</span>
  print cfg</code></pre></div>
<div class=sourceCode include=src/24-parsing/example.config><pre class="sourceCode haskell"><code class="sourceCode haskell">logging 
{
  verbose      <span class=fu>=</span> true
  logfile      <span class=fu>=</span> <span class=st>"/tmp/app.log"</span>
  loggingLevel <span class=fu>=</span> <span class=dv>3</span>
}

database
{
  hostname <span class=fu>=</span> <span class=st>"us-east-1.rds.amazonaws.com"</span>
  username <span class=fu>=</span> <span class=st>"app"</span>
  database <span class=fu>=</span> <span class=st>"booktown"</span>
  password <span class=fu>=</span> <span class=st>"hunter2"</span>
}</code></pre></div>
<h1 id=streaming><font>Streaming</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>串流</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=lazy-io><font>Lazy IO</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>惰性输入输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The problem with using the usual monadic approach to processing data accumulated through IO is that the Prelude tools require us to manifest large amounts of data in memory all at once before we can even begin computation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用通常的 monadic 方法处理通过 IO 累积的数据的问题在于，Prelude 工具要求我们在开始计算之前一次性在内存中显示大量数据。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">mapM<span class=ot> ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> m [b]
sequence<span class=ot> ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> [m a] <span class=ot>-&gt;</span> m [a]</code></pre></div>
<p><font>Reading from the file creates a thunk for the string that forced will then read the file. The problem is then that this method ties the ordering of IO effects to evaluation order which is difficult to reason about in the large.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从文件中读取会为强制读取文件的字符串创建一个 thunk。那么问题是这种方法将 IO 效果的排序与评估顺序联系起来，这很难在大范围内进行推理。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Consider that normally the monad laws ( in the absence of </font><code>seq</code><font> ) guarantee that these computations should be identical. But using lazy IO we can construct a degenerate case.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑通常 monad 法则（在没有 seq 的情况下）保证这些计算应该是相同的。但是使用惰性 IO 我们可以构造一个退化的案例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/25-streaming/lazyio.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>System.IO</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  withFile <span class=st>"foo.txt"</span> <span class=dt>ReadMode</span> <span class=fu>$</span> \fd <span class=ot>-&gt;</span> <span class=kw>do</span>
    contents <span class=ot>&lt;-</span> hGetContents fd
    print contents
  <span class=co>-- "foo\n"</span>

  contents <span class=ot>&lt;-</span> withFile <span class=st>"foo.txt"</span> <span class=dt>ReadMode</span> hGetContents
  print contents
  <span class=co>-- ""</span></code></pre></div>
<p><font>So what we need is a system to guarantee deterministic resource handling with constant memory usage. To that end both the Conduits and Pipes libraries solved this problem using different ( though largely equivalent ) approaches.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>所以我们需要的是一个系统来保证确定性的资源处理和持续的内存使用。为此，Conduits 和 Pipes 库都使用不同的（虽然大体相同）方法解决了这个问题。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=pipes><font>Pipes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>管道</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>await ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Pipe</span> a y m a
<span class=ot>yield ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Pipe</span> x a m ()

<span class=ot>(&gt;-&gt;) ::</span> <span class=dt>Monad</span> m
      <span class=ot>=&gt;</span> <span class=dt>Pipe</span> a b m r
      <span class=ot>-&gt;</span> <span class=dt>Pipe</span> b c m r
      <span class=ot>-&gt;</span> <span class=dt>Pipe</span> a c m r

<span class=ot>runEffect ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Effect</span> m r <span class=ot>-&gt;</span> m r
<span class=ot>toListM ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Producer</span> a m () <span class=ot>-&gt;</span> m [a]</code></pre></div>
<p><font>Pipes is a stream processing library with a strong emphasis on the static semantics of composition. The simplest usage is to connect "pipe" functions with a </font><code>(&gt;-&gt;)</code><font> composition operator, where each component can </font><code>await</code><font> and </font><code>yield</code><font> to push and pull values along the stream.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Pipes 是一个流处理库，非常强调组合的静态语义。最简单的用法是将“管道”函数与 (&gt;-&gt;) 组合运算符连接起来，其中每个组件都可以等待并屈服以沿流推拉值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/25-streaming/pipes.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Pipes</span>
<span class=kw>import </span><span class=dt>Pipes.Prelude</span> <span class=kw>as</span> <span class=dt>P</span>
<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.Identity</span>

<span class=ot>a ::</span> <span class=dt>Producer</span> <span class=dt>Int</span> <span class=dt>Identity</span> ()
a <span class=fu>=</span> forM_ [<span class=dv>1</span><span class=fu>..</span><span class=dv>10</span>] yield

<span class=ot>b ::</span> <span class=dt>Pipe</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=dt>Identity</span> ()
b <span class=fu>=</span>  forever <span class=fu>$</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> await
  yield (x<span class=fu>*</span><span class=dv>2</span>)
  yield (x<span class=fu>*</span><span class=dv>3</span>)
  yield (x<span class=fu>*</span><span class=dv>4</span>)

<span class=ot>c ::</span> <span class=dt>Pipe</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=dt>Identity</span> ()
c <span class=fu>=</span> forever <span class=fu>$</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> await
  <span class=kw>if</span> (x <span class=ot>`mod`</span> <span class=dv>2</span>) <span class=fu>==</span> <span class=dv>0</span>
    <span class=kw>then</span> yield x
    <span class=kw>else</span> return ()

<span class=ot>result ::</span> [<span class=dt>Int</span>]
result <span class=fu>=</span> P.toList <span class=fu>$</span> a <span class=fu>&gt;-&gt;</span> b <span class=fu>&gt;-&gt;</span> c</code></pre></div>
<p><font>For example we could construct a "FizzBuzz" pipe.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们可以构造一个“FizzBu​​zz”管道。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/25-streaming/pipes_io.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiWayIf #-}</span>

<span class=kw>import </span><span class=dt>Pipes</span>
<span class=kw>import qualified</span> <span class=dt>Pipes.Prelude</span> <span class=kw>as</span> <span class=dt>P</span>

<span class=ot>count ::</span> <span class=dt>Producer</span> <span class=dt>Integer</span> <span class=dt>IO</span> ()
count <span class=fu>=</span> each [<span class=dv>1</span><span class=fu>..</span><span class=dv>100</span>]

<span class=ot>fizzbuzz ::</span> <span class=dt>Pipe</span> <span class=dt>Integer</span> <span class=dt>String</span> <span class=dt>IO</span> ()
fizzbuzz <span class=fu>=</span> <span class=kw>do</span>
  n <span class=ot>&lt;-</span> await
  <span class=kw>if</span> <span class=fu>|</span> n <span class=ot>`mod`</span> <span class=dv>15</span> <span class=fu>==</span> <span class=dv>0</span> <span class=ot>-&gt;</span> yield <span class=st>"FizzBuzz"</span>
     <span class=fu>|</span> n <span class=ot>`mod`</span> <span class=dv>5</span>  <span class=fu>==</span> <span class=dv>0</span> <span class=ot>-&gt;</span> yield <span class=st>"Fizz"</span>
     <span class=fu>|</span> n <span class=ot>`mod`</span> <span class=dv>3</span>  <span class=fu>==</span> <span class=dv>0</span> <span class=ot>-&gt;</span> yield <span class=st>"Buzz"</span>
     <span class=fu>|</span> otherwise       <span class=ot>-&gt;</span> return ()
  fizzbuzz

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> runEffect <span class=fu>$</span> count <span class=fu>&gt;-&gt;</span> fizzbuzz <span class=fu>&gt;-&gt;</span> P.stdoutLn</code></pre></div>
<p><font>To continue with the degenerate case we constructed with Lazy IO, consider than we can now compose and sequence deterministic actions over files without having to worry about effect order.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>继续我们使用 Lazy IO 构建的退化案例，考虑一下我们现在可以对文件组合和排序确定性操作，而不必担心效果顺序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/25-streaming/pipes_file.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Pipes</span>
<span class=kw>import </span><span class=dt>Pipes.Prelude</span> <span class=kw>as</span> <span class=dt>P</span>
<span class=kw>import </span><span class=dt>System.IO</span>

<span class=ot>readF ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>Producer</span> <span class=dt>String</span> <span class=dt>IO</span> ()
readF file <span class=fu>=</span> <span class=kw>do</span>
    lift <span class=fu>$</span> putStrLn <span class=fu>$</span> <span class=st>"Opened"</span> <span class=fu>++</span> file
    h <span class=ot>&lt;-</span> lift <span class=fu>$</span> openFile file <span class=dt>ReadMode</span>
    fromHandle h
    lift <span class=fu>$</span> putStrLn <span class=fu>$</span> <span class=st>"Closed"</span> <span class=fu>++</span> file
    lift <span class=fu>$</span> hClose h

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> runEffect <span class=fu>$</span> readF <span class=st>"foo.txt"</span> <span class=fu>&gt;-&gt;</span> P.take <span class=dv>3</span> <span class=fu>&gt;-&gt;</span> stdoutLn</code></pre></div>
<p><font>This is simple a sampling of the functionality of pipes. The documentation for pipes is extensive and great deal of care has been taken make the library extremely thorough. </font><code>pipes</code><font> is a shining example of an accessible yet category theoretic driven design.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是管道功能的简单示例。管道的文档非常广泛，并且已经非常小心，使图书馆非常详尽。 pipes 是一个可访问但类别理论驱动设计的光辉例子。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html>Pipes Tutorial</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：管道教程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=safe-pipes><font>Safe Pipes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>安全管道</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>bracket ::</span> <span class=dt>MonadSafe</span> m <span class=ot>=&gt;</span> <span class=dt>Base</span> m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>Base</span> m b) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m c) <span class=ot>-&gt;</span> m c</code></pre></div>
<p><font>As a motivating example, ZeroMQ is a network messaging library that abstracts over traditional Unix sockets to a variety of network topologies. Most notably it isn't designed to guarantee any sort of transactional guarantees for delivery or recovery in case of errors so it's necessary to design a layer on top of it to provide the desired behavior at the application layer.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作为一个激励性的例子，ZeroMQ 是一个网络消息传递库，它通过传统的 Unix 套接字抽象为各种网络拓扑。最值得注意的是，它并不是为了在出现错误时保证任何类型的交付或恢复事务保证，因此有必要在其之上设计一个层以在应用程序层提供所需的行为。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In Haskell we'd like to guarantee that if we're polling on a socket we get messages delivered in a timely fashion or consider the resource in an error state and recover from it. Using </font><code>pipes-safe</code><font> we can manage the life cycle of lazy IO resources and can safely handle failures, resource termination and finalization gracefully. In other languages this kind of logic would be smeared across several places, or put in some global context and prone to introduce errors and subtle race conditions. Using pipes we instead get a nice tight abstraction designed exactly to fit this kind of use case.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Haskell 中，我们想要保证，如果我们在套接字上进行轮询，我们会及时收到消息，或者认为资源处于错误状态并从中恢复。使用管道安全，我们可以管理惰性 IO 资源的生命周期，并可以安全地处理故障、资源终止和优雅地完成。在其他语言中，这种逻辑会散布在多个地方，或者放在某些全局上下文中，并且容易引入错误和微妙的竞争条件。使用管道，我们反而得到了一个很好的紧密抽象，专门为适应这种用例而设计。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For instance now we can bracket the ZeroMQ socket creation and finalization within the </font><code>SafeT</code><font> monad transformer which guarantees that after successful message delivery we execute the pipes function as expected, or on failure we halt the execution and finalize the socket.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，现在我们可以在 SafeT monad 转换器中包含 ZeroMQ 套接字的创建和完成，这保证了在成功传递消息后我们按预期执行管道功能，或者在失败时我们停止执行并完成套接字。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/25-streaming/pipes_safe.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Pipes</span>
<span class=kw>import </span><span class=dt>Pipes.Safe</span>
<span class=kw>import qualified</span> <span class=dt>Pipes.Prelude</span> <span class=kw>as</span> <span class=dt>P</span>

<span class=kw>import </span><span class=dt>System.Timeout</span> (timeout)
<span class=kw>import </span><span class=dt>Data.ByteString.Char8</span>
<span class=kw>import qualified</span> <span class=dt>System.ZMQ</span> <span class=kw>as</span> <span class=dt>ZMQ</span>

<span class=kw>data</span> <span class=dt>Opts</span> <span class=fu>=</span> <span class=dt>Opts</span>
  { _<span class=ot>addr    ::</span> <span class=dt>String</span>  <span class=co>-- ^ ZMQ socket address</span>
  , _<span class=ot>timeout ::</span> <span class=dt>Int</span>     <span class=co>-- ^ Time in milliseconds for socket timeout</span>
  }

<span class=ot>recvTimeout ::</span> <span class=dt>Opts</span> <span class=ot>-&gt;</span> <span class=dt>ZMQ.Socket</span> a <span class=ot>-&gt;</span> <span class=dt>Producer</span> <span class=dt>ByteString</span> (<span class=dt>SafeT</span> <span class=dt>IO</span>) ()
recvTimeout opts sock <span class=fu>=</span> <span class=kw>do</span>
  body <span class=ot>&lt;-</span> liftIO <span class=fu>$</span> timeout (_timeout opts) (ZMQ.receive sock [])
  <span class=kw>case</span> body <span class=kw>of</span>
    <span class=dt>Just</span> msg <span class=ot>-&gt;</span> <span class=kw>do</span>
      liftIO <span class=fu>$</span> ZMQ.send sock msg []
      yield msg
      recvTimeout opts sock
    <span class=dt>Nothing</span>  <span class=ot>-&gt;</span> liftIO <span class=fu>$</span> print <span class=st>"socket timed out"</span>

<span class=ot>collect ::</span> <span class=dt>ZMQ.Context</span>
        <span class=ot>-&gt;</span> <span class=dt>Opts</span>
        <span class=ot>-&gt;</span> <span class=dt>Producer</span> <span class=dt>ByteString</span> (<span class=dt>SafeT</span> <span class=dt>IO</span>) ()
collect ctx opts <span class=fu>=</span> bracket zinit zclose (recvTimeout opts)
  <span class=kw>where</span>
    <span class=co>-- Initialize the socket</span>
    zinit <span class=fu>=</span> <span class=kw>do</span>
      liftIO <span class=fu>$</span> print <span class=st>"waiting for messages"</span>
      sock <span class=ot>&lt;-</span> ZMQ.socket ctx <span class=dt>ZMQ.Rep</span>
      ZMQ.bind sock (_addr opts)
      return sock

    <span class=co>-- On timeout or completion guarantee the socket get closed.</span>
    zclose sock <span class=fu>=</span> <span class=kw>do</span>
      liftIO <span class=fu>$</span> print <span class=st>"finalizing"</span>
      ZMQ.close sock

<span class=ot>runZmq ::</span> <span class=dt>ZMQ.Context</span> <span class=ot>-&gt;</span> <span class=dt>Opts</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
runZmq ctx opts <span class=fu>=</span> runSafeT <span class=fu>$</span> runEffect <span class=fu>$</span>
  collect ctx opts <span class=fu>&gt;-&gt;</span> P.take <span class=dv>10</span> <span class=fu>&gt;-&gt;</span> P.print

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  ctx <span class=ot>&lt;-</span> ZMQ.init <span class=dv>1</span>
  <span class=kw>let</span> opts <span class=fu>=</span> <span class=dt>Opts</span> {_addr <span class=fu>=</span> <span class=st>"tcp://127.0.0.1:8000"</span>, _timeout <span class=fu>=</span> <span class=dv>1000000</span> }
  runZmq ctx opts
  ZMQ.term ctx</code></pre></div>
<h2 id=conduits><font>Conduits</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>导管</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>await ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>ConduitM</span> i o m (<span class=dt>Maybe</span> i)
<span class=ot>yield ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> o <span class=ot>-&gt;</span> <span class=dt>ConduitM</span> i o m ()
<span class=ot>($$) ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Source</span> m a <span class=ot>-&gt;</span> <span class=dt>Sink</span> a m b <span class=ot>-&gt;</span> m b
<span class=ot>(=$) ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Conduit</span> a m b <span class=ot>-&gt;</span> <span class=dt>Sink</span> b m c <span class=ot>-&gt;</span> <span class=dt>Sink</span> a m c

<span class=kw>type</span> <span class=dt>Sink</span> i <span class=fu>=</span> <span class=dt>ConduitM</span> i <span class=dt>Void</span>
<span class=kw>type</span> <span class=dt>Source</span> m o <span class=fu>=</span> <span class=dt>ConduitM</span> () o m ()
<span class=kw>type</span> <span class=dt>Conduit</span> i m o <span class=fu>=</span> <span class=dt>ConduitM</span> i o m ()</code></pre></div>
<p><font>Conduits are conceptually similar though philosophically different approach to the same problem of constant space deterministic resource handling for IO resources.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>管道在概念上相似，但在处理 IO 资源的恒定空间确定性资源处理的相同问题时采用不同的方法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The first initial difference is that await function now returns a </font><code>Maybe</code><font> which allows different handling of termination. The composition operators are also split into a connecting operator (</font><code>$$</code><font>) and a fusing operator (</font><code>=$</code><font>) for combining Sources and Sink and a Conduit and a Sink respectively.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>第一个最初的区别是 await 函数现在返回一个 Maybe ，它允许对终止进行不同的处理。组合运算符也分为连接运算符（$$）和融合运算符（=$），分别用于组合 Sources 和 Sink 以及 Conduit 和 Sink。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/25-streaming/conduit.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiWayIf #-}</span>

<span class=kw>import </span><span class=dt>Data.Conduit</span>
<span class=kw>import </span><span class=dt>Control.Monad.Trans</span>
<span class=kw>import qualified</span> <span class=dt>Data.Conduit.List</span> <span class=kw>as</span> <span class=dt>CL</span>

<span class=ot>source ::</span> <span class=dt>Source</span> <span class=dt>IO</span> <span class=dt>Int</span>
source <span class=fu>=</span> CL.sourceList [<span class=dv>1</span><span class=fu>..</span><span class=dv>100</span>]

<span class=ot>conduit ::</span> <span class=dt>Conduit</span> <span class=dt>Int</span> <span class=dt>IO</span> <span class=dt>String</span>
conduit <span class=fu>=</span> <span class=kw>do</span>
  val <span class=ot>&lt;-</span> await
  liftIO <span class=fu>$</span> print val
  <span class=kw>case</span> val <span class=kw>of</span>
    <span class=dt>Nothing</span> <span class=ot>-&gt;</span> return ()
    <span class=dt>Just</span> n <span class=ot>-&gt;</span> <span class=kw>do</span>
      <span class=kw>if</span> <span class=fu>|</span> n <span class=ot>`mod`</span> <span class=dv>15</span> <span class=fu>==</span> <span class=dv>0</span> <span class=ot>-&gt;</span> yield <span class=st>"FizzBuzz"</span>
         <span class=fu>|</span> n <span class=ot>`mod`</span> <span class=dv>5</span>  <span class=fu>==</span> <span class=dv>0</span> <span class=ot>-&gt;</span> yield <span class=st>"Fizz"</span>
         <span class=fu>|</span> n <span class=ot>`mod`</span> <span class=dv>3</span>  <span class=fu>==</span> <span class=dv>0</span> <span class=ot>-&gt;</span> yield <span class=st>"Buzz"</span>
         <span class=fu>|</span> otherwise       <span class=ot>-&gt;</span> return ()
      conduit

<span class=ot>sink ::</span> <span class=dt>Sink</span> <span class=dt>String</span> <span class=dt>IO</span> ()
sink <span class=fu>=</span> CL.mapM_ putStrLn

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> source <span class=fu>$$</span> conduit <span class=fu>=$</span> sink</code></pre></div>
<p><font>See: </font><a href=https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview>Conduit Overview</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：导管概述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h1 id=cryptography><font>Cryptography</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>密码学</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=cryptonite><font>cryptonite</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>隐晶石</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=entropy><font>entropy</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>熵</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=memory><font>memory</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>记忆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=crypto-pubkey><font>crypto-pubkey</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>加密公钥</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=crypto-api><font>crypto-api</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>加密API</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=x509><font>x509</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>x509</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=ed25519><font>ed25519</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ed25519</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<hr>
<h1 id=compression><font>Compression</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>压缩</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=lz4><font>lz4</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>lz4</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=zlib><font>zlib</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>zlib</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<hr>
<h1 id=data-formats><font>Data Formats</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据格式</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=json><font>JSON</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>JSON</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Aeson is library for efficient parsing and generating JSON. It is the canonical JSON library for handling JSON.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Aeson 是用于高效解析和生成 JSON 的库。它是用于处理 JSON 的规范 JSON 库。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>decode ::</span> <span class=dt>FromJSON</span> a <span class=ot>=&gt;</span> <span class=dt>ByteString</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
<span class=ot>encode ::</span> <span class=dt>ToJSON</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>ByteString</span>
<span class=ot>eitherDecode ::</span> <span class=dt>FromJSON</span> a <span class=ot>=&gt;</span> <span class=dt>ByteString</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>String</span> a

<span class=ot>fromJSON ::</span> <span class=dt>FromJSON</span> a <span class=ot>=&gt;</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Result</span> a
<span class=ot>toJSON ::</span> <span class=dt>ToJSON</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Value</span></code></pre></div>
<p><font>A point of some subtlety to beginners is that the return types for Aeson functions are </font><strong>polymorphic in their return types</strong><font> meaning that the resulting type of decode is specified only in the context of your programs use of the decode function. So if you use decode in a point your program and bind it to a value </font><code>x</code><font> and then use </font><code>x</code><font> as if it were and integer throughout the rest of your program, Aeson will select the typeclass instance which parses the given input string into a Haskell integer.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对初学者来说有些微妙的一点是 Aeson 函数的返回类型在其返回类型中是多态的，这意味着解码的结果类型仅在程序使用解码函数的上下文中指定。因此，如果您在程序的某个点使用 decode 并将其绑定到值 x，然后在整个程序的其余部分使用 x 和整数，Aeson 将选择将给定输入字符串解析为 Haskell 整数的类型类实例.</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://hackage.haskell.org/package/aeson><strong>Aeson Library<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>永生图书馆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></a></li>
</ul>
<h4 id=value><font>Value</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>价值</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Aeson uses several high performance data structures (Vector, Text, HashMap) by default instead of the naive versions so typically using Aeson will require that us import them and use </font><code>OverloadedStrings</code><font> when indexing into objects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Aeson 默认使用几种高性能数据结构（Vector、Text、HashMap）而不是原始版本，因此通常使用 Aeson 将要求我们导入它们并在索引到对象时使用 OverloadedStrings。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The underlying Aeson structure is called </font><code>Value</code><font> and encodes a recursive tree structure that models the semantics of untyped JSON objects by mapping them onto a large sum type which embodies all possible JSON values.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>底层的 Aeson 结构称为 Value 并编码一个递归树结构，该结构通过将无类型 JSON 对象映射到包含所有可能的 JSON 值的大和类型来模拟无类型 JSON 对象的语义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>Object</span> <span class=fu>=</span> <span class=dt>HashMap</span> <span class=dt>Text</span> <span class=dt>Value</span>

<span class=kw>type</span> <span class=dt>Array</span> <span class=fu>=</span> <span class=dt>Vector</span> <span class=dt>Value</span>

<span class=co>-- | A JSON value represented as a Haskell value.</span>
<span class=kw>data</span> <span class=dt>Value</span>
  <span class=fu>=</span> <span class=dt>Object</span> <span class=fu>!</span><span class=dt>Object</span>
  <span class=fu>|</span> <span class=dt>Array</span> <span class=fu>!</span><span class=dt>Array</span>
  <span class=fu>|</span> <span class=dt>String</span> <span class=fu>!</span><span class=dt>Text</span>
  <span class=fu>|</span> <span class=dt>Number</span> <span class=fu>!</span><span class=dt>Scientific</span>
  <span class=fu>|</span> <span class=dt>Bool</span> <span class=fu>!</span><span class=dt>Bool</span>
  <span class=fu>|</span> <span class=dt>Null</span></code></pre></div>
<p><font>For instance the Value expansion of the following JSON blob:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如以下 JSON blob 的值扩展：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class=op>{</span>
  <span class=st>"a"</span><span class=op>:</span> [<span class=dv>1</span><span class=op>,</span><span class=dv>2</span><span class=op>,</span><span class=dv>3</span>]<span class=op>,</span>
  <span class=st>"b"</span><span class=op>:</span> <span class=dv>1</span>
<span class=op>}</span></code></pre></div>
<p><font>Is represented in Aeson as the </font><code>Value</code><font>:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Aeson 中表示为值：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Object</span>
   (fromList
      [ ( <span class=st>"a"</span>
        , <span class=dt>Array</span> (fromList [ <span class=dt>Number</span> <span class=fl>1.0</span> , <span class=dt>Number</span> <span class=fl>2.0</span> , <span class=dt>Number</span> <span class=fl>3.0</span> ])
        )
      , ( <span class=st>"b"</span> , <span class=dt>Number</span> <span class=fl>1.0</span> )
      ])</code></pre></div>
<p><font>Let's consider some larger examples, we'll work with this contrived example JSON:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>让我们考虑一些更大的例子，我们将使用这个人为的例子 JSON：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/example.json><pre class="sourceCode json"><code class="sourceCode json"><span class=fu>{</span>
    <span class=dt>"id"</span><span class=fu>:</span> <span class=dv>1</span><span class=fu>,</span>
    <span class=dt>"name"</span><span class=fu>:</span> <span class=st>"A green door"</span><span class=fu>,</span>
    <span class=dt>"price"</span><span class=fu>:</span> <span class=fl>12.50</span><span class=fu>,</span>
    <span class=dt>"tags"</span><span class=fu>:</span> <span class=ot>[</span><span class=st>"home"</span><span class=ot>,</span> <span class=st>"green"</span><span class=ot>]</span><span class=fu>,</span>
    <span class=dt>"refs"</span><span class=fu>:</span> <span class=fu>{</span>
      <span class=dt>"a"</span><span class=fu>:</span> <span class=st>"red"</span><span class=fu>,</span>
      <span class=dt>"b"</span><span class=fu>:</span> <span class=st>"blue"</span>
    <span class=fu>}</span>
<span class=fu>}</span></code></pre></div>
<h4 id=unstructured-json><font>Unstructured JSON</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>非结构化 JSON</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>In dynamic scripting languages it's common to parse amorphous blobs of JSON without any a priori structure and then handle validation problems by throwing exceptions while traversing it. We can do the same using Aeson and the Maybe monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在动态脚本语言中，通常会在没有任何先验结构的情况下解析无定形的 JSON 块，然后通过在遍历它时抛出异常来处理验证问题。我们可以使用 Aeson 和 Maybe monad 来做同样的事情。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/aeson_unstructured.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import </span><span class=dt>Data.Aeson</span>
<span class=kw>import </span><span class=dt>Data.Vector</span>
<span class=kw>import qualified</span> <span class=dt>Data.HashMap.Strict</span> <span class=kw>as</span> <span class=dt>M</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=co>-- Pull a key out of an JSON object.</span>
<span class=ot>(^?) ::</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Text</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Value</span>
(<span class=fu>^?</span>) (<span class=dt>Object</span> obj) k <span class=fu>=</span> M.lookup k obj
(<span class=fu>^?</span>) _ _ <span class=fu>=</span> <span class=dt>Nothing</span>

<span class=co>-- Pull the ith value out of a JSON list.</span>
<span class=ot>ix ::</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Value</span>
ix (<span class=dt>Array</span> arr) i <span class=fu>=</span> arr <span class=fu>!?</span> i
ix _ _ <span class=fu>=</span> <span class=dt>Nothing</span>

readJSON str <span class=fu>=</span> <span class=kw>do</span>
  obj <span class=ot>&lt;-</span> decode str
  price <span class=ot>&lt;-</span> obj <span class=fu>^?</span> <span class=st>"price"</span>
  refs  <span class=ot>&lt;-</span> obj <span class=fu>^?</span> <span class=st>"refs"</span>
  tags  <span class=ot>&lt;-</span> obj <span class=fu>^?</span> <span class=st>"tags"</span>
  aref  <span class=ot>&lt;-</span> refs <span class=fu>^?</span> <span class=st>"a"</span>
  tag1  <span class=ot>&lt;-</span> tags <span class=ot>`ix`</span> <span class=dv>0</span>
  return (price, aref, tag1)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile <span class=st>"example.json"</span>
  print <span class=fu>$</span> readJSON contents</code></pre></div>
<h4 id=structured-json><font>Structured JSON</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>结构化 JSON</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>This isn't ideal since we've just smeared all the validation logic across our traversal logic instead of separating concerns and handling validation in separate logic. We'd like to describe the structure before-hand and the invalid case separately. Using Generic also allows Haskell to automatically write the serializer and deserializer between our datatype and the JSON string based on the names of record field names.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这并不理想，因为我们只是在我们的遍历逻辑中涂抹了所有验证逻辑，而不是在单独的逻辑中分离关注点和处理验证。我们想分别描述预先的结构和无效的情况。使用 Generic 还允许 Haskell 根据记录字段名称的名称自动在我们的数据类型和 JSON 字符串之间编写序列化程序和反序列化程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/aeson_structured.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import </span><span class=dt>Data.Aeson</span>
<span class=kw>import </span><span class=dt>GHC.Generics</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>import </span><span class=dt>Control.Applicative</span>

<span class=kw>data</span> <span class=dt>Refs</span> <span class=fu>=</span> <span class=dt>Refs</span>
  {<span class=ot> a ::</span> <span class=dt>Text</span>
  ,<span class=ot> b ::</span> <span class=dt>Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>)

<span class=kw>data</span> <span class=dt>Data</span> <span class=fu>=</span> <span class=dt>Data</span>
  {<span class=ot> id    ::</span> <span class=dt>Int</span>
  ,<span class=ot> name  ::</span> <span class=dt>Text</span>
  ,<span class=ot> price ::</span> <span class=dt>Int</span>
  ,<span class=ot> tags  ::</span> [<span class=dt>Text</span>]
  ,<span class=ot> refs  ::</span> <span class=dt>Refs</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>)

<span class=kw>instance</span> <span class=dt>FromJSON</span> <span class=dt>Data</span>
<span class=kw>instance</span> <span class=dt>FromJSON</span> <span class=dt>Refs</span>
<span class=kw>instance</span> <span class=dt>ToJSON</span> <span class=dt>Data</span>
<span class=kw>instance</span> <span class=dt>ToJSON</span> <span class=dt>Refs</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile <span class=st>"example.json"</span>
  <span class=kw>let</span> <span class=dt>Just</span> dat <span class=fu>=</span> decode contents
  print <span class=fu>$</span> name dat
  print <span class=fu>$</span> a (refs dat)</code></pre></div>
<p><font>Now we get our validated JSON wrapped up into a nicely typed Haskell ADT.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在我们将经过验证的 JSON 包装到一个类型良好的 Haskell ADT 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Data</span>
  { id <span class=fu>=</span> <span class=dv>1</span>
  , name <span class=fu>=</span> <span class=st>"A green door"</span>
  , price <span class=fu>=</span> <span class=dv>12</span>
  , tags <span class=fu>=</span> [ <span class=st>"home"</span> , <span class=st>"green"</span> ]
  , refs <span class=fu>=</span> <span class=dt>Refs</span> { a <span class=fu>=</span> <span class=st>"red"</span> , b <span class=fu>=</span> <span class=st>"blue"</span> }
  }</code></pre></div>
<p><font>The functions </font><code>fromJSON</code><font> and </font><code>toJSON</code><font> can be used to convert between this sum type and regular Haskell types with.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>fromJSON 和 toJSON 函数可用于在这种求和类型和常规 Haskell 类型之间进行转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Result</span> a <span class=fu>=</span> <span class=dt>Error</span> <span class=dt>String</span> <span class=fu>|</span> <span class=dt>Success</span> a</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> fromJSON (<span class=dt>Bool</span> <span class=dt>True</span>)<span class=ot> ::</span> <span class=dt>Result</span> <span class=dt>Bool</span>
<span class=dt>Success</span> <span class=dt>True</span>

λ<span class=fu>:</span> fromJSON (<span class=dt>Bool</span> <span class=dt>True</span>)<span class=ot> ::</span> <span class=dt>Result</span> <span class=dt>Double</span>
<span class=dt>Error</span> <span class=st>"when expecting a Double, encountered Boolean instead"</span></code></pre></div>
<p><font>As of 7.10.2 we can use the new -XDeriveAnyClass to automatically derive instances of FromJSON and TOJSON without the need for standalone instance declarations. These are implemented entirely in terms of the default methods which use Generics under the hood.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>从 7.10.2 开始，我们可以使用新的 -XDeriveAnyClass 自动派生 FromJSON 和 TOJSON 的实例，而无需独立的实例声明。这些完全是根据在引擎盖下使用泛型的默认方法来实现的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/aeson_derive.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>
<span class=ot>{-# LANGUAGE DeriveAnyClass #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import </span><span class=dt>Data.Aeson</span>
<span class=kw>import </span><span class=dt>GHC.Generics</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>data</span> <span class=dt>Refs</span> <span class=fu>=</span> <span class=dt>Refs</span>
  {<span class=ot> a ::</span> <span class=dt>Text</span>
  ,<span class=ot> b ::</span> <span class=dt>Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>,<span class=dt>FromJSON</span>,<span class=dt>ToJSON</span>)

<span class=kw>data</span> <span class=dt>Data</span> <span class=fu>=</span> <span class=dt>Data</span>
  {<span class=ot> id    ::</span> <span class=dt>Int</span>
  ,<span class=ot> name  ::</span> <span class=dt>Text</span>
  ,<span class=ot> price ::</span> <span class=dt>Int</span>
  ,<span class=ot> tags  ::</span> [<span class=dt>Text</span>]
  ,<span class=ot> refs  ::</span> <span class=dt>Refs</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>,<span class=dt>FromJSON</span>,<span class=dt>ToJSON</span>)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile <span class=st>"example.json"</span>
  <span class=kw>let</span> <span class=dt>Just</span> dat <span class=fu>=</span> decode contents
  print <span class=fu>$</span> name dat
  print <span class=fu>$</span> a (refs dat)
  BL.putStrLn <span class=fu>$</span> encode dat</code></pre></div>
<h4 id=hand-written-instances><font>Hand Written Instances</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>手写实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>While it's useful to use generics to derive instances, sometimes you actually want more fine grained control over serialization and de serialization. So we fall back on writing ToJSON and FromJSON instances manually. Using FromJSON we can project into hashmap using the </font><code>(.:)</code><font> operator to extract keys. If the key fails to exist the parser will abort with a key failure message. The ToJSON instances can never fail and simply require us to pattern match on our custom datatype and generate an appropriate value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>虽然使用泛型派生实例很有用，但有时您实际上需要对序列化和反序列化进行更细粒度的控制。所以我们转而手动编写 ToJSON 和 FromJSON 实例。使用 FromJSON，我们可以使用 (.:) 运算符投影到 hashmap 中以提取键。如果密钥不存在，解析器将中止并显示密钥失败消息。 ToJSON 实例永远不会失败，只需要我们对自定义数据类型进行模式匹配并生成适当的值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The law that the FromJSON and ToJSON classes should maintain is that </font><code>encode . decode</code><font> and </font><code>decode . encode</code><font> should map to the same object. Although in practice there many times when we break this rule and especially if the serialize or de serialize is one way.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>FromJSON 和 ToJSON 类应该保持的规律是 encode 。解码和解码。 encode 应该映射到同一个对象。尽管在实践中有很多次我们打破了这条规则，尤其是当序列化或反序列化是一种方式时。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/aeson_custom.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>import </span><span class=dt>Data.Text</span>
<span class=kw>import </span><span class=dt>Data.Aeson</span>
<span class=kw>import </span><span class=dt>Data.Maybe</span>
<span class=kw>import </span><span class=dt>Data.Aeson.Types</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>data</span> <span class=dt>Crew</span> <span class=fu>=</span> <span class=dt>Crew</span>
  {<span class=ot> name  ::</span> <span class=dt>Text</span>
  ,<span class=ot> rank  ::</span> <span class=dt>Rank</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>Rank</span>
  <span class=fu>=</span> <span class=dt>Captain</span>
  <span class=fu>|</span> <span class=dt>Ensign</span>
  <span class=fu>|</span> <span class=dt>Lieutenant</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=co>-- Custom JSON Deserializer</span>

<span class=kw>instance</span> <span class=dt>FromJSON</span> <span class=dt>Crew</span> <span class=kw>where</span>
  parseJSON (<span class=dt>Object</span> o) <span class=fu>=</span> <span class=kw>do</span>
    _name <span class=ot>&lt;-</span> o <span class=fu>.:</span> <span class=st>"name"</span>
    _rank <span class=ot>&lt;-</span> o <span class=fu>.:</span> <span class=st>"rank"</span>
    pure (<span class=dt>Crew</span> _name _rank)

<span class=kw>instance</span> <span class=dt>FromJSON</span> <span class=dt>Rank</span> <span class=kw>where</span>
  parseJSON (<span class=dt>String</span> s) <span class=fu>=</span> <span class=kw>case</span> s <span class=kw>of</span>
    <span class=st>"Captain"</span>    <span class=ot>-&gt;</span> pure <span class=dt>Captain</span>
    <span class=st>"Ensign"</span>     <span class=ot>-&gt;</span> pure <span class=dt>Ensign</span>
    <span class=st>"Lieutenant"</span> <span class=ot>-&gt;</span> pure <span class=dt>Lieutenant</span>
    _            <span class=ot>-&gt;</span> typeMismatch <span class=st>"Could not parse Rank"</span> (<span class=dt>String</span> s)
  parseJSON x <span class=fu>=</span> typeMismatch <span class=st>"Expected String"</span> x

<span class=co>-- Custom JSON Serializer</span>

<span class=kw>instance</span> <span class=dt>ToJSON</span> <span class=dt>Crew</span> <span class=kw>where</span>
  toJSON (<span class=dt>Crew</span> name rank) <span class=fu>=</span> object [
      <span class=st>"name"</span> <span class=fu>.=</span> name
    , <span class=st>"rank"</span> <span class=fu>.=</span> rank
    ]

<span class=kw>instance</span> <span class=dt>ToJSON</span> <span class=dt>Rank</span> <span class=kw>where</span>
  toJSON <span class=dt>Captain</span>    <span class=fu>=</span> <span class=dt>String</span> <span class=st>"Captain"</span>
  toJSON <span class=dt>Ensign</span>     <span class=fu>=</span> <span class=dt>String</span> <span class=st>"Ensign"</span>
  toJSON <span class=dt>Lieutenant</span> <span class=fu>=</span> <span class=dt>String</span> <span class=st>"Lieutenant"</span>


<span class=ot>roundTrips ::</span> <span class=dt>Crew</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
roundTrips <span class=fu>=</span> isJust <span class=fu>.</span> go
  <span class=kw>where</span>
<span class=ot>    go ::</span> <span class=dt>Crew</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Crew</span>
    go <span class=fu>=</span> decode <span class=fu>.</span> encode


<span class=ot>picard ::</span> <span class=dt>Crew</span>
picard <span class=fu>=</span> <span class=dt>Crew</span> { name <span class=fu>=</span> <span class=st>"Jean-Luc Picard"</span>, rank <span class=fu>=</span> <span class=dt>Captain</span> }

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile <span class=st>"crew.json"</span>
  <span class=kw>let</span> (<span class=ot>res ::</span> <span class=dt>Maybe</span> <span class=dt>Crew</span>) <span class=fu>=</span> decode contents
  print res
  print <span class=fu>$</span> roundTrips picard</code></pre></div>
<p><font>See: </font><a href=http://hackage.haskell.org/package/aeson>Aeson Documentation</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：Aeson 文档</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=yaml><font>Yaml</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>山药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Yaml is a textual serialization format similar to JSON. It uses an indentation sensitive structure to encode nested maps of keys and values. The Yaml interface for Haskell is a precise copy of </font><code>Data.Aeson</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Yaml 是一种类似于 JSON 的文本序列化格式。它使用缩进敏感结构来编码键和值的嵌套映射。 Haskell 的 Yaml 接口是 Data.Aeson 的精确副本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://hackage.haskell.org/package/yaml><strong>Yaml Library<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Yaml 库</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></a></li>
</ul>
<div class=sourceCode include=src/26-data-formats/example.yaml><pre class="sourceCode haskell"><code class="sourceCode haskell">invoice<span class=fu>:</span> <span class=dv>34843</span>
date   <span class=fu>:</span> <span class=dv>2001</span><span class=fu>-</span><span class=dv>01</span><span class=fu>-</span><span class=dv>23</span>
bill<span class=fu>:</span> 
    given  <span class=fu>:</span> <span class=dt>Chris</span>
    family <span class=fu>:</span> <span class=dt>Dumars</span>
    address<span class=fu>:</span>
        lines<span class=fu>:</span> <span class=fu>|</span>
            <span class=dv>458</span> <span class=dt>Walkman</span> <span class=dt>Dr</span><span class=fu>.</span>
            <span class=dt>Suite</span> <span class=fu>#</span><span class=dv>292</span>
        city    <span class=fu>:</span> <span class=dt>Royal</span> <span class=dt>Oak</span>
        state   <span class=fu>:</span> <span class=dt>MI</span>
        postal  <span class=fu>:</span> <span class=dv>48046</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Object</span>
  (fromList
     [ ( <span class=st>"invoice"</span> , <span class=dt>Number</span> <span class=fl>34843.0</span> )
     , ( <span class=st>"date"</span> , <span class=dt>String</span> <span class=st>"2001-01-23"</span> )
     , ( <span class=st>"bill-to"</span>
       , <span class=dt>Object</span>
           (fromList
              [ ( <span class=st>"address"</span>
                , <span class=dt>Object</span>
                    (fromList
                       [ ( <span class=st>"state"</span> , <span class=dt>String</span> <span class=st>"MI"</span> )
                       , ( <span class=st>"lines"</span> , <span class=dt>String</span> <span class=st>"458 Walkman Dr.\nSuite #292\n"</span> )
                       , ( <span class=st>"city"</span> , <span class=dt>String</span> <span class=st>"Royal Oak"</span> )
                       , ( <span class=st>"postal"</span> , <span class=dt>Number</span> <span class=fl>48046.0</span> )
                       ])
                )
              , ( <span class=st>"family"</span> , <span class=dt>String</span> <span class=st>"Dumars"</span> )
              , ( <span class=st>"given"</span> , <span class=dt>String</span> <span class=st>"Chris"</span> )
              ])
       )
     ])</code></pre></div>
<p><font>To parse this file we use the following datatypes and functions:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了解析这个文件，我们使用以下数据类型和函数：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/yaml.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>
<span class=ot>{-# LANGUAGE DeriveAnyClass #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>import </span><span class=dt>Data.Yaml</span>

<span class=kw>import </span><span class=dt>Data.Text</span> (<span class=dt>Text</span>)
<span class=kw>import qualified</span> <span class=dt>Data.ByteString</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=kw>data</span> <span class=dt>Invoice</span> <span class=fu>=</span> <span class=dt>Invoice</span>
  {<span class=ot> invoice ::</span> <span class=dt>Int</span>
  ,<span class=ot> date ::</span> <span class=dt>Text</span>
  ,<span class=ot> bill ::</span> <span class=dt>Billing</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>,<span class=dt>FromJSON</span>)

<span class=kw>data</span> <span class=dt>Billing</span> <span class=fu>=</span> <span class=dt>Billing</span>
  {<span class=ot> address ::</span> <span class=dt>Address</span>
  ,<span class=ot> family ::</span> <span class=dt>Text</span>
  ,<span class=ot> given ::</span> <span class=dt>Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>,<span class=dt>FromJSON</span>)

<span class=kw>data</span> <span class=dt>Address</span> <span class=fu>=</span> <span class=dt>Address</span>
  {<span class=ot> lines ::</span> <span class=dt>Text</span>
  ,<span class=ot> city ::</span> <span class=dt>Text</span>
  ,<span class=ot> state ::</span> <span class=dt>Text</span>
  ,<span class=ot> postal ::</span> <span class=dt>Int</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Generic</span>,<span class=dt>FromJSON</span>)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile <span class=st>"example.yaml"</span>
  <span class=kw>let</span> (<span class=ot>res ::</span> <span class=dt>Either</span> <span class=dt>String</span> <span class=dt>Invoice</span>) <span class=fu>=</span> decodeEither contents
  <span class=kw>case</span> res <span class=kw>of</span>
    <span class=dt>Right</span> val <span class=ot>-&gt;</span> print val
    <span class=dt>Left</span> err <span class=ot>-&gt;</span> putStrLn err</code></pre></div>
<p><font>Which generates:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>其中产生：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Invoice</span>
  { invoice <span class=fu>=</span> <span class=dv>34843</span>
  , date <span class=fu>=</span> <span class=st>"2001-01-23"</span>
  , bill <span class=fu>=</span>
      <span class=dt>Billing</span>
        { address <span class=fu>=</span>
            <span class=dt>Address</span>
              { lines <span class=fu>=</span> <span class=st>"458 Walkman Dr.\nSuite #292\n"</span>
              , city <span class=fu>=</span> <span class=st>"Royal Oak"</span>
              , state <span class=fu>=</span> <span class=st>"MI"</span>
              , postal <span class=fu>=</span> <span class=dv>48046</span>
              }
        , family <span class=fu>=</span> <span class=st>"Dumars"</span>
        , given <span class=fu>=</span> <span class=st>"Chris"</span>
        }
  }</code></pre></div>
<h2 id=csv><font>CSV</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>CSV文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Cassava is an efficient CSV parser library. We'll work with this tiny snippet from the iris dataset:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cassava 是一个高效的 CSV 解析器库。我们将使用 iris 数据集中的这个小片段：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://hackage.haskell.org/package/cassava><strong>Cassava Library<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>木薯图书馆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></a></li>
</ul>
<div class=sourceCode include=src/26-data-formats/iris.csv><pre class="sourceCode perl"><code class="sourceCode perl">sepal_length,sepal_width,petal_length,petal_width,plant_class
<span class=fl>5.1</span>,<span class=fl>3.5</span>,<span class=fl>1.4</span>,<span class=fl>0.2</span>,Iris-setosa
<span class=fl>5.0</span>,<span class=fl>2.0</span>,<span class=fl>3.5</span>,<span class=fl>1.0</span>,Iris-versicolor
<span class=fl>6.3</span>,<span class=fl>3.3</span>,<span class=fl>6.0</span>,<span class=fl>2.5</span>,Iris-virginica</code></pre></div>
<h4 id=unstructured-csv><font>Unstructured CSV</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>非结构化 CSV</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Just like with Aeson if we really want to work with unstructured data the library accommodates this.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就像 Aeson 一样，如果我们真的想使用非结构化数据，图书馆可以满足这一要求。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/cassava_unstructured.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Data.Csv</span>

<span class=kw>import </span><span class=dt>Text.Show.Pretty</span>

<span class=kw>import qualified</span> <span class=dt>Data.Vector</span> <span class=kw>as</span> <span class=dt>V</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>type</span> <span class=dt>ErrorMsg</span> <span class=fu>=</span> <span class=dt>String</span>
<span class=kw>type</span> <span class=dt>CsvData</span> <span class=fu>=</span> <span class=dt>V.Vector</span> (<span class=dt>V.Vector</span> <span class=dt>BL.ByteString</span>)

<span class=ot>example ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>ErrorMsg</span> <span class=dt>CsvData</span>)
example fname <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile fname
  return <span class=fu>$</span> decode <span class=dt>NoHeader</span> contents</code></pre></div>
<p><font>We see we get the nested set of stringy vectors:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们看到我们得到了一组嵌套的字符串向量：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">[ [ <span class=st>"sepal_length"</span>
  , <span class=st>"sepal_width"</span>
  , <span class=st>"petal_length"</span>
  , <span class=st>"petal_width"</span>
  , <span class=st>"plant_class"</span>
  ]
, [ <span class=st>"5.1"</span> , <span class=st>"3.5"</span> , <span class=st>"1.4"</span> , <span class=st>"0.2"</span> , <span class=st>"Iris-setosa"</span> ]
, [ <span class=st>"5.0"</span> , <span class=st>"2.0"</span> , <span class=st>"3.5"</span> , <span class=st>"1.0"</span> , <span class=st>"Iris-versicolor"</span> ]
, [ <span class=st>"6.3"</span> , <span class=st>"3.3"</span> , <span class=st>"6.0"</span> , <span class=st>"2.5"</span> , <span class=st>"Iris-virginica"</span> ]
]</code></pre></div>
<h4 id=structured-csv><font>Structured CSV</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>结构化 CSV</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Just like with Aeson we can use Generic to automatically write the deserializer between our CSV data and our custom datatype.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就像 Aeson 一样，我们可以使用 Generic 在我们的 CSV 数据和我们的自定义数据类型之间自动编写反序列化程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/26-data-formats/cassava_structured.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>

<span class=kw>import </span><span class=dt>Data.Csv</span>
<span class=kw>import </span><span class=dt>GHC.Generics</span>
<span class=kw>import qualified</span> <span class=dt>Data.Vector</span> <span class=kw>as</span> <span class=dt>V</span>
<span class=kw>import qualified</span> <span class=dt>Data.ByteString.Lazy</span> <span class=kw>as</span> <span class=dt>BL</span>

<span class=kw>data</span> <span class=dt>Plant</span> <span class=fu>=</span> <span class=dt>Plant</span>
  {<span class=ot> sepal_length ::</span> <span class=dt>Double</span>
  ,<span class=ot> sepal_width  ::</span> <span class=dt>Double</span>
  ,<span class=ot> petal_length ::</span> <span class=dt>Double</span>
  ,<span class=ot> petal_width  ::</span> <span class=dt>Double</span>
  ,<span class=ot> plant_class ::</span> <span class=dt>String</span>
  } <span class=kw>deriving</span> (<span class=dt>Generic</span>, <span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>FromNamedRecord</span> <span class=dt>Plant</span>
<span class=kw>instance</span> <span class=dt>ToNamedRecord</span> <span class=dt>Plant</span>

<span class=kw>type</span> <span class=dt>ErrorMsg</span> <span class=fu>=</span> <span class=dt>String</span>
<span class=kw>type</span> <span class=dt>CsvData</span> <span class=fu>=</span> (<span class=dt>Header</span>, <span class=dt>V.Vector</span> <span class=dt>Plant</span>)

<span class=ot>parseCSV ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>IO</span> (<span class=dt>Either</span> <span class=dt>ErrorMsg</span> <span class=dt>CsvData</span>)
parseCSV fname <span class=fu>=</span> <span class=kw>do</span>
  contents <span class=ot>&lt;-</span> BL.readFile fname
  return <span class=fu>$</span> decodeByName contents

main <span class=fu>=</span> parseCSV <span class=st>"iris.csv"</span> <span class=fu>&gt;&gt;=</span> print</code></pre></div>
<p><font>And again we get a nice typed ADT as a result.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>结果我们又得到了一个漂亮的类型化 ADT。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class=dt>Plant</span>
    { sepal_length <span class=fu>=</span> <span class=fl>5.1</span>
    , sepal_width <span class=fu>=</span> <span class=fl>3.5</span>
    , petal_length <span class=fu>=</span> <span class=fl>1.4</span>
    , petal_width <span class=fu>=</span> <span class=fl>0.2</span>
    , plant_class <span class=fu>=</span> <span class=st>"Iris-setosa"</span>
    }
, <span class=dt>Plant</span>
    { sepal_length <span class=fu>=</span> <span class=fl>5.0</span>
    , sepal_width <span class=fu>=</span> <span class=fl>2.0</span>
    , petal_length <span class=fu>=</span> <span class=fl>3.5</span>
    , petal_width <span class=fu>=</span> <span class=fl>1.0</span>
    , plant_class <span class=fu>=</span> <span class=st>"Iris-versicolor"</span>
    }
, <span class=dt>Plant</span>
    { sepal_length <span class=fu>=</span> <span class=fl>6.3</span>
    , sepal_width <span class=fu>=</span> <span class=fl>3.3</span>
    , petal_length <span class=fu>=</span> <span class=fl>6.0</span>
    , petal_width <span class=fu>=</span> <span class=fl>2.5</span>
    , plant_class <span class=fu>=</span> <span class=st>"Iris-virginica"</span>
    }
]</code></pre></div>
<h1 id=network-web-programming><font>Network &amp; Web Programming</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>网络与网络编程</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=http><font>HTTP</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>HTTP</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell has a variety of HTTP request and processing libraries. The simplest and most flexible is the </font><a href=https://hackage.haskell.org/package/HTTP>HTTP library</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 有多种 HTTP 请求和处理库。最简单和最灵活的是 HTTP 库。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/http.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Network.HTTP.Types</span>
<span class=kw>import </span><span class=dt>Network.HTTP.Client</span>
<span class=kw>import </span><span class=dt>Control.Applicative</span>
<span class=kw>import </span><span class=dt>Control.Concurrent.Async</span>

<span class=kw>type</span> <span class=dt>URL</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=ot>get ::</span> <span class=dt>Manager</span> <span class=ot>-&gt;</span> <span class=dt>URL</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>Int</span>
get m url <span class=fu>=</span> <span class=kw>do</span>
  req <span class=ot>&lt;-</span> parseUrl url
  statusCode <span class=fu>&lt;$&gt;</span> responseStatus <span class=fu>&lt;$&gt;</span> httpNoBody req m

<span class=ot>single ::</span> <span class=dt>IO</span> <span class=dt>Int</span>
single <span class=fu>=</span> <span class=kw>do</span>
  withManager defaultManagerSettings <span class=fu>$</span> \m <span class=ot>-&gt;</span> <span class=kw>do</span>
    get m <span class=st>"http://haskell.org"</span>

<span class=ot>parallel ::</span> <span class=dt>IO</span> [<span class=dt>Int</span>]
parallel <span class=fu>=</span> <span class=kw>do</span>
  withManager defaultManagerSettings <span class=fu>$</span> \m <span class=ot>-&gt;</span> <span class=kw>do</span>
    <span class=co>-- Fetch w3.org 10 times concurrently</span>
    <span class=kw>let</span> urls <span class=fu>=</span> replicate <span class=dv>10</span> <span class=st>"http://www.w3.org"</span>
    mapConcurrently (get m) urls

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>=&lt;&lt;</span> single
  print <span class=fu>=&lt;&lt;</span> parallel</code></pre></div>
<h2 id=blaze><font>Blaze</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>火焰</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Blaze is an HTML combinator library that provides that capacity to build composable bits of HTML programmatically. It doesn't string templating libraries like </font><a href=#hastache>Hastache</a><font> but instead provides an API for building up HTML documents from logic where the format out of the output is generated procedurally.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Blaze 是一个 HTML 组合器库，它提供了以编程方式构建 HTML 的可组合位的能力。它没有像 Hastache 这样的字符串模板库，而是提供了一个 API，用于从逻辑中构建 HTML 文档，其中输出的格式是按程序生成的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For sequencing HTML elements the elements can either be sequenced in a monad or with monoid operations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>为了对 HTML 元素进行排序，可以在 monad 中或使用幺半群操作对元素进行排序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/blaze.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>module</span> <span class=dt>Html</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Text.Blaze.Html5</span>
<span class=kw>import </span><span class=dt>Text.Blaze.Html.Renderer.Text</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>T</span>

<span class=ot>example ::</span> <span class=dt>Html</span>
example <span class=fu>=</span> <span class=kw>do</span>
  h1 <span class=st>"First header"</span>
  p <span class=fu>$</span> ul <span class=fu>$</span> mconcat [li <span class=st>"First"</span>, li <span class=st>"Second"</span>]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  T.putStrLn <span class=fu>$</span> renderHtml example</code></pre></div>
<p><font>For custom datatypes we can implement the </font><code>ToMarkup</code><font>class to convert between Haskell data structures and HTML representation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于自定义数据类型，我们可以实现 ToMarkup 类以在 Haskell 数据结构和 HTML 表示之间进行转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/blaze_instance.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RecordWildCards #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>module</span> <span class=dt>Html</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Text.Blaze.Html5</span>
<span class=kw>import </span><span class=dt>Text.Blaze.Html.Renderer.Text</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>T</span>

<span class=kw>data</span> <span class=dt>Employee</span> <span class=fu>=</span> <span class=dt>Employee</span>
  {<span class=ot> name ::</span> <span class=dt>T.Text</span>
  ,<span class=ot> age ::</span> <span class=dt>Int</span>
  }

<span class=kw>instance</span> <span class=dt>ToMarkup</span> <span class=dt>Employee</span> <span class=kw>where</span>
  toMarkup <span class=dt>Employee</span> {<span class=fu>..</span>} <span class=fu>=</span> ul <span class=fu>$</span> mconcat
    [ li (toHtml name)
    , li (toHtml age)
    ]

<span class=ot>fred ::</span> <span class=dt>Employee</span>
fred <span class=fu>=</span> <span class=dt>Employee</span> { name <span class=fu>=</span> <span class=st>"Fred"</span>, age <span class=fu>=</span> <span class=dv>35</span> }

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  T.putStrLn <span class=fu>$</span> renderHtml (toHtml fred)</code></pre></div>
<h2 id=warp><font>Warp</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>经</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Warp is a efficient web server, it's the backend request engine behind several of popular Haskell web frameworks. The internals have been finely tuned to utilize Haskell's concurrent runtime and is capable of handling a great deal of concurrent requests.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Warp 是一个高效的网络服务器，它是几个流行的 Haskell 网络框架背后的后端请求引擎。内部结构经过微调以利用 Haskell 的并发运行时，并且能够处理大量并发请求。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/warp.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Network.Wai</span>
<span class=kw>import </span><span class=dt>Network.Wai.Handler.Warp</span> (run)
<span class=kw>import </span><span class=dt>Network.HTTP.Types</span>

<span class=ot>app ::</span> <span class=dt>Application</span>
app req <span class=fu>=</span> return <span class=fu>$</span> responseLBS status200 [] <span class=st>"Engage!"</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> run <span class=dv>8000</span> app</code></pre></div>
<p><font>See: </font><a href=http://aosabook.org/en/posa/warp.html>Warp</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：变形</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=scotty><font>Scotty</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>斯科蒂</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Continuing with our trek through web libraries, Scotty is a web microframework similar in principle to Flask in Python or Sinatra in Ruby.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>继续我们的网络库之旅，Scotty 是一个网络微框架，在原理上类似于 Python 中的 Flask 或 Ruby 中的 Sinatra。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/scotty.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Web.Scotty</span>

<span class=kw>import qualified</span> <span class=dt>Text.Blaze.Html5</span> <span class=kw>as</span> <span class=dt>H</span>
<span class=kw>import </span><span class=dt>Text.Blaze.Html5</span> (toHtml, <span class=dt>Html</span>)
<span class=kw>import </span><span class=dt>Text.Blaze.Html.Renderer.Text</span> (renderHtml)

<span class=ot>greet ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Html</span>
greet user <span class=fu>=</span> H.html <span class=fu>$</span> <span class=kw>do</span>
  H.head <span class=fu>$</span>
    H.title <span class=st>"Welcome!"</span>
  H.body <span class=fu>$</span> <span class=kw>do</span>
    H.h1 <span class=st>"Greetings!"</span>
    H.p (<span class=st>"Hello "</span> <span class=fu>&gt;&gt;</span> toHtml user <span class=fu>&gt;&gt;</span> <span class=st>"!"</span>)

app <span class=fu>=</span> <span class=kw>do</span>
  get <span class=st>"/"</span> <span class=fu>$</span>
    text <span class=st>"Home Page"</span>

  get <span class=st>"/greet/:name"</span> <span class=fu>$</span> <span class=kw>do</span>
    name <span class=ot>&lt;-</span> param <span class=st>"name"</span>
    html <span class=fu>$</span> renderHtml (greet name)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> scotty <span class=dv>8000</span> app</code></pre></div>
<p><font>Of importance to note is the Blaze library used here overloads do-notation but is not itself a proper monad so the various laws and invariants that normally apply for monads may break down or fail with error terms.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>值得注意的是，这里使用的 Blaze 库重载了 do-notation，但它本身并不是一个合适的 monad，因此通常适用于 monad 的各种定律和不变量可能会因错误项而崩溃或失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html>Making a Website with Haskell</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：使用 Haskell 制作网站</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=servant><font>Servant</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>仆人</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=hastache><font>Hastache</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>黑芝麻</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Hastache is string templating based on the "Mustache" style of encoding metavariables with double braces </font><code>{{ x }}</code><font>. Hastache supports automatically converting many Haskell types into strings and uses the efficient Text functions for formatting.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Hastache 是基于“Mustache”风格的字符串模板，使用双大括号 {{ x }} 编码元变量。 Hastache 支持自动将许多 Haskell 类型转换为字符串，并使用高效的 Text 函数进行格式化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The variables loaded into the template are specified in either a function mapping variable names to printable MuType values. For instance using a function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>加载到模板中的变量在将变量名称映射到可打印 MuType 值的函数中指定。例如使用函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/hastache.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Text.Hastache</span>
<span class=kw>import </span><span class=dt>Text.Hastache.Context</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy</span> <span class=kw>as</span> <span class=dt>TL</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>TL</span>

<span class=kw>import </span><span class=dt>Data.Data</span>

<span class=ot>template ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>MuContext</span> <span class=dt>IO</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>TL.Text</span>
template <span class=fu>=</span> hastacheFile defaultConfig

<span class=co>-- Function strContext</span>
<span class=ot>context ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>MuType</span> <span class=dt>IO</span>
context <span class=st>"body"</span>  <span class=fu>=</span> <span class=dt>MuVariable</span> (<span class=st>"Hello World"</span><span class=ot> ::</span> <span class=dt>TL.Text</span>)
context <span class=st>"title"</span> <span class=fu>=</span> <span class=dt>MuVariable</span> (<span class=st>"Haskell is lovely"</span><span class=ot> ::</span> <span class=dt>TL.Text</span>)
context _       <span class=fu>=</span> <span class=dt>MuVariable</span> ()

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  output <span class=ot>&lt;-</span> template <span class=st>"templates/home.html"</span> (mkStrContext context)
  TL.putStrLn output</code></pre></div>
<p><font>Or using Data-Typeable record and </font><code>mkGenericContext</code><font>, the Haskell field names are converted into variable names.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者使用 Data-Typeable record 和 mkGenericContext，将 Haskell 字段名称转换为变量名称。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/27-web/hastache_generic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Text.Hastache</span>
<span class=kw>import </span><span class=dt>Text.Hastache.Context</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy</span> <span class=kw>as</span> <span class=dt>TL</span>
<span class=kw>import qualified</span> <span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>TL</span>

<span class=kw>import </span><span class=dt>Data.Data</span>

<span class=ot>template ::</span> FilePath <span class=ot>-&gt;</span> <span class=dt>MuContext</span> <span class=dt>IO</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>TL.Text</span>
template <span class=fu>=</span> hastacheFile defaultConfig

<span class=co>-- Record context</span>
<span class=kw>data</span> <span class=dt>TemplateCtx</span> <span class=fu>=</span> <span class=dt>TemplateCtx</span>
  {<span class=ot> body ::</span> <span class=dt>TL.Text</span>
  ,<span class=ot> title ::</span> <span class=dt>TL.Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Data</span>, <span class=dt>Typeable</span>)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> ctx <span class=fu>=</span> <span class=dt>TemplateCtx</span> { body <span class=fu>=</span> <span class=st>"Hello"</span>, title <span class=fu>=</span> <span class=st>"Haskell"</span> }
  output <span class=ot>&lt;-</span> template <span class=st>"templates/home.html"</span> (mkGenericContext ctx)
  TL.putStrLn output</code></pre></div>
<p><font>The MuType and MuContext types can be parameterized by any monad or transformer that implements </font><code>MonadIO</code><font>, not just IO.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>MuType 和 MuContext 类型可以由任何实现 MonadIO 的 monad 或转换器参数化，而不仅仅是 IO。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h1 id=databases><font>Databases</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>数据库</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=postgres><font>Postgres</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Postgres</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Postgres is an object-relational database management system with a rich extension of the SQL standard. Consider the following tables specified in DDL.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Postgres 是一种对象关系数据库管理系统，具有 SQL 标准的丰富扩展。考虑 DDL 中指定的下表。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode sql"><code class="sourceCode sql"><span class=kw>CREATE</span> <span class=kw>TABLE</span> <span class=ot>"books"</span> (
    <span class=ot>"id"</span> <span class=dt>integer</span> <span class=kw>NOT</span> <span class=kw>NULL</span>,
    <span class=ot>"title"</span> text <span class=kw>NOT</span> <span class=kw>NULL</span>,
    <span class=ot>"author_id"</span> <span class=dt>integer</span>,
    <span class=ot>"subject_id"</span> <span class=dt>integer</span>,
    <span class=kw>Constraint</span> <span class=ot>"books_id_pkey"</span> <span class=kw>Primary</span> <span class=kw>Key</span> (<span class=ot>"id"</span>)
);

<span class=kw>CREATE</span> <span class=kw>TABLE</span> <span class=ot>"authors"</span> (
    <span class=ot>"id"</span> <span class=dt>integer</span> <span class=kw>NOT</span> <span class=kw>NULL</span>,
    <span class=ot>"last_name"</span> text,
    <span class=ot>"first_name"</span> text,
    <span class=kw>Constraint</span> <span class=ot>"authors_pkey"</span> <span class=kw>Primary</span> <span class=kw>Key</span> (<span class=ot>"id"</span>)
);</code></pre></div>
<p><font>The postgresql-simple bindings provide a thin wrapper to various libpq commands to interact a Postgres server. These functions all take a </font><code>Connection</code><font> object to the database instance and allow various bytestring queries to be sent and result sets mapped into Haskell datatypes. There are four primary functions for these interactions:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>postgresql-simple 绑定为各种 libpq 命令提供了一个瘦包装器，以与 Postgres 服务器交互。这些函数都将 Connection 对象带到数据库实例，并允许发送各种字节串查询并将结果集映射到 Haskell 数据类型。这些交互有四个主要功能：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>query_ ::</span> <span class=dt>FromRow</span> r <span class=ot>=&gt;</span> <span class=dt>Connection</span> <span class=ot>-&gt;</span> <span class=dt>Query</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> [r]
<span class=ot>query ::</span> (<span class=dt>ToRow</span> q, <span class=dt>FromRow</span> r) <span class=ot>=&gt;</span> <span class=dt>Connection</span> <span class=ot>-&gt;</span> <span class=dt>Query</span> <span class=ot>-&gt;</span> q <span class=ot>-&gt;</span> <span class=dt>IO</span> [r]
<span class=ot>execute ::</span> <span class=dt>ToRow</span> q <span class=ot>=&gt;</span> <span class=dt>Connection</span> <span class=ot>-&gt;</span> <span class=dt>Query</span> <span class=ot>-&gt;</span> q <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>Int64</span>
<span class=ot>execute_ ::</span> <span class=dt>Connection</span> <span class=ot>-&gt;</span> <span class=dt>Query</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>Int64</span></code></pre></div>
<p><font>The result of the </font><code>query</code><font> function is a list of elements which implement the FromRow typeclass. This can be many things including a single elemment (Only), a list of tuples where each element implements </font><code>FromField</code><font> or a custom datatype that itself implements </font><code>FromRow</code><font>. Under the hood the database bindings inspects the Postgres </font><code>oid</code><font> objects and then attempts to convert them into the Haskell datatype of the field being scrutinised. This can fail at runtime if the types in the database don't align with the expected types in the logic executing the SQL query.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>查询函数的结果是实现 FromRow 类型类的元素列表。这可以是很多东西，包括单个元素（仅）、每个元素实现 FromField 的元组列表或本身实现 FromRow 的自定义数据类型。在后台，数据库绑定检查 Postgres oid 对象，然后尝试将它们转换为正在检查的字段的 Haskell 数据类型。如果数据库中的类型与执行 SQL 查询的逻辑中的预期类型不一致，这可能会在运行时失败。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=tuples><font>Tuples</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>元组</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<div class=sourceCode include=src/28-databases/postgres.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>
<span class=kw>import qualified</span> <span class=dt>Database.PostgreSQL.Simple</span> <span class=kw>as</span> <span class=dt>SQL</span>

<span class=ot>creds ::</span> <span class=dt>SQL.ConnectInfo</span>
creds <span class=fu>=</span> SQL.defaultConnectInfo
  { SQL.connectUser <span class=fu>=</span> <span class=st>"example"</span>
  , SQL.connectPassword <span class=fu>=</span> <span class=st>"example"</span>
  , SQL.connectDatabase <span class=fu>=</span> <span class=st>"booktown"</span>
  }

<span class=ot>selectBooks ::</span> <span class=dt>SQL.Connection</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> [(<span class=dt>Int</span>, <span class=dt>T.Text</span>, <span class=dt>Int</span>)]
selectBooks conn <span class=fu>=</span> SQL.query_ conn <span class=st>"select id, title, author_id from books"</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  conn <span class=ot>&lt;-</span> SQL.connect creds
  books <span class=ot>&lt;-</span> selectBooks conn
  print books</code></pre></div>
<p><font>This yields the result set:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这会产生结果集：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">[ ( <span class=dv>7808</span> , <span class=st>"The Shining"</span> , <span class=dv>4156</span> )
, ( <span class=dv>4513</span> , <span class=st>"Dune"</span> , <span class=dv>1866</span> )
, ( <span class=dv>4267</span> , <span class=st>"2001: A Space Odyssey"</span> , <span class=dv>2001</span> )
, ( <span class=dv>1608</span> , <span class=st>"The Cat in the Hat"</span> , <span class=dv>1809</span> )
, ( <span class=dv>1590</span> , <span class=st>"Bartholomew and the Oobleck"</span> , <span class=dv>1809</span> )
, ( <span class=dv>25908</span> , <span class=st>"Franklin in the Dark"</span> , <span class=dv>15990</span> )
, ( <span class=dv>1501</span> , <span class=st>"Goodnight Moon"</span> , <span class=dv>2031</span> )
, ( <span class=dv>190</span> , <span class=st>"Little Women"</span> , <span class=dv>16</span> )
, ( <span class=dv>1234</span> , <span class=st>"The Velveteen Rabbit"</span> , <span class=dv>25041</span> )
, ( <span class=dv>2038</span> , <span class=st>"Dynamic Anatomy"</span> , <span class=dv>1644</span> )
, ( <span class=dv>156</span> , <span class=st>"The Tell-Tale Heart"</span> , <span class=dv>115</span> )
, ( <span class=dv>41473</span> , <span class=st>"Programming Python"</span> , <span class=dv>7805</span> )
, ( <span class=dv>41477</span> , <span class=st>"Learning Python"</span> , <span class=dv>7805</span> )
, ( <span class=dv>41478</span> , <span class=st>"Perl Cookbook"</span> , <span class=dv>7806</span> )
, ( <span class=dv>41472</span> , <span class=st>"Practical PostgreSQL"</span> , <span class=dv>1212</span> )
]</code></pre></div>
<h4 id=custom-types><font>Custom Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自定义类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<div class=sourceCode include=src/28-databases/postgres_custom.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>

<span class=kw>import qualified</span> <span class=dt>Database.PostgreSQL.Simple</span> <span class=kw>as</span> <span class=dt>SQL</span>
<span class=kw>import </span><span class=dt>Database.PostgreSQL.Simple.FromRow</span> (<span class=dt>FromRow</span>(..), field)

<span class=kw>data</span> <span class=dt>Book</span> <span class=fu>=</span> <span class=dt>Book</span>
  {<span class=ot> id_ ::</span> <span class=dt>Int</span>
  ,<span class=ot> title ::</span> <span class=dt>T.Text</span>
  ,<span class=ot> author_id ::</span> <span class=dt>Int</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>FromRow</span> <span class=dt>Book</span> <span class=kw>where</span>
  fromRow <span class=fu>=</span> <span class=dt>Book</span> <span class=fu>&lt;$&gt;</span> field <span class=fu>&lt;*&gt;</span> field <span class=fu>&lt;*&gt;</span> field

<span class=ot>creds ::</span> <span class=dt>SQL.ConnectInfo</span>
creds <span class=fu>=</span> SQL.defaultConnectInfo
  { SQL.connectUser <span class=fu>=</span> <span class=st>"example"</span>
  , SQL.connectPassword <span class=fu>=</span> <span class=st>"example"</span>
  , SQL.connectDatabase <span class=fu>=</span> <span class=st>"booktown"</span>
  }

<span class=ot>selectBooks ::</span> <span class=dt>SQL.Connection</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> [<span class=dt>Book</span>]
selectBooks conn <span class=fu>=</span> SQL.query_ conn <span class=st>"select id, title, author_id from books limit 4"</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  conn <span class=ot>&lt;-</span> SQL.connect creds
  books <span class=ot>&lt;-</span> selectBooks conn
  print books</code></pre></div>
<p><font>This yields the result set:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这会产生结果集：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class=dt>Book</span> { id_ <span class=fu>=</span> <span class=dv>7808</span> , title <span class=fu>=</span> <span class=st>"The Shining"</span> , author_id <span class=fu>=</span> <span class=dv>4156</span> }
, <span class=dt>Book</span> { id_ <span class=fu>=</span> <span class=dv>4513</span> , title <span class=fu>=</span> <span class=st>"Dune"</span> , author_id <span class=fu>=</span> <span class=dv>1866</span> }
, <span class=dt>Book</span> { id_ <span class=fu>=</span> <span class=dv>4267</span> , title <span class=fu>=</span> <span class=st>"2001: A Space Odyssey"</span> , author_id <span class=fu>=</span> <span class=dv>2001</span> }
, <span class=dt>Book</span> { id_ <span class=fu>=</span> <span class=dv>1608</span> , title <span class=fu>=</span> <span class=st>"The Cat in the Hat"</span> , author_id <span class=fu>=</span> <span class=dv>1809</span> }
]</code></pre></div>
<h4 id=quasiquoter><font>Quasiquoter</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>准报价者</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>As SQL expressions grow in complexity they often span multiple lines and sometimes its useful to just drop down to a quasiquoter to embed the whole query. The quoter here is pure, and just generates the </font><code>Query</code><font> object behind as a ByteString.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>随着 SQL 表达式的复杂性增加，它们通常会跨越多行，有时仅下降到准引用以嵌入整个查询很有用。这里的引用是纯粹的，只是将后面的Query对象生成为一个ByteString。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/28-databases/postgres_qq.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>

<span class=kw>import qualified</span> <span class=dt>Database.PostgreSQL.Simple</span> <span class=kw>as</span> <span class=dt>SQL</span>
<span class=kw>import </span><span class=dt>Database.PostgreSQL.Simple.SqlQQ</span> (sql)
<span class=kw>import </span><span class=dt>Database.PostgreSQL.Simple.FromRow</span> (<span class=dt>FromRow</span>(..), field)

<span class=kw>data</span> <span class=dt>Book</span> <span class=fu>=</span> <span class=dt>Book</span>
  {<span class=ot> id_ ::</span> <span class=dt>Int</span>
  ,<span class=ot> title ::</span> <span class=dt>T.Text</span>
  ,<span class=ot> first_name ::</span> <span class=dt>T.Text</span>
  ,<span class=ot> last_name ::</span> <span class=dt>T.Text</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>FromRow</span> <span class=dt>Book</span> <span class=kw>where</span>
  fromRow <span class=fu>=</span> <span class=dt>Book</span> <span class=fu>&lt;$&gt;</span> field <span class=fu>&lt;*&gt;</span> field <span class=fu>&lt;*&gt;</span> field <span class=fu>&lt;*&gt;</span> field

<span class=ot>creds ::</span> <span class=dt>SQL.ConnectInfo</span>
creds <span class=fu>=</span> SQL.defaultConnectInfo
  { SQL.connectUser <span class=fu>=</span> <span class=st>"example"</span>
  , SQL.connectPassword <span class=fu>=</span> <span class=st>"example"</span>
  , SQL.connectDatabase <span class=fu>=</span> <span class=st>"booktown"</span>
  }

<span class=ot>selectBooks ::</span> <span class=dt>SQL.Query</span>
selectBooks <span class=fu>=</span> [sql<span class=fu>|</span>
select
  books<span class=fu>.</span>id,
  books<span class=fu>.</span>title,
  authors<span class=fu>.</span>first_name,
  authors<span class=fu>.</span>last_name
from books
join authors on
  authors<span class=fu>.</span>id <span class=fu>=</span> books<span class=fu>.</span>author_id
limit <span class=dv>5</span>
<span class=fu>|</span>]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  conn <span class=ot>&lt;-</span> SQL.connect creds
  (<span class=ot>books ::</span> [<span class=dt>Book</span>]) <span class=ot>&lt;-</span> SQL.query_ conn selectBooks
  print books</code></pre></div>
<p><font>This yields the result set:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这会产生结果集：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class=dt>Book</span>
    { id_ <span class=fu>=</span> <span class=dv>41472</span>
    , title <span class=fu>=</span> <span class=st>"Practical PostgreSQL"</span>
    , first_name <span class=fu>=</span> <span class=st>"John"</span>
    , last_name <span class=fu>=</span> <span class=st>"Worsley"</span>
    }
, <span class=dt>Book</span>
    { id_ <span class=fu>=</span> <span class=dv>25908</span>
    , title <span class=fu>=</span> <span class=st>"Franklin in the Dark"</span>
    , first_name <span class=fu>=</span> <span class=st>"Paulette"</span>
    , last_name <span class=fu>=</span> <span class=st>"Bourgeois"</span>
    }
, <span class=dt>Book</span>
    { id_ <span class=fu>=</span> <span class=dv>1234</span>
    , title <span class=fu>=</span> <span class=st>"The Velveteen Rabbit"</span>
    , first_name <span class=fu>=</span> <span class=st>"Margery Williams"</span>
    , last_name <span class=fu>=</span> <span class=st>"Bianco"</span>
    }
, <span class=dt>Book</span>
    { id_ <span class=fu>=</span> <span class=dv>190</span>
    , title <span class=fu>=</span> <span class=st>"Little Women"</span>
    , first_name <span class=fu>=</span> <span class=st>"Louisa May"</span>
    , last_name <span class=fu>=</span> <span class=st>"Alcott"</span>
    }
]</code></pre></div>
<h2 id=redis><font>Redis</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>雷迪斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Redis is an in-memory key-value store with support for a variety of datastructures. The Haskell exposure is exposed in a </font><code>Redis</code><font> monad which sequences a set of </font><a href=http://redis.io/commands>redis commands</a><font> taking ByteString arguments and then executes them against a connection object.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Redis 是一种内存中键值存储，支持多种数据结构。 Haskell 暴露在 Redis monad 中暴露，它对一组采用 ByteString 参数的 redis 命令进行排序，然后针对连接对象执行它们。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/28-databases/hedis.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Database.Redis</span>
<span class=kw>import </span><span class=dt>Data.ByteString.Char8</span>

<span class=ot>session ::</span> <span class=dt>Redis</span> (<span class=dt>Either</span> <span class=dt>Reply</span> (<span class=dt>Maybe</span> <span class=dt>ByteString</span>))
session <span class=fu>=</span> <span class=kw>do</span>
  set <span class=st>"hello"</span> <span class=st>"haskell"</span>
  get <span class=st>"hello"</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  conn <span class=ot>&lt;-</span> connect defaultConnectInfo
  res <span class=ot>&lt;-</span> runRedis conn session
  print res</code></pre></div>
<p><font>Redis is quite often used as a lightweight pubsub server, and the bindings integrate with the Haskell concurrency primitives so that listeners can be sparked and shared across threads off without blocking the main thread.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Redis 经常用作轻量级 pubsub 服务器，并且绑定与 Haskell 并发原语集成，因此可以在不阻塞主线程的情况下触发和跨线程共享侦听器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/28-databases/hedis_pubsub.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Database.Redis</span>

<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Monad.Trans</span>
<span class=kw>import </span><span class=dt>Data.ByteString.Char8</span>

<span class=kw>import </span><span class=dt>Control.Concurrent</span>

<span class=ot>subscriber ::</span> <span class=dt>Redis</span> ()
subscriber <span class=fu>=</span>
 pubSub (subscribe [<span class=st>"news"</span>]) <span class=fu>$</span> \msg <span class=ot>-&gt;</span> <span class=kw>do</span>
   print msg
   return mempty

<span class=ot>publisher ::</span> <span class=dt>Redis</span> ()
publisher <span class=fu>=</span> forM_ [<span class=dv>1</span><span class=fu>..</span><span class=dv>100</span>] <span class=fu>$</span> \n <span class=ot>-&gt;</span> publish <span class=st>"news"</span> (pack (show n))

<span class=co>-- connects to localhost:6379</span>
<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  conn1 <span class=ot>&lt;-</span> connect defaultConnectInfo
  conn2 <span class=ot>&lt;-</span> connect defaultConnectInfo

  <span class=co>-- Fork off a publisher</span>
  forkIO <span class=fu>$</span> runRedis conn1 publisher

  <span class=co>-- Subscribe for messages</span>
  runRedis conn2 subscriber</code></pre></div>
<h2 id=acid-state><font>Acid State</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>酸性状态</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Acid-state allows us to build a "database" for around our existing Haskell datatypes that guarantees atomic transactions. For example, we can build a simple key-value store wrapped around the Map type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Acid-state 允许我们围绕我们现有的 Haskell 数据类型构建一个“数据库”，以保证原子事务。例如，我们可以围绕 Map 类型构建一个简单的键值存储。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/28-databases/acid.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>
<span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>import </span><span class=dt>Data.Acid</span>
<span class=kw>import </span><span class=dt>Data.Typeable</span>
<span class=kw>import </span><span class=dt>Data.SafeCopy</span>
<span class=kw>import </span><span class=dt>Control.Monad.Reader</span> (ask)

<span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>Map</span>
<span class=kw>import qualified</span> <span class=dt>Control.Monad.State</span> <span class=kw>as</span> <span class=dt>S</span>

<span class=kw>type</span> <span class=dt>Key</span> <span class=fu>=</span> <span class=dt>String</span>
<span class=kw>type</span> <span class=dt>Value</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Database</span> <span class=fu>=</span> <span class=dt>Database</span> <span class=fu>!</span>(<span class=dt>Map.Map</span> <span class=dt>Key</span> <span class=dt>Value</span>)
    <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Ord</span>, <span class=dt>Eq</span>, <span class=dt>Typeable</span>)

<span class=fu>$</span>(deriveSafeCopy <span class=dv>0</span> <span class=ch>'base ''Database)</span>

<span class=ot>insertKey ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>Update</span> <span class=dt>Database</span> ()
insertKey key value
    <span class=fu>=</span> <span class=kw>do</span> <span class=dt>Database</span> m <span class=ot>&lt;-</span> S.get
         S.put (<span class=dt>Database</span> (Map.insert key value m))

<span class=ot>lookupKey ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Query</span> <span class=dt>Database</span> (<span class=dt>Maybe</span> <span class=dt>Value</span>)
lookupKey key
    <span class=fu>=</span> <span class=kw>do</span> <span class=dt>Database</span> m <span class=ot>&lt;-</span> ask
         return (Map.lookup key m)

<span class=ot>deleteKey ::</span> <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Update</span> <span class=dt>Database</span> ()
deleteKey key
    <span class=fu>=</span> <span class=kw>do</span> <span class=dt>Database</span> m <span class=ot>&lt;-</span> S.get
         S.put (<span class=dt>Database</span> (Map.delete key m))

<span class=ot>allKeys ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Query</span> <span class=dt>Database</span> [(<span class=dt>Key</span>, <span class=dt>Value</span>)]
allKeys limit
    <span class=fu>=</span> <span class=kw>do</span> <span class=dt>Database</span> m <span class=ot>&lt;-</span> ask
         return <span class=fu>$</span> take limit (Map.toList m)

<span class=fu>$</span>(makeAcidic <span class=ch>''</span><span class=dt>Database</span> [<span class=ch>'insertKey, '</span>lookupKey, <span class=ch>'allKeys, '</span>deleteKey])

<span class=ot>fixtures ::</span> <span class=dt>Map.Map</span> <span class=dt>String</span> <span class=dt>String</span>
fixtures <span class=fu>=</span> Map.empty

<span class=ot>test ::</span>  <span class=dt>Key</span> <span class=ot>-&gt;</span> <span class=dt>Value</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
test key val <span class=fu>=</span> <span class=kw>do</span>
    database <span class=ot>&lt;-</span> openLocalStateFrom <span class=st>"db/"</span> (<span class=dt>Database</span> fixtures)
    result <span class=ot>&lt;-</span> update database (<span class=dt>InsertKey</span> key val)
    result <span class=ot>&lt;-</span> query database (<span class=dt>AllKeys</span> <span class=dv>10</span>)
    print result</code></pre></div>
<hr>
<h1 id=ghc><font>GHC</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>全球健康中心</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<div class="alert alert-danger">
<p><font>This is a </font><strong>very advanced</strong><font> section, knowledge of GHC internals is rarely necessary.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个非常高级的部分，很少需要 GHC 内部知识。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h2 id=block-diagram><font>Block Diagram</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>框图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The flow of code through GHC is a process of translation between several intermediate languages and optimizations and transformations thereof. A common pattern for many of these AST types is they are parametrized over a binder type and at various stages the binders will be transformed, for example the Renamer pass effectively translates the </font><code>HsSyn</code><font> datatype from a AST parametrized over literal strings as the user enters into a </font><code>HsSyn</code><font> parameterized over qualified names that includes modules and package names into a higher level Name type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>代码在GHC中的流动是几种中间语言之间的翻译和优化转换的过程。许多这些 AST 类型的一个常见模式是它们在活页夹类型上进行参数化，并且在不同阶段活页夹将被转换，例如，当用户输入一个HsSyn 将包含模块和包名称的限定名称参数化为更高级别的名称类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h5 id=ghc-compiler><font>GHC Compiler</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GHC 编译器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h5>
<div class=center>
<div class=figure>
<img src=data:image/png;base64,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 alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/ghc.png>
</div>
</div>
<h5 id=ghc-compiler-passes><font>GHC Compiler Passes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>GHC 编译器通过</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h5>
<ul>
<li><strong>Parser/Frontend</strong><font>: An enormous AST translated from human syntax that makes explicit possible all expressible syntax ( declarations, do-notation, where clauses, syntax extensions, template haskell, ... ). This is unfiltered Haskell and it is </font><em>enormous</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解析器/前端：从人类语法翻译而来的巨大 AST，它使所有可表达的语法（声明、do-notation、where 子句、语法扩展、模板 haskell 等）成为可能。这是未经过滤的 Haskell，它非常庞大。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Renamer</strong><font> takes syntax from the frontend and transforms all names to be qualified (</font><code>base:Prelude.map</code><font> instead of </font><code>map</code><font>) and any shadowed names in lambda binders transformed into unique names.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Renamer 从前端获取语法并将所有名称转换为限定名称（base:Prelude.map 而不是 map），并将 lambda 绑定器中的任何阴影名称转换为唯一名称。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Typechecker</strong><font> is a large pass that serves two purposes, first is the core type bidirectional inference engine where most of the work happens and the translation between the frontend </font><code>Core</code><font> syntax.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Typechecker 是一个大通道，有两个用途，首先是核心类型双向推理引擎，大部分工作都在这里进行，以及前端核心语法之间的转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Desugarer</strong><font> translates several higher level syntactic constructors
</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Desugarer 翻译了几个更高级别的句法构造函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result><ul>
<li><code>where</code><font> statements are turned into (possibly recursive) nested </font><code>let</code><font> statements.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>where 语句被转换为（可能是递归的）嵌套的 let 语句。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Nested pattern matches are expanded out into splitting trees of case statements.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>嵌套模式匹配被扩展为 case 语句的分裂树。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>do-notation is expanded into explicit bind statements.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>do-notation 被扩展为显式绑定语句。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Lots of others.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>还有很多。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul></li>
<li><strong>Simplifier</strong><font> transforms many Core constructs into forms that are more adaptable to compilation. For example let statements will be floated or raised, pattern matches will simplified, inner loops will be pulled out and transformed into more optimal forms. Non-intuitively the resulting may actually be much more complex (for humans) after going through the simplifier!</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Simplifier 将许多 Core 构造转换为更适合编译的形式。例如，let 语句将被浮动或引发，模式匹配将被简化，内部循环将被拉出并转换为更优化的形式。非直观地，经过简化器后，结果实际上可能要复杂得多（对人类而言）！</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Stg</strong><font> pass translates the resulting Core into STG (Spineless Tagless G-Machine) which effectively makes all laziness explicit and encodes the thunks and update frames that will be handled during evaluation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Stg pass 将生成的 Core 转换为 STG（Spineless Tagless G-Machine），这有效地使所有懒惰显式化，并对将在评估期间处理的 thunk 和更新帧进行编码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Codegen/Cmm</strong><font> pass will then translate STG into Cmm (flavoured C--) a simple imperative language that manifests the low-level implementation details of runtime types. The runtime closure types and stack frames are made explicit and low-level information about the data and code (arity, updatability, free variables, pointer layout) made manifest in the info tables present on most constructs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>然后，Codegen/Cmm pass 会将 STG 翻译成 Cmm（风味 C--），这是一种简单的命令式语言，可显示运行时类型的低级实现细节。运行时闭包类型和堆栈帧是显式的，关于数据和代码的低级信息（arity、可更新性、自由变量、指针布局）在大多数构造的信息表中体现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><strong>Native Code</strong><font> The final pass will than translate the resulting code into either LLVM or Assembly via either through GHC's home built native code generator (NCG) or the LLVM backend.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>本机代码 最后一步将通过 GHC 的自制本机代码生成器 (NCG) 或 LLVM 后端将生成的代码转换为 LLVM 或程序集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><font>Information for each pass can dumped out via a rather large collection of flags. The GHC internals are very accessible although some passes are somewhat easier to understand than others. Most of the time </font><code>-ddump-simpl</code><font> and </font><code>-ddump-stg</code><font> are sufficient to get an understanding of how the code will compile, unless of course you're dealing with very specialized optimizations or hacking on GHC itself.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>每次通过的信息都可以通过相当大的标志集合导出。 GHC 的内部结构非常易于访问，尽管有些过程比其他过程更容易理解。大多数时候 -ddump-simpl 和 -ddump-stg 足以了解代码将如何编译，当然除非您正在处理非常专业的优化或对 GHC 本身进行黑客攻击。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Flag</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>旗帜</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Action</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>行动</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>-ddump-parsed<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-解析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Frontend AST.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>前端 AST。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-rn<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-rn</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of the rename pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>重命名过程的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-tc<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-tc</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of the typechecker.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型检查器的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-splices<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump拼接</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of TemplateHaskell splices.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>TemplateHaskell 拼接的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-types<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump 类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Typed AST representation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型化的 AST 表示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-deriv<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-deriv</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of deriving instances.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>派生实例的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-ds<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-ds</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of the desugar pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>脱糖过程的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-spec<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump规范</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of specialisation pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专业化通行证的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-rules<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-规则</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of applying rewrite rules.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>应用重写规则的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-vect<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-vect</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output results of vectorize pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>vectorize pass 的输出结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-simpl<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-简单</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Ouptut of the SimplCore pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SimplCore pass 的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-inlinings<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-inlinings</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of the inliner.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>内衬的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-cse<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-cse</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Output of the common subexpression elimination pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>公共子表达式消除过程的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-prep<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-准备</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The CorePrep pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>CorePrep 通行证。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-stg<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-stg</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The resulting STG.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>由此产生的 STG。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-cmm<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-cmm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The resulting Cmm.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>结果 Cmm。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-opt-cmm<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-opt-cmm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The resulting Cmm optimization pass.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生成的 Cmm 优化通过。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>-ddump-asm<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-asm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The final assembly generated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最后生成的程序集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>-ddump-llvm<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>-ddump-llvm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>The final LLVM IR generated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生成的最终 LLVM IR。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<h2 id=core><font>Core</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>核</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Core is the explicitly typed System-F family syntax through that all Haskell constructs can be expressed in.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>核心是显式类型的 System-F 系列语法，所有 Haskell 结构都可以在其中表达。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>To inspect the core from GHCi we can invoke it using the following flags and the following shell alias. We have explicitly disable the printing of certain metadata and longform names to make the representation easier to read.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要从 GHCi 检查核心，我们可以使用以下标志和以下 shell 别名调用它。我们已明确禁用某些元数据和长格式名称的打印，以使表示更易于阅读。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash"><span class=kw>alias</span> ghci-core=<span class=st>"ghci -ddump-simpl -dsuppress-idinfo \</span>
<span class=st>-dsuppress-coercions -dsuppress-type-applications \</span>
<span class=st>-dsuppress-uniques -dsuppress-module-prefixes"</span></code></pre></div>
<p><font>At the interactive prompt we can then explore the core representation interactively:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在交互式提示下，我们可以交互式地探索核心表示：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>ghci-core</span>
λ: <span class=kw>let</span> f x = x + 2 <span class=kw>;</span> <span class=kw>f</span> :: Int -<span class=kw>&gt;</span> Int

==================== <span class=kw>Simplified</span> expression ====================
<span class=kw>returnIO</span>
  <span class=kw>(:</span> ((<span class=dt>\ </span>(x :: Int<span class=kw>)</span> <span class=kw>-&gt;</span> + <span class=ot>$fNumInt</span> x (I# 2)) <span class=kw>`cast`</span> <span class=kw>...</span>) <span class=kw>(</span>[]<span class=kw>)</span>)

λ: <span class=kw>let</span> f x = (x, x)

==================== <span class=kw>Simplified</span> expression ====================
<span class=kw>returnIO</span> (: ((<span class=dt>\ </span>(@ t) <span class=kw>(x</span> :: t<span class=kw>)</span> <span class=kw>-&gt;</span> (x, x)) <span class=kw>`cast`</span> <span class=kw>...</span>) <span class=kw>(</span>[]<span class=kw>)</span>)</code></pre></div>
<p><a href=http://hackage.haskell.org/package/ghc-core>ghc-core</a><font> is also very useful for looking at GHC's compilation artifacts.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghc-core 对于查看 GHC 的编译工件也非常有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>ghc-core</span> --no-cast --no-asm</code></pre></div>
<p><font>Alternatively the major stages of the compiler ( parse tree, core, stg, cmm, asm ) can be manually outputted and inspected by passing several flags to the compiler:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者，可以通过将几个标志传递给编译器来手动输出和检查编译器的主要阶段（解析树、核心、stg、cmm、asm）：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>ghc</span> -ddump-to-file -ddump-parsed -ddump-simpl -ddump-stg -ddump-cmm -ddump-asm</code></pre></div>
<p><strong>Reading Core<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>阅读核心</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>Core from GHC is roughly human readable, but it's helpful to look at simple human written examples to get the hang of what's going on.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 的核心大致是人类可读的，但是查看简单的人类编写的示例以了解正在发生的事情是有帮助的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class=ot> ::</span> a <span class=ot>-&gt;</span> a
id x <span class=fu>=</span> x</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class=ot> ::</span> forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> a
id <span class=fu>=</span> \ (<span class=fu>@</span> a) (<span class=ot>x ::</span> a) <span class=ot>-&gt;</span> x

<span class=ot>idInt ::</span> <span class=dt>GHC.Types.Int</span> <span class=ot>-&gt;</span> <span class=dt>GHC.Types.Int</span>
idInt <span class=fu>=</span> id <span class=fu>@</span> <span class=dt>GHC.Types.Int</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>compose ::</span> (b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> c
compose f g x <span class=fu>=</span> f (g x)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>compose ::</span> forall b c a<span class=fu>.</span> (b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> c
compose <span class=fu>=</span> \ (<span class=fu>@</span> b) (<span class=fu>@</span> c) (<span class=fu>@</span> a) (<span class=ot>f1 ::</span> b <span class=ot>-&gt;</span> c) (<span class=ot>g ::</span> a <span class=ot>-&gt;</span> b) (<span class=ot>x1 ::</span> a) <span class=ot>-&gt;</span> f1 (g x1)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class=ot> ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [b]
map f []     <span class=fu>=</span> []
map f (x<span class=fu>:</span>xs) <span class=fu>=</span> f x <span class=fu>:</span> map f xs</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class=ot> ::</span> forall a b<span class=fu>.</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [b]
map <span class=fu>=</span>
  \ (<span class=fu>@</span> a) (<span class=fu>@</span> b) (<span class=ot>f ::</span> a <span class=ot>-&gt;</span> b) (<span class=ot>xs ::</span> [a]) <span class=ot>-&gt;</span>
    <span class=kw>case</span> xs <span class=kw>of</span> _ {
      []     <span class=ot>-&gt;</span> [] <span class=fu>@</span> b;
      <span class=fu>:</span> y ys <span class=ot>-&gt;</span> <span class=fu>:</span> <span class=fu>@</span> b (f y) (map <span class=fu>@</span> a <span class=fu>@</span> b f ys)
    }</code></pre></div>
<p><font>Machine generated names are created for a lot of transformation of Core. Generally they consist of a prefix and unique identifier. The prefix is often pass specific ( i.e. </font><code>ds</code><font> for desugar generated name s) and sometimes specific names are generated for specific automatically generated code. A list of the common prefixes and their meaning is show below.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>机器生成的名称是为 Core 的大量转换而创建的。通常它们由前缀和唯一标识符组成。前缀通常是传递特定的（即 ds 用于 desugar generated name s），有时特定的名称是为特定的自动生成的代码生成的。常见前缀列表及其含义如下所示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Prefix</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字首</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Description</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>$f...<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$f...</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Dict-fun identifiers (from inst decls)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Dict-fun 标识符（来自 inst decls）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>$dmop<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$dmop</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Default method for 'op'</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>“op”的默认方法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>$wf<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$wf</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Worker for function 'f'</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>函数“f”的工人</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>$sf<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$旧金山</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Specialised version of f</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>f 的特殊版本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>$gdm<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$gdm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Generated class method</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生成类方法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>$d<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$d</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Dictionary names</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>词典名称</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>$s<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$s</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Specialized function name</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>专用函数名称</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>$f<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$f</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Foreign export</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对外出口</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>$pnC<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>$pnC</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>n'th superclass selector for class C</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C类的第n个超类选择器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>T:C<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>时间：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Tycon for dictionary for class C</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C 类字典的 Tycon</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>D:C<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>D:C</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Data constructor for dictionary for class C</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C类字典的数据构造函数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>NTCo:T<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>NTCo:T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Coercion for newtype T to its underlying runtime representation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将新类型 T 强制转换为其底层运行时表示</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Of important note is that the Λ and λ for type-level and value-level lambda abstraction are represented by the same symbol (</font><code>\</code><font>) in core, which is a simplifying detail of the GHC's implementation but a source of some confusion when starting.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>值得注意的是，类型级和值级 lambda 抽象的 Λ 和 λ 在核心中由相同的符号 (\) 表示，这是 GHC 实现的简化细节，但在开始时会引起一些混淆。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- System-F Notation</span>
Λ b c a<span class=fu>.</span> λ (f1 <span class=fu>:</span> b <span class=ot>-&gt;</span> c) (g <span class=fu>:</span> a <span class=ot>-&gt;</span> b) (x1 <span class=fu>:</span> a)<span class=fu>.</span> f1 (g x1)

<span class=co>-- Haskell Core</span>
\ (<span class=fu>@</span> b) (<span class=fu>@</span> c) (<span class=fu>@</span> a) (<span class=ot>f1 ::</span> b <span class=ot>-&gt;</span> c) (<span class=ot>g ::</span> a <span class=ot>-&gt;</span> b) (<span class=ot>x1 ::</span> a) <span class=ot>-&gt;</span> f1 (g x1)</code></pre></div>
<p><font>The </font><code>seq</code><font> function has an intuitive implementation in the Core language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>seq 函数在 Core 语言中有一个直观的实现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class=ot>`seq`</span> y</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>case</span> x <span class=kw>of</span> _ {
  __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span> y
}</code></pre></div>
<p><font>One particularly notable case of the Core desugaring process is that pattern matching on overloaded numbers implicitly translates into equality test (i.e. </font><code>Eq</code><font>).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Core 脱糖过程的一个特别值得注意的案例是，对重载数字的模式匹配隐式地转换为相等性测试（即 Eq）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class=dv>0</span> <span class=fu>=</span> <span class=dv>1</span>
f <span class=dv>1</span> <span class=fu>=</span> <span class=dv>2</span>
f <span class=dv>2</span> <span class=fu>=</span> <span class=dv>3</span>
f <span class=dv>3</span> <span class=fu>=</span> <span class=dv>4</span>
f <span class=dv>4</span> <span class=fu>=</span> <span class=dv>5</span>
f _ <span class=fu>=</span> <span class=dv>0</span>


<span class=ot>f ::</span> forall a b<span class=fu>.</span> (<span class=dt>Eq</span> a, <span class=dt>Num</span> a, <span class=dt>Num</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> b
f <span class=fu>=</span>
  \ (<span class=fu>@</span> a)
    (<span class=fu>@</span> b)
    (<span class=fu>$</span><span class=ot>dEq ::</span> <span class=dt>Eq</span> a)
    (<span class=fu>$</span><span class=ot>dNum ::</span> <span class=dt>Num</span> a)
    (<span class=fu>$</span><span class=ot>dNum1 ::</span> <span class=dt>Num</span> b)
    (<span class=ot>ds ::</span> a) <span class=ot>-&gt;</span>
    <span class=kw>case</span> <span class=fu>==</span> <span class=fu>$</span>dEq ds (fromInteger <span class=fu>$</span>dNum (__integer <span class=dv>0</span>)) <span class=kw>of</span> _ {
      <span class=dt>False</span> <span class=ot>-&gt;</span>
        <span class=kw>case</span> <span class=fu>==</span> <span class=fu>$</span>dEq ds (fromInteger <span class=fu>$</span>dNum (__integer <span class=dv>1</span>)) <span class=kw>of</span> _ {
          <span class=dt>False</span> <span class=ot>-&gt;</span>
            <span class=kw>case</span> <span class=fu>==</span> <span class=fu>$</span>dEq ds (fromInteger <span class=fu>$</span>dNum (__integer <span class=dv>2</span>)) <span class=kw>of</span> _ {
              <span class=dt>False</span> <span class=ot>-&gt;</span>
                <span class=kw>case</span> <span class=fu>==</span> <span class=fu>$</span>dEq ds (fromInteger <span class=fu>$</span>dNum (__integer <span class=dv>3</span>)) <span class=kw>of</span> _ {
                  <span class=dt>False</span> <span class=ot>-&gt;</span>
                    <span class=kw>case</span> <span class=fu>==</span> <span class=fu>$</span>dEq ds (fromInteger <span class=fu>$</span>dNum (__integer <span class=dv>4</span>)) <span class=kw>of</span> _ {
                      <span class=dt>False</span> <span class=ot>-&gt;</span> fromInteger <span class=fu>$</span>dNum1 (__integer <span class=dv>0</span>);
                      <span class=dt>True</span> <span class=ot>-&gt;</span> fromInteger <span class=fu>$</span>dNum1 (__integer <span class=dv>5</span>)
                    };
                  <span class=dt>True</span> <span class=ot>-&gt;</span> fromInteger <span class=fu>$</span>dNum1 (__integer <span class=dv>4</span>)
                };
              <span class=dt>True</span> <span class=ot>-&gt;</span> fromInteger <span class=fu>$</span>dNum1 (__integer <span class=dv>3</span>)
            };
          <span class=dt>True</span> <span class=ot>-&gt;</span> fromInteger <span class=fu>$</span>dNum1 (__integer <span class=dv>2</span>)
        };
      <span class=dt>True</span> <span class=ot>-&gt;</span> fromInteger <span class=fu>$</span>dNum1 (__integer <span class=dv>1</span>)
    }</code></pre></div>
<p><font>Of course, adding a concrete type signature changes the desugar just matching on the unboxed values.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，添加具体类型签名会更改仅匹配未装箱值的脱糖。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
f <span class=fu>=</span>
  \ (<span class=ot>ds ::</span> <span class=dt>Int</span>) <span class=ot>-&gt;</span>
    <span class=kw>case</span> ds <span class=kw>of</span> _ { <span class=dt>I</span><span class=fu>#</span> ds1 <span class=ot>-&gt;</span>
    <span class=kw>case</span> ds1 <span class=kw>of</span> _ {
      __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>0</span>;
      <span class=dv>0</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>1</span>;
      <span class=dv>1</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>2</span>;
      <span class=dv>2</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>3</span>;
      <span class=dv>3</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>4</span>;
      <span class=dv>4</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>5</span>
    }
    }</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf>Core Spec<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>核心规范</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/>Core By Example<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>核心实例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://smunix.github.io/ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType.html>CoreSynType<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>CoreSynType</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=inliner><font>Inliner</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>内胆</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>infixr</span> <span class=dv>0</span>  <span class=fu>$</span>

<span class=ot>($)::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b
f <span class=fu>$</span> x <span class=fu>=</span>  f x</code></pre></div>
<p><font>Having to enter a secondary closure every time we used </font><code>($)</code><font> would introduce an enormous overhead. Fortunately GHC has a pass to eliminate small functions like this by simply replacing the function call with the body of its definition at appropriate call-sites. The compiler contains a variety of heuristics for determining when this kind of substitution is appropriate and the potential costs involved.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>每次我们使用 ($) 时都必须进入二级闭包会带来巨大的开销。幸运的是，GHC 可以通过在适当的调用点简单地用函数定义的主体替换函数调用来消除像这样的小函数。编译器包含多种启发式方法，用于确定何时适合进行此类替换以及涉及的潜在成本。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In addition to the automatic inliner, manual pragmas are provided for more granular control over inlining. It's important to note that naive inlining quite often results in significantly worse performance and longer compilation times.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>除了自动内联之外，还提供了手动编译指示以对内联进行更精细的控制。重要的是要注意，简单的内联通常会导致性能显着下降和编译时间延长。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# INLINE func #-}</span>
<span class=ot>{-# INLINABLE func #-}</span>
<span class=ot>{-# NOINLINE func #-}</span></code></pre></div>
<p><font>For example the contrived case where we apply a binary function to two arguments. The function body is small and instead of entering another closure just to apply the given function, we could in fact just inline the function application at the call site.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，我们将二元函数应用于两个参数的人为情况。函数体很小，而不是进入另一个闭包只是为了应用给定的函数，我们实际上可以在调用点内联函数应用程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# INLINE foo #-}</span>
<span class=ot>{-# NOINLINE bar #-}</span>

<span class=ot>foo ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c
foo f x y <span class=fu>=</span> f x y

<span class=ot>bar ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> c
bar f x y <span class=fu>=</span> f x y

<span class=ot>test1 ::</span> <span class=dt>Int</span>
test1 <span class=fu>=</span> foo (<span class=fu>+</span>) <span class=dv>10</span> <span class=dv>20</span>

<span class=ot>test2 ::</span> <span class=dt>Int</span>
test2 <span class=fu>=</span> bar (<span class=fu>+</span>) <span class=dv>20</span> <span class=dv>30</span></code></pre></div>
<p><font>Looking at the core, we can see that in </font><code>test1</code><font> the function has indeed been expanded at the call site and simply performs the addition there instead of another indirection.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>查看核心，我们可以看到在 test1 中，该函数确实在调用站点进行了扩展，并在那里简单地执行加法，而不是另一个间接寻址。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>test1 ::</span> <span class=dt>Int</span>
test1 <span class=fu>=</span>
  <span class=kw>let</span> {
<span class=ot>    f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
    f <span class=fu>=</span> <span class=fu>+</span> <span class=fu>$</span>fNumInt } <span class=kw>in</span>
  <span class=kw>let</span> {
<span class=ot>    x ::</span> <span class=dt>Int</span>
    x <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>10</span> } <span class=kw>in</span>
  <span class=kw>let</span> {
<span class=ot>    y ::</span> <span class=dt>Int</span>
    y <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> <span class=dv>20</span> } <span class=kw>in</span>
  f x y

<span class=ot>test2 ::</span> <span class=dt>Int</span>
test2 <span class=fu>=</span> bar (<span class=fu>+</span> <span class=fu>$</span>fNumInt) (<span class=dt>I</span><span class=fu>#</span> <span class=dv>20</span>) (<span class=dt>I</span><span class=fu>#</span> <span class=dv>30</span>)</code></pre></div>
<p><font>Cases marked with </font><code>NOINLINE</code><font> generally indicate that the logic in the function is using something like </font><code>unsafePerformIO</code><font> or some other unholy function. In these cases naive inlining might duplicate effects at multiple call-sites throughout the program which would be undesirable.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标有 NOINLINE 的情况通常表明函数中的逻辑正在使用诸如 unsafePerformIO 之类的东西或其他一些邪恶的函数。在这些情况下，简单的内联可能会在整个程序的多个调用点重复效果，这是不受欢迎的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf>Secrets of the Glasgow Haskell Compiler inliner<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Glasgow Haskell 编译器内联器的秘密</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=dictionaries><font>Dictionaries</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>词典</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The Haskell language defines the notion of Typeclasses but is agnostic to how they are implemented in a Haskell compiler. GHC's particular implementation uses a pass called the </font><em>dictionary passing translation</em><font> part of the elaboration phase of the typechecker which translates Core functions with typeclass constraints into implicit parameters of which record-like structures containing the function implementations are passed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 语言定义了类型类的概念，但不知道它们在 Haskell 编译器中是如何实现的。 GHC 的特定实现使用类型检查器精化阶段的称为字典传递翻译部分的传递，它将具有类型类约束的核心函数转换为隐式参数，传递包含函数实现的类似记录的结构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Num</span> a <span class=kw>where</span>
<span class=ot>  (+) ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
<span class=ot>  (*) ::</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
<span class=ot>  negate ::</span> a <span class=ot>-&gt;</span> a</code></pre></div>
<p><font>This class can be thought as the implementation equivalent to the following parameterized record of functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这个类可以被认为是等价于以下函数参数化记录的实现。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>DNum</span> a <span class=fu>=</span> <span class=dt>DNum</span> (a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a) (a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a) (a <span class=ot>-&gt;</span> a)

add (<span class=dt>DNum</span> a m n) <span class=fu>=</span> a
mul (<span class=dt>DNum</span> a m n) <span class=fu>=</span> m
neg (<span class=dt>DNum</span> a m n) <span class=fu>=</span> n

<span class=ot>numDInt ::</span> <span class=dt>DNum</span> <span class=dt>Int</span>
numDInt <span class=fu>=</span> <span class=dt>DNum</span> plusInt timesInt negateInt

<span class=ot>numDFloat ::</span> <span class=dt>DNum</span> <span class=dt>Float</span>
numDFloat <span class=fu>=</span> <span class=dt>DNum</span> plusFloat timesFloat negateFloat</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>+</span><span class=ot> ::</span> forall a<span class=fu>.</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
<span class=fu>+</span> <span class=fu>=</span> \ (<span class=fu>@</span> a) (<span class=ot>tpl ::</span> <span class=dt>Num</span> a) <span class=ot>-&gt;</span>
  <span class=kw>case</span> tpl <span class=kw>of</span> _ { <span class=dt>D</span><span class=fu>:</span><span class=dt>Num</span> tpl _ _ <span class=ot>-&gt;</span> tpl }

<span class=fu>*</span><span class=ot> ::</span> forall a<span class=fu>.</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
<span class=fu>*</span> <span class=fu>=</span> \ (<span class=fu>@</span> a) (<span class=ot>tpl ::</span> <span class=dt>Num</span> a) <span class=ot>-&gt;</span>
  <span class=kw>case</span> tpl <span class=kw>of</span> _ { <span class=dt>D</span><span class=fu>:</span><span class=dt>Num</span> _ tpl _ <span class=ot>-&gt;</span> tpl }

negate<span class=ot> ::</span> forall a<span class=fu>.</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a
negate <span class=fu>=</span> \ (<span class=fu>@</span> a) (<span class=ot>tpl ::</span> <span class=dt>Num</span> a) <span class=ot>-&gt;</span>
  <span class=kw>case</span> tpl <span class=kw>of</span> _ { <span class=dt>D</span><span class=fu>:</span><span class=dt>Num</span> _ _ tpl <span class=ot>-&gt;</span> tpl }</code></pre></div>
<p><code>Num</code><font> and </font><code>Ord</code><font> have simple translation but for monads with existential type variables in their signatures, the only way to represent the equivalent dictionary is using </font><code>RankNTypes</code><font>. In addition a typeclass may also include superclasses which would be included in the typeclass dictionary and parameterized over the same arguments and an implicit superclass constructor function is created to pull out functions from the superclass for the current monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Num 和 Ord 具有简单的翻译，但对于在其签名中具有存在类型变量的 monad，表示等效字典的唯一方法是使用 RankNTypes。此外，类型类还可能包含超类，这些超类将包含在类型类字典中并通过相同的参数进行参数化，并且创建隐式超类构造函数以从超类中提取当前 monad 的函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>DMonad</span> m <span class=fu>=</span> <span class=dt>DMonad</span>
  {<span class=ot> bind   ::</span> forall a b<span class=fu>.</span> m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m b
  ,<span class=ot> return ::</span> forall a<span class=fu>.</span> a <span class=ot>-&gt;</span> m a
  }</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> (<span class=dt>Functor</span> t, <span class=dt>Foldable</span> t) <span class=ot>=&gt;</span> <span class=dt>Traversable</span> t <span class=kw>where</span>
<span class=ot>    traverse ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> f b) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> f (t b)
    traverse f <span class=fu>=</span> sequenceA <span class=fu>.</span> fmap f</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>DTraversable</span> t <span class=fu>=</span> <span class=dt>DTraversable</span>
  {<span class=ot> dFunctorTraversable ::</span> <span class=dt>DFunctor</span> t  <span class=co>-- superclass dictionary</span>
  ,<span class=ot> dFoldableTraversable ::</span> <span class=dt>DFoldable</span> t <span class=co>-- superclass dictionary</span>
  ,<span class=ot> traverse ::</span> forall a<span class=fu>.</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> f b) <span class=ot>-&gt;</span> t a <span class=ot>-&gt;</span> f (t b)
  }</code></pre></div>
<p><font>Indeed this is not that far from how GHC actually implements typeclasses. It elaborates into projection functions and data constructors nearly identical to this, and are expanded out to a dictionary argument for each typeclass constraint of every polymorphic function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>事实上，这与 GHC 实际实现类型类的方式相差无几。它详细阐述了与此几乎相同的投影函数和数据构造函数，并扩展为每个多态函数的每个类型类约束的字典参数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=specialization><font>Specialization</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>专业化</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Overloading in Haskell is normally not entirely free by default, although with an optimization called specialization it can be made to have zero cost at specific points in the code where performance is crucial. This is not enabled by default by virtue of the fact that GHC is not a whole-program optimizing compiler and most optimizations ( not all ) stop at module boundaries.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认情况下，Haskell 中的重载通常不是完全免费的，尽管通过称为专业化的优化可以使代码中性能至关重要的特定点的成本为零。由于 GHC 不是一个全程序优化编译器，并且大多数优化（不是全部）在模块边界处停止，因此默认情况下不启用此功能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>GHC's method of implementing typeclasses means that explicit dictionaries are threaded around implicitly throughout the call sites. This is normally the most natural way to implement this functionality since it preserves separate compilation. A function can be compiled independently of where it is declared, not recompiled at every point in the program where it's called. The dictionary passing allows the caller to thread the implementation logic for the types to the call-site where it can then be used throughout the body of the function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 实现类型类的方法意味着显式字典在整个调用站点中隐式地穿插。这通常是实现此功能的最自然方式，因为它保留了单独的编译。函数可以独立于它声明的位置进行编译，而不是在程序中调用它的每个点都重新编译。字典传递允许调用者将类型的实现逻辑线程化到调用点，然后可以在整个函数体中使用它。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Of course this means that in order to get at a specific typeclass function we need to project ( possibly multiple times ) into the dictionary structure to pluck out the function reference. The runtime makes this very cheap but not entirely free.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，这意味着为了获得特定的类型类函数，我们需要（可能多次）投影到字典结构中以提取函数引用。运行时使它非常便宜但并非完全免费。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Many C++ compilers or whole program optimizing compilers do the opposite however, they explicitly specialize each and every function at the call site replacing the overloaded function with its type-specific implementation. We can selectively enable this kind of behavior using class specialization.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>许多 C++ 编译器或整个程序优化编译器做相反的事情，但是，它们明确地专门化调用站点的每个函数，用其特定于类型的实现替换重载函数。我们可以使用类特化有选择地启用这种行为。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/29-ghc/specialize.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Specialize</span> (spec, nonspec, f) <span class=kw>where</span>

<span class=ot>{-# SPECIALIZE INLINE f :: Double -&gt; Double -&gt; Double #-}</span>

<span class=ot>f ::</span> <span class=dt>Floating</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
f x y <span class=fu>=</span> exp (x <span class=fu>+</span> y) <span class=fu>*</span> exp (x <span class=fu>+</span> y)

<span class=ot>nonspec ::</span> <span class=dt>Float</span>
nonspec <span class=fu>=</span> f (<span class=dv>10</span><span class=ot> ::</span> <span class=dt>Float</span>) (<span class=dv>20</span><span class=ot> ::</span> <span class=dt>Float</span>)

<span class=ot>spec ::</span> <span class=dt>Double</span>
spec <span class=fu>=</span> f (<span class=dv>10</span><span class=ot> ::</span> <span class=dt>Double</span>) (<span class=dv>20</span><span class=ot> ::</span> <span class=dt>Double</span>)</code></pre></div>
<p><strong>Non-specialized<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>非专业</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> forall a<span class=fu>.</span> <span class=dt>Floating</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a
f <span class=fu>=</span>
  \ (<span class=fu>@</span> a) (<span class=fu>$</span><span class=ot>dFloating ::</span> <span class=dt>Floating</span> a) (<span class=ot>eta ::</span> a) (<span class=ot>eta1 ::</span> a) <span class=ot>-&gt;</span>
    <span class=kw>let</span> {
<span class=ot>      a ::</span> <span class=dt>Fractional</span> a
      a <span class=fu>=</span> <span class=fu>$</span>p1Floating <span class=fu>@</span> a <span class=fu>$</span>dFloating } <span class=kw>in</span>
    <span class=kw>let</span> {
      <span class=fu>$</span><span class=ot>dNum ::</span> <span class=dt>Num</span> a
      <span class=fu>$</span>dNum <span class=fu>=</span> <span class=fu>$</span>p1Fractional <span class=fu>@</span> a a } <span class=kw>in</span>
    <span class=fu>*</span> <span class=fu>@</span> a
      <span class=fu>$</span>dNum
      (exp <span class=fu>@</span> a <span class=fu>$</span>dFloating (<span class=fu>+</span> <span class=fu>@</span> a <span class=fu>$</span>dNum eta eta1))
      (exp <span class=fu>@</span> a <span class=fu>$</span>dFloating (<span class=fu>+</span> <span class=fu>@</span> a <span class=fu>$</span>dNum eta eta1))</code></pre></div>
<p><font>In the specialized version the typeclass operations placed directly at the call site and are simply unboxed arithmetic. This will map to a tight set of sequential CPU instructions and is very likely the same code generated by C.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在专用版本中，类型类操作直接放置在调用点并且只是未装箱的算术。这将映射到一组紧密的顺序 CPU 指令，并且很可能与 C 生成的代码相同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>spec ::</span> <span class=dt>Double</span>
spec <span class=fu>=</span> <span class=dt>D</span><span class=fu>#</span> (<span class=fu>*##</span> (expDouble<span class=fu>#</span> <span class=fl>30.0</span>) (expDouble<span class=fu>#</span> <span class=fl>30.0</span>))</code></pre></div>
<p><font>The non-specialized version has to project into the typeclass dictionary (</font><code>$fFloatingFloat</code><font>) 6 times and likely go through around 25 branches to perform the same operation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>非专用版本必须投射到类型类字典（$fFloatingFloat）中 6 次，并且可能经过大约 25 个分支来执行相同的操作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>nonspec ::</span> <span class=dt>Float</span>
nonspec <span class=fu>=</span>
  f <span class=fu>@</span> <span class=dt>Float</span> <span class=fu>$</span>fFloatingFloat (<span class=dt>F</span><span class=fu>#</span> (__float <span class=fl>10.0</span>)) (<span class=dt>F</span><span class=fu>#</span> (__float <span class=fl>20.0</span>))</code></pre></div>
<p><font>For a tight loop over numeric types specializing at the call site can result in orders of magnitude performance increase. Although the cost in compile-time can often be non-trivial and when used function used at many call-sites this can slow GHC's simplifier pass to a crawl.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于专注于调用站点的数字类型的紧密循环，可以使性能提高几个数量级。虽然编译时的成本通常是不小的，并且当在许多调用站点使用函数时，这可能会减慢 GHC 的简化器传递速度。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The best advice is profile and look for large uses of dictionary projection in tight loops and then specialize and inline in these places.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最好的建议是分析并寻找在紧密循环中大量使用字典投影的方法，然后在这些地方进行专门化和内联。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Using the </font><code>SPECIALISE INLINE</code><font> pragma can unintentionally cause GHC to diverge if applied over a recursive function, it will try to specialize itself infinitely.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果应用于递归函数，使用 SPECIALIZE INLINE pragma 可能会无意中导致 GHC 发散，它将尝试无限地特化自身。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=static-compilation><font>Static Compilation</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>静态编译</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>On Linux, Haskell programs can be compiled into a standalone statically linked binary that includes the runtime statically linked into it.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在 Linux 上，Haskell 程序可以编译成独立的静态链接二进制文件，其中包括静态链接到其中的运行时。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>ghc</span> -O2 --make -static -optc-static -optl-static -optl-pthread Example.hs
$ <span class=kw>file</span> Example
<span class=kw>Example</span>: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), <span class=kw>statically</span> linked, for GNU/Linux 2.6.32, not stripped
$ <span class=kw>ldd</span> Example
        <span class=kw>not</span> a dynamic executable</code></pre></div>
<p><font>In addition the file size of the resulting binary can be reduced by stripping unneeded symbols.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此外，可以通过剥离不需要的符号来减小生成的二进制文件的大小。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>strip</span> Example</code></pre></div>
<p><a href=http://upx.sourceforge.net/>upx</a><font> can additionally be used to compress the size of the executable down further.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>upx 还可用于进一步压缩可执行文件的大小。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=unboxed-types><font>Unboxed Types</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未装箱类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The usual numerics types in Haskell can be considered to be a regular algebraic datatype with special constructor arguments for their underlying unboxed values. Normally unboxed types and explicit unboxing are not used in normal code, they are wired-in to the compiler.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中常用的数值类型可以被认为是一种常规的代数数据类型，具有特殊的构造函数参数用于其底层未装箱的值。通常未装箱类型和显式拆箱不会在普通代码中使用，它们被连接到编译器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Int</span> <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> <span class=dt>Int</span><span class=fu>#</span>

<span class=kw>data</span> <span class=dt>Integer</span>
  <span class=fu>=</span> <span class=dt>S</span><span class=fu>#</span> <span class=dt>Int</span><span class=fu>#</span>              <span class=co>-- Small integers</span>
  <span class=fu>|</span> <span class=dt>J</span><span class=fu>#</span> <span class=dt>Int</span><span class=fu>#</span> <span class=dt>ByteArray</span><span class=fu>#</span>   <span class=co>-- Large GMP integers</span>

<span class=kw>data</span> <span class=dt>Float</span> <span class=fu>=</span> <span class=dt>F</span><span class=fu>#</span> <span class=dt>Float</span><span class=fu>#</span></code></pre></div>
<table>
<thead>
<tr class=header>
<th align=left><font>Syntax</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>句法</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Primitive Type</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>原始类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>3#</code></td>
<td align=left><font>GHC.Prim.Int#</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Prim.Int#</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>3##</code></td>
<td align=left><font>GHC.Prim.Word#</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Prim.Word#</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>3.14#</code></td>
<td align=left><font>GHC.Prim.Float#</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Prim.Float#</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>3.14##</code></td>
<td align=left><font>GHC.Prim.Double#</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Prim.Double#</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>'c'#<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>'C'＃</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>GHC.Prim.Char#</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Prim.Char#</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>"Haskell"##<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>“哈斯克尔”##</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>GHC.Prim.Addr#</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC.Prim.地址#</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>An unboxed type with kind </font><code>#</code><font> and will never unify a type variable of kind </font><code>*</code><font>. Intuitively a type with kind </font><code>*</code><font> indicates a type with a uniform runtime representation that can be used polymorphically.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>具有种类 # 的未装箱类型，永远不会统一种类 * 的类型变量。直观上，带有 kind * 的类型表示具有统一运行时表示的类型，可以以多态方式使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><em>Lifted</em><font> - Can contain a bottom term, represented by a pointer. ( </font><code>Int</code><font>, </font><code>Any</code><font>, </font><code>(,)</code><font> )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Lifted - 可以包含一个底部术语，由指针表示。 （整数，任何，（，））</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><em>Unlited</em><font> - Cannot contain a bottom term, represented by a value on the stack. ( </font><code>Int#</code><font>, </font><code>(#, #)</code><font> )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Unlited - 不能包含底部术语，由堆栈上的值表示。 ( Int#, (#, #) )</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<div class=sourceCode include=src/29-ghc/prim.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE BangPatterns, MagicHash, UnboxedTuples #-}</span>

<span class=kw>import </span><span class=dt>GHC.Exts</span>
<span class=kw>import </span><span class=dt>GHC.Prim</span>

<span class=ot>ex1 ::</span> <span class=dt>Bool</span>
ex1 <span class=fu>=</span> gtChar<span class=fu>#</span> a<span class=fu>#</span> b<span class=fu>#</span>
  <span class=kw>where</span>
    <span class=fu>!</span>(<span class=dt>C</span><span class=fu>#</span> a<span class=fu>#</span>) <span class=fu>=</span> <span class=ch>'a'</span>
    <span class=fu>!</span>(<span class=dt>C</span><span class=fu>#</span> b<span class=fu>#</span>) <span class=fu>=</span> <span class=ch>'b'</span>

<span class=ot>ex2 ::</span> <span class=dt>Int</span>
ex2 <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> (a<span class=fu>#</span> <span class=fu>+#</span> b<span class=fu>#</span>)
  <span class=kw>where</span>
    <span class=fu>!</span>(<span class=dt>I</span><span class=fu>#</span> a<span class=fu>#</span>) <span class=fu>=</span> <span class=dv>1</span>
    <span class=fu>!</span>(<span class=dt>I</span><span class=fu>#</span> b<span class=fu>#</span>) <span class=fu>=</span> <span class=dv>2</span>

<span class=ot>ex3 ::</span> <span class=dt>Int</span>
ex3 <span class=fu>=</span> (<span class=dt>I</span><span class=fu>#</span> (<span class=dv>1</span><span class=fu>#</span> <span class=fu>+#</span> <span class=dv>2</span><span class=fu>#</span> <span class=fu>*#</span> <span class=dv>3</span><span class=fu>#</span> <span class=fu>+#</span> <span class=dv>4</span><span class=fu>#</span>))

<span class=ot>ex4 ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
ex4 <span class=fu>=</span> (<span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>False</span>), <span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>True</span>))</code></pre></div>
<p><font>The function for integer arithmetic used in the </font><code>Num</code><font> typeclass for </font><code>Int</code><font> is just pattern matching on this type to reveal the underlying unboxed value, performing the builtin arithmetic and then performing the packing up into </font><code>Int</code><font> again.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Int 的 Num 类型类中使用的整数算术函数只是对该类型进行模式匹配以揭示底层未装箱的值，执行内置算术，然后再次执行打包到 Int 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>plusInt ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
(<span class=dt>I</span><span class=fu>#</span> x) <span class=ot>`plusInt`</span> (<span class=dt>I</span><span class=fu>#</span> y) <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> (x <span class=fu>+#</span> y)</code></pre></div>
<p><font>Where </font><code>(+#)</code><font> is a low level function built into GHC that maps to intrinsic integer addition instruction for the CPU.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>其中 (+#) 是 GHC 中内置的低级函数，它映射到 CPU 的固有整数加法指令。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>plusInt ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
plusInt a b <span class=fu>=</span> <span class=kw>case</span> a <span class=kw>of</span> {
    (<span class=dt>I</span><span class=fu>#</span> a_) <span class=ot>-&gt;</span> <span class=kw>case</span> b <span class=kw>of</span> {
      (<span class=dt>I</span><span class=fu>#</span> b_) <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> (<span class=fu>+#</span> a_ b_);
    };
};</code></pre></div>
<p><font>Runtime values in Haskell are by default represented uniformly by a boxed </font><code>StgClosure*</code><font> struct which itself contains several payload values, which can themselves either be pointers to other boxed values or to unboxed literal values that fit within the system word size and are stored directly within the closure in memory. The layout of the box is described by a bitmap in the header for the closure which describes which values in the payload are either pointers or non-pointers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 中的运行时值默认由一个装箱的 StgClosure* 结构统一表示，该结构本身包含多个有效负载值，这些值本身可以是指向其他装箱值的指针，也可以是适合系统字大小的未装箱文字值的指针，并直接存储在在内存中关闭。框的布局由闭包标头中的位图描述，闭包描述有效负载中的哪些值是指针或非指针。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><code>unpackClosure#</code><font> primop can be used to extract this information at runtime by reading off the bitmap on the closure.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>unpackClosure# primop 可用于在运行时通过读取闭包上的位图来提取此信息。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/29-ghc/closure_size.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MagicHash, UnboxedTuples #-}</span>
<span class=ot>{-# OPTIONS_GHC -O1 #-}</span>

<span class=kw>module</span> <span class=dt>Main</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>GHC.Exts</span>
<span class=kw>import </span><span class=dt>GHC.Base</span>
<span class=kw>import </span><span class=dt>Foreign</span>

<span class=kw>data</span> <span class=dt>Size</span> <span class=fu>=</span> <span class=dt>Size</span>
  {<span class=ot> ptrs  ::</span> <span class=dt>Int</span>
  ,<span class=ot> nptrs ::</span> <span class=dt>Int</span>
  ,<span class=ot> size  ::</span> <span class=dt>Int</span>
  } <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=ot>unsafeSizeof ::</span> a <span class=ot>-&gt;</span> <span class=dt>Size</span>
unsafeSizeof a <span class=fu>=</span>
  <span class=kw>case</span> unpackClosure<span class=fu>#</span> a <span class=kw>of</span>
    (<span class=fu>#</span> x, ptrs, nptrs <span class=fu>#</span>) <span class=ot>-&gt;</span>
      <span class=kw>let</span> header  <span class=fu>=</span> sizeOf (undefined<span class=ot> ::</span> <span class=dt>Int</span>)
          ptr_c   <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> (sizeofArray<span class=fu>#</span> ptrs)
          nptr_c  <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> (sizeofByteArray<span class=fu>#</span> nptrs) <span class=ot>`div`</span> sizeOf (undefined<span class=ot> ::</span> <span class=dt>Word</span>)
          payload <span class=fu>=</span> <span class=dt>I</span><span class=fu>#</span> (sizeofArray<span class=fu>#</span> ptrs <span class=fu>+#</span> sizeofByteArray<span class=fu>#</span> nptrs)
          size    <span class=fu>=</span> header <span class=fu>+</span> payload
      <span class=kw>in</span> <span class=dt>Size</span> ptr_c nptr_c size

<span class=kw>data</span> <span class=dt>A</span> <span class=fu>=</span> <span class=dt>A</span> <span class=ot>{-# UNPACK #-}</span> <span class=fu>!</span><span class=dt>Int</span>
<span class=kw>data</span> <span class=dt>B</span> <span class=fu>=</span> <span class=dt>B</span> <span class=dt>Int</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print (unsafeSizeof (<span class=dt>A</span> <span class=dv>42</span>))
  print (unsafeSizeof (<span class=dt>B</span> <span class=dv>42</span>))</code></pre></div>
<p><font>For example the datatype with the </font><code>UNPACK</code><font> pragma contains 1 non-pointer and 0 pointers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，带有 UNPACK pragma 的数据类型包含 1 个非指针和 0 个指针。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>A</span> <span class=fu>=</span> <span class=dt>A</span> <span class=ot>{-# UNPACK #-}</span> <span class=fu>!</span><span class=dt>Int</span>
<span class=dt>Size</span> {ptrs <span class=fu>=</span> <span class=dv>0</span>, nptrs <span class=fu>=</span> <span class=dv>1</span>, size <span class=fu>=</span> <span class=dv>16</span>}</code></pre></div>
<p><font>While the default packed datatype contains 1 pointer and 0 non-pointers.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认打包数据类型包含 1 个指针和 0 个非指针。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>B</span> <span class=fu>=</span> <span class=dt>B</span> <span class=dt>Int</span>
<span class=dt>Size</span> {ptrs <span class=fu>=</span> <span class=dv>1</span>, nptrs <span class=fu>=</span> <span class=dv>0</span>, size <span class=fu>=</span> <span class=dv>9</span>}</code></pre></div>
<p><font>The closure representation for data constructors are also "tagged" at the runtime with the tag of the specific constructor. This is however not a runtime type tag since there is no way to recover the type from the tag as all constructor simply use the sequence (0, 1, 2, ...). The tag is used to discriminate cases in pattern matching. The builtin </font><code>dataToTag#</code><font> can be used to pluck off the tag for an arbitrary datatype. This is used in some cases when desugaring pattern matches.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>数据构造函数的闭包表示也在运行时使用特定构造函数的标签“标记”。然而，这不是运行时类型标记，因为无法从标记中恢复类型，因为所有构造函数仅使用序列 (0, 1, 2, ...)。标签用于区分模式匹配中的大小写。内置的 dataToTag# 可用于去除任意数据类型的标签。这在某些情况下用于模式匹配的脱糖。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">dataToTag<span class=fu>#</span><span class=ot> ::</span> a <span class=ot>-&gt;</span> <span class=dt>Int</span><span class=fu>#</span></code></pre></div>
<p><font>For example:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- data Bool = False | True</span>
<span class=co>-- False ~ 0</span>
<span class=co>-- True  ~ 1</span>

<span class=ot>a ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
a <span class=fu>=</span> (<span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>False</span>), <span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>True</span>))
<span class=co>-- (0, 1)</span>

<span class=co>-- data Ordering = LT | EQ | GT</span>
<span class=co>-- LT ~ 0</span>
<span class=co>-- EQ ~ 1</span>
<span class=co>-- GT ~ 2</span>

<span class=ot>b ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>, <span class=dt>Int</span>)
b <span class=fu>=</span> (<span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>LT</span>), <span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>EQ</span>), <span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> <span class=dt>GT</span>))
<span class=co>-- (0, 1, 2)</span>

<span class=co>-- data Either a b = Left a | Right b</span>
<span class=co>-- Left ~ 0</span>
<span class=co>-- Right ~ 1</span>

<span class=ot>c ::</span> (<span class=dt>Int</span>, <span class=dt>Int</span>)
c <span class=fu>=</span> (<span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> (<span class=dt>Left</span> <span class=dv>0</span>)), <span class=dt>I</span><span class=fu>#</span> (dataToTag<span class=fu>#</span> (<span class=dt>Right</span> <span class=dv>1</span>)))
<span class=co>-- (0, 1)</span></code></pre></div>
<p><font>String literals included in the source code are also translated into several primop operations. The </font><code>Addr#</code><font> type in Haskell stands for a static contagious buffer pre-allocated on the Haskell heap that can hold a </font><code>char*</code><font> sequence. The operation </font><code>unpackCString#</code><font> can scan this buffer and fold it up into a list of Chars from inside Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>源代码中包含的字符串文字也被翻译成几个 primop 操作。 Haskell 中的 Addr# 类型代表一个预先分配在 Haskell 堆上的静态传染缓冲区，它可以容纳一个 char* 序列。操作 unpackCString# 可以扫描这个缓冲区并将它折叠成来自 Haskell 内部的 Chars 列表。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">unpackCString<span class=fu>#</span><span class=ot> ::</span> <span class=dt>Addr</span><span class=fu>#</span> <span class=ot>-&gt;</span> [<span class=dt>Char</span>]</code></pre></div>
<p><font>This is done in the early frontend desugarer phase, where literals are translated into </font><code>Addr#</code><font> inline instead of giant chain of Cons'd characters. So our "Hello World" translates into the following Core:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是在早期的前端脱糖器阶段完成的，其中文字被翻译成 Addr# inline 而不是巨大的 Cons'd 字符链。所以我们的“Hello World”转化为以下核心：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- print "Hello World"</span>
print (unpackCString<span class=fu>#</span> <span class=st>"Hello World"</span><span class=fu>#</span>)</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://www.haskell.org/ghc/docs/papers/unboxed-values.ps.gz>Unboxed Values as First-Class Citizens<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>作为一等公民的拆箱价值观</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=iost><font>IO/ST</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>输入/输出</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Both the IO and the ST monad have special state in the GHC runtime and share a very similar implementation. Both </font><code>ST a</code><font> and </font><code>IO a</code><font> are passing around an unboxed tuple of the form:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>IO 和 ST monad 在 GHC 运行时都有特殊的状态，并且共享非常相似的实现。 ST a 和 IO a 都在传递以下形式的未装箱元组：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class=fu>#</span> token, a <span class=fu>#</span>)</code></pre></div>
<p><font>The </font><code>RealWorld#</code><font> token is "deeply magical" and doesn't actually expand into any code when compiled, but simply threaded around through every bind of the IO or ST monad and has several properties of being unique and not being able to be duplicated to ensure sequential IO actions are actually sequential. </font><code>unsafePerformIO</code><font> can thought of as the unique operation which discards the world token and plucks the </font><code>a</code><font> out, and is as the name implies not normally safe.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>RealWorld# 令牌是“非常神奇的”，在编译时实际上并没有扩展成任何代码，而是简单地绕过 IO 或 ST monad 的每个绑定，并且具有几个独特的属性，并且不能被复制以确保顺序 IO 操作实际上是顺序的。 unsafePerformIO 可以认为是丢弃世界令牌并拔出a的唯一操作，顾名思义通常不安全。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><code>PrimMonad</code><font> abstracts over both these monads with an associated data family for the world token or ST thread, and can be used to write operations that generic over both ST and IO. This is used extensively inside of the vector package to allow vector algorithms to be written generically either inside of IO or ST.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>PrimMonad 对这两个 monad 进行了抽象，并为世界令牌或 ST 线程关联了一个数据系列，并且可用于编写对 ST 和 IO 通用的操作。这在 vector 包中广泛使用，以允许在 IO 或 ST 中通用地编写矢量算法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/29-ghc/io_impl.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MagicHash #-}</span>
<span class=ot>{-# LANGUAGE UnboxedTuples #-}</span>

<span class=kw>import </span><span class=dt>GHC.IO</span> ( <span class=dt>IO</span>(..) )
<span class=kw>import </span><span class=dt>GHC.Prim</span> ( <span class=dt>State</span>#, <span class=dt>RealWorld</span> )
<span class=kw>import </span><span class=dt>GHC.Base</span> ( realWorld# )

<span class=kw>instance</span>  <span class=dt>Monad</span> <span class=dt>IO</span>  <span class=kw>where</span>
    m <span class=fu>&gt;&gt;</span> k    <span class=fu>=</span> m <span class=fu>&gt;&gt;=</span> \ _ <span class=ot>-&gt;</span> k
    return    <span class=fu>=</span> returnIO
    (<span class=fu>&gt;&gt;=</span>)     <span class=fu>=</span> bindIO
    fail s    <span class=fu>=</span> failIO s

<span class=ot>returnIO ::</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a
returnIO x <span class=fu>=</span> <span class=dt>IO</span> <span class=fu>$</span> \ s <span class=ot>-&gt;</span> (<span class=fu>#</span> s, x <span class=fu>#</span>)

<span class=ot>bindIO ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>IO</span> b) <span class=ot>-&gt;</span> <span class=dt>IO</span> b
bindIO (<span class=dt>IO</span> m) k <span class=fu>=</span> <span class=dt>IO</span> <span class=fu>$</span> \ s <span class=ot>-&gt;</span> <span class=kw>case</span> m s <span class=kw>of</span> (<span class=fu>#</span> new_s, a <span class=fu>#</span>) <span class=ot>-&gt;</span> unIO (k a) new_s

<span class=ot>thenIO ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> b <span class=ot>-&gt;</span> <span class=dt>IO</span> b
thenIO (<span class=dt>IO</span> m) k <span class=fu>=</span> <span class=dt>IO</span> <span class=fu>$</span> \ s <span class=ot>-&gt;</span> <span class=kw>case</span> m s <span class=kw>of</span> (<span class=fu>#</span> new_s, _ <span class=fu>#</span>) <span class=ot>-&gt;</span> unIO k new_s

<span class=ot>unIO ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> (<span class=dt>State</span><span class=fu>#</span> <span class=dt>RealWorld</span> <span class=ot>-&gt;</span> (<span class=fu>#</span> <span class=dt>State</span><span class=fu>#</span> <span class=dt>RealWorld</span>, a <span class=fu>#</span>))
unIO (<span class=dt>IO</span> a) <span class=fu>=</span> a</code></pre></div>
<div class=sourceCode include=src/29-ghc/monad_prim.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MagicHash #-}</span>
<span class=ot>{-# LANGUAGE UnboxedTuples #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>

<span class=kw>import </span><span class=dt>GHC.IO</span> ( <span class=dt>IO</span>(..) )
<span class=kw>import </span><span class=dt>GHC.ST</span> ( <span class=dt>ST</span>(..) )
<span class=kw>import </span><span class=dt>GHC.Prim</span> ( <span class=dt>State</span>#, <span class=dt>RealWorld</span> )
<span class=kw>import </span><span class=dt>GHC.Base</span> ( realWorld# )

<span class=kw>class</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>PrimMonad</span> m <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>PrimState</span> m
<span class=ot>  primitive ::</span> (<span class=dt>State</span><span class=fu>#</span> (<span class=dt>PrimState</span> m) <span class=ot>-&gt;</span> (<span class=fu>#</span> <span class=dt>State</span><span class=fu>#</span> (<span class=dt>PrimState</span> m), a <span class=fu>#</span>)) <span class=ot>-&gt;</span> m a
<span class=ot>  internal ::</span> m a <span class=ot>-&gt;</span> <span class=dt>State</span><span class=fu>#</span> (<span class=dt>PrimState</span> m) <span class=ot>-&gt;</span> (<span class=fu>#</span> <span class=dt>State</span><span class=fu>#</span> (<span class=dt>PrimState</span> m), a <span class=fu>#</span>)

<span class=kw>instance</span> <span class=dt>PrimMonad</span> <span class=dt>IO</span> <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>PrimState</span> <span class=dt>IO</span> <span class=fu>=</span> <span class=dt>RealWorld</span>
  <span class=kw>primitive</span> <span class=fu>=</span> <span class=dt>IO</span>
  internal (<span class=dt>IO</span> p) <span class=fu>=</span> p

<span class=kw>instance</span> <span class=dt>PrimMonad</span> (<span class=dt>ST</span> s) <span class=kw>where</span>
  <span class=kw>type</span> <span class=dt>PrimState</span> (<span class=dt>ST</span> s) <span class=fu>=</span> s
  <span class=kw>primitive</span> <span class=fu>=</span> <span class=dt>ST</span>
  internal (<span class=dt>ST</span> p) <span class=fu>=</span> p</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://www.fpcomplete.com/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens>Evaluation order and state tokens<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>评估顺序和状态令牌</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=ghc-heap-view><font>ghc-heap-view</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>ghc 堆视图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Through some dark runtime magic we can actually inspect the </font><code>StgClosure</code><font> structures at runtime using various C and Cmm hacks to probe at the fields of the structure's representation to the runtime. The library </font><code>ghc-heap-view</code><font> can be used to introspect such things, although there is really no use for this kind of thing in everyday code it is very helpful when studying the GHC internals to be able to inspect the runtime implementation details and get at the raw bits underlying all Haskell types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通过一些黑暗的运行时魔法，我们实际上可以在运行时检查 StgClosure 结构，使用各种 C 和 Cmm hack 来探测结构对运行时的表示的字段。库 ghc-heap-view 可以用来反省这些东西，虽然在日常代码中确实没有用到这种东西，但在研究 GHC 内部结构时非常有帮助，能够检查运行时实现细节并获得所有 Haskell 类型的原始位。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/29-ghc/heapview.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MagicHash #-}</span>

<span class=kw>import </span><span class=dt>GHC.Exts</span>
<span class=kw>import </span><span class=dt>GHC.HeapView</span>

<span class=kw>import </span><span class=dt>System.Mem</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=co>-- Constr</span>
  clo <span class=ot>&lt;-</span> getClosureData <span class=fu>$!</span> ([<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]<span class=ot> ::</span> [<span class=dt>Int</span>])
  print clo

  <span class=co>-- Thunk</span>
  <span class=kw>let</span> thunk <span class=fu>=</span> id (<span class=dv>1</span><span class=fu>+</span><span class=dv>1</span>)
  clo <span class=ot>&lt;-</span> getClosureData thunk
  print clo

  <span class=co>-- evaluate to WHNF</span>
  thunk <span class=ot>`seq`</span> return ()

  <span class=co>-- Indirection</span>
  clo <span class=ot>&lt;-</span> getClosureData thunk
  print clo

  <span class=co>-- force garbage collection</span>
  performGC

  <span class=co>-- Value</span>
  clo <span class=ot>&lt;-</span> getClosureData thunk
  print clo</code></pre></div>
<p><font>A constructor (in this for cons constructor of list type) is represented by a </font><code>CONSTR</code><font> closure that holds two pointers to the head and the tail. The integer in the head argument is a static reference to the pre-allocated number and we see a single static reference in the SRT (static reference table).</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个构造函数（在这个列表类型的 cons 构造函数中）由一个 CONSTR 闭包表示，它包含两个指向头部和尾部的指针。 head 参数中的整数是对预分配数字的静态引用，我们在 SRT（静态引用表）中看到一个静态引用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>ConsClosure</span> {
  info <span class=fu>=</span> <span class=dt>StgInfoTable</span> {
    ptrs <span class=fu>=</span> <span class=dv>2</span>,
    nptrs <span class=fu>=</span> <span class=dv>0</span>,
    tipe <span class=fu>=</span> <span class=dt>CONSTR_2_0</span>,
    srtlen <span class=fu>=</span> <span class=dv>1</span>
  },
  ptrArgs <span class=fu>=</span> [<span class=bn>0x000000000074aba8</span><span class=fu>/</span><span class=dv>1</span>,<span class=bn>0x00007fca10504260</span><span class=fu>/</span><span class=dv>2</span>],
  dataArgs <span class=fu>=</span> [],
  pkg <span class=fu>=</span> <span class=st>"ghc-prim"</span>,
  modl <span class=fu>=</span> <span class=st>"GHC.Types"</span>,
  name <span class=fu>=</span> <span class=st>":"</span>
}</code></pre></div>
<p><font>We can also observe the evaluation and update of a thunk in process ( </font><code>id (1+1)</code><font> ). The initial thunk is simply a thunk type with a pointer to the code to evaluate it to a value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们还可以观察进程中 thunk 的评估和更新 ( id (1+1) )。初始 thunk 只是一个 thunk 类型，带有指向代码的指针以将其计算为一个值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>ThunkClosure</span> {
  info <span class=fu>=</span> <span class=dt>StgInfoTable</span> {
    ptrs <span class=fu>=</span> <span class=dv>0</span>,
    nptrs <span class=fu>=</span> <span class=dv>0</span>,
    tipe <span class=fu>=</span> <span class=dt>THUNK</span>,
    srtlen <span class=fu>=</span> <span class=dv>9</span>
  },
  ptrArgs <span class=fu>=</span> [],
  dataArgs <span class=fu>=</span> []
}</code></pre></div>
<p><font>When forced it is then evaluated and replaced with an Indirection closure which points at the computed value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当强制执行时，它会被评估并替换为指向计算值的间接闭包。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>BlackholeClosure</span> {
  info <span class=fu>=</span> <span class=dt>StgInfoTable</span> {
    ptrs <span class=fu>=</span> <span class=dv>1</span>,
    nptrs <span class=fu>=</span> <span class=dv>0</span>,
    tipe <span class=fu>=</span> <span class=dt>BLACKHOLE</span>,
    srtlen <span class=fu>=</span> <span class=dv>0</span>
  },
  indirectee <span class=fu>=</span> <span class=bn>0x00007fca10511e88</span><span class=fu>/</span><span class=dv>1</span>
}</code></pre></div>
<p><font>When the copying garbage collector passes over the indirection, it then simply replaces the indirection with a reference to the actual computed value computed by </font><code>indirectee</code><font> so that future access does need to chase a pointer through the indirection pointer to get the result.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当复制垃圾收集器通过间接时，它会简单地将间接替换为对由 indirectee 计算的实际计算值的引用，以便将来的访问确实需要通过间接指针追逐指针以获得结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>ConsClosure</span> {
  info <span class=fu>=</span> <span class=dt>StgInfoTable</span> {
    ptrs <span class=fu>=</span> <span class=dv>0</span>,
    nptrs <span class=fu>=</span> <span class=dv>1</span>,
    tipe <span class=fu>=</span> <span class=dt>CONSTR_0_1</span>,
    srtlen <span class=fu>=</span> <span class=dv>0</span>
  },
  ptrArgs <span class=fu>=</span> [],
  dataArgs <span class=fu>=</span> [<span class=dv>2</span>],
  pkg <span class=fu>=</span> <span class=st>"integer-gmp"</span>,
  modl <span class=fu>=</span> <span class=st>"GHC.Integer.Type"</span>,
  name <span class=fu>=</span> <span class=st>"S#"</span>
}</code></pre></div>
<h2 id=stg><font>STG</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>STG</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>After being compiled into Core, a program is translated into a very similar intermediate form known as STG ( Spineless Tagless G-Machine ) an abstract machine model that makes all laziness explicit. The spineless indicates that function applications in the language do not have a spine of applications of functions are collapsed into a sequence of arguments. Currying is still present in the semantics since arity information is stored and partially applied functions will evaluate differently than saturated functions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在被编译成 Core 之后，一个程序被翻译成一种非常相似的中间形式，称为 STG（Spineless Tagless G-Machine），这是一种抽象的机器模型，它使所有的懒惰变得明确。 spineless 表示该语言中的函数应用程序没有函数应用程序的主干，这些函数应用程序被折叠成一系列参数。 Currying 仍然存在于语义中，因为存储了 arity 信息并且部分应用的函数将与饱和函数进行不同的评估。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Spine</span>
f x y z <span class=fu>=</span> <span class=dt>App</span> (<span class=dt>App</span> (<span class=dt>App</span> f x) y) z

<span class=co>-- Spineless</span>
f x y z <span class=fu>=</span> <span class=dt>App</span> f [x, y, z]</code></pre></div>
<p><font>All let statements in STG bind a name to a </font><em>lambda form</em><font>. A lambda form with no arguments is a thunk, while a lambda-form with arguments indicates that a closure is to be allocated that captures the variables explicitly mentioned.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>STG 中的所有 let 语句都将名称绑定到 lambda 形式。没有参数的 lambda 形式是一个 thunk，而带有参数的 lambda 形式表示要分配一个闭包来捕获明确提到的变量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Thunks themselves are either reentrant (</font><code>\r</code><font>) or updatable (</font><code>\u</code><font>) indicating that the thunk and either yields a value to the stack or is allocated on the heap after the update frame is evaluated All subsequent entry's of the thunk will yield the already-computed value without needing to redo the same work.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>thunk 本身是可重入的 (\r) 或可更新的 (\u)，表明 thunk 要么产生一个值到堆栈，要么在评估更新帧后分配到堆上 thunk 的所有后续条目将产生已经-计算值而无需重做相同的工作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>A lambda form also indicates the </font><em>static reference table</em><font> a collection of references to static heap allocated values referred to by the body of the function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>lambda 形式还表示静态引用表是对函数体引用的静态堆分配值的引用集合。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example turning on </font><code>-ddump-stg</code><font> we can see the expansion of the following compose function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如打开 -ddump-stg 我们可以看到下面的 compose 函数的扩展。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Frontend</span>
compose f g <span class=fu>=</span> \x <span class=ot>-&gt;</span> f (g x)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Core</span>
<span class=ot>compose ::</span> forall t t1 t2<span class=fu>.</span> (t1 <span class=ot>-&gt;</span> t) <span class=ot>-&gt;</span> (t2 <span class=ot>-&gt;</span> t1) <span class=ot>-&gt;</span> t2 <span class=ot>-&gt;</span> t
compose <span class=fu>=</span>
  \ (<span class=fu>@</span> t) (<span class=fu>@</span> t1) (<span class=fu>@</span> t2) (<span class=ot>f ::</span> t1 <span class=ot>-&gt;</span> t) (<span class=ot>g ::</span> t2 <span class=ot>-&gt;</span> t1) (<span class=ot>x ::</span> t2) <span class=ot>-&gt;</span>
    f (g x)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- STG</span>
<span class=ot>compose ::</span> forall t t1 t2<span class=fu>.</span> (t1 <span class=ot>-&gt;</span> t) <span class=ot>-&gt;</span> (t2 <span class=ot>-&gt;</span> t1) <span class=ot>-&gt;</span> t2 <span class=ot>-&gt;</span> t <span class=fu>=</span>
    \r [f g x] <span class=kw>let</span> {<span class=ot> sat ::</span> t1 <span class=fu>=</span> \u [] g x; } <span class=kw>in</span>  f sat;
<span class=dt>SRT</span>(compose)<span class=fu>:</span> []</code></pre></div>
<p><font>For a more sophisticated example, let's trace the compilation of the factorial function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于更复杂的示例，让我们跟踪阶乘函数的编译。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Frontend</span>
<span class=ot>fac ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
fac a <span class=dv>0</span> <span class=fu>=</span> a
fac a n <span class=fu>=</span> fac (n<span class=fu>*</span>a) (n<span class=fu>-</span><span class=dv>1</span>)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Core</span>
<span class=dt>Rec</span> {
<span class=ot>fac ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
fac <span class=fu>=</span>
  \ (<span class=ot>a ::</span> <span class=dt>Int</span>) (<span class=ot>ds ::</span> <span class=dt>Int</span>) <span class=ot>-&gt;</span>
    <span class=kw>case</span> ds <span class=kw>of</span> wild { <span class=dt>I</span><span class=fu>#</span> ds1 <span class=ot>-&gt;</span>
    <span class=kw>case</span> ds1 <span class=kw>of</span> _ {
      __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span>
        fac (<span class=fu>*</span> <span class=fu>@</span> <span class=dt>Int</span> <span class=fu>$</span>fNumInt wild a) (<span class=fu>-</span> <span class=fu>@</span> <span class=dt>Int</span> <span class=fu>$</span>fNumInt wild (<span class=dt>I</span><span class=fu>#</span> <span class=dv>1</span>));
      <span class=dv>0</span> <span class=ot>-&gt;</span> a
    }
    }
end <span class=dt>Rec</span> }</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- STG</span>
<span class=ot>fac ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=fu>=</span>
    \r srt<span class=fu>:</span>(<span class=dv>0</span>,<span class=fu>*</span>bitmap<span class=fu>*</span>) [a ds]
        <span class=kw>case</span> ds <span class=kw>of</span> wild {
          <span class=dt>I</span><span class=fu>#</span> ds1 <span class=ot>-&gt;</span>
              <span class=kw>case</span> ds1 <span class=kw>of</span> _ {
                __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span>
                    <span class=kw>let</span> {
<span class=ot>                      sat ::</span> <span class=dt>Int</span> <span class=fu>=</span>
                          \u srt<span class=fu>:</span>(<span class=dv>1</span>,<span class=fu>*</span>bitmap<span class=fu>*</span>) []
                              <span class=kw>let</span> {<span class=ot> sat ::</span> <span class=dt>Int</span> <span class=fu>=</span> <span class=dt>NO_CCS</span> <span class=dt>I</span><span class=fu>#!</span> [<span class=dv>1</span>]; } <span class=kw>in</span>  <span class=fu>-</span> <span class=fu>$</span>fNumInt wild sat; } <span class=kw>in</span>
                    <span class=kw>let</span> {<span class=ot> sat ::</span> <span class=dt>Int</span> <span class=fu>=</span> \u srt<span class=fu>:</span>(<span class=dv>1</span>,<span class=fu>*</span>bitmap<span class=fu>*</span>) [] <span class=fu>*</span> <span class=fu>$</span>fNumInt wild a;
                    } <span class=kw>in</span>  fac sat sat;
                <span class=dv>0</span> <span class=ot>-&gt;</span> a;
              };
        };
<span class=dt>SRT</span>(fac)<span class=fu>:</span> [fac, <span class=fu>$</span>fNumInt]</code></pre></div>
<p><font>Notice that the factorial function allocates two thunks ( look for </font><code>\u</code><font>) inside of the loop which are updated when computed. It also includes static references to both itself (for recursion) and the dictionary for instance of </font><code>Num</code><font> typeclass over the type </font><code>Int</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请注意，阶乘函数在循环内分配了两个 thunk（查找 \u），它们在计算时更新。它还包括对自身（用于递归）和 Int 类型上 Num 类型类实例的字典的静态引用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=workerwrapper><font>Worker/Wrapper</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>工人/包装</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>With </font><code>-O2</code><font> turned on GHC will perform a special optimization known as the Worker-Wrapper transformation which will split the logic of the factorial function across two definitions, the worker will operate over stack unboxed allocated machine integers which compiles into a tight inner loop while the wrapper calls into the worker and collects the end result of the loop and packages it back up into a boxed heap value. This can often be an order of of magnitude faster than the naive implementation which needs to pack and unpack the boxed integers on every iteration.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>打开 -O2 后，GHC 将执行一种称为 Worker-Wrapper 转换的特殊优化，它将阶乘函数的逻辑拆分为两个定义，worker 将对堆栈未装箱分配的机器整数进行操作，这些整数编译成一个紧密的内部循环，而wrapper 调用 worker 并收集循环的最终结果并将其打包回装箱堆值中。这通常比需要在每次迭代中打包和解包装箱整数的简单实现快一个数量级。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- Worker</span>
<span class=fu>$</span><span class=ot>wfac ::</span> <span class=dt>Int</span><span class=fu>#</span> <span class=ot>-&gt;</span> <span class=dt>Int</span><span class=fu>#</span> <span class=ot>-&gt;</span> <span class=dt>Int</span><span class=fu>#</span> <span class=fu>=</span>
    \r [ww ww1]
        <span class=kw>case</span> ww1 <span class=kw>of</span> ds {
          __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span>
              <span class=kw>case</span> <span class=fu>-#</span> [ds <span class=dv>1</span>] <span class=kw>of</span> sat {
                __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span>
                    <span class=kw>case</span> <span class=fu>*#</span> [ds ww] <span class=kw>of</span> sat { __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span> <span class=fu>$</span>wfac sat sat; };
              };
          <span class=dv>0</span> <span class=ot>-&gt;</span> ww;
        };
<span class=dt>SRT</span>(<span class=fu>$</span>wfac)<span class=fu>:</span> []

<span class=co>-- Wrapper</span>
<span class=ot>fac ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=fu>=</span>
    \r [w w1]
        <span class=kw>case</span> w <span class=kw>of</span> _ {
          <span class=dt>I</span><span class=fu>#</span> ww <span class=ot>-&gt;</span>
              <span class=kw>case</span> w1 <span class=kw>of</span> _ {
                <span class=dt>I</span><span class=fu>#</span> ww1 <span class=ot>-&gt;</span> <span class=kw>case</span> <span class=fu>$</span>wfac ww ww1 <span class=kw>of</span> ww2 { __<span class=dt>DEFAULT</span> <span class=ot>-&gt;</span> <span class=dt>I</span><span class=fu>#</span> [ww2]; };
              };
        };
<span class=dt>SRT</span>(fac)<span class=fu>:</span> []</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/>Writing Haskell as Fast as C<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>写 Haskell 和 C 一样快</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=z-encoding><font>Z-Encoding</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Z编码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The Z-encoding is Haskell's convention for generating names that are safely represented in the compiler target language. Simply put the z-encoding renames many symbolic characters into special sequences of the z character.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z 编码是 Haskell 的约定，用于生成在编译器目标语言中安全表示的名称。简单地说，z 编码将许多符号字符重命名为 z 字符的特殊序列。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>String</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>细绳</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Z-Encoded String</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z 编码字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>foo<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>富</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>foo<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>富</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>z<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>z</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>zz<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z Z</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>Z<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>ZZ<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z Z</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>()</code></td>
<td align=left><code>Z0T<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z0T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>(,)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(,)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>Z2T<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z2T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>(,,)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(,,)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>Z3T<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z3T</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>_</code></td>
<td align=left><code>zu<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>祖</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>(</code></td>
<td align=left><code>ZL<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ZL</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>)</code></td>
<td align=left><code>ZR<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ZR</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>:</code></td>
<td align=left><code>ZC<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>零碳</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>#</code></td>
<td align=left><code>zh<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>zh</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>.</code></td>
<td align=left><code>zi<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>(#,#)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(#,#)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>Z2H<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z2H</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>(-&gt;)<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>(-&gt;)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>ZLzmzgZR<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ZLZZGZR</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
</tbody>
</table>
<p><font>In this way we don't have to generate unique unidentifiable names for character rich names and can simply have a straightforward way to translate them into something unique but identifiable.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通过这种方式，我们不必为字符丰富的名称生成唯一的、无法识别的名称，并且可以简单地使用一种直接的方法将它们翻译成独特但可识别的东西。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>So for some example names from GHC generated code:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，对于 GHC 生成的代码中的一些示例名称：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Z-Encoded String</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Z 编码字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Decoded String</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>解码字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>ZCMain_main_closure<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ZCMain_main_closure</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>:Main_main_closure<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>:main_main_closure</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>base_GHCziBase_map_closure<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>base_GHCziBase_map_closure</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>base_GHC.Base_map_closure<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>base_GHC.Base_map_closure</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>base_GHCziInt_I32zh_con_info<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>base_GHCziInt_I32zh_con_info</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>base_GHC.Int_I32#_con_info<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>base_GHC.Int_I32#_con_info</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=even>
<td align=left><code>ghczmprim_GHCziTuple_Z3T_con_info<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghczmprim_GHCziTuple_Z3T_con_info</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>ghc-prim_GHC.Tuple_(,,)_con_in<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghc-prim_GHC.Tuple_(,,)_con_in</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
<tr class=odd>
<td align=left><code>ghczmprim_GHCziTypes_ZC_con_info<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghczmprim_GHCziTypes_ZC_con_info</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>ghc-prim_GHC.Types_:_con_info<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>ghc-prim_GHC.Types_:_con_info</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
</tr>
</tbody>
</table>
<h2 id=cmm><font>Cmm</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>厘米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Cmm is GHC's complex internal intermediate representation that maps directly onto the generated code for the compiler target. Cmm code generated from Haskell is CPS-converted, all functions never return a value, they simply call the next frame in the continuation stack. All evaluation of functions proceed by indirectly jumping to a code object with its arguments placed on the stack by the caller.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cmm 是 GHC 复杂的内部中间表示，它直接映射到为编译器目标生成的代码。从 Haskell 生成的 Cmm 代码是 CPS 转换的，所有函数从不返回值，它们只是调用延续堆栈中的下一帧。函数的所有求值都通过间接跳转到代码对象来进行，代码对象的参数由调用者放在堆栈上。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>This is drastically different than C's evaluation model, where are placed on the stack and a function yields a value to the stack after it returns.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这与 C 的求值模型截然不同，C 的求值模型将 放在堆栈上，函数在返回后向堆栈产生一个值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>There are several common suffixes you'll see used in all closures and function names:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>您会在所有闭包和函数名称中看到几个常见的后缀：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Symbol</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>象征</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Meaning</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>意义</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>0</code></td>
<td align=left><font>No argument</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>没有争论</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>p<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>p</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Garage Collected Pointer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>车库收集指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>n<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>n</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Word-sized non-pointer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字大小的非指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>l<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>升</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>64-bit non-pointer (long)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>64 位非指针（长）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>v<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>v</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Void</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>空白</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>f<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>F</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Float</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂浮</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>d<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>d</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Double</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双倍的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>v16<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>v16</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>16-byte vector</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>16 字节向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>v32<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>v32</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>32-byte vector</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>32 字节向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>v64<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>v64</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>64-byte vector</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>64 字节向量</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><strong>Cmm Registers<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cmm 寄存器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>There are 10 registers that described in the machine model. </font><strong>Sp</strong><font> is the pointer to top of the stack, </font><strong>SpLim</strong><font> is the pointer to last element in the stack. </font><strong>Hp</strong><font> is the heap pointer, used for allocation and garbage collection with </font><strong>HpLim</strong><font> the current heap limit.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>机器模型中描述了 10 个寄存器。 Sp 是指向栈顶的指针，SpLim 是指向栈中最后一个元素的指针。 Hp 是堆指针，用于分配和垃圾收集，HpLim 是当前堆限制。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The </font><strong>R1</strong><font> register always holds the active closure, and subsequent registers are arguments passed in registers. Functions with more than 10 values spill into memory.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R1 寄存器始终保存活动闭包，后续寄存器是在寄存器中传递的参数。具有超过 10 个值的函数溢出到内存中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><font>Sp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Sp</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>SpLim</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>SpLim</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>Hp</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生命值</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>HpLim</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>HpLim</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>HpAlloc</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>HpAlloc</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R1</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R1</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R2</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R2</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R3</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R3</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R4</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R4</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R5</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R5</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R6</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R6</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R7</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R7</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R9</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R9</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
<li><font>R10</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R10</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></li>
</ul>
<p><strong>Examples<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>To understand Cmm it is useful to look at the code generated by the equivalent Haskell and slowly understand the equivalence and mechanical translation maps one to the other.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>要理解 Cmm，查看等效的 Haskell 生成的代码并慢慢理解等效和机械翻译映射是很有用的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>There are generally two parts to every Cmm definition, the </font><strong>info table</strong><font> and the </font><strong>entry code</strong><font>. The info table maps directly </font><code>StgInfoTable</code><font> struct and contains various fields related to the type of the closure, its payload, and references. The code objects are basic blocks of generated code that correspond to the logic of the Haskell function/constructor.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>每个 Cmm 定义通常有两个部分，信息表和入口代码。信息表直接映射 StgInfoTable 结构，并包含与闭包类型、其有效负载和引用相关的各种字段。代码对象是生成代码的基本块，对应于 Haskell 函数/构造函数的逻辑。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For the simplest example consider a constant static constructor. Simply a function which yields the Unit value. In this case the function is simply a constructor with no payload, and is statically allocated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于最简单的示例，请考虑一个常量静态构造函数。只是一个产生单位值的函数。在这种情况下，该函数只是一个没有有效载荷的构造函数，并且是静态分配的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">unit <span class=fu>=</span> ()</code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     unit_closure:
         <span class=dt>const</span> ()_static_info;
 }]</code></pre></div>
<p><font>Consider a static constructor with an argument.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑一个带参数的静态构造函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>con ::</span> <span class=dt>Maybe</span> ()
con <span class=fu>=</span> <span class=dt>Just</span> ()</code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     con_closure:
         <span class=dt>const</span> Just_static_info;
         <span class=dt>const</span> ()_closure<span class=dv>+1</span>;
         <span class=dt>const</span> <span class=dv>1</span>;
 }]</code></pre></div>
<p><font>Consider a literal constant. This is a static value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑一个文字常量。这是一个静态值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>lit ::</span> <span class=dt>Int</span>
lit <span class=fu>=</span> <span class=dv>1</span></code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     lit_closure:
         <span class=dt>const</span> I<span class=er>#</span>_static_info;
         <span class=dt>const</span> <span class=dv>1</span>;
 }]</code></pre></div>
<p><font>Consider the identity function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑恒等函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">id x <span class=fu>=</span> x</code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     id_closure:
         <span class=dt>const</span> id_info;
 },
 id_info()
         { label: id_info
           rep:HeapRep <span class=dt>static</span> { Fun {arity: <span class=dv>1</span> fun_type: ArgSpec <span class=dv>5</span>} }
         }
     ch1:
         R1 = R2;
         jump stg_ap_0_fast; <span class=co>// [R1]</span>
 }]</code></pre></div>
<p><font>Consider the constant function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑常数函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">constant x y <span class=fu>=</span> x</code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     constant_closure:
         <span class=dt>const</span> constant_info;
 },
 constant_info()
         { label: constant_info
           rep:HeapRep <span class=dt>static</span> { Fun {arity: <span class=dv>2</span> fun_type: ArgSpec <span class=dv>12</span>} }
         }
     cgT:
         R1 = R2;
         jump stg_ap_0_fast; <span class=co>// [R1]</span>
 }]</code></pre></div>
<p><font>Consider a function where application of a function ( of unknown arity ) occurs.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑一个函数，其中应用了一个函数（未知数量）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">compose f g x <span class=fu>=</span> f (g x)</code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     compose_closure:
         <span class=dt>const</span> compose_info;
 },
 compose_info()
         { label: compose_info
           rep:HeapRep <span class=dt>static</span> { Fun {arity: <span class=dv>3</span> fun_type: ArgSpec <span class=dv>20</span>} }
         }
     ch9:
         Hp = Hp + <span class=dv>32</span>;
         <span class=kw>if</span> (Hp &gt; HpLim) <span class=kw>goto</span> chd;
         I64[Hp - <span class=dv>24</span>] = stg_ap_2_upd_info;
         I64[Hp - <span class=dv>8</span>] = R3;
         I64[Hp + <span class=dv>0</span>] = R4;
         R1 = R2;
         R2 = Hp - <span class=dv>24</span>;
         jump stg_ap_p_fast; <span class=co>// [R1, R2]</span>
     che:
         R1 = compose_closure;
         jump stg_gc_fun; <span class=co>// [R1, R4, R3, R2]</span>
     chd:
         HpAlloc = <span class=dv>32</span>;
         <span class=kw>goto</span> che;
 }]</code></pre></div>
<p><font>Consider a function which branches using pattern matching:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>考虑一个使用模式匹配进行分支的函数：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>哈斯克尔：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>match ::</span> <span class=dt>Either</span> a a <span class=ot>-&gt;</span> a
match x <span class=fu>=</span> <span class=kw>case</span> x <span class=kw>of</span>
  <span class=dt>Left</span> a <span class=ot>-&gt;</span> a
  <span class=dt>Right</span> b <span class=ot>-&gt;</span> b</code></pre></div>
<p><font>Cmm:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class=st>"data"</span> {
     match_closure:
         <span class=dt>const</span> match_info;
 },
 sio_ret()
         { label: sio_info
           rep:StackRep []
         }
     ciL:
         _ciM::I64 = R1 &amp; <span class=dv>7</span>;
         <span class=kw>if</span> (_ciM::I64 &gt;= <span class=dv>2</span>) <span class=kw>goto</span> ciN;
         R1 = I64[R1 + <span class=dv>7</span>];
         Sp = Sp + <span class=dv>8</span>;
         jump stg_ap_0_fast; <span class=co>// [R1]</span>
     ciN:
         R1 = I64[R1 + <span class=dv>6</span>];
         Sp = Sp + <span class=dv>8</span>;
         jump stg_ap_0_fast; <span class=co>// [R1]</span>
 },
 match_info()
         { label: match_info
           rep:HeapRep <span class=dt>static</span> { Fun {arity: <span class=dv>1</span> fun_type: ArgSpec <span class=dv>5</span>} }
         }
     ciP:
         <span class=kw>if</span> (Sp - <span class=dv>8</span> &lt; SpLim) <span class=kw>goto</span> ciR;
         R1 = R2;
         I64[Sp - <span class=dv>8</span>] = sio_info;
         Sp = Sp - <span class=dv>8</span>;
         <span class=kw>if</span> (R1 &amp; <span class=dv>7</span> != <span class=dv>0</span>) <span class=kw>goto</span> ciU;
         jump I64[R1]; <span class=co>// [R1]</span>
     ciR:
         R1 = match_closure;
         jump stg_gc_fun; <span class=co>// [R1, R2]</span>
     ciU: jump sio_info; <span class=co>// [R1]</span>
 }]</code></pre></div>
<p><strong>Macros<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>宏指令</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>Cmm itself uses many macros to stand for various constructs, many of which are defined in an external C header file. A short reference for the common types:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cmm 本身使用许多宏来代表各种构造，其中许多是在外部 C 头文件中定义的。常见类型的简短参考：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Cmm</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>厘米</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Description</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>描述</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>C_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>char</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字符</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>D_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>D_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>double</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>双倍的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>F_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>F_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>float</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂浮</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>W_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>W_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>word</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>P_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>P_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>garbage collected pointer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>垃圾回收指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>I_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>int</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>L_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>L_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>long</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>长的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>FN_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>FN_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>function pointer (no arguments)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>函数指针（无参数）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>EF_<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>EF_</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>extern function pointer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>外部函数指针</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>I8<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>I8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>8-bit integer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>8 位整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>I16<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>I16</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>16-bit integer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>16 位整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>I32<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>I32</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>32-bit integer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>32 位整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>I64<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>I64</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>64-bit integer</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>64 位整数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<p><font>Many of the predefined closures (</font><code>stg_ap_p_fast</code><font>, etc) are themselves mechanically generated and more or less share the same form ( a giant switch statement on closure type, update frame, stack adjustment). Inside of GHC is a file named </font><code>GenApply.hs</code><font> that generates most of these functions. See the Gist link in the reading section for the current source file that GHC generates. For example the output for </font><code>stg_ap_p_fast</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>许多预定义的闭包（stg_ap_p_fast 等）本身是机械生成的，或多或少共享相同的形式（关于闭包类型、更新框架、堆栈调整的巨大 switch 语句）。 GHC 内部有一个名为 GenApply.hs 的文件，它生成了其中的大部分函数。请参阅阅读部分中的 Gist 链接以获取 GHC 生成的当前源文件。例如 stg_ap_p_fast 的输出。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">stg_ap_p_fast
{   W_ info;
    W_ arity;
    <span class=kw>if</span> (GETTAG(R1)==<span class=dv>1</span>) {
        Sp_adj(<span class=dv>0</span>);
        jump %GET_ENTRY(R1<span class=dv>-1</span>) [R1,R2];
    }
    <span class=kw>if</span> (Sp - WDS(<span class=dv>2</span>) &lt; SpLim) {
        Sp_adj(<span class=dv>-2</span>);
        W_[Sp+WDS(<span class=dv>1</span>)] = R2;
        Sp(<span class=dv>0</span>) = stg_ap_p_info;
        jump __stg_gc_enter_1 [R1];
    }
    R1 = UNTAG(R1);
    info = %GET_STD_INFO(R1);
    <span class=kw>switch</span> [INVALID_OBJECT .. N_CLOSURE_TYPES] (TO_W_(%INFO_TYPE(info))) {
        <span class=kw>case</span> FUN,
             FUN_1_0,
             FUN_0_1,
             FUN_2_0,
             FUN_1_1,
             FUN_0_2,
             FUN_STATIC: {
            arity = TO_W_(StgFunInfoExtra_arity(%GET_FUN_INFO(R1)));
            ASSERT(arity &gt; <span class=dv>0</span>);
            <span class=kw>if</span> (arity == <span class=dv>1</span>) {
                Sp_adj(<span class=dv>0</span>);
                R1 = R1 + <span class=dv>1</span>;
                jump %GET_ENTRY(UNTAG(R1)) [R1,R2];
            } <span class=kw>else</span> {
                Sp_adj(<span class=dv>-2</span>);
                W_[Sp+WDS(<span class=dv>1</span>)] = R2;
                <span class=kw>if</span> (arity &lt; <span class=dv>8</span>) {
                  R1 = R1 + arity;
                }
                BUILD_PAP(<span class=dv>1</span>,<span class=dv>1</span>,stg_ap_p_info,FUN);
            }
        }
        <span class=kw>default</span>: {
            Sp_adj(<span class=dv>-2</span>);
            W_[Sp+WDS(<span class=dv>1</span>)] = R2;
            jump RET_LBL(stg_ap_p) [];
        }
    }
}</code></pre></div>
<p><font>Handwritten Cmm can be included in a module manually by first compiling it through GHC into an object and then using a special FFI invocation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>手写 Cmm 可以手动包含在模块中，方法是首先通过 GHC 将其编译为对象，然后使用特殊的 FFI 调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/29-ghc/factorial.cmm><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=ot>#include "Cmm.h"</span>

factorial {
  entry:
      W_ n  ;
      W_ acc;
      n = R1 ;
      acc = n ;
      n = n - <span class=dv>1</span> ;
    
  <span class=kw>for</span>:
      <span class=kw>if</span> (n &lt;= <span class=dv>0</span> ) {
          RET_N(acc);
      } <span class=kw>else</span> {
          acc = acc * n  ;
          n = n - <span class=dv>1</span> ;
          <span class=kw>goto</span> <span class=kw>for</span> ;
      }
      RET_N(<span class=dv>0</span>);
}</code></pre></div>
<div class=sourceCode include=src/29-ghc/cmm_include.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- ghc -c factorial.cmm -o factorial.o</span>
<span class=co>-- ghc factorial.o Example.hs -o Example</span>

<span class=ot>{-# LANGUAGE MagicHash #-}</span>
<span class=ot>{-# LANGUAGE UnliftedFFITypes #-}</span>
<span class=ot>{-# LANGUAGE GHCForeignImportPrim #-}</span>
<span class=ot>{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class=kw>module</span> <span class=dt>Main</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>GHC.Prim</span>
<span class=kw>import </span><span class=dt>GHC.Word</span>

foreign <span class=kw>import </span>prim "factorial" factorial_cmm  :: <span class=dt>Word</span># -&gt; <span class=dt>Word</span>#

<span class=ot>factorial ::</span> <span class=dt>Word64</span> <span class=ot>-&gt;</span> <span class=dt>Word64</span>
factorial (<span class=dt>W64</span><span class=fu>#</span> n) <span class=fu>=</span>  <span class=dt>W64</span><span class=fu>#</span> (factorial_cmm n)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> print (factorial <span class=dv>5</span>)</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType>CmmType<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>厘米类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/ghc/ghc/blob/master/includes/stg/MiscClosures.h>MiscClosures<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>杂项闭包</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmArgRep.hs>StgCmmArgRep<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>StgCmmArgRep</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<p><font>Cmm Runtime:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Cmm 运行时：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://github.com/ghc/ghc/blob/master/rts/Apply.cmm>Apply.cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>申请.cmm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/ghc/ghc/blob/master/rts/StgStdThunks.cmm>StgStdThunks.cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>StgStdThunks.cmm 文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/ghc/ghc/blob/master/rts/StgMiscClosures.cmm>StgMiscClosures.cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>StgMiscClosures.cmm 文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm>PrimOps.cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>PrimOps.cmm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/ghc/ghc/blob/master/rts/Updates.cmm>Updates.cmm<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>更新.cmm</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://gist.github.com/sdiehl/e5c9daab7a6d1da0ede7>Precompiled Closures ( Autogenerated Output )<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>预编译闭包（自动生成的输出）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=optimization-hacks><font>Optimization Hacks</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>优化技巧</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h4 id=tables-next-to-code><font>Tables Next to Code</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代码旁边的表格</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>GHC will place the info table for a toplevel closure directly next to the entry-code for the objects in memory such that the fields from the info table can be accessed by pointer arithmetic on the function pointer to the code itself. Not performing this optimization would involve chasing through one more pointer to get to the info table. Given how often info-tables are accessed using the tables-next-to-code optimization results in a tractable speedup.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>GHC 会将顶层闭包的信息表直接放在内存中对象的入口代码旁边，这样信息表中的字段就可以通过指向代码本身的函数指针上的指针算法来访问。不执行此优化将涉及追逐一个指针以获取信息表。鉴于使用 tables-next-to-code 优化访问信息表的频率会导致易于处理的加速。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=pointer-tagging><font>Pointer Tagging</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>指针标记</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<p><font>Depending on the type of the closure involved, GHC will utilize the last few bits in a pointer to the closure to store information that can be read off from the bits of pointer itself before jumping into or access the info tables. For thunks this can be information like whether it is evaluated to WHNF or not, for constructors it contains the constructor tag (if it fits) to avoid an info table lookup.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>根据所涉及闭包的类型，GHC 将利用指向闭包的指针中的最后几位来存储信息，这些信息可以在跳入或访问信息表之前从指针本身的位中读取。对于 thunk，这可以是诸如是否评估为 WHNF 之类的信息，对于构造函数，它包含构造函数标记（如果适合）以避免信息表查找。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Depending on the architecture the tag bits are either the last 2 or 3 bits of a pointer.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>根据体系结构，标记位是指针的最后 2 位或 3 位。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=co>// 32 bit arch</span>
TAG_BITS = <span class=dv>2</span>

<span class=co>// 64-bit arch</span>
TAG_BITS = <span class=dv>3</span></code></pre></div>
<p><font>These occur in Cmm most frequently via the following macro definitions:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这些通过以下宏定义最常出现在 Cmm 中：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=ot>#define TAG_MASK ((1 &lt;&lt; TAG_BITS) - 1)</span>
<span class=ot>#define UNTAG(p) (p &amp; ~TAG_MASK)</span>
<span class=ot>#define GETTAG(p) (p &amp; TAG_MASK)</span></code></pre></div>
<p><font>So for instance in many of the precompiled functions, there will be a test for whether the active closure </font><code>R1</code><font> is already evaluated.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>因此，例如在许多预编译函数中，将测试活动闭包 R1 是否已被评估。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class=kw>if</span> (GETTAG(R1)==<span class=dv>1</span>) {
    Sp_adj(<span class=dv>0</span>);
    jump %GET_ENTRY(R1<span class=dv>-1</span>) [R1,R2];
}</code></pre></div>
<h2 id=interface-files><font>Interface Files</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>接口文件</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>During compilation GHC will produce interface files for each module that are the binary encoding of specific symbols (functions, typeclasses, etc) exported by that modules as well as any package dependencies it itself depends on. This is effectively the serialized form of the ModGuts structure used internally in the compiler. The internal structure of this file can be dumped using the </font><code>--show-iface</code><font> flag. The precise structure changes between versions of GHC.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在编译期间，GHC 将为每个模块生成接口文件，这些接口文件是该模块导出的特定符号（函数、类型类等）的二进制编码，以及它本身依赖的任何包依赖项。这实际上是编译器内部使用的 ModGuts 结构的序列化形式。可以使用 --show-iface 标志转储此文件的内部结构。 GHC 版本之间的精确结构会发生变化。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>ghc</span> --show-iface let.hi
<span class=kw>Magic</span>: Wanted 33214052,
       <span class=kw>got</span>    33214052
<span class=kw>Version</span>: Wanted [7, 0, 8, 4],
         <span class=kw>got</span>    [7, 0, 8, 4]
<span class=kw>Way</span>: Wanted [],
     <span class=kw>got</span>    []
<span class=kw>interface</span> main:Main 7084
  <span class=kw>interface</span> hash: 1991c3e0edf3e849aeb53783fb616df2
  <span class=kw>ABI</span> hash: 0b7173fb01d2226a2e61df72371034ee
  <span class=kw>export-list</span> hash: 0f26147773230f50ea3b06fe20c9c66c
  <span class=kw>orphan</span> hash: 693e9af84d3dfcc71e640e005bdc5e2e
  <span class=kw>flag</span> hash: 9b3dfba8e3209c5b5c132a214b6b9bd3
  <span class=kw>used</span> TH splices: False
  <span class=kw>where</span>
<span class=kw>exports</span>:
  <span class=kw>Main.main</span>
<span class=kw>module</span> dependencies:
<span class=kw>package</span> dependencies: base* ghc-prim integer-gmp
<span class=kw>orphans</span>: base:GHC.Base base:GHC.Float base:GHC.Real
<span class=kw>family</span> instance modules: base:Data.Either base:Data.Monoid
                         <span class=kw>base</span>:Data.Type.Equality base:GHC.Generics
<span class=kw>import</span>  -/  base:GHC.Num 5e7786970581cacc802bf850d458a30b
<span class=kw>import</span>  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
<span class=kw>import</span>  -/  base:System.IO cadd0efb01c47ddd8f52d750739fdbdf
<span class=kw>import</span>  -/  ghc-prim:GHC.Types dcba736fa3dfba12d307ab18354845d2
<span class=kw>4cfa03293a8356d627c0c5fec26936e2</span>
  <span class=kw>main</span> :: GHC.Types.IO ()
<span class=kw>vectorised</span> variables:
<span class=kw>vectorised</span> tycons:
<span class=kw>vectorised</span> reused tycons:
<span class=kw>parallel</span> variables:
<span class=kw>parallel</span> tycons:
<span class=kw>trusted</span>: safe-inferred
<span class=kw>require</span> own pkg trusted: False</code></pre></div>
<h1 id=profiling><font>Profiling</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>剖析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=ekg><font>EKG</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>心电图</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>EKG is a monitoring tool that can monitor various aspect of GHC's runtime alongside an active process. The interface for the output is viewable within a browser interface. The monitoring process is forked off (in a system thread) from the main process.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>EKG 是一种监控工具，可以监控 GHC 运行时的各个方面以及活动进程。输出界面可在浏览器界面中查看。监控进程从主进程中分叉出来（在系统线程中）。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/29-ghc/ekg.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# Language OverloadedStrings #-}</span>

<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>System.Remote.Monitoring</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  ekg <span class=ot>&lt;-</span> forkServer <span class=st>"localhost"</span> <span class=dv>8000</span>
  putStrLn <span class=st>"Started server on http://localhost:8000"</span>
  forever <span class=fu>$</span> getLine <span class=fu>&gt;&gt;=</span> putStrLn</code></pre></div>
<div class=figure>
<img src=data:image/png;base64,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 alt data-sf-original-src=https://smunix.github.io/dev.stephendiehl.com/hask/img/ekg.png>
</div>
<h2 id=rts-profiling><font>RTS Profiling</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>RTS 分析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The GHC runtime system can be asked to dump information about allocations and percentage of wall time spent in various portions of the runtime system.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>可以要求 GHC 运行时系统转储有关分配的信息以及在运行时系统的各个部分花费的时间百分比。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> <span class=fu>./</span>program <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span>s

       <span class=dv>1</span>,<span class=dv>939</span>,<span class=dv>784</span> bytes allocated <span class=kw>in</span> the heap
          <span class=dv>11</span>,<span class=dv>160</span> bytes copied during <span class=dt>GC</span>
          <span class=dv>44</span>,<span class=dv>416</span> bytes maximum residency (<span class=dv>2</span> sample(s))
          <span class=dv>21</span>,<span class=dv>120</span> bytes maximum slop
               <span class=dv>1</span> <span class=dt>MB</span> total memory <span class=kw>in</span> use (<span class=dv>0</span> <span class=dt>MB</span> lost due to fragmentation)

                                    <span class=dt>Tot</span> time (elapsed)  <span class=dt>Avg</span> pause  <span class=dt>Max</span> pause
  <span class=dt>Gen</span>  <span class=dv>0</span>         <span class=dv>2</span> colls,     <span class=dv>0</span> par    <span class=fl>0.00</span>s    <span class=fl>0.00</span>s     <span class=fl>0.0000</span>s    <span class=fl>0.0000</span>s
  <span class=dt>Gen</span>  <span class=dv>1</span>         <span class=dv>2</span> colls,     <span class=dv>0</span> par    <span class=fl>0.00</span>s    <span class=fl>0.00</span>s     <span class=fl>0.0002</span>s    <span class=fl>0.0003</span>s

  <span class=dt>INIT</span>    time    <span class=fl>0.00</span>s  (  <span class=fl>0.00</span>s elapsed)
  <span class=dt>MUT</span>     time    <span class=fl>0.00</span>s  (  <span class=fl>0.01</span>s elapsed)
  <span class=dt>GC</span>      time    <span class=fl>0.00</span>s  (  <span class=fl>0.00</span>s elapsed)
  <span class=dt>EXIT</span>    time    <span class=fl>0.00</span>s  (  <span class=fl>0.00</span>s elapsed)
  <span class=dt>Total</span>   time    <span class=fl>0.01</span>s  (  <span class=fl>0.01</span>s elapsed)

  <span class=fu>%</span><span class=dt>GC</span>     time       <span class=fl>5.0</span><span class=fu>%</span>  (<span class=fl>7.1</span><span class=fu>%</span> elapsed)

  <span class=dt>Alloc</span> rate    <span class=dv>398</span>,<span class=dv>112</span>,<span class=dv>898</span> bytes per <span class=dt>MUT</span> second

  <span class=dt>Productivity</span>  <span class=fl>91.4</span><span class=fu>%</span> <span class=kw>of</span> total user, <span class=fl>128.8</span><span class=fu>%</span> <span class=kw>of</span> total elapsed</code></pre></div>
<p><font>Productivity indicates the amount of time spent during execution compared to the time spent garbage collecting. Well tuned CPU bound programs are often in the 90-99% range of productivity range.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生产率表示执行期间花费的时间与垃圾收集所花费的时间相比。经过良好调优的 CPU 受限程序通常在 90-99% 的生产率范围内。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In addition individual function profiling information can be generated by compiling the program with </font><code>-prof</code><font> flag. The resulting information is outputted to a </font><code>.prof</code><font> file of the same name as the module. This is useful for tracking down hotspots in the program.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>此外，可以通过使用 -prof 标志编译程序来生成单独的函数分析信息。结果信息输出到与模块同名的 .prof 文件。这对于跟踪程序中的热点很有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span> ghc <span class=fu>-</span><span class=dt>O2</span> program<span class=fu>.</span>hs <span class=fu>-</span>prof <span class=fu>-</span>auto<span class=fu>-</span>all
<span class=fu>$</span> <span class=fu>./</span>program <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span>p
<span class=fu>$</span> cat program<span class=fu>.</span>prof
        <span class=dt>Mon</span> <span class=dt>Oct</span> <span class=dv>27</span> <span class=dv>23</span><span class=fu>:</span><span class=dv>00</span> <span class=dv>2014</span> <span class=dt>Time</span> and <span class=dt>Allocation</span> <span class=dt>Profiling</span> <span class=dt>Report</span>  (<span class=dt>Final</span>)

           program <span class=fu>+</span><span class=dt>RTS</span> <span class=fu>-</span>p <span class=fu>-</span><span class=dt>RTS</span>

        total time  <span class=fu>=</span>        <span class=fl>0.01</span> secs   (<span class=dv>7</span> ticks <span class=fu>@</span> <span class=dv>1000</span> us, <span class=dv>1</span> processor)
        total alloc <span class=fu>=</span>   <span class=dv>1</span>,<span class=dv>937</span>,<span class=dv>336</span> bytes  (excludes profiling overheads)

<span class=dt>COST</span> <span class=dt>CENTRE</span> <span class=dt>MODULE</span>           <span class=fu>%</span>time <span class=fu>%</span>alloc

<span class=dt>CAF</span>         <span class=dt>Main</span>             <span class=fl>100.0</span>   <span class=fl>97.2</span>
<span class=dt>CAF</span>         <span class=dt>GHC.IO.Handle.FD</span>   <span class=fl>0.0</span>    <span class=fl>1.8</span>


                                                      individual     inherited
<span class=dt>COST</span> <span class=dt>CENTRE</span> <span class=dt>MODULE</span>                  no<span class=fu>.</span>     entries  <span class=fu>%</span>time <span class=fu>%</span>alloc   <span class=fu>%</span>time <span class=fu>%</span>alloc

<span class=dt>MAIN</span>        <span class=dt>MAIN</span>                     <span class=dv>42</span>           <span class=dv>0</span>    <span class=fl>0.0</span>    <span class=fl>0.7</span>   <span class=fl>100.0</span>  <span class=fl>100.0</span>
 <span class=dt>CAF</span>        <span class=dt>Main</span>                     <span class=dv>83</span>           <span class=dv>0</span>  <span class=fl>100.0</span>   <span class=fl>97.2</span>   <span class=fl>100.0</span>   <span class=fl>97.2</span>
 <span class=dt>CAF</span>        <span class=dt>GHC.IO.Encoding</span>          <span class=dv>78</span>           <span class=dv>0</span>    <span class=fl>0.0</span>    <span class=fl>0.1</span>     <span class=fl>0.0</span>    <span class=fl>0.1</span>
 <span class=dt>CAF</span>        <span class=dt>GHC.IO.Handle.FD</span>         <span class=dv>77</span>           <span class=dv>0</span>    <span class=fl>0.0</span>    <span class=fl>1.8</span>     <span class=fl>0.0</span>    <span class=fl>1.8</span>
 <span class=dt>CAF</span>        <span class=dt>GHC.Conc.Signal</span>          <span class=dv>74</span>           <span class=dv>0</span>    <span class=fl>0.0</span>    <span class=fl>0.0</span>     <span class=fl>0.0</span>    <span class=fl>0.0</span>
 <span class=dt>CAF</span>        <span class=dt>GHC.IO.Encoding.Iconv</span>    <span class=dv>69</span>           <span class=dv>0</span>    <span class=fl>0.0</span>    <span class=fl>0.0</span>     <span class=fl>0.0</span>    <span class=fl>0.0</span>
 <span class=dt>CAF</span>        <span class=dt>GHC.Show</span>                 <span class=dv>60</span>           <span class=dv>0</span>    <span class=fl>0.0</span>    <span class=fl>0.0</span>     <span class=fl>0.0</span>    <span class=fl>0.0</span></code></pre></div>
<h1 id=languages><font>Languages</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<h2 id=unbound><font>unbound</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未绑定</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Several libraries exist to mechanize the process of writing name capture and substitution, since it is largely mechanical. Probably the most robust is the </font><code>unbound</code><font> library. For example we can implement the infer function for a small Hindley-Milner system over a simple typed lambda calculus without having to write the name capture and substitution mechanics ourselves.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>存在几个库来机械化编写名称捕获和替换的过程，因为它在很大程度上是机械的。可能最强大的是未绑定的库。例如，我们可以通过简单的类型化 lambda 演算为小型 Hindley-Milner 系统实现推断函数，而无需自己编写名称捕获和替换机制。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/30-languages/unbound.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE UndecidableInstances #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE OverloadedStrings #-}</span>

<span class=kw>module</span> <span class=dt>Infer</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Data.String</span>
<span class=kw>import </span><span class=dt>Data.Map</span> (<span class=dt>Map</span>)
<span class=kw>import </span><span class=dt>Control.Monad.Error</span>
<span class=kw>import qualified</span> <span class=dt>Data.Map</span> <span class=kw>as</span> <span class=dt>Map</span>

<span class=kw>import qualified</span> <span class=dt>Unbound.LocallyNameless</span> <span class=kw>as</span> <span class=dt>NL</span>
<span class=kw>import </span><span class=dt>Unbound.LocallyNameless</span> <span class=kw>hiding</span> (<span class=dt>Subst</span>, compose)

<span class=kw>data</span> <span class=dt>Type</span>
  <span class=fu>=</span> <span class=dt>TVar</span> (<span class=dt>Name</span> <span class=dt>Type</span>)
  <span class=fu>|</span> <span class=dt>TArr</span> <span class=dt>Type</span> <span class=dt>Type</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Var</span> (<span class=dt>Name</span> <span class=dt>Expr</span>)
  <span class=fu>|</span> <span class=dt>Lam</span> (<span class=dt>Bind</span> (<span class=dt>Name</span> <span class=dt>Expr</span>) <span class=dt>Expr</span>)
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Let</span> (<span class=dt>Bind</span> (<span class=dt>Name</span> <span class=dt>Expr</span>) <span class=dt>Expr</span>)
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=fu>$</span>(derive [<span class=ch>''</span><span class=dt>Type</span>, <span class=ch>''</span><span class=dt>Expr</span>])


<span class=kw>instance</span> <span class=dt>IsString</span> <span class=dt>Expr</span> <span class=kw>where</span>
    fromString <span class=fu>=</span> <span class=dt>Var</span> <span class=fu>.</span> fromString
<span class=kw>instance</span> <span class=dt>IsString</span> <span class=dt>Type</span> <span class=kw>where</span>
    fromString <span class=fu>=</span> <span class=dt>TVar</span> <span class=fu>.</span> fromString
<span class=kw>instance</span> <span class=dt>IsString</span> (<span class=dt>Name</span> <span class=dt>Expr</span>) <span class=kw>where</span>
    fromString <span class=fu>=</span> string2Name
<span class=kw>instance</span> <span class=dt>IsString</span> (<span class=dt>Name</span> <span class=dt>Type</span>) <span class=kw>where</span>
    fromString <span class=fu>=</span> string2Name

<span class=kw>instance</span> <span class=dt>Eq</span> <span class=dt>Type</span> <span class=kw>where</span>
    (<span class=fu>==</span>) <span class=fu>=</span> eqType

<span class=ot>eqType ::</span> <span class=dt>Type</span> <span class=ot>-&gt;</span> <span class=dt>Type</span> <span class=ot>-&gt;</span> <span class=dt>Bool</span>
eqType (<span class=dt>TVar</span> v1) (<span class=dt>TVar</span> v2) <span class=fu>=</span> v1 <span class=fu>==</span> v2
eqType _ _ <span class=fu>=</span> <span class=dt>False</span>

<span class=ot>uvar ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
uvar x <span class=fu>=</span> <span class=dt>Var</span> (s2n x)

<span class=ot>tvar ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Type</span>
tvar x <span class=fu>=</span> <span class=dt>TVar</span> (s2n x)

<span class=kw>instance</span> <span class=dt>Alpha</span> <span class=dt>Type</span>
<span class=kw>instance</span> <span class=dt>Alpha</span> <span class=dt>Expr</span>

<span class=kw>instance</span> <span class=dt>NL.Subst</span> <span class=dt>Type</span> <span class=dt>Type</span> <span class=kw>where</span>
  isvar (<span class=dt>TVar</span> v) <span class=fu>=</span> <span class=dt>Just</span> (<span class=dt>SubstName</span> v)
  isvar _ <span class=fu>=</span> <span class=dt>Nothing</span>

<span class=kw>instance</span> <span class=dt>NL.Subst</span> <span class=dt>Expr</span> <span class=dt>Expr</span> <span class=kw>where</span>
  isvar (<span class=dt>Var</span> v) <span class=fu>=</span> <span class=dt>Just</span> (<span class=dt>SubstName</span> v)
  isvar _ <span class=fu>=</span> <span class=dt>Nothing</span>

<span class=kw>instance</span> <span class=dt>NL.Subst</span> <span class=dt>Expr</span> <span class=dt>Type</span> <span class=kw>where</span>


<span class=kw>data</span> <span class=dt>TypeError</span>
  <span class=fu>=</span> <span class=dt>UnboundVariable</span> (<span class=dt>Name</span> <span class=dt>Expr</span>)
  <span class=fu>|</span> <span class=dt>GenericTypeError</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Error</span> <span class=dt>TypeError</span> <span class=kw>where</span>
  noMsg <span class=fu>=</span> <span class=dt>GenericTypeError</span>


<span class=kw>type</span> <span class=dt>Env</span> <span class=fu>=</span> <span class=dt>Map</span> (<span class=dt>Name</span> <span class=dt>Expr</span>) <span class=dt>Type</span>
<span class=kw>type</span> <span class=dt>Constraint</span> <span class=fu>=</span> (<span class=dt>Type</span>, <span class=dt>Type</span>)
<span class=kw>type</span> <span class=dt>Infer</span> <span class=fu>=</span> <span class=dt>ErrorT</span> <span class=dt>TypeError</span> <span class=dt>FreshM</span>

<span class=ot>empty ::</span> <span class=dt>Env</span>
empty <span class=fu>=</span> Map.empty

<span class=ot>freshtv ::</span> <span class=dt>Infer</span> <span class=dt>Type</span>
freshtv <span class=fu>=</span> <span class=kw>do</span>
  x <span class=ot>&lt;-</span> fresh <span class=st>"_t"</span>
  return <span class=fu>$</span> <span class=dt>TVar</span> x

<span class=ot>infer ::</span> <span class=dt>Env</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Infer</span> (<span class=dt>Type</span>, [<span class=dt>Constraint</span>])
infer env expr <span class=fu>=</span> <span class=kw>case</span> expr  <span class=kw>of</span>

  <span class=dt>Lam</span> b <span class=ot>-&gt;</span> <span class=kw>do</span>
    (n,e) <span class=ot>&lt;-</span> unbind b
    tv <span class=ot>&lt;-</span> freshtv
    <span class=kw>let</span> env' <span class=fu>=</span> Map.insert n tv env
    (t, cs) <span class=ot>&lt;-</span> infer env' e
    return (<span class=dt>TArr</span> tv t, cs)

  <span class=dt>App</span> e1 e2 <span class=ot>-&gt;</span> <span class=kw>do</span>
     (t1, cs1) <span class=ot>&lt;-</span> infer env e1
     (t2, cs2) <span class=ot>&lt;-</span> infer env e2
     tv <span class=ot>&lt;-</span> freshtv
     return (tv, (t1, <span class=dt>TArr</span> t2 tv) <span class=fu>:</span> cs1 <span class=fu>++</span> cs2)

  <span class=dt>Var</span> n <span class=ot>-&gt;</span> <span class=kw>do</span>
     <span class=kw>case</span> Map.lookup n env <span class=kw>of</span>
        <span class=dt>Nothing</span> <span class=ot>-&gt;</span> throwError <span class=fu>$</span> <span class=dt>UnboundVariable</span> n
        <span class=dt>Just</span> t  <span class=ot>-&gt;</span> return (t, [])

  <span class=dt>Let</span> b <span class=ot>-&gt;</span> <span class=kw>do</span>
     (n, e) <span class=ot>&lt;-</span> unbind b
     (tBody, csBody) <span class=ot>&lt;-</span> infer env e
     <span class=kw>let</span> env' <span class=fu>=</span> Map.insert n tBody env
     (t, cs) <span class=ot>&lt;-</span> infer env' e
     return (t, cs <span class=fu>++</span> csBody)</code></pre></div>
<h2 id=unbound-generics><font>unbound-generics</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未绑定泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Recently unbound was ported to use GHC.Generics instead of Template Haskell. The API is effectively the same, so for example a simple lambda calculus could be written as:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最近 unbound 被移植到使用 GHC.Generics 而不是 Template Haskell。 API 实际上是相同的，因此例如一个简单的 lambda 演算可以写成：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/30-languages/unbound-generics.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DeriveGeneric #-}</span>
<span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class=kw>module</span> <span class=dt>LC</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Unbound.Generics.LocallyNameless</span>
<span class=kw>import </span><span class=dt>Unbound.Generics.LocallyNameless.Internal.Fold</span> (toListOf)

<span class=kw>import </span><span class=dt>GHC.Generics</span>

<span class=kw>import </span><span class=dt>Data.Typeable</span> (<span class=dt>Typeable</span>)
<span class=kw>import </span><span class=dt>Data.Set</span> <span class=kw>as</span> <span class=dt>S</span>

<span class=kw>import </span><span class=dt>Control.Monad.Reader</span> (<span class=dt>Reader</span>, runReader)

<span class=kw>data</span> <span class=dt>Exp</span>
  <span class=fu>=</span> <span class=dt>Var</span> (<span class=dt>Name</span> <span class=dt>Exp</span>)
  <span class=fu>|</span> <span class=dt>Lam</span> (<span class=dt>Bind</span> (<span class=dt>Name</span> <span class=dt>Exp</span>) <span class=dt>Exp</span>)
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Exp</span> <span class=dt>Exp</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Generic</span>, <span class=dt>Typeable</span>)

<span class=kw>instance</span> <span class=dt>Alpha</span> <span class=dt>Exp</span>

<span class=kw>instance</span> <span class=dt>Subst</span> <span class=dt>Exp</span> <span class=dt>Exp</span> <span class=kw>where</span>
  isvar (<span class=dt>Var</span> x) <span class=fu>=</span> <span class=dt>Just</span> (<span class=dt>SubstName</span> x)
  isvar _       <span class=fu>=</span> <span class=dt>Nothing</span>

<span class=ot>fvSet ::</span> (<span class=dt>Alpha</span> a, <span class=dt>Typeable</span> b) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>S.Set</span> (<span class=dt>Name</span> b)
fvSet <span class=fu>=</span> S.fromList <span class=fu>.</span> toListOf fv

<span class=kw>type</span> <span class=dt>M</span> a <span class=fu>=</span> <span class=dt>FreshM</span> a

<span class=ot>(=~) ::</span> <span class=dt>Exp</span> <span class=ot>-&gt;</span> <span class=dt>Exp</span> <span class=ot>-&gt;</span> <span class=dt>M</span> <span class=dt>Bool</span>
e1 <span class=fu>=~</span> e2 <span class=fu>|</span> e1 <span class=ot>`aeq`</span> e2 <span class=fu>=</span> return <span class=dt>True</span>
e1 <span class=fu>=~</span> e2 <span class=fu>=</span> <span class=kw>do</span>
    e1' <span class=ot>&lt;-</span> red e1
    e2' <span class=ot>&lt;-</span> red e2
    <span class=kw>if</span> e1' <span class=ot>`aeq`</span> e1 <span class=fu>&amp;&amp;</span> e2' <span class=ot>`aeq`</span> e2
      <span class=kw>then</span> return <span class=dt>False</span>
      <span class=kw>else</span> e1' <span class=fu>=~</span> e2'

<span class=co>-- Reduction</span>
<span class=ot>red ::</span> <span class=dt>Exp</span> <span class=ot>-&gt;</span> <span class=dt>M</span> <span class=dt>Exp</span>
red (<span class=dt>App</span> e1 e2) <span class=fu>=</span> <span class=kw>do</span>
  e1' <span class=ot>&lt;-</span> red e1
  e2' <span class=ot>&lt;-</span> red e2
  <span class=kw>case</span> e1' <span class=kw>of</span>
    <span class=dt>Lam</span> bnd <span class=ot>-&gt;</span> <span class=kw>do</span>
        (x, e1'') <span class=ot>&lt;-</span> unbind bnd
        return <span class=fu>$</span> subst x e2' e1''
    otherwise <span class=ot>-&gt;</span> return <span class=fu>$</span> <span class=dt>App</span> e1' e2'
red (<span class=dt>Lam</span> bnd) <span class=fu>=</span> <span class=kw>do</span>
   (x, e) <span class=ot>&lt;-</span> unbind bnd
   e' <span class=ot>&lt;-</span> red e
   <span class=kw>case</span> e <span class=kw>of</span>
     <span class=dt>App</span> e1 (<span class=dt>Var</span> y) <span class=fu>|</span> y <span class=fu>==</span> x <span class=fu>&amp;&amp;</span> x <span class=ot>`S.notMember`</span> fvSet e1 <span class=ot>-&gt;</span> return e1
     otherwise <span class=ot>-&gt;</span> return (<span class=dt>Lam</span> (bind x e'))
red (<span class=dt>Var</span> x) <span class=fu>=</span> return <span class=fu>$</span> (<span class=dt>Var</span> x)


<span class=ot>x ::</span> <span class=dt>Name</span> <span class=dt>Exp</span>
x <span class=fu>=</span> string2Name <span class=st>"x"</span>

<span class=ot>y ::</span> <span class=dt>Name</span> <span class=dt>Exp</span>
y <span class=fu>=</span> string2Name <span class=st>"y"</span>

<span class=ot>z ::</span> <span class=dt>Name</span> <span class=dt>Exp</span>
z <span class=fu>=</span> string2Name <span class=st>"z"</span>

<span class=ot>s ::</span> <span class=dt>Name</span> <span class=dt>Exp</span>
s <span class=fu>=</span> string2Name <span class=st>"s"</span>

<span class=ot>lam ::</span> <span class=dt>Name</span> <span class=dt>Exp</span> <span class=ot>-&gt;</span> <span class=dt>Exp</span> <span class=ot>-&gt;</span> <span class=dt>Exp</span>
lam x y <span class=fu>=</span> <span class=dt>Lam</span> (bind x y)

zero  <span class=fu>=</span> lam s (lam z (<span class=dt>Var</span> z))
one   <span class=fu>=</span> lam s (lam z (<span class=dt>App</span> (<span class=dt>Var</span> s) (<span class=dt>Var</span> z)))
two   <span class=fu>=</span> lam s (lam z (<span class=dt>App</span> (<span class=dt>Var</span> s) (<span class=dt>App</span> (<span class=dt>Var</span> s) (<span class=dt>Var</span> z))))
three <span class=fu>=</span> lam s (lam z (<span class=dt>App</span> (<span class=dt>Var</span> s) (<span class=dt>App</span> (<span class=dt>Var</span> s) (<span class=dt>App</span> (<span class=dt>Var</span> s) (<span class=dt>Var</span> z)))))

plus <span class=fu>=</span> lam x (lam y (lam s (lam z (<span class=dt>App</span> (<span class=dt>App</span> (<span class=dt>Var</span> x) (<span class=dt>Var</span> s)) (<span class=dt>App</span> (<span class=dt>App</span> (<span class=dt>Var</span> y) (<span class=dt>Var</span> s)) (<span class=dt>Var</span> z))))))

true <span class=fu>=</span> lam x (lam y (<span class=dt>Var</span> x))
false <span class=fu>=</span> lam x (lam y (<span class=dt>Var</span> y))
if_ x y z <span class=fu>=</span> (<span class=dt>App</span> (<span class=dt>App</span> x y) z)

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> lam x (<span class=dt>Var</span> x) <span class=ot>`aeq`</span> lam y (<span class=dt>Var</span> y)
  print <span class=fu>$</span> not (lam x (<span class=dt>Var</span> y) <span class=ot>`aeq`</span> lam x (<span class=dt>Var</span> x))
  print <span class=fu>$</span> lam x (<span class=dt>App</span> (lam y (<span class=dt>Var</span> x)) (lam y (<span class=dt>Var</span> y))) <span class=fu>=~</span> (lam y (<span class=dt>Var</span> y))
  print <span class=fu>$</span> lam x (<span class=dt>App</span> (<span class=dt>Var</span> y) (<span class=dt>Var</span> x)) <span class=fu>=~</span> <span class=dt>Var</span> y
  print <span class=fu>$</span> if_ true (<span class=dt>Var</span> x) (<span class=dt>Var</span> y) <span class=fu>=~</span> <span class=dt>Var</span> x
  print <span class=fu>$</span> if_ false (<span class=dt>Var</span> x) (<span class=dt>Var</span> y) <span class=fu>=~</span> <span class=dt>Var</span> y
  print <span class=fu>$</span> <span class=dt>App</span> (<span class=dt>App</span> plus one) two <span class=fu>=~</span> three</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://github.com/lambdageek/unbound-generics>unbound-generics<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>未绑定泛型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=llvm-general><font>llvm-general</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>llvm-通用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>LLVM is a library for generating machine code. The llvm-general bindings provide a way to model, compile and execute LLVM bytecode from within the Haskell runtime.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>LLVM 是一个用于生成机器代码的库。 llvm-general 绑定提供了一种在 Haskell 运行时内建模、编译和执行 LLVM 字节码的方法。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/30-languages/llvm-general.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Standalone</span> <span class=kw>where</span>

<span class=co>-- Pretty Printer</span>
<span class=kw>import </span><span class=dt>LLVM.General.Pretty</span> (ppllvm)

<span class=co>-- AST</span>
<span class=kw>import qualified</span> <span class=dt>LLVM.General.AST</span> <span class=kw>as</span> <span class=dt>AST</span>
<span class=kw>import qualified</span> <span class=dt>LLVM.General.AST.Linkage</span> <span class=kw>as</span> <span class=dt>Linkage</span>
<span class=kw>import qualified</span> <span class=dt>LLVM.General.AST.Visibility</span> <span class=kw>as</span> <span class=dt>Visibility</span>
<span class=kw>import qualified</span> <span class=dt>LLVM.General.AST.CallingConvention</span> <span class=kw>as</span> <span class=dt>Convention</span>

<span class=kw>import </span><span class=dt>Data.Text.Lazy.IO</span> <span class=kw>as</span> <span class=dt>TIO</span>

<span class=ot>astModule ::</span> <span class=dt>AST.Module</span>
astModule <span class=fu>=</span> <span class=dt>AST.Module</span>
    { AST.moduleName         <span class=fu>=</span> <span class=st>"example-llvm-module"</span>
    , AST.moduleDataLayout   <span class=fu>=</span> <span class=dt>Nothing</span>
    , AST.moduleTargetTriple <span class=fu>=</span> <span class=dt>Nothing</span>
    , AST.moduleDefinitions  <span class=fu>=</span>
        [ <span class=dt>AST.GlobalDefinition</span>
            (<span class=dt>AST.Function</span>
                <span class=dt>Linkage.External</span>
                <span class=dt>Visibility.Default</span>
                <span class=dt>Nothing</span>
                <span class=dt>Convention.C</span>
                []
                (<span class=dt>AST.IntegerType</span> <span class=dv>8</span>)
                (<span class=dt>AST.Name</span> <span class=st>"f"</span>)
                ([<span class=dt>AST.Parameter</span> (<span class=dt>AST.IntegerType</span> <span class=dv>8</span>) (<span class=dt>AST.Name</span> <span class=st>"x"</span>) []], <span class=dt>False</span>)
                []
                <span class=dt>Nothing</span>
                <span class=dt>Nothing</span>
                <span class=dv>0</span>
                <span class=dt>Nothing</span>
                <span class=dt>Nothing</span>
                [ <span class=dt>AST.BasicBlock</span>
                    (<span class=dt>AST.Name</span> <span class=st>"entry"</span>)
                    []
                    (<span class=dt>AST.Do</span>
                        (<span class=dt>AST.Ret</span>
                            (<span class=dt>Just</span>
                                (<span class=dt>AST.LocalReference</span>
                                    (<span class=dt>AST.IntegerType</span> <span class=dv>8</span>)
                                    (<span class=dt>AST.Name</span> <span class=st>"x"</span>)
                                )
                            )
                            []
                        )
                    )
                ]
            )
        ]
    }

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> TIO.putStrLn (ppllvm astModule)</code></pre></div>
<p><font>Generates the following textual LLVM IR which can them be executed using the JIT in the </font><code>llvm-general</code><font> package or passed to the various llvm commandline utilities.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>生成以下文本 LLVM IR，它们可以使用 llvm-general 包中的 JIT 执行或传递给各种 llvm 命令行实用程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode llvm"><code class="sourceCode llvm"><span class=co>; ModuleID = 'example-llvm-module'</span>

<span class=kw>define</span> <span class=dt>i8</span> <span class=fu>@f</span>(<span class=dt>i8</span> <span class=fu>%x</span>){
<span class=fu>entry:</span>
  <span class=kw>ret</span> <span class=dt>i8</span> <span class=fu>%x</span>
}</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://github.com/sdiehl/llvm-tutorial-standalone>Minimal Example of LLVM Haskell JIT<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>LLVM Haskell JIT 的最小示例</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://smunix.github.io/www.stephendiehl.com/llvm/index.html>Implementing a JIT Compiled Language with Haskell and LLVM<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>使用 Haskell 和 LLVM 实现 JIT 编译语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=pretty><font>pretty</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>漂亮的</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Pretty printer combinators compose logic to print strings.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>漂亮的打印机组合器组合逻辑来打印字符串。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left></th>
<th align=left><font>Combinators</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>组合器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>&lt;&gt;<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>&lt;&gt;</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Concatenation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>级联</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>&lt;+&gt;<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>&lt;+&gt;</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Spaced concatenation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>间隔连接</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>char<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>字符</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Renders a character as a </font><code>Doc</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将角色呈现为 Doc</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>text<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>Renders a string as a </font><code>Doc</code><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将字符串呈现为 Doc</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<div class=sourceCode include=src/30-languages/pretty.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>

<span class=kw>import </span><span class=dt>Text.PrettyPrint</span>
<span class=kw>import </span><span class=dt>Text.Show.Pretty</span> (ppShow)

<span class=ot>parensIf ::</span>  <span class=dt>Bool</span> <span class=ot>-&gt;</span> <span class=dt>Doc</span> <span class=ot>-&gt;</span> <span class=dt>Doc</span>
parensIf <span class=dt>True</span> <span class=fu>=</span> parens
parensIf <span class=dt>False</span> <span class=fu>=</span> id

<span class=kw>type</span> <span class=dt>Name</span> <span class=fu>=</span> <span class=dt>String</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Var</span> <span class=dt>String</span>
  <span class=fu>|</span> <span class=dt>Lit</span> <span class=dt>Ground</span>
  <span class=fu>|</span> <span class=dt>App</span> <span class=dt>Expr</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Lam</span> <span class=dt>Name</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=kw>data</span> <span class=dt>Ground</span>
  <span class=fu>=</span> <span class=dt>LInt</span> <span class=dt>Int</span>
  <span class=fu>|</span> <span class=dt>LBool</span> <span class=dt>Bool</span>
  <span class=kw>deriving</span> (<span class=dt>Show</span>, <span class=dt>Eq</span>, <span class=dt>Ord</span>)


<span class=kw>class</span> <span class=dt>Pretty</span> p <span class=kw>where</span>
<span class=ot>  ppr ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> p <span class=ot>-&gt;</span> <span class=dt>Doc</span>

<span class=kw>instance</span> <span class=dt>Pretty</span> <span class=dt>String</span> <span class=kw>where</span>
  ppr _ x <span class=fu>=</span> text x

<span class=kw>instance</span> <span class=dt>Pretty</span> <span class=dt>Expr</span> <span class=kw>where</span>
  ppr _ (<span class=dt>Var</span> x)         <span class=fu>=</span> text x
  ppr _ (<span class=dt>Lit</span> (<span class=dt>LInt</span> a))  <span class=fu>=</span> text (show a)
  ppr _ (<span class=dt>Lit</span> (<span class=dt>LBool</span> b)) <span class=fu>=</span> text (show b)

  ppr p e<span class=fu>@</span>(<span class=dt>App</span> _ _) <span class=fu>=</span>
    <span class=kw>let</span> (f, xs) <span class=fu>=</span> viewApp e <span class=kw>in</span>
    <span class=kw>let</span> args <span class=fu>=</span> sep <span class=fu>$</span> map (ppr (p<span class=fu>+</span><span class=dv>1</span>)) xs <span class=kw>in</span>
    parensIf (p<span class=fu>&gt;</span><span class=dv>0</span>) <span class=fu>$</span> ppr p f <span class=fu>&lt;+&gt;</span> args

  ppr p e<span class=fu>@</span>(<span class=dt>Lam</span> _ _) <span class=fu>=</span>
    <span class=kw>let</span> body <span class=fu>=</span> ppr (p<span class=fu>+</span><span class=dv>1</span>) (viewBody e) <span class=kw>in</span>
    <span class=kw>let</span> vars <span class=fu>=</span> map (ppr <span class=dv>0</span>) (viewVars e) <span class=kw>in</span>
    parensIf (p<span class=fu>&gt;</span><span class=dv>0</span>) <span class=fu>$</span> char <span class=ch>'\\'</span> <span class=fu>&lt;&gt;</span> hsep vars <span class=fu>&lt;+&gt;</span> text <span class=st>"."</span> <span class=fu>&lt;+&gt;</span> body

<span class=ot>viewVars ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> [<span class=dt>Name</span>]
viewVars (<span class=dt>Lam</span> n a) <span class=fu>=</span> n <span class=fu>:</span> viewVars a
viewVars _ <span class=fu>=</span> []

<span class=ot>viewBody ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
viewBody (<span class=dt>Lam</span> _ a) <span class=fu>=</span> viewBody a
viewBody x <span class=fu>=</span> x

<span class=ot>viewApp ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> (<span class=dt>Expr</span>, [<span class=dt>Expr</span>])
viewApp (<span class=dt>App</span> e1 e2) <span class=fu>=</span> go e1 [e2]
  <span class=kw>where</span>
    go (<span class=dt>App</span> a b) xs <span class=fu>=</span> go a (b <span class=fu>:</span> xs)
    go f xs <span class=fu>=</span> (f, xs)

<span class=ot>ppexpr ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
ppexpr <span class=fu>=</span> render <span class=fu>.</span> ppr <span class=dv>0</span>


s, k,<span class=ot> example ::</span> <span class=dt>Expr</span>
s <span class=fu>=</span> <span class=dt>Lam</span> <span class=st>"f"</span> (<span class=dt>Lam</span> <span class=st>"g"</span> (<span class=dt>Lam</span> <span class=st>"x"</span> (<span class=dt>App</span> (<span class=dt>Var</span> <span class=st>"f"</span>) (<span class=dt>App</span> (<span class=dt>Var</span> <span class=st>"g"</span>) (<span class=dt>Var</span> <span class=st>"x"</span>)))))
k <span class=fu>=</span> <span class=dt>Lam</span> <span class=st>"x"</span> (<span class=dt>Lam</span> <span class=st>"y"</span> (<span class=dt>Var</span> <span class=st>"x"</span>))
example <span class=fu>=</span> <span class=dt>App</span> s k

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  putStrLn <span class=fu>$</span> ppexpr s
  putStrLn <span class=fu>$</span> ppShow example</code></pre></div>
<p><font>The pretty printed form of the </font><code>k</code><font> combinator:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>k 组合子的漂亮印刷形式：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">\f g x <span class=fu>.</span> (f (g x))</code></pre></div>
<p><font>The </font><code>Text.Show.Pretty</code><font> library can be used to pretty print nested data structures in a more human readable form for any type that implements </font><code>Show</code><font>. For example a dump of the structure for the AST of SK combinator with </font><code>ppShow</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>对于实现 Show 的任何类型，Text.Show.Pretty 库可用于以更易于阅读的形式漂亮地打印嵌套数据结构。例如，使用 ppShow 转储 SK 组合器的 AST 结构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>App</span>
  (<span class=dt>Lam</span>
     <span class=st>"f"</span> (<span class=dt>Lam</span> <span class=st>"g"</span> (<span class=dt>Lam</span> <span class=st>"x"</span> (<span class=dt>App</span> (<span class=dt>Var</span> <span class=st>"f"</span>) (<span class=dt>App</span> (<span class=dt>Var</span> <span class=st>"g"</span>) (<span class=dt>Var</span> <span class=st>"x"</span>))))))
  (<span class=dt>Lam</span> <span class=st>"x"</span> (<span class=dt>Lam</span> <span class=st>"y"</span> (<span class=dt>Var</span> <span class=st>"x"</span>)))</code></pre></div>
<p><font>Adding the following to your ghci.conf can be useful for working with deeply nested structures interactively.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>将以下内容添加到您的 ghci.conf 中对于以交互方式处理深层嵌套结构很有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Text.Show.Pretty</span> (ppShow)
<span class=kw>let</span> pprint x <span class=fu>=</span> putStrLn <span class=fu>$</span> ppShow x</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://belle.sourceforge.net/doc/hughes95design.pdf>The Design of a Pretty-printing Library<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>漂亮打印库的设计</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=wl-pprint-text><font>wl-pprint-text</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>wl-pprint-文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><code>wl-pprint-text</code><font> is a Wadler-style pretty printing library that uses Text builder objects for efficient generation under the hood. It exposes effectively the same interface as the String-based </font><code>pretty</code><font> library but is much more performant.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>wl-pprint-text 是一个 Wadler 风格的漂亮打印库，它使用文本构建器对象在后台高效生成。它有效地公开了与基于字符串的漂亮库相同的接口，但性能更高。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h5 id=combinators><font>Combinators</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>组合器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h5>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>renderPretty ::</span> <span class=dt>Float</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Doc</span> <span class=ot>-&gt;</span> <span class=dt>SimpleDoc</span>
<span class=ot>renderCompact ::</span> <span class=dt>Doc</span> <span class=ot>-&gt;</span> <span class=dt>SimpleDoc</span>
<span class=ot>renderOneLine ::</span> <span class=dt>Doc</span> <span class=ot>-&gt;</span> <span class=dt>SimpleDoc</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h4 id=monadic-api><font>Monadic API</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>单子 API</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h4>
<ul>
<li><a href=https://hackage.haskell.org/package/wl-pprint-text>wl-pprint-text<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>wl-pprint-文本</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=pretty-show><font>pretty-show</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>漂亮秀</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>TODO</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>去做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=haskeline><font>Haskeline</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哈士奇林</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskeline is cross-platform readline support which plays nice with GHCi as well.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskeline 是跨平台的 readline 支持，它也可以与 GHCi 配合使用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runInputT ::</span> <span class=dt>Settings</span> <span class=dt>IO</span> <span class=ot>-&gt;</span> <span class=dt>InputT</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a
<span class=ot>getInputLine ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>InputT</span> <span class=dt>IO</span> (<span class=dt>Maybe</span> <span class=dt>String</span>)</code></pre></div>
<div class=sourceCode include=src/30-languages/haskelline.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Monad.Trans</span>
<span class=kw>import </span><span class=dt>System.Console.Haskeline</span>

<span class=kw>type</span> <span class=dt>Repl</span> a <span class=fu>=</span> <span class=dt>InputT</span> <span class=dt>IO</span> a

<span class=ot>process ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()
process <span class=fu>=</span> putStrLn

<span class=ot>repl ::</span> <span class=dt>Repl</span> ()
repl <span class=fu>=</span> <span class=kw>do</span>
  minput <span class=ot>&lt;-</span> getInputLine <span class=st>"Repl&gt; "</span>
  <span class=kw>case</span> minput <span class=kw>of</span>
    <span class=dt>Nothing</span> <span class=ot>-&gt;</span> outputStrLn <span class=st>"Goodbye."</span>
    <span class=dt>Just</span> input <span class=ot>-&gt;</span> (liftIO <span class=fu>$</span> process input) <span class=fu>&gt;&gt;</span> repl

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> runInputT defaultSettings repl</code></pre></div>
<h2 id=repline><font>Repline</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>回复</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Certain sets of tasks in building command line REPL interfaces are so common that is becomes useful to abstract them out into a library. While haskeline provides a sensible lower-level API for interfacing with GNU readline, it is somewhat tedious to implement tab completion logic and common command logic over and over. To that end Repline assists in building interactive shells that that resemble GHCi's default behavior.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>构建命令行 REPL 界面的某些任务集非常常见，因此将它们抽象到一个库中非常有用。虽然 haskeline 为与 GNU readline 的接口提供了一个合理的低级 API，但一遍又一遍地实现制表符完成逻辑和通用命令逻辑有点乏味。为此，Repline 有助于构建类似于 GHCi 默认行为的交互式 shell。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/30-languages/repline.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>Main</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Control.Monad.Trans</span>
<span class=kw>import </span><span class=dt>System.Console.Repline</span>

<span class=kw>import </span><span class=dt>Data.List</span> (isPrefixOf)
<span class=kw>import </span><span class=dt>System.Process</span> (callCommand)

<span class=kw>type</span> <span class=dt>Repl</span> a <span class=fu>=</span> <span class=dt>HaskelineT</span> <span class=dt>IO</span> a

<span class=co>-- Evaluation : handle each line user inputs</span>
<span class=ot>cmd ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Repl</span> ()
cmd input <span class=fu>=</span> liftIO <span class=fu>$</span> print input

<span class=co>-- Tab Completion: return a completion for partial words entered</span>
<span class=ot>completer ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>WordCompleter</span> m
completer n <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> names <span class=fu>=</span> [<span class=st>"kirk"</span>, <span class=st>"spock"</span>, <span class=st>"mccoy"</span>]
  return <span class=fu>$</span> filter (isPrefixOf n) names

<span class=co>-- Commands</span>
<span class=ot>help ::</span> [<span class=dt>String</span>] <span class=ot>-&gt;</span> <span class=dt>Repl</span> ()
help args <span class=fu>=</span> liftIO <span class=fu>$</span> print <span class=fu>$</span> <span class=st>"Help: "</span> <span class=fu>++</span> show args

<span class=ot>say ::</span> [<span class=dt>String</span>] <span class=ot>-&gt;</span> <span class=dt>Repl</span> ()
say args <span class=fu>=</span> <span class=kw>do</span>
  _ <span class=ot>&lt;-</span> liftIO <span class=fu>$</span> callCommand <span class=fu>$</span> <span class=st>"cowsay"</span> <span class=fu>++</span> <span class=st>" "</span> <span class=fu>++</span> (unwords args)
  return ()

<span class=ot>options ::</span> [(<span class=dt>String</span>, [<span class=dt>String</span>] <span class=ot>-&gt;</span> <span class=dt>Repl</span> ())]
options <span class=fu>=</span> [
    (<span class=st>"help"</span>, help)  <span class=co>-- :help</span>
  , (<span class=st>"say"</span>, say)    <span class=co>-- :say</span>
  ]

<span class=ot>ini ::</span> <span class=dt>Repl</span> ()
ini <span class=fu>=</span> liftIO <span class=fu>$</span> putStrLn <span class=st>"Welcome!"</span>

<span class=ot>repl ::</span> <span class=dt>IO</span> ()
repl <span class=fu>=</span> evalRepl <span class=st>"&gt;&gt;&gt; "</span> cmd options (<span class=dt>Word0</span> completer) ini

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> repl</code></pre></div>
<p><font>Trying it out. (</font><code>&lt;TAB&gt;</code><font> indicates a user keypress )</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>尝试一下。 （&lt;TAB&gt; 表示用户按键）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class=kw>runhaskell</span> Simple.hs
<span class=co># Or if in a sandbox: cabal exec runhaskell Simple.hs</span>
<span class=kw>Welcome</span>!
<span class=kw>&gt;&gt;&gt;</span> <span class=kw>&lt;TAB&gt;</span>
<span class=kw>kirk</span> spock mccoy

<span class=kw>&gt;&gt;&gt;</span> <span class=kw>k&lt;</span>TAB<span class=kw>&gt;</span>
<span class=kw>kirk</span>

<span class=kw>&gt;&gt;&gt;</span> <span class=kw>spam</span>
<span class=st>"spam"</span>

<span class=kw>&gt;&gt;&gt;</span> :<span class=kw>say</span> Hello Haskell
 <span class=kw>_______________</span>
<span class=kw>&lt;</span> <span class=kw>Hello</span> Haskell <span class=kw>&gt;</span>
 <span class=kw>---------------</span>
        <span class=kw>\ </span>  ^__^
         <span class=kw>\ </span> (oo)\<span class=kw>_______</span>
            <span class=kw>(__)\ </span>      )\/<span class=kw>\</span>
                <span class=kw>||----w</span> <span class=kw>|</span>
                <span class=kw>||</span>     <span class=kw>||</span></code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=https://github.com/sdiehl/repline>repline<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>回复</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h1 id=template-haskell><font>Template Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of TemplateHaskell is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，TemplateHaskell 的知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h2 id=perils-of-metaprogramming><font>Perils of Metaprogramming</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>元编程的危险</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Template Haskell is a very powerful set of abstractions, some might say </font><strong>too</strong><font> powerful. It effectively allows us to run arbitrary code at compile-time to generate other Haskell code. You can some absolutely crazy things, like going off and reading from the filesystem or doing network calls that informs how your code compiles leading to non-deterministic builds.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>模板 Haskell 是一组非常强大的抽象，有些人可能会说太强大了。它有效地允许我们在编译时运行任意代码以生成其他 Haskell 代码。你可以做一些绝对疯狂的事情，比如离开并从文件系统读取或者进行网络调用来通知你的代码如何编译导致非确定性构建。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>While in some extreme cases TH is useful, some discretion is required when using this in production setting. TemplateHaskell can cause your build times to grow without bound, force you to manually sort all definitions your modules, and generally produce unmaintainable code. If you find yourself falling back on metaprogramming ask yourself, what in my abstractions has failed me such that my only option is to </font><em>write code that writes code</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>虽然在某些极端情况下 TH 很有用，但在生产环境中使用它时需要一些谨慎。 TemplateHaskell 会导致您的构建时间无限制地增长，迫使您手动对模块的所有定义进行排序，并且通常会产生无法维护的代码。如果您发现自己退回到元编程，问问自己，在我的抽象中有什么让我失望，以至于我唯一的选择是编写代码来编写代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class="alert alert-danger">
<p><font>Consideration should be used before enabling TemplateHaskell. Consider an idiomatic solution first.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在启用 TemplateHaskell 之前应考虑使用。首先考虑一个惯用的解决方案。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<h2 id=quasiquotation><font>Quasiquotation</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>准报价</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Quasiquotation allows us to express "quoted" blocks of syntax that need not necessarily be be the syntax of the host language, but unlike just writing a giant string it is instead parsed into some AST datatype in the host language. Notably values from the host languages can be injected into the custom language via user-definable logic allowing information to flow between the two languages.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Quasiquotation 允许我们表达“引用”的语法块，这些语法块不一定是宿主语言的语法，但与仅仅编写一个巨大的字符串不同，它被解析为宿主语言中的某种 AST 数据类型。值得注意的是，来自宿主语言的值可以通过用户可定义的逻辑注入到自定义语言中，从而允许信息在两种语言之间流动。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In practice quasiquotation can be used to implement custom domain specific languages or integrate with other general languages entirely via code-generation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在实践中，准引用可用于实现自定义域特定语言或完全通过代码生成与其他通用语言集成。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>We've already seen how to write a Parsec parser, now let's write a quasiquoter for it.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>我们已经了解了如何编写 Parsec 解析器，现在让我们为它编写一个准引用器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/Quasiquote.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>module</span> <span class=dt>Quasiquote</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Language.Haskell.TH</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH.Syntax</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH.Quote</span>

<span class=kw>import </span><span class=dt>Text.Parsec</span>
<span class=kw>import </span><span class=dt>Text.Parsec.String</span> (<span class=dt>Parser</span>)
<span class=kw>import </span><span class=dt>Text.Parsec.Language</span> (emptyDef)

<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Expr</span> <span class=kw>as</span> <span class=dt>Ex</span>
<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Token</span> <span class=kw>as</span> <span class=dt>Tok</span>

<span class=kw>import </span><span class=dt>Control.Monad.Identity</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Tr</span>
  <span class=fu>|</span> <span class=dt>Fl</span>
  <span class=fu>|</span> <span class=dt>Zero</span>
  <span class=fu>|</span> <span class=dt>Succ</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Pred</span> <span class=dt>Expr</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>)

<span class=kw>instance</span> <span class=dt>Lift</span> <span class=dt>Expr</span> <span class=kw>where</span>
  lift <span class=dt>Tr</span>         <span class=fu>=</span> [<span class=fu>|</span> <span class=dt>Tr</span> <span class=fu>|</span>]
  lift <span class=dt>Fl</span>         <span class=fu>=</span> [<span class=fu>|</span> <span class=dt>Tr</span> <span class=fu>|</span>]
  lift <span class=dt>Zero</span>       <span class=fu>=</span> [<span class=fu>|</span> <span class=dt>Zero</span> <span class=fu>|</span>]
  lift (<span class=dt>Succ</span> a)   <span class=fu>=</span> [<span class=fu>|</span> <span class=dt>Succ</span> a <span class=fu>|</span>]
  lift (<span class=dt>Pred</span> a)   <span class=fu>=</span> [<span class=fu>|</span> <span class=dt>Pred</span> a <span class=fu>|</span>]

<span class=kw>type</span> <span class=dt>Op</span> <span class=fu>=</span> <span class=dt>Ex.Operator</span> <span class=dt>String</span> () <span class=dt>Identity</span>

<span class=ot>lexer ::</span> <span class=dt>Tok.TokenParser</span> ()
lexer <span class=fu>=</span> Tok.makeTokenParser emptyDef

<span class=ot>parens ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
parens <span class=fu>=</span> Tok.parens lexer

<span class=ot>reserved ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> ()
reserved <span class=fu>=</span> Tok.reserved lexer

<span class=ot>semiSep ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> [a]
semiSep <span class=fu>=</span> Tok.semiSep lexer

<span class=ot>reservedOp ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> ()
reservedOp <span class=fu>=</span> Tok.reservedOp lexer

<span class=ot>prefixOp ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> <span class=dt>Op</span> a
prefixOp x f <span class=fu>=</span> <span class=dt>Ex.Prefix</span> (reservedOp x <span class=fu>&gt;&gt;</span> return f)

<span class=ot>table ::</span> [[<span class=dt>Op</span> <span class=dt>Expr</span>]]
table <span class=fu>=</span> [
    [ prefixOp <span class=st>"succ"</span> <span class=dt>Succ</span>
    , prefixOp <span class=st>"pred"</span> <span class=dt>Pred</span>
    ]
  ]

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> Ex.buildExpressionParser table factor

true, false,<span class=ot> zero ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
true  <span class=fu>=</span> reserved <span class=st>"true"</span> <span class=fu>&gt;&gt;</span> return <span class=dt>Tr</span>
false <span class=fu>=</span> reserved <span class=st>"false"</span> <span class=fu>&gt;&gt;</span> return <span class=dt>Fl</span>
zero  <span class=fu>=</span> reservedOp <span class=st>"0"</span> <span class=fu>&gt;&gt;</span> return <span class=dt>Zero</span>

<span class=ot>factor ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
factor <span class=fu>=</span>
      true
  <span class=fu>&lt;|&gt;</span> false
  <span class=fu>&lt;|&gt;</span> zero
  <span class=fu>&lt;|&gt;</span> parens expr

<span class=ot>contents ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
contents p <span class=fu>=</span> <span class=kw>do</span>
  Tok.whiteSpace lexer
  r <span class=ot>&lt;-</span> p
  eof
  return r

<span class=ot>toplevel ::</span> <span class=dt>Parser</span> [<span class=dt>Expr</span>]
toplevel <span class=fu>=</span> semiSep expr

<span class=ot>parseExpr ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>ParseError</span> <span class=dt>Expr</span>
parseExpr s <span class=fu>=</span> parse (contents expr) <span class=st>"&lt;stdin&gt;"</span> s

<span class=ot>parseToplevel ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>ParseError</span> [<span class=dt>Expr</span>]
parseToplevel s <span class=fu>=</span> parse (contents toplevel) <span class=st>"&lt;stdin&gt;"</span> s

<span class=ot>calcExpr ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Exp</span>
calcExpr str <span class=fu>=</span> <span class=kw>do</span>
  filename <span class=ot>&lt;-</span> loc_filename <span class=ot>`fmap`</span> location
  <span class=kw>case</span> parse (contents expr) filename str <span class=kw>of</span>
    <span class=dt>Left</span> err <span class=ot>-&gt;</span> error (show err)
    <span class=dt>Right</span> tag <span class=ot>-&gt;</span> [<span class=fu>|</span> tag <span class=fu>|</span>]

<span class=ot>calc ::</span> <span class=dt>QuasiQuoter</span>
calc <span class=fu>=</span> <span class=dt>QuasiQuoter</span> calcExpr err err err
  <span class=kw>where</span> err <span class=fu>=</span> error <span class=st>"Only defined for values"</span></code></pre></div>
<p><font>Testing it out:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>测试一下：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/quasiquote_use.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>

<span class=kw>import </span><span class=dt>Quasiquote</span>

<span class=ot>a ::</span> <span class=dt>Expr</span>
a <span class=fu>=</span> [calc<span class=fu>|</span>true<span class=fu>|</span>]
<span class=co>-- Tr</span>

<span class=ot>b ::</span> <span class=dt>Expr</span>
b <span class=fu>=</span> [calc<span class=fu>|</span>succ (succ <span class=dv>0</span>)<span class=fu>|</span>]
<span class=co>-- Succ (Succ Zero)</span>

<span class=ot>c ::</span> <span class=dt>Expr</span>
c <span class=fu>=</span> [calc<span class=fu>|</span>pred (succ <span class=dv>0</span>)<span class=fu>|</span>]
<span class=co>-- Pred (Succ Zero)</span></code></pre></div>
<p><font>One extremely important feature is the ability to preserve position information so that errors in the embedded language can be traced back to the line of the host syntax.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>一个极其重要的特性是能够保留位置信息，以便可以将嵌入式语言中的错误追溯到宿主语法行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=language-c-quote><font>language-c-quote</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>语言-c-引用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Of course since we can provide an arbitrary parser for the quoted expression, one might consider embedding the AST of another language entirely. For example C or CUDA C.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，由于我们可以为引用的表达式提供任意解析器，因此可以考虑完全嵌入另一种语言的 AST。例如 C 或 CUDA C。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>hello ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>C.Func</span>
hello msg <span class=fu>=</span> [cfun<span class=fu>|</span>

int main(int argc, const char <span class=fu>*</span>argv[])
{
    printf(<span class=fu>$</span>msg);
    return <span class=dv>0</span>;
}

<span class=fu>|</span>]</code></pre></div>
<p><font>Evaluating this we get back an AST representation of the quoted C program which we can manipulate or print back out to textual C code using </font><code>ppr</code><font> function.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>评估这个我们得到引用的 C 程序的 AST 表示，我们可以使用 ppr 函数操作或打印回文本 C 代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Func</span>
  (<span class=dt>DeclSpec</span> [] [] (<span class=dt>Tint</span> <span class=dt>Nothing</span>))
  (<span class=dt>Id</span> <span class=st>"main"</span>)
  <span class=dt>DeclRoot</span>
  (<span class=dt>Params</span>
     [ <span class=dt>Param</span> (<span class=dt>Just</span> (<span class=dt>Id</span> <span class=st>"argc"</span>)) (<span class=dt>DeclSpec</span> [] [] (<span class=dt>Tint</span> <span class=dt>Nothing</span>)) <span class=dt>DeclRoot</span>
     , <span class=dt>Param</span>
         (<span class=dt>Just</span> (<span class=dt>Id</span> <span class=st>"argv"</span>))
         (<span class=dt>DeclSpec</span> [] [ <span class=dt>Tconst</span> ] (<span class=dt>Tchar</span> <span class=dt>Nothing</span>))
         (<span class=dt>Array</span> [] <span class=dt>NoArraySize</span> (<span class=dt>Ptr</span> [] <span class=dt>DeclRoot</span>))
     ]
     <span class=dt>False</span>)
  [ <span class=dt>BlockStm</span>
      (<span class=dt>Exp</span>
         (<span class=dt>Just</span>
            (<span class=dt>FnCall</span>
               (<span class=dt>Var</span> (<span class=dt>Id</span> <span class=st>"printf"</span>))
               [ <span class=dt>Const</span> (<span class=dt>StringConst</span> [ <span class=st>"\"Hello Haskell!\""</span> ] <span class=st>"Hello Haskell!"</span>)
               ])))
  , <span class=dt>BlockStm</span> (<span class=dt>Return</span> (<span class=dt>Just</span> (<span class=dt>Const</span> (<span class=dt>IntConst</span> <span class=st>"0"</span> <span class=dt>Signed</span> <span class=dv>0</span>))))
  ]</code></pre></div>
<p><font>In this example we just spliced in the anti-quoted Haskell string in the printf statement, but we can pass many other values to and from the quoted expressions including identifiers, numbers, and other quoted expressions which implement the </font><code>Lift</code><font> type class.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在这个例子中，我们只是在 printf 语句中拼接了反引号的 Haskell 字符串，但我们可以将许多其他值传递给引用表达式，包括标识符、数字和其他实现 Lift 类型类的引用表达式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example now if we wanted programmatically generate the source for a CUDA kernel to run on a GPU we can switch over the CUDA C dialect to emit the C code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，现在如果我们想以编程方式生成 CUDA 内核的源代码以在 GPU 上运行，我们可以切换 CUDA C 方言以发出 C 代码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/cquote.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>import </span><span class=dt>Text.PrettyPrint.Mainland</span>
<span class=kw>import qualified</span> <span class=dt>Language.C.Syntax</span> <span class=kw>as</span> <span class=dt>C</span>
<span class=kw>import qualified</span> <span class=dt>Language.C.Quote.CUDA</span> <span class=kw>as</span> <span class=dt>Cuda</span>

<span class=ot>cuda_fun ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Float</span> <span class=ot>-&gt;</span> <span class=dt>C.Func</span>
cuda_fun fn n a <span class=fu>=</span> [Cuda.cfun<span class=fu>|</span>

__global__ void <span class=fu>$</span>id<span class=fu>:</span>fn (float <span class=fu>*</span>x, float <span class=fu>*</span>y) {
  int i <span class=fu>=</span> blockIdx<span class=fu>.</span>x<span class=fu>*</span>blockDim<span class=fu>.</span>x <span class=fu>+</span> threadIdx<span class=fu>.</span>x;
  <span class=kw>if</span> ( i<span class=fu>&lt;$</span>n ) { y[i] <span class=fu>=</span> <span class=fu>$</span>a<span class=fu>*</span>x[i] <span class=fu>+</span> y[i]; }
}

<span class=fu>|</span>]

<span class=ot>cuda_driver ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>C.Func</span>
cuda_driver fn n <span class=fu>=</span> [Cuda.cfun<span class=fu>|</span>

void driver (float <span class=fu>*</span>x, float <span class=fu>*</span>y) {
  float <span class=fu>*</span>d_x, <span class=fu>*</span>d_y;

  cudaMalloc(<span class=fu>&amp;</span>d_x, <span class=fu>$</span>n<span class=fu>*</span>sizeof(float));
  cudaMalloc(<span class=fu>&amp;</span>d_y, <span class=fu>$</span>n<span class=fu>*</span>sizeof(float));

  cudaMemcpy(d_x, x, <span class=fu>$</span>n, cudaMemcpyHostToDevice);
  cudaMemcpy(d_y, y, <span class=fu>$</span>n, cudaMemcpyHostToDevice);

  <span class=fu>$</span>id<span class=fu>:</span>fn<span class=fu>&lt;&lt;&lt;</span>(<span class=fu>$</span>n<span class=fu>+</span><span class=dv>255</span>)<span class=fu>/</span><span class=dv>256</span>, <span class=dv>256</span><span class=fu>&gt;&gt;&gt;</span>(d_x, d_y);

  cudaFree(d_x);
  cudaFree(d_y);
  return <span class=dv>0</span>;
}

<span class=fu>|</span>]

<span class=ot>makeKernel ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Float</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> [<span class=dt>C.Func</span>]
makeKernel fn a n <span class=fu>=</span> [
    cuda_fun fn n a
  , cuda_driver fn n
  ]

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> ker <span class=fu>=</span> makeKernel <span class=st>"saxpy"</span> <span class=dv>2</span> <span class=dv>65536</span>
  mapM_ (print <span class=fu>.</span> ppr) ker</code></pre></div>
<p><font>Running this we generate:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>运行这个我们生成：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode cpp"><code class="sourceCode cpp">__global__ <span class=dt>void</span> saxpy(<span class=dt>float</span>* x, <span class=dt>float</span>* y)
{
    <span class=dt>int</span> i = blockIdx.x * blockDim.x + threadIdx.x;

    <span class=kw>if</span> (i &lt; <span class=dv>65536</span>) {
        y[i] = <span class=fl>2.0</span> * x[i] + y[i];
    }
}
<span class=dt>int</span> driver(<span class=dt>float</span>* x, <span class=dt>float</span>* y)
{
    <span class=dt>float</span>* d_x, * d_y;

    cudaMalloc(&amp;d_x, <span class=dv>65536</span> * <span class=kw>sizeof</span>(<span class=dt>float</span>));
    cudaMalloc(&amp;d_y, <span class=dv>65536</span> * <span class=kw>sizeof</span>(<span class=dt>float</span>));
    cudaMemcpy(d_x, x, <span class=dv>65536</span>, cudaMemcpyHostToDevice);
    cudaMemcpy(d_y, y, <span class=dv>65536</span>, cudaMemcpyHostToDevice);
    saxpy&lt;&lt;&lt;(<span class=dv>65536</span> + <span class=dv>255</span>) / <span class=dv>256</span>, <span class=dv>256</span>&gt;&gt;&gt;(d_x, d_y);
    <span class=kw>return</span> <span class=dv>0</span>;
}</code></pre></div>
<p><font>Run the resulting output through </font><code>nvcc -ptx -c</code><font> to get the PTX associated with the outputted code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通过 nvcc -ptx -c 运行生成的输出以获取与输出代码关联的 PTX。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=template-haskell-1><font>Template Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板 Haskell</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Of course the most useful case of quasiquotation is the ability to procedurally generate Haskell code itself from inside of Haskell. The </font><code>template-haskell</code><font> framework provides four entry points for the quotation to generate various types of Haskell declarations and expressions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，准引用最有用的情况是能够从 Haskell 内部按程序生成 Haskell 代码本身。 template-haskell 框架提供了四个入口点供引用生成各种类型的Haskell 声明和表达式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Type</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Quasiquoted</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>准引用</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Class</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>班级</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><code>Q Exp<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Q指数</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>[e| ... |]<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>[e| ... |]</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>expression</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>表达</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>Q Pat<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>问帕特</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>[p| ... |]<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>[p| ... |]</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>pattern</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>图案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=odd>
<td align=left><code>Q Type<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Q型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>[t| ... |]<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>[吨| ... |]</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>type</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类型</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
<tr class=even>
<td align=left><code>Q [Dec]<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>问 [十二月]</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><code>[d| ... |]<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>[d| ... |]</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></code></td>
<td align=left><font>declaration</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>宣言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
</tr>
</tbody>
</table>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>QuasiQuoter</span> <span class=fu>=</span> <span class=dt>QuasiQuoter</span>
  {<span class=ot> quoteExp  ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Exp</span>
  ,<span class=ot> quotePat  ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Pat</span>
  ,<span class=ot> quoteType ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Type</span>
  ,<span class=ot> quoteDec  ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> [<span class=dt>Dec</span>]
  }</code></pre></div>
<p><font>The logic evaluating, splicing, and introspecting compile-time values is embedded within the Q monad, which has a </font><code>runQ</code><font> which can be used to evaluate its context. These functions of this monad is deeply embedded in the implementation of GHC.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>逻辑评估、拼接和内省编译时值嵌入在 Q monad 中，它有一个 runQ 可用于评估其上下文。这个 monad 的这些功能深深嵌入到 GHC 的实现中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>runQ ::</span> <span class=dt>Quasi</span> m <span class=ot>=&gt;</span> <span class=dt>Q</span> a <span class=ot>-&gt;</span> m a
<span class=ot>runIO ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>Q</span> a</code></pre></div>
<p><font>Just as before, TemplateHaskell provides the ability to lift Haskell values into the their AST quantities within the quoted expression using the Lift type class.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>和以前一样，TemplateHaskell 提供了使用 Lift 类型类将 Haskell 值提升到引用表达式中的 AST 数量的能力。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>class</span> <span class=dt>Lift</span> t <span class=kw>where</span>
<span class=ot>  lift ::</span> t <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Exp</span>

<span class=kw>instance</span> <span class=dt>Lift</span> <span class=dt>Integer</span> <span class=kw>where</span>
  lift x <span class=fu>=</span> return (<span class=dt>LitE</span> (<span class=dt>IntegerL</span> x))

<span class=kw>instance</span> <span class=dt>Lift</span> <span class=dt>Int</span> <span class=kw>where</span>
  lift x<span class=fu>=</span> return (<span class=dt>LitE</span> (<span class=dt>IntegerL</span> (fromIntegral x)))

<span class=kw>instance</span> <span class=dt>Lift</span> <span class=dt>Char</span> <span class=kw>where</span>
  lift x <span class=fu>=</span> return (<span class=dt>LitE</span> (<span class=dt>CharL</span> x))

<span class=kw>instance</span> <span class=dt>Lift</span> <span class=dt>Bool</span> <span class=kw>where</span>
  lift <span class=dt>True</span>  <span class=fu>=</span> return (<span class=dt>ConE</span> trueName)
  lift <span class=dt>False</span> <span class=fu>=</span> return (<span class=dt>ConE</span> falseName)

<span class=kw>instance</span> <span class=dt>Lift</span> a <span class=ot>=&gt;</span> <span class=dt>Lift</span> (<span class=dt>Maybe</span> a) <span class=kw>where</span>
  lift <span class=dt>Nothing</span>  <span class=fu>=</span> return (<span class=dt>ConE</span> nothingName)
  lift (<span class=dt>Just</span> x) <span class=fu>=</span> liftM (<span class=dt>ConE</span> justName <span class=ot>`AppE`</span>) (lift x)

<span class=kw>instance</span> <span class=dt>Lift</span> a <span class=ot>=&gt;</span> <span class=dt>Lift</span> [a] <span class=kw>where</span>
  lift xs <span class=fu>=</span> <span class=kw>do</span> { xs' <span class=ot>&lt;-</span> mapM lift xs; return (<span class=dt>ListE</span> xs') }</code></pre></div>
<p><font>In many cases Template Haskell can be used interactively to explore the AST form of various Haskell syntax.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在许多情况下，Template Haskell 可以交互式地用于探索各种 Haskell 语法的 AST 形式。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> runQ [e<span class=fu>|</span> \x <span class=ot>-&gt;</span> x <span class=fu>|</span>]
<span class=dt>LamE</span> [<span class=dt>VarP</span> x_2] (<span class=dt>VarE</span> x_2)

λ<span class=fu>:</span> runQ [d<span class=fu>|</span> <span class=kw>data</span> <span class=dt>Nat</span> <span class=fu>=</span> <span class=dt>Z</span> <span class=fu>|</span> <span class=dt>S</span> <span class=dt>Nat</span> <span class=fu>|</span>]
[<span class=dt>DataD</span> [] <span class=dt>Nat_0</span> [] [<span class=dt>NormalC</span> <span class=dt>Z_2</span> [],<span class=dt>NormalC</span> <span class=dt>S_1</span> [(<span class=dt>NotStrict</span>,<span class=dt>ConT</span> <span class=dt>Nat_0</span>)]] []]

λ<span class=fu>:</span> runQ [p<span class=fu>|</span> <span class=dt>S</span> (<span class=dt>S</span> <span class=dt>Z</span>)<span class=fu>|</span>]
<span class=dt>ConP</span> <span class=dt>Singleton.S</span> [<span class=dt>ConP</span> <span class=dt>Singleton.S</span> [<span class=dt>ConP</span> <span class=dt>Singleton.Z</span> []]]

λ<span class=fu>:</span> runQ [t<span class=fu>|</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> [<span class=dt>Int</span>] <span class=fu>|</span>]
<span class=dt>AppT</span> (<span class=dt>AppT</span> <span class=dt>ArrowT</span> (<span class=dt>ConT</span> <span class=dt>GHC.Types.Int</span>)) (<span class=dt>AppT</span> <span class=dt>ListT</span> (<span class=dt>ConT</span> <span class=dt>GHC.Types.Int</span>))

λ<span class=fu>:</span> <span class=kw>let</span> g <span class=fu>=</span> <span class=fu>$</span>(runQ [<span class=fu>|</span> \x <span class=ot>-&gt;</span> x <span class=fu>|</span>])

λ<span class=fu>:</span> g <span class=dv>3</span>
<span class=dv>3</span></code></pre></div>
<p><font>Using </font><a href=http://hackage.haskell.org/package/template-haskell-2.4.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec>Language.Haskell.TH</a><font> we can piece together Haskell AST element by element but subject to our own custom logic to generate the code. This can be somewhat painful though as the source-language (called </font><code>HsSyn</code><font>) to Haskell is enormous, consisting of around 100 nodes in its AST many of which are dependent on the state of language pragmas.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>使用 Language.Haskell.TH 我们可以将 Haskell AST 元素逐个拼凑起来，但要遵循我们自己的自定义逻辑来生成代码。这可能有些痛苦，因为 Haskell 的源语言（称为 HsSyn）非常庞大，其 AST 中包含大约 100 个节点，其中许多节点依赖于语言编译指示的状态。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=co>-- builds the function (f = \(a,b) -&gt; a)</span>
<span class=ot>f ::</span> <span class=dt>Q</span> [<span class=dt>Dec</span>]
f <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> f <span class=fu>=</span> mkName <span class=st>"f"</span>
  a <span class=ot>&lt;-</span> newName <span class=st>"a"</span>
  b <span class=ot>&lt;-</span> newName <span class=st>"b"</span>
  return [ <span class=dt>FunD</span> f [ <span class=dt>Clause</span> [<span class=dt>TupP</span> [<span class=dt>VarP</span> a, <span class=dt>VarP</span> b]] (<span class=dt>NormalB</span> (<span class=dt>VarE</span> a)) [] ] ]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>my_id ::</span> a <span class=ot>-&gt;</span> a
my_id x <span class=fu>=</span> <span class=fu>$</span>( [<span class=fu>|</span> x <span class=fu>|</span>] )

main <span class=fu>=</span> print (my_id <span class=st>"Hello Haskell!"</span>)</code></pre></div>
<p><font>As a debugging tool it is useful to be able to dump the reified information out for a given symbol interactively, to do so there is a simple little hack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>作为调试工具，能够以交互方式为给定符号转储具体信息是很有用的，为此有一个简单的小技巧。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/template_info.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>import </span><span class=dt>Text.Show.Pretty</span> (ppShow)
<span class=kw>import </span><span class=dt>Language.Haskell.TH</span>

<span class=ot>introspect ::</span> <span class=dt>Name</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Exp</span>
introspect n <span class=fu>=</span> <span class=kw>do</span>
  t <span class=ot>&lt;-</span> reify n
  runIO <span class=fu>$</span> putStrLn <span class=fu>$</span> ppShow t
  [<span class=fu>|</span> return () <span class=fu>|</span>]</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class=fu>:</span> <span class=fu>$</span>(introspect <span class=ch>'id)</span>
<span class=dt>VarI</span>
  GHC.Base.id
  (<span class=dt>ForallT</span>
     [ <span class=dt>PlainTV</span> a_1627405383 ]
     []
     (<span class=dt>AppT</span> (<span class=dt>AppT</span> <span class=dt>ArrowT</span> (<span class=dt>VarT</span> a_1627405383)) (<span class=dt>VarT</span> a_1627405383)))
  <span class=dt>Nothing</span>
  (<span class=dt>Fixity</span> <span class=dv>9</span> <span class=dt>InfixL</span>)


λ<span class=fu>:</span> <span class=fu>$</span>(introspect <span class=ch>''</span><span class=dt>Maybe</span>)
<span class=dt>TyConI</span>
  (<span class=dt>DataD</span>
     []
     <span class=dt>Data.Maybe.Maybe</span>
     [ <span class=dt>PlainTV</span> a_1627399528 ]
     [ <span class=dt>NormalC</span> <span class=dt>Data.Maybe.Nothing</span> []
     , <span class=dt>NormalC</span> <span class=dt>Data.Maybe.Just</span> [ ( <span class=dt>NotStrict</span> , <span class=dt>VarT</span> a_1627399528 ) ]
     ]
     [])</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Language.Haskell.TH</span>

<span class=ot>foo ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span>
foo x <span class=fu>=</span> x <span class=fu>+</span> <span class=dv>1</span>

<span class=kw>data</span> <span class=dt>Bar</span>

<span class=ot>fooInfo ::</span> <span class=dt>InfoQ</span>
fooInfo <span class=fu>=</span> reify <span class=ch>'foo</span>

<span class=ot>barInfo ::</span> <span class=dt>InfoQ</span>
barInfo <span class=fu>=</span> reify <span class=ch>''</span><span class=dt>Bar</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span>( [d<span class=fu>|</span> <span class=kw>data</span> <span class=dt>T</span> <span class=fu>=</span> <span class=dt>T1</span> <span class=fu>|</span> <span class=dt>T2</span> <span class=fu>|</span>] )

main <span class=fu>=</span> print [<span class=dt>T1</span>, <span class=dt>T2</span>]</code></pre></div>
<p><font>Splices are indicated by </font><code>$(f)</code><font> syntax for the expression level and at the toplevel simply by invocation of the template Haskell function. Running GHC with </font><code>-ddump-splices</code><font> shows our code being spliced in at the specific location in the AST at compile-time.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>拼接由表达式级别的 $(f) 语法指示，在顶层仅通过调用模板 Haskell 函数来指示。使用 -ddump-splices 运行 GHC 显示我们的代码在编译时被拼接在 AST 的特定位置。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=fu>$</span>(f)

template_haskell_show<span class=fu>.</span>hs<span class=fu>:</span><span class=dv>1</span><span class=fu>:</span><span class=dv>1</span><span class=fu>:</span> <span class=dt>Splicing</span> declarations
    f
  <span class=fu>======&gt;</span>
    template_haskell_show<span class=fu>.</span>hs<span class=fu>:</span><span class=dv>8</span><span class=fu>:</span><span class=dv>3</span><span class=fu>-</span><span class=dv>10</span>
    f (a_a5bd, b_a5be) <span class=fu>=</span> a_a5bd</code></pre></div>
<div class=sourceCode include=src/31-template-haskell/Splice.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>module</span> <span class=dt>Splice</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Language.Haskell.TH</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH.Syntax</span>

<span class=ot>spliceF ::</span> <span class=dt>Q</span> [<span class=dt>Dec</span>]
spliceF <span class=fu>=</span> <span class=kw>do</span>
  <span class=kw>let</span> f <span class=fu>=</span> mkName <span class=st>"f"</span>
  a <span class=ot>&lt;-</span> newName <span class=st>"a"</span>
  b <span class=ot>&lt;-</span> newName <span class=st>"b"</span>
  return [ <span class=dt>FunD</span> f [ <span class=dt>Clause</span> [<span class=dt>VarP</span> a, <span class=dt>VarP</span> b] (<span class=dt>NormalB</span> (<span class=dt>VarE</span> a)) [] ] ]

<span class=ot>spliceG ::</span> <span class=dt>Lift</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Q</span> [<span class=dt>Dec</span>]
spliceG n <span class=fu>=</span> runQ [d<span class=fu>|</span> g a <span class=fu>=</span> n <span class=fu>|</span>]</code></pre></div>
<div class=sourceCode include=src/31-template-haskell/Insert.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>import </span><span class=dt>Splice</span>

spliceF
spliceG <span class=st>"argument"</span>

main <span class=fu>=</span> <span class=kw>do</span>
  print <span class=fu>$</span> f <span class=dv>1</span> <span class=dv>2</span>
  print <span class=fu>$</span> g ()</code></pre></div>
<p><font>At the point of the splice all variables and types used must be in scope, so it must appear after their declarations in the module. As a result we often have to mentally topologically sort our code when using TemplateHaskell such that declarations are defined in order.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在拼接点，使用的所有变量和类型都必须在范围内，因此它必须出现在它们在模块中的声明之后。因此，在使用 TemplateHaskell 时，我们经常不得不在头脑中对代码进行拓扑排序，以便按顺序定义声明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Exp>Template Haskell AST</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：模板 Haskell AST</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=antiquotation><font>Antiquotation</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>反报价</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Extending our quasiquotation from above now that we have TemplateHaskell machinery we can implement the same class of logic that it uses to pass Haskell values in and pull Haskell values out via pattern matching on templated expressions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>现在我们有了 TemplateHaskell 机制，从上面扩展我们的准引用，我们可以实现相同的逻辑类，它用于通过模板表达式上的模式匹配将 Haskell 值传入和拉出 Haskell 值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/Antiquote.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>
<span class=ot>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class=kw>module</span> <span class=dt>Antiquote</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Data.Generics</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH.Quote</span>

<span class=kw>import </span><span class=dt>Text.Parsec</span>
<span class=kw>import </span><span class=dt>Text.Parsec.String</span> (<span class=dt>Parser</span>)
<span class=kw>import </span><span class=dt>Text.Parsec.Language</span> (emptyDef)

<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Expr</span> <span class=kw>as</span> <span class=dt>Ex</span>
<span class=kw>import qualified</span> <span class=dt>Text.Parsec.Token</span> <span class=kw>as</span> <span class=dt>Tok</span>

<span class=kw>data</span> <span class=dt>Expr</span>
  <span class=fu>=</span> <span class=dt>Tr</span>
  <span class=fu>|</span> <span class=dt>Fl</span>
  <span class=fu>|</span> <span class=dt>Zero</span>
  <span class=fu>|</span> <span class=dt>Succ</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Pred</span> <span class=dt>Expr</span>
  <span class=fu>|</span> <span class=dt>Antiquote</span> <span class=dt>String</span>
  <span class=kw>deriving</span> (<span class=dt>Eq</span>, <span class=dt>Show</span>, <span class=dt>Data</span>, <span class=dt>Typeable</span>)

<span class=ot>lexer ::</span> <span class=dt>Tok.TokenParser</span> ()
lexer <span class=fu>=</span> Tok.makeTokenParser emptyDef

<span class=ot>parens ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
parens <span class=fu>=</span> Tok.parens lexer

<span class=ot>reserved ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> ()
reserved <span class=fu>=</span> Tok.reserved lexer

<span class=ot>identifier ::</span> <span class=dt>Parser</span> <span class=dt>String</span>
identifier <span class=fu>=</span> Tok.identifier lexer

<span class=ot>semiSep ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> [a]
semiSep <span class=fu>=</span> Tok.semiSep lexer

<span class=ot>reservedOp ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Parser</span> ()
reservedOp <span class=fu>=</span> Tok.reservedOp lexer

oper s f assoc <span class=fu>=</span> <span class=dt>Ex.Prefix</span> (reservedOp s <span class=fu>&gt;&gt;</span> return f)

table <span class=fu>=</span> [ oper <span class=st>"succ"</span> <span class=dt>Succ</span> <span class=dt>Ex.AssocLeft</span>
        , oper <span class=st>"pred"</span> <span class=dt>Pred</span> <span class=dt>Ex.AssocLeft</span>
        ]

<span class=ot>expr ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
expr <span class=fu>=</span> Ex.buildExpressionParser [table] factor

true, false,<span class=ot> zero ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
true  <span class=fu>=</span> reserved <span class=st>"true"</span> <span class=fu>&gt;&gt;</span> return <span class=dt>Tr</span>
false <span class=fu>=</span> reserved <span class=st>"false"</span> <span class=fu>&gt;&gt;</span> return <span class=dt>Fl</span>
zero  <span class=fu>=</span> reservedOp <span class=st>"0"</span> <span class=fu>&gt;&gt;</span> return <span class=dt>Zero</span>

<span class=ot>antiquote ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
antiquote <span class=fu>=</span> <span class=kw>do</span>
  char <span class=ch>'$'</span>
  var <span class=ot>&lt;-</span> identifier
  return <span class=fu>$</span> <span class=dt>Antiquote</span> var

<span class=ot>factor ::</span> <span class=dt>Parser</span> <span class=dt>Expr</span>
factor <span class=fu>=</span> true
      <span class=fu>&lt;|&gt;</span> false
      <span class=fu>&lt;|&gt;</span> zero
      <span class=fu>&lt;|&gt;</span> antiquote
      <span class=fu>&lt;|&gt;</span> parens expr

<span class=ot>contents ::</span> <span class=dt>Parser</span> a <span class=ot>-&gt;</span> <span class=dt>Parser</span> a
contents p <span class=fu>=</span> <span class=kw>do</span>
  Tok.whiteSpace lexer
  r <span class=ot>&lt;-</span> p
  eof
  return r

<span class=ot>parseExpr ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Either</span> <span class=dt>ParseError</span> <span class=dt>Expr</span>
parseExpr s <span class=fu>=</span> parse (contents expr) <span class=st>"&lt;stdin&gt;"</span> s


<span class=kw>class</span> <span class=dt>Expressible</span> a <span class=kw>where</span>
<span class=ot>  express ::</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span>

<span class=kw>instance</span> <span class=dt>Expressible</span> <span class=dt>Expr</span> <span class=kw>where</span>
  express <span class=fu>=</span> id

<span class=kw>instance</span> <span class=dt>Expressible</span> <span class=dt>Bool</span> <span class=kw>where</span>
  express <span class=dt>True</span> <span class=fu>=</span> <span class=dt>Tr</span>
  express <span class=dt>False</span> <span class=fu>=</span> <span class=dt>Fl</span>

<span class=kw>instance</span> <span class=dt>Expressible</span> <span class=dt>Integer</span> <span class=kw>where</span>
  express <span class=dv>0</span> <span class=fu>=</span> <span class=dt>Zero</span>
  express n <span class=fu>=</span> <span class=dt>Succ</span> (express (n <span class=fu>-</span> <span class=dv>1</span>))


<span class=ot>exprE ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Exp</span>
exprE s <span class=fu>=</span> <span class=kw>do</span>
  filename <span class=ot>&lt;-</span> loc_filename <span class=ot>`fmap`</span> location
  <span class=kw>case</span> parse (contents expr) filename s <span class=kw>of</span>
    <span class=dt>Left</span> err <span class=ot>-&gt;</span> error (show err)
    <span class=dt>Right</span> exp <span class=ot>-&gt;</span> dataToExpQ (const <span class=dt>Nothing</span> <span class=ot>`extQ`</span> antiExpr) exp

<span class=ot>exprP ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> <span class=dt>Pat</span>
exprP s <span class=fu>=</span> <span class=kw>do</span>
  filename <span class=ot>&lt;-</span> loc_filename <span class=ot>`fmap`</span> location
  <span class=kw>case</span> parse (contents expr) filename s <span class=kw>of</span>
    <span class=dt>Left</span> err <span class=ot>-&gt;</span> error (show err)
    <span class=dt>Right</span> exp <span class=ot>-&gt;</span> dataToPatQ (const <span class=dt>Nothing</span> <span class=ot>`extQ`</span> antiExprPat) exp

<span class=co>-- antiquote RHS</span>
<span class=ot>antiExpr ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> (<span class=dt>Q</span> <span class=dt>Exp</span>)
antiExpr (<span class=dt>Antiquote</span> v) <span class=fu>=</span> <span class=dt>Just</span> embed
  <span class=kw>where</span> embed <span class=fu>=</span> [<span class=fu>|</span> express <span class=fu>$</span>(varE (mkName v)) <span class=fu>|</span>]
antiExpr _ <span class=fu>=</span> <span class=dt>Nothing</span>

<span class=co>-- antiquote LHS</span>
<span class=ot>antiExprPat ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> (<span class=dt>Q</span> <span class=dt>Pat</span>)
antiExprPat (<span class=dt>Antiquote</span> v) <span class=fu>=</span> <span class=dt>Just</span> <span class=fu>$</span> varP (mkName v)
antiExprPat _ <span class=fu>=</span> <span class=dt>Nothing</span>

<span class=ot>mini ::</span> <span class=dt>QuasiQuoter</span>
mini <span class=fu>=</span> <span class=dt>QuasiQuoter</span> exprE exprP undefined undefined</code></pre></div>
<div class=sourceCode include=src/31-template-haskell/use_antiquote.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>

<span class=kw>import </span><span class=dt>Antiquote</span>

<span class=co>-- extract</span>
<span class=ot>a ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
a [mini<span class=fu>|</span>succ <span class=fu>$</span>x<span class=fu>|</span>] <span class=fu>=</span> x

<span class=ot>b ::</span> <span class=dt>Expr</span> <span class=ot>-&gt;</span> <span class=dt>Expr</span>
b [mini<span class=fu>|</span>succ <span class=fu>$</span>x<span class=fu>|</span>] <span class=fu>=</span> [mini<span class=fu>|</span>pred <span class=fu>$</span>x<span class=fu>|</span>]

<span class=ot>c ::</span> <span class=dt>Expressible</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Expr</span>
c x <span class=fu>=</span> [mini<span class=fu>|</span>succ <span class=fu>$</span>x<span class=fu>|</span>]

<span class=ot>d ::</span> <span class=dt>Expr</span>
d <span class=fu>=</span> c (<span class=dv>8</span><span class=ot> ::</span> <span class=dt>Integer</span>)
<span class=co>-- Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))</span>

<span class=ot>e ::</span> <span class=dt>Expr</span>
e <span class=fu>=</span> c <span class=dt>True</span>
<span class=co>-- Succ Tr</span></code></pre></div>
<h2 id=templated-type-families><font>Templated Type Families</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板化类型族</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of TemplateHaskell is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，TemplateHaskell 的知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Just like at the value-level we can construct type-level constructions by piecing together their AST.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就像在值级别一样，我们可以通过拼凑它们的 AST 来构建类型级别的结构。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Type</span>          <span class=dt>AST</span>
<span class=fu>----------</span>    <span class=fu>----------</span>
t1 <span class=ot>-&gt;</span> t2      <span class=dt>ArrowT</span> <span class=ot>`AppT`</span> t2 <span class=ot>`AppT`</span> t2
[t]           <span class=dt>ListT</span> <span class=ot>`AppT`</span> t
(t1,t2)       <span class=dt>TupleT</span> <span class=dv>2</span> <span class=ot>`AppT`</span> t1 <span class=ot>`AppT`</span> t2</code></pre></div>
<p><font>For example consider that type-level arithmetic is still somewhat incomplete in GHC 7.6, but there often cases where the span of typelevel numbers is not full set of integers but is instead some bounded set of numbers. We can instead define operations with a type-family instead of using an inductive definition ( which often requires manual proofs ) and simply enumerates the entire domain of arguments to the type-family and maps them to some result computed at compile-time.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，在 GHC 7.6 中，类型级算术仍然有些不完整，但通常情况下，类型级数字的范围不是完整的整数集，而是一些有界数字集。我们可以使用类型族来定义操作，而不是使用归纳定义（这通常需要手动证明​​），并简单地枚举类型族的整个参数域，并将它们映射到编译时计算的某个结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>For example the modulus operator would be non-trivial to implement at type-level but instead we can use the </font><code>enumFamily</code><font> function to splice in type-family which simply enumerates all possible pairs of numbers up to a desired depth.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，模数运算符在类型级别实现起来并不简单，但我们可以使用 enumFamily 函数拼接类型族，它简单地枚举所有可能的数字对，直到达到所需的深度。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/EnumFamily.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>module</span> <span class=dt>EnumFamily</span> <span class=kw>where</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH</span>

<span class=ot>enumFamily ::</span> (<span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Integer</span> <span class=ot>-&gt;</span> <span class=dt>Integer</span>)
           <span class=ot>-&gt;</span> <span class=dt>Name</span>
           <span class=ot>-&gt;</span> <span class=dt>Integer</span>
           <span class=ot>-&gt;</span> <span class=dt>Q</span> [<span class=dt>Dec</span>]
enumFamily f bop upper <span class=fu>=</span> return decls
  <span class=kw>where</span>
    decls <span class=fu>=</span> <span class=kw>do</span>
      i <span class=ot>&lt;-</span> [<span class=dv>1</span><span class=fu>..</span>upper]
      j <span class=ot>&lt;-</span> [<span class=dv>2</span><span class=fu>..</span>upper]
      return <span class=fu>$</span> <span class=dt>TySynInstD</span> bop (rhs i j)

    rhs i j <span class=fu>=</span> <span class=dt>TySynEqn</span>
      [<span class=dt>LitT</span> (<span class=dt>NumTyLit</span> i), <span class=dt>LitT</span> (<span class=dt>NumTyLit</span> j)]
      (<span class=dt>LitT</span> (<span class=dt>NumTyLit</span> (i <span class=ot>`f`</span> j)))</code></pre></div>
<div class=sourceCode include=src/31-template-haskell/enum_family_splice.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>import </span><span class=dt>EnumFamily</span>

<span class=kw>import </span><span class=dt>Data.Proxy</span>
<span class=kw>import </span><span class=dt>GHC.TypeLits</span>

<span class=kw>type</span> family <span class=dt>Mod</span> (<span class=ot>m ::</span> <span class=dt>Nat</span>) (<span class=ot>n ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span>
<span class=kw>type</span> family <span class=dt>Add</span> (<span class=ot>m ::</span> <span class=dt>Nat</span>) (<span class=ot>n ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span>
<span class=kw>type</span> family <span class=dt>Pow</span> (<span class=ot>m ::</span> <span class=dt>Nat</span>) (<span class=ot>n ::</span> <span class=dt>Nat</span>)<span class=ot> ::</span> <span class=dt>Nat</span>

enumFamily mod <span class=ch>''</span><span class=dt>Mod</span> <span class=dv>10</span>
enumFamily (<span class=fu>+</span>) <span class=ch>''</span><span class=dt>Add</span> <span class=dv>10</span>
enumFamily (<span class=fu>^</span>) <span class=ch>''</span><span class=dt>Pow</span> <span class=dv>10</span>

<span class=ot>a ::</span> <span class=dt>Integer</span>
a <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dt>Mod</span> <span class=dv>6</span> <span class=dv>4</span>))
<span class=co>-- 2</span>

<span class=ot>b ::</span> <span class=dt>Integer</span>
b <span class=fu>=</span> natVal (<span class=dt>Proxy</span><span class=ot> ::</span> <span class=dt>Proxy</span> (<span class=dt>Pow</span> <span class=dv>3</span> (<span class=dt>Mod</span> <span class=dv>6</span> <span class=dv>4</span>)))
<span class=co>-- 9</span>

<span class=co>--    enumFamily mod ''Mod 3</span>
<span class=co>--  ======&gt;</span>
<span class=co>--    template_typelevel_splice.hs:7:1-14</span>
<span class=co>--    type instance Mod 2 1 = 0</span>
<span class=co>--    type instance Mod 2 2 = 0</span>
<span class=co>--    type instance Mod 2 3 = 2</span>
<span class=co>--    type instance Mod 3 1 = 0</span>
<span class=co>--    type instance Mod 3 2 = 1</span>
<span class=co>--    type instance Mod 3 3 = 0</span>
<span class=co>--    ...</span></code></pre></div>
<p><font>In practice GHC seems fine with enormous type-family declarations although compile-time may increase a bit as a result.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在实践中，GHC 似乎可以处理大量的类型族声明，尽管编译时间可能会因此增加一点。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The singletons library also provides a way to automate this process by letting us write seemingly value-level declarations inside of a quasiquoter and then promoting the logic to the type-level. For example if we wanted to write a value-level and type-level map function for our HList this would normally involve quite a bit of boilerplate, now it can stated very concisely.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单例库还提供了一种自动化此过程的方法，让我们在准引用器中编写看似值级别的声明，然后将逻辑提升到类型级别。例如，如果我们想为我们的 HList 编写值级别和类型级别的映射函数，这通常会涉及相当多的样板文件，现在可以非常简洁地说明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/singleton_promote.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE GADTs #-}</span>
<span class=ot>{-# LANGUAGE DataKinds #-}</span>
<span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TypeFamilies #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>
<span class=ot>{-# LANGUAGE KindSignatures #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class=kw>import </span><span class=dt>Data.Singletons</span>
<span class=kw>import </span><span class=dt>Data.Singletons.TH</span>

<span class=fu>$</span>(promote [d<span class=fu>|</span>
<span class=ot>  map ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [b]
  map _ [] <span class=fu>=</span> []
  map f (x<span class=fu>:</span>xs) <span class=fu>=</span> f x <span class=fu>:</span> map f xs
  <span class=fu>|</span>])

<span class=kw>infixr</span> <span class=dv>5</span> <span class=ot>::</span><span class=fu>:</span>

<span class=kw>data</span> <span class=dt>HList</span> (<span class=ot>ts ::</span> [ <span class=fu>*</span> ]) <span class=kw>where</span>
  <span class=dt>Nil</span><span class=ot> ::</span> <span class=dt>HList</span> <span class=ch>'[]</span>
<span class=ot>  (:::) ::</span> t <span class=ot>-&gt;</span> <span class=dt>HList</span> ts <span class=ot>-&gt;</span> <span class=dt>HList</span> (t <span class=ch>': ts)</span>

<span class=co>-- TypeLevel</span>
<span class=co>-- MapJust :: [*] -&gt; [Maybe *]</span>
<span class=kw>type</span> <span class=dt>MapJust</span> xs <span class=fu>=</span> <span class=dt>Map</span> <span class=dt>Maybe</span> xs

<span class=co>-- Value Level</span>
<span class=co>-- mapJust :: [a] -&gt; [Maybe a]</span>
<span class=ot>mapJust ::</span> <span class=dt>HList</span> xs <span class=ot>-&gt;</span> <span class=dt>HList</span> (<span class=dt>MapJust</span> xs)
mapJust <span class=dt>Nil</span> <span class=fu>=</span> <span class=dt>Nil</span>
mapJust (x <span class=ot>::</span><span class=fu>:</span> xs) <span class=fu>=</span> (<span class=dt>Just</span> x) <span class=ot>::</span><span class=fu>:</span> mapJust xs

<span class=kw>type</span> <span class=dt>A</span> <span class=fu>=</span> [<span class=dt>Bool</span>, <span class=dt>String</span> , <span class=dt>Double</span> , ()]

<span class=ot>a ::</span> <span class=dt>HList</span> <span class=dt>A</span>
a <span class=fu>=</span> <span class=dt>True</span> <span class=ot>::</span><span class=fu>:</span> <span class=st>"foo"</span> <span class=ot>::</span><span class=fu>:</span> <span class=fl>3.14</span> <span class=ot>::</span><span class=fu>:</span> () <span class=ot>::</span><span class=fu>:</span> <span class=dt>Nil</span>


<span class=ot>example1 ::</span> <span class=dt>HList</span> (<span class=dt>MapJust</span> <span class=dt>A</span>)
example1 <span class=fu>=</span> mapJust a

<span class=co>-- example1 reduces to example2 when expanded</span>
<span class=ot>example2 ::</span> <span class=dt>HList</span> ([<span class=dt>Maybe</span> <span class=dt>Bool</span>, <span class=dt>Maybe</span> <span class=dt>String</span> , <span class=dt>Maybe</span> <span class=dt>Double</span> , <span class=dt>Maybe</span> ()])
example2 <span class=fu>=</span> <span class=dt>Just</span> <span class=dt>True</span> <span class=ot>::</span><span class=fu>:</span> <span class=dt>Just</span> <span class=st>"foo"</span> <span class=ot>::</span><span class=fu>:</span> <span class=dt>Just</span> <span class=fl>3.14</span> <span class=ot>::</span><span class=fu>:</span> <span class=dt>Just</span> () <span class=ot>::</span><span class=fu>:</span> <span class=dt>Nil</span></code></pre></div>
<h2 id=templated-type-classes><font>Templated Type Classes</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>模板化类型类</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of TemplateHaskell is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，TemplateHaskell 的知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Probably the most common use of Template Haskell is the automatic generation of type-class instances. Consider if we wanted to write a simple Pretty printing class for a flat data structure that derived the ppr method in terms of the names of the constructors in the AST we could write a simple instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Template Haskell 最常见的用途可能是自动生成类型类实例。考虑一下，如果我们想为平面数据结构编写一个简单的 Pretty 打印类，根据 AST 中构造函数的名称派生 ppr 方法，我们可以编写一个简单的实例。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/Class.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>
<span class=ot>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=ot>{-# LANGUAGE FlexibleContexts #-}</span>

<span class=kw>module</span> <span class=dt>Class</span> <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Language.Haskell.TH</span>

<span class=kw>class</span> <span class=dt>Pretty</span> a <span class=kw>where</span>
<span class=ot>  ppr ::</span> a <span class=ot>-&gt;</span> <span class=dt>String</span>

<span class=ot>normalCons ::</span> <span class=dt>Con</span> <span class=ot>-&gt;</span> <span class=dt>Name</span>
normalCons (<span class=dt>NormalC</span> n _) <span class=fu>=</span> n

<span class=ot>getCons ::</span> <span class=dt>Info</span> <span class=ot>-&gt;</span> [<span class=dt>Name</span>]
getCons cons <span class=fu>=</span> <span class=kw>case</span> cons <span class=kw>of</span>
    <span class=dt>TyConI</span> (<span class=dt>DataD</span>    _ _ _ tcons _) <span class=ot>-&gt;</span> map normalCons tcons
    con <span class=ot>-&gt;</span> error <span class=fu>$</span> <span class=st>"Can't derive for:"</span> <span class=fu>++</span> (show con)

<span class=ot>pretty ::</span> <span class=dt>Name</span> <span class=ot>-&gt;</span> <span class=dt>Q</span> [<span class=dt>Dec</span>]
pretty dt <span class=fu>=</span> <span class=kw>do</span>
  info <span class=ot>&lt;-</span> reify dt
  <span class=dt>Just</span> cls <span class=ot>&lt;-</span> lookupTypeName <span class=st>"Pretty"</span>
  <span class=kw>let</span> datatypeStr <span class=fu>=</span> nameBase dt
  <span class=kw>let</span> cons <span class=fu>=</span> getCons info
  <span class=kw>let</span> dtype <span class=fu>=</span> mkName (datatypeStr)
  <span class=kw>let</span> mkInstance xs <span class=fu>=</span>
        <span class=dt>InstanceD</span>
        []                              <span class=co>-- Context</span>
        (<span class=dt>AppT</span>
          (<span class=dt>ConT</span> cls)                    <span class=co>-- Instance</span>
          (<span class=dt>ConT</span> dtype))                 <span class=co>-- Head</span>
        [(<span class=dt>FunD</span> (mkName <span class=st>"ppr"</span>) xs)]      <span class=co>-- Methods</span>
  <span class=kw>let</span> methods <span class=fu>=</span> map cases cons
  return <span class=fu>$</span> [mkInstance methods]

<span class=co>-- Pattern matches on the ``ppr`` method</span>
<span class=ot>cases ::</span> <span class=dt>Name</span> <span class=ot>-&gt;</span> <span class=dt>Clause</span>
cases a <span class=fu>=</span> <span class=dt>Clause</span> [<span class=dt>ConP</span> a []] (<span class=dt>NormalB</span> (<span class=dt>LitE</span> (<span class=dt>StringL</span> (nameBase a)))) []</code></pre></div>
<p><font>In a separate file invoke the pretty instance at the toplevel, and with </font><code>--ddump-splice</code><font> if we want to view the spliced class instance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在一个单独的文件中调用顶层的漂亮实例，如果我们想查看拼接的类实例，则使用--ddump-splice。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/splice_class.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>
<span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>import </span><span class=dt>Class</span>

<span class=kw>data</span> <span class=dt>PlatonicSolid</span>
  <span class=fu>=</span> <span class=dt>Tetrahedron</span>
  <span class=fu>|</span> <span class=dt>Cube</span>
  <span class=fu>|</span> <span class=dt>Octahedron</span>
  <span class=fu>|</span> <span class=dt>Dodecahedron</span>
  <span class=fu>|</span> <span class=dt>Icosahedron</span>

pretty <span class=ch>''</span><span class=dt>PlatonicSolid</span>

<span class=ot>main ::</span> <span class=dt>IO</span> ()
main <span class=fu>=</span> <span class=kw>do</span>
  putStrLn (ppr <span class=dt>Octahedron</span>)
  putStrLn (ppr <span class=dt>Dodecahedron</span>)</code></pre></div>
<h2 id=multiline-strings><font>Multiline Strings</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>多行字符串</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell no language support for multiline strings literals, although we can emulate this by using a quasiquoter. The resulting String literal is then converted using toString into whatever result type is desired.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 没有对多行字符串文字的语言支持，尽管我们可以通过使用准引号来模拟这一点。然后使用 toString 将生成的字符串文字转换为所需的任何结果类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/Multiline.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>module</span> <span class=dt>Multiline</span> (s) <span class=kw>where</span>

<span class=kw>import </span><span class=dt>Data.String</span>
<span class=kw>import </span><span class=dt>Language.Haskell.TH.Quote</span>

<span class=ot>s ::</span> <span class=dt>QuasiQuoter</span>
s <span class=fu>=</span> <span class=dt>QuasiQuoter</span>
  { quoteExp  <span class=fu>=</span> (\a <span class=ot>-&gt;</span> [<span class=fu>|</span>fromString a<span class=fu>|</span>]) <span class=fu>.</span> trim
  , quotePat  <span class=fu>=</span> \_ <span class=ot>-&gt;</span> fail <span class=st>"illegal raw string QuasiQuote"</span>
  , quoteType <span class=fu>=</span> \_ <span class=ot>-&gt;</span> fail <span class=st>"illegal raw string QuasiQuote"</span>
  , quoteDec  <span class=fu>=</span> \_ <span class=ot>-&gt;</span> fail <span class=st>"illegal raw string QuasiQuote"</span>
  }

<span class=ot>trim ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>String</span>
trim (<span class=ch>'\n'</span><span class=fu>:</span>xs) <span class=fu>=</span> xs
trim xs <span class=fu>=</span> xs</code></pre></div>
<p><font>In a separate module we can then enable Quasiquotes and embed the string.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>在一个单独的模块中，我们可以启用 Quasiquotes 并嵌入字符串。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/31-template-haskell/multiline_example.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE QuasiQuotes #-}</span>

<span class=kw>import </span><span class=dt>Multiline</span> (s)
<span class=kw>import qualified</span> <span class=dt>Data.Text</span> <span class=kw>as</span> <span class=dt>T</span>

<span class=ot>foo ::</span> <span class=dt>T.Text</span>
foo <span class=fu>=</span> [s<span class=fu>|</span>
<span class=dt>This</span>
is
my
multiline
string
<span class=fu>|</span>]</code></pre></div>
<h2 id=git-embed><font>git-embed</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>git 嵌入</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Often times it is neccessary to embed the specific Git version hash of a build inside the exectuable. Using git-embed the compiler will effectivelly shell out to the command line to retrieve the version information of the CWD Git repostory and use Template Haskell to define embed this information at compile-time. This is often useful for embedding in </font><code>--version</code><font> information in the command line interface to your program or service.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>通常需要将构建的特定 Git 版本散列嵌入到可执行文件中。使用 git-embed 编译器将有效地输出到命令行以检索 CWD Git 存储库的版本信息，并使用 Template Haskell 在编译时定义嵌入此信息。这对于在程序或服务的命令行界面中嵌入 --version 信息通常很有用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TemplateHaskell #-}</span>

<span class=kw>import </span><span class=dt>Git.Embed</span>
<span class=kw>import </span><span class=dt>Data.Version</span>
<span class=kw>import </span><span class=dt>Paths_myprog</span>

<span class=ot>gitRev ::</span> <span class=dt>String</span>
gitRev <span class=fu>=</span> <span class=fu>$</span>(embedGitShortRevision)

<span class=ot>gitBranch ::</span> <span class=dt>String</span>
gitBranch <span class=fu>=</span> <span class=fu>$</span>(embedGitBranch)

<span class=ot>ver ::</span> <span class=dt>String</span>
ver <span class=fu>=</span> showVersion Paths_myprog.version</code></pre></div>
<p><font>See: </font><a href=https://hackage.haskell.org/package/git-embed>git-embed</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>参见：git-embed</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<hr>
<h1 id=categories><font>Categories</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<div class="alert alert-danger">
<p><font>This is an advanced section, knowledge of category theory is not typically necessary to write Haskell.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这是一个高级部分，范畴论知识通常不是编写 Haskell 所必需的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
</div>
<p><font>Alas we come to the topic of category theory. Some might say all discussion of Haskell eventually leads here at one point or another.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>唉，我们来到了范畴论的话题。有些人可能会说，所有关于 Haskell 的讨论最终都会在某一时刻引向这里。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Nevertheless the overall importance of category theory in the context of Haskell has been somewhat overstated and unfortunately mystified to some extent. The reality is that amount of category theory which is directly applicable to Haskell roughly amounts to a subset of the first chapter of any undergraduate text. And even then, </font><em>no actual knowledge of category theory is required to use Haskell at all</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>然而，在 Haskell 的背景下，范畴论的整体重要性被夸大了，不幸的是，它在某种程度上被神秘化了。事实上，直接适用于 Haskell 的范畴论的数量大致相当于任何本科教材第一章的一个子集。即便如此，使用 Haskell 也根本不需要范畴论的实际知识。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=algebraic-relations><font>Algebraic Relations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代数关系</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Grossly speaking category theory is not terribly important to Haskell programming, and although some libraries derive some inspiration from the subject; most do not. What is more important is a general understanding of equational reasoning and a familiarity with various algebraic relations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>总的来说，范畴论对 Haskell 编程并不是特别重要，尽管一些图书馆从这个主题中获得了一些灵感；大多数没有。更重要的是对等式推理的一般理解和对各种代数关系的熟悉。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Certain relations show up so frequently we typically refer to their properties by name ( often drawn from an equivalent abstract algebra concept ). Consider a binary operation </font><code>a `op` b</code><font> and a unary operation </font><code>f</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>某些关系出现得如此频繁，我们通常通过名称来引用它们的属性（通常来自等效的抽象代数概念）。考虑一个二元运算 a `op` b 和一个一元运算 f。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Associativity<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>结合性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=ot>`op`</span> (b <span class=ot>`op`</span> c) <span class=fu>=</span> (a <span class=ot>`op`</span> b) <span class=ot>`op`</span> c</code></pre></div>
<p><strong>Commutativity<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>交换性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=ot>`op`</span> b <span class=fu>=</span> b <span class=ot>`op`</span> a</code></pre></div>
<p><strong>Units<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单位</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=ot>`op`</span> e <span class=fu>=</span> a
e <span class=ot>`op`</span> a <span class=fu>=</span> a</code></pre></div>
<p><strong>Inversion<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>反转</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(inv a) <span class=ot>`op`</span> a <span class=fu>=</span> e
a <span class=ot>`op`</span> (inv a) <span class=fu>=</span> e</code></pre></div>
<p><strong>Zeros<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>零点</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=ot>`op`</span> e <span class=fu>=</span> e
e <span class=ot>`op`</span> a <span class=fu>=</span> e</code></pre></div>
<p><strong>Linearity<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>线性度</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f (x <span class=ot>`op`</span> y) <span class=fu>=</span> f x <span class=ot>`op`</span> f y</code></pre></div>
<p><strong>Idempotency<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>幂等性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f (f x) <span class=fu>=</span> f x</code></pre></div>
<p><strong>Distributivity<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>分配率</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=ot>`f`</span> (b <span class=ot>`g`</span> c) <span class=fu>=</span> (a <span class=ot>`f`</span> b) <span class=ot>`g`</span> (a <span class=ot>`f`</span> c)
(b <span class=ot>`g`</span> c) <span class=ot>`f`</span> a <span class=fu>=</span> (b <span class=ot>`f`</span> a) <span class=ot>`g`</span> (c <span class=ot>`f`</span> a)</code></pre></div>
<p><strong>Anticommutativity<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>反交换性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class=ot>`op`</span> b <span class=fu>=</span> inv (b <span class=ot>`op`</span> a)</code></pre></div>
<p><font>And of course combinations of these properties over multiple functions gives rise to higher order systems of relations that occur over and over again throughout functional programming, and once we recognize them we can abstract over them. For instance a monoid is a combination of a unit and a single associative operation over a set of values.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>当然，这些属性在多个函数上的组合会产生更高阶的关系系统，这些系统在整个函数式编程中一遍又一遍地出现，一旦我们认识到它们，我们就可以对它们进行抽象。例如，幺半群是一个单元和对一组值的单个关联运算的组合。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<table>
<thead>
<tr class=header>
<th align=left><font>Structure</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>结构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
<th align=left><font>Notation</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>符号</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></th>
</tr>
</thead>
<tbody>
<tr class=odd>
<td align=left><font>Monoid</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>幺半群</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><span class="math inline">(<em>M</em>, •)<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>(M, •)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></span></td>
</tr>
<tr class=even>
<td align=left><font>Monad</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>单子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></td>
<td align=left><span class="math inline">(<em>T</em>, <em>μ</em>, <em>η</em>)<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>(T,∼μ,∼η)</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></span></td>
</tr>
</tbody>
</table>
<h2 id=categories-1><font>Categories</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The most basic structure is a category which is an algebraic structure of objects (</font><code>Obj</code><font>) and morphisms (</font><code>Hom</code><font>) with the structure that morphisms compose associatively and the existence of an identity morphism for each object.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最基本的结构是范畴，它是对象（Obj）和态射（Hom）的代数结构，具有态射关联组合的结构，并且每个对象都存在一个恒等态射。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>With kind polymorphism enabled we can write down the general category parameterized by a type variable "c" for category, and the instance </font><code>Hask</code><font> the category of Haskell types with functions between types as morphisms.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>启用种类多态性后，我们可以写下由类别变量“c”参数化的一般类别，实例 Hask 是 Haskell 类型的类别，类型之间的函数作为态射。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/33-categories/categories.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE PolyKinds #-}</span>
<span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> ((.), id)

<span class=co>-- Morphisms</span>
<span class=kw>type</span> (a <span class=fu>~&gt;</span> b) c <span class=fu>=</span> c a b

<span class=kw>class</span> <span class=dt>Category</span> (<span class=ot>c ::</span> k <span class=ot>-&gt;</span> k <span class=ot>-&gt;</span> <span class=fu>*</span>) <span class=kw>where</span>
<span class=ot>  id ::</span> (a <span class=fu>~&gt;</span> a) c
<span class=ot>  (.) ::</span> (y <span class=fu>~&gt;</span> z) c <span class=ot>-&gt;</span> (x <span class=fu>~&gt;</span> y) c <span class=ot>-&gt;</span> (x <span class=fu>~&gt;</span> z) c

<span class=kw>type</span> <span class=dt>Hask</span> <span class=fu>=</span> (<span class=ot>-&gt;</span>)

<span class=kw>instance</span> <span class=dt>Category</span> <span class=dt>Hask</span> <span class=kw>where</span>
  id x <span class=fu>=</span> x
  (f <span class=fu>.</span> g) x <span class=fu>=</span> f (g x)</code></pre></div>
<p><font>Categories are interesting since they exhibit various composition properties and ways in which various elements in the category can be composed and rewritten while preserving several invariants about the program.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>类别很有趣，因为它们展示了各种组合属性以及类别中的各种元素可以组合和重写的方式，同时保留了程序的几个不变量。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=isomorphisms><font>Isomorphisms</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>同构</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Two objects of a category are said to be isomorphic if we can construct a morphism with 2-sided inverse that takes the structure of an object to another form and back to itself when inverted.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>如果我们可以构造一个具有 2 边逆的态射，将一个对象的结构转换为另一种形式，并在反转时返回到自身，则称一个范畴的两个对象是同构的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f  ::</span> a <span class=ot>-&gt;</span> b
<span class=ot>f' ::</span> b <span class=ot>-&gt;</span> a</code></pre></div>
<p><font>Such that:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这样：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class=fu>.</span> f' <span class=fu>=</span> id
f'<span class=fu>.</span> f  <span class=fu>=</span> id</code></pre></div>
<p><font>For example the types </font><code>Either () a</code><font> and </font><code>Maybe a</code><font> are isomorphic.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如类型 Either () a 和 Maybe a 是同构的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/33-categories/iso.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>

<span class=kw>data</span> <span class=dt>Iso</span> a b <span class=fu>=</span> <span class=dt>Iso</span> {<span class=ot> to ::</span> a <span class=ot>-&gt;</span> b,<span class=ot> from ::</span> b <span class=ot>-&gt;</span> a }

<span class=ot>f ::</span> forall a<span class=fu>.</span> <span class=dt>Maybe</span> a <span class=ot>-&gt;</span> <span class=dt>Either</span> () a
f (<span class=dt>Just</span> a) <span class=fu>=</span> <span class=dt>Right</span> a
f <span class=dt>Nothing</span>  <span class=fu>=</span> <span class=dt>Left</span> ()

<span class=ot>f' ::</span> forall a<span class=fu>.</span> <span class=dt>Either</span> () a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
f' (<span class=dt>Left</span> _)  <span class=fu>=</span> <span class=dt>Nothing</span>
f' (<span class=dt>Right</span> a) <span class=fu>=</span> <span class=dt>Just</span> a

<span class=ot>iso ::</span> <span class=dt>Iso</span> (<span class=dt>Maybe</span> a) (<span class=dt>Either</span> () a)
iso <span class=fu>=</span> <span class=dt>Iso</span> f f'

<span class=kw>data</span> <span class=dt>V</span> <span class=fu>=</span> <span class=dt>V</span> <span class=kw>deriving</span> <span class=dt>Eq</span>

ex1 <span class=fu>=</span> f  (f' (<span class=dt>Right</span> <span class=dt>V</span>)) <span class=fu>==</span> <span class=dt>Right</span> <span class=dt>V</span>
ex2 <span class=fu>=</span> f' (f  (<span class=dt>Just</span> <span class=dt>V</span>))  <span class=fu>==</span> <span class=dt>Just</span> <span class=dt>V</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>data</span> <span class=dt>Iso</span> a b <span class=fu>=</span> <span class=dt>Iso</span> {<span class=ot> to ::</span> a <span class=ot>-&gt;</span> b,<span class=ot> from ::</span> b <span class=ot>-&gt;</span> a }

<span class=kw>instance</span> <span class=dt>Category</span> <span class=dt>Iso</span> <span class=kw>where</span>
  id <span class=fu>=</span> <span class=dt>Iso</span> id id
  (<span class=dt>Iso</span> f f') <span class=fu>.</span> (<span class=dt>Iso</span> g g') <span class=fu>=</span> <span class=dt>Iso</span> (f <span class=fu>.</span> g) (g' <span class=fu>.</span> f')</code></pre></div>
<h2 id=duality><font>Duality</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>二元性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>One of the central ideas is the notion of duality, that reversing some internal structure yields a new structure with a "mirror" set of theorems. The dual of a category reverse the direction of the morphisms forming the category C</font><sup>Op</sup><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>其中一个中心思想是对偶性的概念，即颠倒一些内部结构会产生一个带有一组“镜像”定理的新结构。范畴的对偶反转了构成范畴 COp 的态射的方向。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/33-categories/dual.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>import </span><span class=dt>Control.Category</span>
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> ((.), id)

<span class=kw>newtype</span> <span class=dt>Op</span> a b <span class=fu>=</span> <span class=dt>Op</span> (b <span class=ot>-&gt;</span> a)

<span class=kw>instance</span> <span class=dt>Category</span> <span class=dt>Op</span> <span class=kw>where</span>
  id <span class=fu>=</span> <span class=dt>Op</span> id
  (<span class=dt>Op</span> f) <span class=fu>.</span> (<span class=dt>Op</span> g) <span class=fu>=</span> <span class=dt>Op</span> (g <span class=fu>.</span> f)</code></pre></div>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://blog.ezyang.com/2012/10/duality-for-haskellers/>Duality for Haskellers<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Haskellers 的二元性</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=functors><font>Functors</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>函子</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Functors are mappings between the objects and morphisms of categories that preserve identities and composition.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>函子是保持身份和组合的对象和类别态射之间的映射。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/33-categories/functors.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=ot>{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> (<span class=dt>Functor</span>, fmap, id)

<span class=kw>class</span> (<span class=dt>Category</span> c, <span class=dt>Category</span> d) <span class=ot>=&gt;</span> <span class=dt>Functor</span> c d t <span class=kw>where</span>
<span class=ot>  fmap ::</span> c a b <span class=ot>-&gt;</span> d (t a) (t b)

<span class=kw>type</span> <span class=dt>Hask</span> <span class=fu>=</span> (<span class=ot>-&gt;</span>)

<span class=kw>instance</span> <span class=dt>Category</span> <span class=dt>Hask</span> <span class=kw>where</span>
  id x <span class=fu>=</span> x
  (f <span class=fu>.</span> g) x <span class=fu>=</span> f (g x)

<span class=kw>instance</span> <span class=dt>Functor</span> <span class=dt>Hask</span> <span class=dt>Hask</span> [] <span class=kw>where</span>
  fmap f [] <span class=fu>=</span> []
  fmap f (x<span class=fu>:</span>xs) <span class=fu>=</span> f x <span class=fu>:</span> (fmap f xs)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id ≡ id
fmap (a <span class=fu>.</span> b) ≡ (fmap a) <span class=fu>.</span> (fmap b)</code></pre></div>
<h2 id=natural-transformations><font>Natural Transformations</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>自然变换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Natural transformations are mappings between functors that are invariant under interchange of morphism composition order.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自然变换是在态射组合顺序互换下不变的函子之间的映射。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=kw>type</span> <span class=dt>Nat</span> f g <span class=fu>=</span> forall a<span class=fu>.</span> f a <span class=ot>-&gt;</span> g a</code></pre></div>
<p><font>Such that for a natural transformation </font><code>h</code><font> we have:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这样对于自然变换 h 我们有：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f <span class=fu>.</span> h ≡ h <span class=fu>.</span> fmap f</code></pre></div>
<p><font>The simplest example is between (f = List) and (g = Maybe) types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>最简单的例子是在 (f = List) 和 (g = Maybe) 类型之间。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>headMay ::</span> forall a<span class=fu>.</span> [a] <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a
headMay []     <span class=fu>=</span> <span class=dt>Nothing</span>
headMay (x<span class=fu>:</span>xs) <span class=fu>=</span> <span class=dt>Just</span> x</code></pre></div>
<p><font>Regardless of how we chase </font><code>safeHead</code><font>, we end up with the same result.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>无论我们如何追逐 safeHead，我们最终都会得到相同的结果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay xs) ≡ headMay (fmap f xs)</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay [])
<span class=fu>=</span> fmap f <span class=dt>Nothing</span>
<span class=fu>=</span> <span class=dt>Nothing</span>

headMay (fmap f [])
<span class=fu>=</span> headMay []
<span class=fu>=</span> <span class=dt>Nothing</span></code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay (x<span class=fu>:</span>xs))
<span class=fu>=</span> fmap f (<span class=dt>Just</span> x)
<span class=fu>=</span> <span class=dt>Just</span> (f x)

headMay (fmap f (x<span class=fu>:</span>xs))
<span class=fu>=</span> headMay [f x]
<span class=fu>=</span> <span class=dt>Just</span> (f x)</code></pre></div>
<p><font>Or consider the Functor </font><code>(-&gt;)</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>或者考虑 Functor (-&gt;)。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>f ::</span> (<span class=dt>Functor</span> t)
  <span class=ot>=&gt;</span> (<span class=ot>-&gt;</span>) a b
  <span class=ot>-&gt;</span> (<span class=ot>-&gt;</span>) (t a) (t b)
f <span class=fu>=</span> fmap

<span class=ot>g ::</span> (b <span class=ot>-&gt;</span> c)
  <span class=ot>-&gt;</span> (<span class=ot>-&gt;</span>) a b
  <span class=ot>-&gt;</span> (<span class=ot>-&gt;</span>) a c
g <span class=fu>=</span> (<span class=fu>.</span>)

<span class=ot>c ::</span> (<span class=dt>Functor</span> t)
  <span class=ot>=&gt;</span> (b <span class=ot>-&gt;</span> c)
  <span class=ot>-&gt;</span> (<span class=ot>-&gt;</span>) (t a) (t b)
  <span class=ot>-&gt;</span> (<span class=ot>-&gt;</span>) (t a) (t c)
c <span class=fu>=</span> f <span class=fu>.</span> g</code></pre></div>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class=fu>.</span> g x <span class=fu>=</span> c x <span class=fu>.</span> g</code></pre></div>
<p><font>A lot of the expressive power of Haskell types comes from the interesting fact that, with a few caveats, polymorphic Haskell functions are natural transformations.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 类型的很多表达能力来自一个有趣的事实，即有一些警告，多态 Haskell 函数是自然转换。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>See: </font><a href=http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html>You Could Have Defined Natural Transformations</a><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>请参阅：您可以定义自然变换</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=adjunctions><font>Adjunctions</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>附属词</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>TODO</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>去做</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=yoneda-lemma><font>Yoneda Lemma</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>米田引理</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>The Yoneda lemma is an elementary, but deep result in Category theory. The Yoneda lemma states that for any functor </font><code>F</code><font>, the types </font><code>F a</code><font> and </font><code>∀ b. (a -&gt; b) -&gt; F b</code><font> are isomorphic.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>米田引理是范畴论中一个基本但深刻的结果。米田引理指出，对于任何函子 F，类型 F a 和∀ b。 (a -&gt; b) -&gt; F b 是同构的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE RankNTypes #-}</span>

<span class=ot>embed ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> f a <span class=ot>-&gt;</span> (forall b <span class=fu>.</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f b)
embed x f <span class=fu>=</span> fmap f x

<span class=ot>unembed ::</span> <span class=dt>Functor</span> f <span class=ot>=&gt;</span> (forall b <span class=fu>.</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> f b) <span class=ot>-&gt;</span> f a
unembed f <span class=fu>=</span> f id</code></pre></div>
<p><font>So that we have:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>这样我们就有了：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">embed <span class=fu>.</span> unembed ≡ id
unembed <span class=fu>.</span> embed ≡ id</code></pre></div>
<p><font>The most broad hand-wavy statement of the theorem is that an object in a category can be represented by the set of morphisms into it, and that the information about these morphisms alone sufficiently determines all properties of the object itself.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>该定理最广泛的手波式陈述是范畴中的一个对象可以用它的态射集来表示，并且仅关于这些态射的信息就足以决定对象本身的所有属性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>In terms of Haskell types, given a fixed type </font><code>a</code><font> and a functor </font><code>f</code><font>, if we have some a higher order polymorphic function </font><code>g</code><font> that when given a function of type </font><code>a -&gt; b</code><font> yields </font><code>f b</code><font> then the behavior </font><code>g</code><font> is entirely determined by </font><code>a -&gt; b</code><font> and the behavior of </font><code>g</code><font> can written purely in terms of </font><code>f a</code><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>就 Haskell 类型而言，给定一个固定类型 a 和一个函子 f，如果我们有一些高阶多态函数 g，当给定一个类型为 a -&gt; b 的函数产生 f b 时，行为 g 完全由 a -&gt; 决定b 和 g 的行为可以纯粹用 f a 来表示。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>DeMorgan's Law<hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>德摩根定律</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></strong></p>
<p><font>See:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>看：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<ul>
<li><a href=http://blog.sigfpe.com/2006/11/yoneda-lemma.html>Reverse Engineering Machines with the Yoneda Lemma<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>使用米田引理逆向工程机器</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<h2 id=kleisli-category><font>Kleisli Category</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>克莱斯利类别</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Kleisli composition (i.e. Kleisli Fish) is defined to be:</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Kleisli 成分（即 Kleisli 鱼）定义为：</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>(&gt;=&gt;) ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> (b <span class=ot>-&gt;</span> m c) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> m c
f <span class=fu>&gt;=&gt;</span> g ≡ \x <span class=ot>-&gt;</span> f x <span class=fu>&gt;&gt;=</span> g

<span class=ot>(&lt;=&lt;) ::</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> (b <span class=ot>-&gt;</span> m c) <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> m c
(<span class=fu>&lt;=&lt;</span>) <span class=fu>=</span> flip (<span class=fu>&gt;=&gt;</span>)</code></pre></div>
<p><font>The monad laws stated in terms of the Kleisli category of a monad </font><code>m</code><font> are stated much more symmetrically as one associativity law and two identity laws.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>以单子 m 的 Kleisli 范畴表示的单子法则更对称地表示为一个结合律和两个恒等律。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class=fu>&gt;=&gt;</span> g) <span class=fu>&gt;=&gt;</span> h ≡ f <span class=fu>&gt;=&gt;</span> (g <span class=fu>&gt;=&gt;</span> h)
return <span class=fu>&gt;=&gt;</span> f ≡ f
f <span class=fu>&gt;=&gt;</span> return ≡  f</code></pre></div>
<p><font>Stated simply that the monad laws above are just the category laws in the Kleisli category.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>简单地说，上面的单子法则只是 Kleisli 范畴中的范畴法则。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode include=src/33-categories/kleisli.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=ot>{-# LANGUAGE TypeOperators #-}</span>
<span class=ot>{-# LANGUAGE ExplicitForAll #-}</span>

<span class=kw>import </span><span class=dt>Control.Monad</span>
<span class=kw>import </span><span class=dt>Control.Category</span>
<span class=kw>import </span><span class=dt>Prelude</span> <span class=kw>hiding</span> ((.))

<span class=co>-- Kleisli category</span>
<span class=kw>newtype</span> <span class=dt>Kleisli</span> m a b <span class=fu>=</span> <span class=dt>K</span> (a <span class=ot>-&gt;</span> m b)

<span class=co>-- Kleisli morphisms ( a -&gt; m b )</span>
<span class=kw>type</span> (a <span class=fu>:~&gt;</span> b) m <span class=fu>=</span> <span class=dt>Kleisli</span> m a b

<span class=kw>instance</span> <span class=dt>Monad</span> m <span class=ot>=&gt;</span> <span class=dt>Category</span> (<span class=dt>Kleisli</span> m) <span class=kw>where</span>
  id            <span class=fu>=</span> <span class=dt>K</span> return
  (<span class=dt>K</span> f) <span class=fu>.</span> (<span class=dt>K</span> g) <span class=fu>=</span> <span class=dt>K</span> (f <span class=fu>&lt;=&lt;</span> g)


<span class=ot>just ::</span> (a <span class=fu>:~&gt;</span> a) <span class=dt>Maybe</span>
just <span class=fu>=</span> <span class=dt>K</span> <span class=dt>Just</span>

<span class=ot>left ::</span> forall a b<span class=fu>.</span> (a <span class=fu>:~&gt;</span> b) <span class=dt>Maybe</span> <span class=ot>-&gt;</span> (a <span class=fu>:~&gt;</span> b) <span class=dt>Maybe</span>
left f <span class=fu>=</span> just <span class=fu>.</span> f

<span class=ot>right ::</span> forall a b<span class=fu>.</span> (a <span class=fu>:~&gt;</span> b) <span class=dt>Maybe</span> <span class=ot>-&gt;</span> (a <span class=fu>:~&gt;</span> b) <span class=dt>Maybe</span>
right f <span class=fu>=</span> f <span class=fu>.</span> just</code></pre></div>
<p><font>For example, </font><code>Just</code><font> is just an identity morphism in the Kleisli category of the </font><code>Maybe</code><font> monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>例如，Just 只是 Maybe monad 的 Kleisli 范畴中的恒等态射。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<div class=sourceCode><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class=dt>Just</span> <span class=fu>&gt;=&gt;</span> f ≡ f
f <span class=fu>&gt;=&gt;</span> <span class=dt>Just</span> ≡ f</code></pre></div>
<h2 id=resources><font>Resources</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>资源</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<ul>
<li><a href=http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182>Category Theory, Awodey<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>范畴论，Awodey</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href="https://www.youtube.com/watch?v=ZKmodCApZwk">Category Theory Foundations<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>范畴论基础</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category Theory for Programmers<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>程序员范畴论</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=http://www.youtube.com/user/TheCatsters>The Catsters<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>卡特斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
<hr>
<h1 id=other-languages><font>Other Languages</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>其他语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<p><font>Let us attempt to objectively compare Haskell to other programming languages with regards to which language principles they share and in what respects they differ. These comparisons are not advisements to use or avoid any of these languages, but rather statements of the similarities and differences between them at the language level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>让我们尝试客观地将 Haskell 与其他编程语言进行比较，了解它们共享哪些语言原则以及它们在哪些方面有所不同。这些比较并不是建议使用或避免使用这些语言中的任何一种，而是在语言级别上说明它们之间的异同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>No notion of "weak" or "strong" typing will be discussed because the terms have no universal meaning.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不会讨论“弱”或“强”类型的概念，因为这些术语没有普遍意义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>No notion of "object-oriented" or "functional" paradigms will be discussed because the terms have no universal meaning.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>不会讨论“面向对象”或“功能”范例的概念，因为这些术语没有普遍意义。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=haskell><font>Haskell</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>哈斯克尔</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Haskell's genesis happened in 1987 at the </font><a href=https://www.haskell.org/onlinereport/preface-jfp.html>Functional Programming Languages and Computer Architecture</a><font> conference in Portland, OR. Participants had achieved a consensus that there was a profusion of non-strict, pure languages and concluded that this excess was hampering the development and wider use of such languages. Subsequently, a committee was formed to design a new pure, lazy, general purpose programming language. Out of this collaboration emerged Haskell, named for logician </font><a href=https://smunix.github.io/en.wikipedia.org/wiki/Haskell_Curry.html>Haskell B. Curry</a><font>, upon whose research the logical underpinnings of the Haskell language rest.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 的起源发生在 1987 年在俄勒冈州波特兰举行的函数式编程语言和计算机体系结构会议上。与会者达成共识，即存在大量非严格的纯语言，并得出结论认为这种过多阻碍了此类语言的发展和更广泛使用。随后，成立了一个委员会来设计一种新的纯粹的、惰性的、通用的编程语言。在这次合作中出现了 Haskell，以逻辑学家 Haskell B. Curry 的名字命名，Haskell 语言的逻辑基础基于他的研究。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Since 1987, the Haskell language standard has continued to evolve. Haskell 1.0 was released in April of 1990, with particularly significant updates to the standard released in </font><a href=https://www.haskell.org/onlinereport/>1998</a><font> and </font><a href=https://www.haskell.org/onlinereport/haskell2010/>2010</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>自 1987 年以来，Haskell 语言标准一直在不断发展。 Haskell 1.0 于 1990 年 4 月发布，对 1998 年和 2010 年发布的标准进行了特别重要的更新。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell's main implementation is </font><a href=https://www.haskell.org/ghc/><em>ghc</em></a><font>. GHC is licenced under a permissive, non-copyleft, 3-clause BSD-style licence.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell的主要实现是ghc。 GHC 是根据一个宽松的、非 copyleft 的、3 条款 BSD 风格的许可证获得许可的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell is a </font><em>general purpose language</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 是一种通用语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell is </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 被垃圾收集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell is </font><em>compiled</em><font> through a custom native code generator.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 是通过自定义本机代码生成器编译的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell is </font><em>statically</em><font> typed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 是静态类型的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell allows polymorphism by means of </font><em>parametric polymorphism</em><font> and </font><em>ad-hoc polymorphism</em><font> through typeclasses.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 允许通过参数多态性实现多态性，通过类型类实现临时多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell is </font><em>pure</em><font> and statically tracks effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 是纯粹的并且静态地跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell employs </font><em>lazy evaluation</em><font> by default using </font><em>call-by-need</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 默认使用按需调用的惰性求值。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Haskell's package manager is cabal-install or stack.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Haskell 的包管理器是 cabal-install 或 stack。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=ocaml><font>OCaml</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>OCaml</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>OCaml, originally known as Objective Caml, is the main implementation of the Caml programming language. The type system of OCaml is significantly less advanced than modern GHC Haskell and does not supported higher-kinded types or type-level programming to the extent that has become prevalent in portions of recent Haskell. The OCaml compiler is also significantly less advanced than modern GHC runtime and largely does not perform any compiler optimizations or program transformations. The language itself does have several advantages over Haskell in that is has a module system. Although it is possible to write pure OCaml, there is no language-integrated support, and the current engineering practice around the language encourages ubiquitous impurity in third-party libraries.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml，最初称为 Objective Caml，是 Caml 编程语言的主要实现。 OCaml 的类型系统明显不如现代 GHC Haskell 先进，并且不支持更高种类的类型或类型级编程，以至于在最近的 Haskell 的某些部分中变得普遍。 OCaml 编译器也明显不如现代 GHC 运行时先进，并且基本上不执行任何编译器优化或程序转换。该语言本身确实比 Haskell 有几个优势，因为它有一个模块系统。尽管可以编写纯 OCaml，但没有语言集成支持，当前围绕该语言的工程实践鼓励第三方库中无处不在的杂质。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Both have fairly modern type systems, but OCaml does not enforce purity and uses call-by-value.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：两者都有相当现代的类型系统，但 OCaml 不强制纯度并使用按值调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml's main implementation is </font><a href=http://ocaml.org/><em>ocamlc</em></a><font>. The OCaml compiler is distributed under </font><a href=http://www.gnu.org/licenses/license-list.html#QPL>the Q Public licence</a><font>, a permissive, non-copyleft FLOSS licence. Some portions of the OCaml libaries are licensed under the </font><a href=http://www.gnu.org/licenses/gpl.html>GPLv2</a><font>. See the </font><a href=https://github.com/ocaml/ocaml/blob/trunk/LICENSE>OCaml GitHub page</a><font> for more information about licensing specifics.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml的主要实现是ocamlc。 OCaml 编译器是根据 Q 公共许可证分发的，这是一种宽松的、非 copyleft 的 FLOSS 许可证。 OCaml 库的某些部分在 GPLv2 下获得许可。有关许可细节的更多信息，请参阅 OCaml GitHub 页面。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml is a </font><em>general purpose language</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 是一种通用语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml is </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 是垃圾回收的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml allows polymorphism by means of </font><em>parametric polymorphism</em><font> and </font><em>ad-hoc polymorphism</em><font> through modular implicits.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 允许通过参数多态性实现多态性，并通过模块化隐式实现临时多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml has a module system and functors.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 有一个模块系统和仿函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml is not an optimizing compiler.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 不是优化编译器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml is </font><em>impure</em><font> by default and does not statically track effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 默认是不纯的，不会静态跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml's evaluation is </font><em>call-by-value</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 的评估是按值调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>OCaml has a package manager called </font><a href=https://opam.ocaml.org/>OPAM</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>OCaml 有一个名为 OPAM 的包管理器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=standard-ml><font>Standard ML</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>标准机器学习</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Standard ML was a general-purpose, modular, functional programming language with compile-time type checking and type inference.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 是一种通用的、模块化的、函数式编程语言，具有编译时类型检查和类型推断。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><a href=https://smunix.github.io/en.wikipedia.org/wiki/Standard_ML.html>Standard ML</a><font> was traditionally a general purpose language, although it's lack of a modern compiler largely only makes it useful for work on pure type theory and proof assistants and not in industrial settings. Standard ML has been largely abandoned in recent years and is a good example of a promising language that withered on the vine from a lack of engineering effort devoted toward the backend compiler.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 传统上是一种通用语言，尽管它缺乏现代编译器，这在很大程度上只使其对纯类型理论和证明助手的工作有用，而不是在工业环境中。近年来，标准 ML 已基本被废弃，这是一个很好的例子，说明一种有前途的语言由于缺乏专门用于后端编译器的工程努力而在藤蔓上枯萎。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Standard ML is no longer actively developed, Haskell is.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：标准 ML 不再积极开发，Haskell 是。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML's main implementation is </font><a href=http://smlnj.org/><em>smlnj</em></a><font>. Other implementations existed in </font><a href=http://mlton.org/><em>mlton</em></a><font> and </font><a href=http://www.polyml.org/><em>polyml</em></a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 的主要实现是 smlnj。其他实现存在于 mlton 和 polyml 中。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML has no package manager.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 没有包管理器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML allows polymorphism by means of </font><em>parametric polymorphism</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 允许通过参数多态性实现多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML has a module system and functors.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 具有模块系统和仿函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML is </font><em>impure</em><font> by default and does not statically track effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认情况下，标准 ML 是不纯的，不会静态跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML implementations are typically </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 实现通常被垃圾收集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML's evaluation is </font><em>call-by-value</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 的评估是按值调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Standard ML employs strict evaluation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>标准 ML 采用严格的评估。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=agda><font>Agda</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>阿格达</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Agda is a dependently typed functional programming language used in type theory research. Unlike Coq, has no support for tactics, and proofs are written in a functional programming style.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Agda 是一种用于类型理论研究的依赖类型函数式编程语言。与 Coq 不同，它不支持策略，并且证明是以函数式编程风格编写的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Agda is not a general purpose language, Haskell is. Agda is not used to write executable programs for practical uses outside of research.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Agda 不是通用语言，Haskell 是。 Agda 不用于为研究以外的实际用途编写可执行程序。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Agda's main implementation is </font><em>agda</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Agda的主要实现是agda。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Agda is not a general purpose language, it is largely used as a proof environment and tool for constructive mathematics.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Agda 不是通用语言，它主要用作构造性数学的证明环境和工具。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Agda has no package manager.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Agda 没有包管理器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Agda is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Agda 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=coq><font>Coq</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>辅酶Q</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Coq is an interactive theorem prover based on the calculus of inductive constructions. It compiles into a Core language called Gallina whose defining feature is that it is weakly normalizing (i.e. all programs terminate ). Although Coq allows limited extraction of some programs to other languages, it is not by itself a programming language in the traditional sense, most Coq programs are not run or compiled.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Coq 是一个基于归纳结构微积分的交互式定理证明器。它编译成一种名为 Gallina 的核心语言，其定义特征是弱规范化（即所有程序都终止）。尽管 Coq 允许将某些程序有限地提取为其他语言，但它本身并不是传统意义上的编程语言，大多数 Coq 程序都不会运行或编译。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Coq is not a general purpose language, Haskell is.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Coq 不是通用语言，Haskell 是。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Coq's main implementation is </font><em>coq</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Coq的主要实现是coq。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Coq is </font><em>not a general purpose language</em><font>, it is largely used as a proof environment.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Coq 不是通用语言，它主要用作证明环境。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Coq is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Coq 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=idris><font>Idris</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>伊德里斯</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Idris is a general-purpose purely functional programming language with dependent types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 是一种具有依赖类型的通用纯函数式编程语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Idris has dependent types and call-by-value semantics, Haskell does not have dependent types and uses call-by-need.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Idris 具有依赖类型和按值调用语义，Haskell 没有依赖类型并使用按需调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris's main implementation is </font><em>idris</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 的主要实现是 idris。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris is a </font><em>general purpose language</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 是一种通用语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris allows polymorphism by means of </font><em>parametric polymorphism</em><font> and </font><em>ad-hoc polymorphism</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 通过参数多态和临时多态允许多态。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris's evaluation is </font><em>call-by-value</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 的评估是按价值调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris is </font><em>garbage collected</em><font> by default, although there is some novel work on </font><a href=http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html>uniqueness types</a><font> which can statically guarantee aliasing properties of references.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 默认是垃圾回收的，尽管有一些关于唯一性类型的新颖工作可以静态保证引用的别名属性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Idris is </font><em>pure</em><font> and statically tracks effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Idris 是纯粹的静态跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=rust><font>Rust</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>锈</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Rust is a general-purpose, multi-paradigm, compiled programming language developed by Mozilla Research. It incorporates many of the foundational ideas of Haskell's type system but uses a more traditional imperative evaluation model. Rust includes type inference, ad-hoc polymorphism, sum types, and option chaining as safe exception handling. Notably Rust lacks higher-kinded types which does not allow many modern functional abstractions to be encoded in the language. Rust does not enforce purity or track effects, but has a system for statically analyzing lifetimes of references informing the efficient compilation of many language constructs to occur without heap allocation.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 是由 Mozilla Research 开发的一种通用、多范式、编译型编程语言。它结合了 Haskell 类型系统的许多基本思想，但使用了更传统的命令式评估模型。 Rust 包括类型推断、临时多态性、求和类型和选项链作为安全异常处理。值得注意的是，Rust 缺少更高种类的类型，这些类型不允许在语言中编码许多现代功能抽象。 Rust 不强制纯度或跟踪效果，但有一个系统用于静态分析引用的生命周期，通知许多语言结构的有效编译在没有堆分配的情况下发生。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Rust is a modern imperative typed language, Haskell is a modern functional typed language with recent type system. Rust does not have the capacity to distinguish between pure and impure functions at the language level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Rust 是一种现代命令式语言，Haskell 是一种具有最新类型系统的现代函数式语言。 Rust 没有能力在语言级别区分纯函数和非纯函数。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust's main implementation is </font><em>rustc</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 的主要实现是 rustc。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust is a </font><em>general purpose language</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 是一种通用语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust's package manager is Cargo.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 的包管理器是 Cargo。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust allows polymorphism by means of </font><em>parametric polymorphism</em><font> and </font><em>ad-hoc polymorphism</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 通过参数多态性和临时多态性允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust is </font><em>not garbage collected</em><font> by default, instead uses static semantics to analyze lifetimes. Optionally supports garbage collection.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 默认不进行垃圾回收，而是使用静态语义来分析生命周期。可选地支持垃圾收集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Rust is </font><em>impure</em><font> by default and does not statically track effects. It does however have static tracking of memory allocations and lifetimes.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Rust 默认是不纯的，不会静态跟踪效果。然而，它确实有内存分配和生命周期的静态跟踪。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=purescript><font>Purescript</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>纯文字</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Purescript is a Haskell-like language that compiles into Javascript for evaluation within a web browser. Semantically it is very close to Haskell except that is uses a call-by-value model instead of Haksell's call-by-need. The type system is a superset of Haskell 2010 and includes ad-hoc polymorphism, parametric polymorphism, rank-n polymorphism, row-polymorphism, higher-kinded types and full algebraic data types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Purescript 是一种类似 Haskell 的语言，可以编译成 Javascript 以便在 Web 浏览器中进行评估。从语义上讲，它非常接近 Haskell，只是它使用按值调用模型而不是 Haksell 的按需调用。该类型系统是 Haskell 2010 的超集，包括临时多态性、参数多态性、rank-n 多态性、行多态性、更高种类的类型和完整的代数数据类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Purescript targets Javascript in the browser, while GHC Haskell is designed to work on top of the GHC managed runtime.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Purescript 以浏览器中的 Javascript 为目标，而 GHC Haskell 旨在在 GHC 管理的运行时之上工作。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Purescript's main implementation is </font><em>purescript</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Purescript 的主要实现是 purescript。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Purescript is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Purescript 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Purescript's evaluation is </font><em>call-by-value</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Purescript 的评估是按值调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Purescript is </font><em>pure</em><font> and statically tracks effects using an extensible record system embedded in the Eff monad.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Purescript 是纯粹的静态跟踪效果，使用嵌入在 Eff monad 中的可扩展记录系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=elm><font>Elm</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>榆树</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Elm is a ML-like language that compiles into Javascript for evaluation within a web browser.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Elm 是一种类似 ML 的语言，可以编译成 Javascript 以便在 Web 浏览器中进行评估。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Elm targets Javascript in the browser, while GHC Haskell is designed to work on top of the GHC managed runtime. Elm lacks any semblance of a modern ML type system features, and has no coherent story for overloading, modules or higher polymorphism.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Elm 以浏览器中的 Javascript 为目标，而 GHC Haskell 旨在在 GHC 管理的运行时之上工作。 Elm 缺乏现代 ML 类型系统特征的任何外观，并且没有关于重载、模块或更高多态性的连贯故事。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Elm's main implementation is </font><em>elm</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Elm的主要实现是elm。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Elm is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Elm 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Elm targets Javascript and is "transpiled" to Javascript source code to be run exclusively in a browser or Javascript interpreter.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Elm 以 Javascript 为目标，并被“转译”为 Javascript 源代码，以专门在浏览器或 Javascript 解释器中运行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Elm allows polymorphism by means of </font><em>parametric polymorphism</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Elm 通过参数多态性允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Elm is </font><em>pure</em><font> and statically tracks effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Elm 是纯粹的静态跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=python><font>Python</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Python</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Python is a widely used general-purpose, high-level programming language. It is based on object-style of programming constructions and allows first class functions and higher order functions. Python is unityped and is notable for it's simplistic runtime and global mutex preventing concurrency.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Python 是一种广泛使用的通用高级编程语言。它基于对象风格的编程结构，并允许一流的函数和高阶函数。 Python 是统一类型的，以其简单的运行时和防止并发的全局互斥锁而著称。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Python is unityped and imperative, Haskell is statically typed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Python 是统一类型和命令式的，Haskell 是静态类型的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Python's main implementation is </font><em>cpython</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Python的主要实现是cpython。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Python is a </font><em>unityped</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Python 是一种统一类型的语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Python is </font><em>impure</em><font> by default and does not statically track effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>默认情况下，Python 是不纯的，不会静态跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Python internally refers to runtime value tags as </font><em>types</em><font>, which differs from the Haskell notion of types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Python 在内部将运行时值标记称为类型，这与 Haskell 的类型概念不同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Python allows polymorphism by means of unityping, all functions can take any type.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Python 通过统一类型允许多态性，所有函数都可以采用任何类型。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=r><font>R</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>R</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>R is a programming language and software environment for statistical computing and graphics. The R language is widely used among statisticians and data miners for developing statistical software and data analysis</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R 是一种用于统计计算和图形的编程语言和软件环境。 R 语言在统计学家和数据挖掘者中广泛用于开发统计软件和数据分析</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: R is unityped and domain specific language, Haskell is statically typed and general purpose.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：R 是统一类型和领域特定语言，Haskell 是静态类型和通用语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>R's main implementation is </font><em>r</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R的主要实现是r。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>R is a </font><em>unityped</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R 是一种统一类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>R allows polymorphism by means of </font><em>unityping</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R 通过统一类型允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>R internally refers to runtime value tags as </font><em>types</em><font>, which differs from the Haskell notion of types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R 在内部将运行时值标记称为类型，这与 Haskell 的类型概念不同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>R is </font><em>interpreted</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>R 被解释。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=julia><font>Julia</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>茱莉亚</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Julia is a high-level dynamic programming language designed to address the requirements of high-performance numerical and scientific computing.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Julia 是一种高级动态编程语言，旨在满足高性能数值和科学计算的要求。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Julia is unityped and imperative, Haskell is statically typed.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Julia 是统一类型和命令式的，Haskell 是静态类型的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Julia's main implementation is </font><em>juliia</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Julia 的主要实现是 julia.</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Julia is a </font><em>unityped</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Julia 是一种统一类型的语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Julia allows polymorphism by means of </font><em>unityping</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Julia 通过统一类型允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Julia internally refers to runtime value tags as </font><em>types</em><font>, which differs from the Haskell notion of types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Julia 在内部将运行时值标记称为类型，这与 Haskell 的类型概念不同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Julia is </font><em>compiled</em><font> through the LLVM framework.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Julia 是通过 LLVM 框架编译的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=erlang><font>Erlang</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>二郎</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Erlang is a general-purpose programming language and runtime environment. Erlang has built-in support for concurrency, distribution and fault tolerance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 是一种通用编程语言和运行时环境。 Erlang 内置了对并发、分布和容错的支持。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Erlang is unityped and imperative, Haskell is statically typed and functional.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Erlang 是统一类型和命令式的，Haskell 是静态类型和函数式的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang's main implementation is </font><em>erl</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang的主要实现是erl。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang is a </font><em>unityped</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 是一种统一类型的语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang is interpreted.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 被解释。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang allows polymorphism by means of </font><em>unityping</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 通过统一类型允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang's evaluation is </font><em>call-by-value</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 的评估是按值调用。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang internally refers to runtime value tags as </font><em>types</em><font>, which differs from the Haskell notion of types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 在内部将运行时值标记称为类型，这与 Haskell 的类型概念不同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Erlang is </font><em>impure</em><font> by default and does not statically track effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Erlang 默认是不纯的，不会静态跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=elixer><font>Elixer</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>长生不老药</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=java><font>Java</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>爪哇</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Java is a general purpose programming language. It is an object-oriented, concurrent language which is statically typed. It is one of the most frequently used languages in the industry, as well as a common language used in academia to teach the fundamentals of object oriented programming.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Java 是一种通用编程语言。它是一种面向对象的并发语言，是静态类型的。它是业界最常用的语言之一，也是学术界用来教授面向对象编程基础知识的通用语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Java is an object-oriented language, compared to Haskell which is functional.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：与函数式的 Haskell 相比，Java 是一种面向对象的语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Java is </font><em>statically compiled</em><font> to Java Bytecode which can be ran on a Java Virtual Machine.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Java 被静态编译为 Java 字节码，可以在 Java 虚拟机上运行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Java's most recent version is Java8</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Java的最新版本是Java8</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Java is cross-platform. It can be ran on Linux, Windows and Mac.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Java是跨平台的。它可以在 Linux、Windows 和 Mac 上运行。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=clojure><font>Clojure</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Clojure 语言</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Clojure is a modern LISP dialect that emphasizes immutability. It does not enforce safety and idiomatic clojure often includes mutable references and destructive updates. There are some efforts toward an optional typing system provided by the </font><a href=https://github.com/clojure/core.typed>core.typed</a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure 是一种强调不变性的现代 LISP 方言。它不强制执行安全性，并且惯用的 clojure 通常包含可变引用和破坏性更新。 core.typed 提供了一个可选的类型系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Clojure is a unityped typed Lisp dialect, while Haskell is in the ML family.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Clojure 是统一类型的 Lisp 方言，而 Haskell 属于 ML 家族。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Clojure's main implementation is </font><em>clojure</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure的主要实现是clojure。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Clojure is a </font><em>unityped</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure 是一种统一类型的语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Clojure allows polymorphism by means of </font><em>unityping</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure 通过统一类型允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Clojure is </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure 是垃圾回收的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Clojure internally refers to runtime value tags as </font><em>types</em><font>, which differs from the Haskell notion of types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure 在内部将运行时值标记称为类型，这与 Haskell 的类型概念不同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Clojure is </font><em>compiled</em><font> to Java Virtual Machine bytecode.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Clojure 被编译为 Java 虚拟机字节码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=swift><font>Swift</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>迅速</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Swift is a multi-paradigm language created for iOS and OS X development by Apple. Swift incorporates recent developments in language design and uncommonly includes return type polymorphism, type inference, ad-hoc polymorphism, sum types, and option chaining as safe exception handling. Swift does not enforce purity or track effects, and allows mutable and destructive updates.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 是 Apple 为 iOS 和 OS X 开发创建的多范式语言。 Swift 结合了语言设计的最新发展，并且不常见地包括返回类型多态性、类型推断、即席多态性、求和类型和选项链作为安全异常处理。 Swift 不强制纯度或跟踪效果，并允许可变和破坏性更新。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Swift is reasonably modern imperative typed language, Haskell is a modern functional typed language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Swift 是相当现代的命令式语言，Haskell 是现代函数式语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Swift's main implementation is </font><em>swiftc</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 的主要实现是 swiftc。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Swift allows polymorphism by means of </font><em>parametric polymorphism</em><font> and </font><em>ad-hoc polymorphism</em><font> through through inheritance, interfaces, and reflection.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 通过继承、接口和反射允许通过参数多态和临时多态实现多态。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Swift is </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 是垃圾回收的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Swift is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Swift is </font><em>compiled</em><font> through the LLVM framework.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 是通过 LLVM 框架编译的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Swift </font><em>does not</em><font> have an effect system.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Swift 没有效果系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=scheme><font>Scheme</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>方案</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=racket><font>Racket</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>球拍</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=c><font>C#</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>C＃</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>C# is a typed, class-based, single-inheritance object-oriented programming language originally developed at Microsoft as the flagship language for the .NET framework. Early versions closely resemble </font><em>Java</em><font>, but the language has since picked up a few influences from declarative and functional programming paradigms. .NET is Windows-only, but a cross-platform replacement, </font><em>Mono</em><font>, exists, that makes it possible to run .NET code on OS X and Linux.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 是一种类型化、基于类的单继承面向对象编程语言，最初由 Microsoft 作为 .NET 框架的旗舰语言开发。早期版本与 Java 非常相似，但该语言此后受到了声明式和函数式编程范例的一些影响。 .NET 仅适用于 Windows，但存在跨平台替代品 Mono，这使得在 OS X 和 Linux 上运行 .NET 代码成为可能。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: C# is an impure object-oriented language, Haskell is a pure functional language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：C# 是一种不纯的面向对象语言，Haskell 是一种纯函数式语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C#'s main implementation is </font><em>C#.NET</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C#的主要实现是C#.NET。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C# is a </font><em>general purpose</em><font> programming language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 是一种通用编程语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C# is </font><em>garbage collected</em><font> (but allows opting out of GC through the use of </font><code>unsafe</code><font> blocks)</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 是垃圾收集器（但允许通过使用不安全块选择退出 GC）</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C# is a </font><em>statically typed</em><font> language with limited </font><em>type inference</em><font> and some support for </font><em>dynamic typing</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 是一种静态类型语言，具有有限的类型推断和对动态类型的一些支持。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C# allows polymorphism by means of </font><em>parametric polymorphism</em><font> through generics, </font><em>ad-hoc polymorphism</em><font> through inheritance, interfaces, and reflection.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 允许通过泛型的参数多态性、通过继承、接口和反射的临时多态性来实现多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C# is impure and </font><em>does not</em><font> track effects.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 是不纯的，不跟踪效果。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C# is typically </font><em>compiled</em><font> to .NET IL, which is then interpreted by the .NET runtime.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C# 通常编译为 .NET IL，然后由 .NET 运行时解释。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=f><font>F#</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>F＃</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=c-1><font>C++</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>C++</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>C++ is a typed multi-paradigm (imperative, structured/procedural, class-based multiple-inheritance object-oriented, template metaprogramming) programming language developed by Bjarne Stroustrup in the early 1980s. The philosophy strongly favors zero-cost abstractions, and values performance higher than convenience. This has made the language extremely large and complex, and the culture and ecosystem diverse and fractured. Today, C++ is mainly found in legacy projects, but remains popular in areas where realtime performance and deterministic memory allocation are critical, such as embedded, audio/video, games, HFT, etc.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 是 Bjarne Stroustrup 在 1980 年代初期开发的一种类型化多范式（命令式、结构化/过程式、基于类的多重继承面向对象、模板元编程）编程语言。该理念强烈支持零成本抽象，并且重视性能高于便利性。这使得语言极其庞大和复杂，文化和生态系统变得多样化和支离破碎。如今，C++ 主要出现在遗留项目中，但在实时性能和确定性内存分配至关重要的领域仍然很受欢迎，例如嵌入式、音频/视频、游戏、HFT 等。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: C++ is impure and uses RAII, Haskell is pure and garbage-collected.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：C++ 是不纯的并且使用 RAII，Haskell 是纯的并且使用垃圾收集。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ has no canonical implementation; notable compilers include </font><em>gcc</em><font>, </font><em>clang</em><font>, and </font><em>MSVC++</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 没有规范的实现；著名的编译器包括 gcc、clang 和 MSVC++。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ is a </font><em>general purpose</em><font> programming language, with a bias towards </font><em>systems programming</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 是一种通用编程语言，偏向于系统编程。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ is </font><em>not garbage collected</em><font>. Manual memory management (as in C) is supported, but the recommended paradigm is </font><em>RAII</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 不会被垃圾回收。支持手动内存管理（如在 C 中），但推荐的范例是 RAII。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ is a </font><em>statically typed</em><font> language with limited </font><em>type inference</em><font> and many backdoors to bypass the type checker.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 是一种静态类型语言，具有有限的类型推断和许多绕过类型检查器的后门。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ allows polymorphism by means of </font><em>parametric polymorphism</em><font> through template metaprogramming, and </font><em>ad-hoc polymorphism</em><font> through inheritance.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 允许通过模板元编程的参数多态性实现多态性，并通过继承实现临时多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ is </font><em>compiled</em><font>, the typical compilation target is native machine code.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++编译，典型的编译目标是本机机器码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>C++ </font><em>does not</em><font> track effects. It has limited support for tracking mutability at the type level.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>C++ 不跟踪效果。它对在类型级别跟踪可变性的支持有限。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=go><font>Go</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>去</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><a href=https://golang.org/>Go</a><font> is a programming language developed at Google. Although Go is statically typed, it has failed to integrate most modern advances in programming language design done after the 1970s and instead chooses a seemingly regressive design. Most notably, it lacks any notion of generics, while polymorphism is achieved either by manual code duplication or unsafe coercions.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go 是谷歌开发的一种编程语言。尽管 Go 是静态类型的，但它未能整合 1970 年代后编程语言设计的大多数现代进步，而是选择了一种看似倒退的设计。最值得注意的是，它没有任何泛型的概念，而多态性是通过手动代码复制或不安全的强制转换来实现的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Go is a language designed around the idea that language design has not advanced since 1970, while Haskell incorporates many ideas from modern research.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Go 是一种围绕语言设计自 1970 年以来没有进步的思想而设计的语言，而 Haskell 则融合了许多现代研究的思想。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Go's main implementation is </font><a href=https://go.googlesource.com/go><em>go</em></a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go的主要实现是go。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Go is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Go has </font><em>no safe polymorphism</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go 没有安全的多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Go is statically </font><em>compiled</em><font> with a custom toolchain.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go 是使用自定义工具链静态编译的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Go is </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go 是垃圾收集器。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Go </font><em>does not</em><font> have an effect system.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Go 没有效果系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=scala><font>Scala</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>斯卡拉</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>Scala is a general purpose multi-paradigm language. Like Java, Scala is object-oriented, and uses a curly-brace syntax reminiscent of the C programming language. Unlike Java, Scala has many features of functional programming languages like Scheme, Standard ML and Haskell, including currying, type inference, immutability, lazy evaluation, and pattern matching.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala 是一种通用的多范式语言。与 Java 一样，Scala 也是面向对象的，并且使用花括号语法让人联想到 C 编程语言。与 Java 不同，Scala 具有 Scheme、Standard ML 和 Haskell 等函数式编程语言的许多特性，包括柯里化、类型推断、不变性、惰性求值和模式匹配。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Scala mixes functional programming with imperative programming and does not take a language-integrated stance on purity or effect tracking which breaks equational reasoning. External libraries and frameworks exist that embrace functional programming more effectively, but it is not enforced and imperative code and thin wrappers around Java libs quite often leaks industrial codebases.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：Scala 将函数式编程与命令式编程混合在一起，并且在纯度或效果跟踪方面不采取语言集成的立场，这会破坏等式推理。存在更有效地包含函数式编程的外部库和框架，但它不是强制的，命令式代码和 Java 库周围的薄包装器经常泄漏工业代码库。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Scala's main implementation is </font><a href=http://www.scala-lang.org/><em>scala</em></a><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala的主要实现是scala。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Scala is a </font><em>statically typed</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala 是一种静态类型语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Scala allows polymorphism by means of </font><em>parametric polymorphism</em><font> and </font><em>ad-hoc polymorphism</em><font> through implicits.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala 允许通过参数多态性实现多态性，通过隐式实现临时多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Scala is </font><em>garbage collected</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala 是垃圾回收的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Scala language </font><em>does not</em><font> have an effect system.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala 语言没有效果系统。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Scala is statically </font><em>compiled</em><font> to Java Virtual Machien bytecode.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Scala 被静态编译为 Java Virtual Machien 字节码。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=javascript><font>Javascript</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Javascript</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<p><font>JavaScript is a high-level, dynamic, untyped, and interpreted programming language that was ubiquitous in web development during the 90s and 00s. Javascript is most kindly described as a language that "just happened" and an enduring testament to human capacity to route around problems.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>JavaScript 是一种高级、动态、无类型和解释型编程语言，在 90 年代和 00 年代的 Web 开发中无处不在。 Javascript 被最亲切地描述为一种“刚刚发生”的语言，并且是人类解决问题能力的持久证明。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><strong>Main difference</strong><font>: Like many web technologies Javascript "just happened" and it's design was dominated by economic factors. Haskell was designed with some insight into the end result.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>主要区别：像许多 Web 技术一样，Javascript“刚刚出现”，它的设计受经济因素支配。 Haskell 的设计对最终结果有一定的洞察力。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Javascripts implementations include </font><em>NodeJS</em><font>, </font><em>V8</em><font> and </font><em>spidermoneky</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Javascripts 实现包括 NodeJS、V8 和 spidermoneky。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Javascript is a </font><em>unityped</em><font> language.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Javascript 是一种统一类型的语言。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Javascript is </font><em>interpreted</em><font>, tracing JIT specialization is common.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Javascript 被解释，跟踪 JIT 专业化很常见。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Javascript allows polymorphism by means of </font><em>unityping</em><font>.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Javascript 通过统一类型允许多态性。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>Javascript internally refers to runtime value tags as </font><em>types</em><font>, which differs from the Haskell notion of types.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>Javascript 在内部将运行时值标记称为类型，这与 Haskell 的类型概念不同。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<p><font>The majority of Javascript implementations are garbage collected.</font><hcfy-result style=display:block class="__hcfy-result-comparison__ __hcfy-result-comparison-block__"><hcfy-result-content contenteditable=false>大多数 Javascript 实现都是垃圾回收的。</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></p>
<h2 id=kotlin><font>Kotlin</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>科特林</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=php><font>PHP</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>PHP</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=perl><font>Perl</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Perl</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<h2 id=lua><font>Lua</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>Lua</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h2>
<hr>
<h1 id=code><font>Code</font><hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>代码</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></h1>
<ul>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/01-basics/>01-basics/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>01-基础/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/02-monads/>02-monads/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>02-单子/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/03-monad-transformers/>03-monad-transformers/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>03-monad-变形金刚/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/04-extensions/>04-extensions/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>04-扩展名/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/05-laziness/>05-laziness/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>05-懒惰/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/06-prelude/>06-prelude/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>06-序曲/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/07-text-bytestring/>07-text-bytestring/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>07-文本字节串/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/08-applicatives/>08-applicatives/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>08-应用程序/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/09-errors/>09-errors/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>09-错误/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/10-advanced-monads/>10-advanced-monads/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>10-高级单子/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/11-quantification/>11-quantification/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>11-量化/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/12-gadts/>12-gadts/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>12-gadts/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/13-lambda-calculus/>13-lambda-calculus/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>13-lambda-演算/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/14-interpreters/>14-interpreters/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>14位口译员/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/15-testing/>15-testing/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>15-测试/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/16-type-families/>16-type-families/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>16型家庭/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/17-promotion/>17-promotion/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>17-促销/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/18-generics/>18-generics/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>18-仿制药/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/19-numbers/>19-numbers/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>19号/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/20-data-structures/>20-data-structures/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>20-数据结构/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/21-ffi/>21-ffi/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>21-菲/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/22-concurrency/>22-concurrency/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>22-并发/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/23-graphics/>23-graphics/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>23-图形/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/24-parsing/>24-parsing/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>24-解析/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/25-streaming/>25-streaming/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>25-流媒体/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/26-data-formats/>26-data-formats/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>26 数据格式/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/27-web/>27-web/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>27-网络/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/28-databases/>28-databases/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>28个数据库/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/29-ghc/>29-ghc/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>29-ghc/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/30-languages/>30-languages/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>30种语言/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/31-template-haskell/>31-template-haskell/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>31-模板-haskell/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
<li><a href=https://github.com/sdiehl/wiwinwlh/tree/master/src/33-categories/>33-categories/<hcfy-result style=display:inline-block class="__hcfy-result-comparison__ __hcfy-result-comparison-inline__"><hcfy-result-content contenteditable=false>33类/</hcfy-result-content><hcfy-result-actions></hcfy-result-actions></hcfy-result></a></li>
</ul>
 </div>
 </div>
 <script data-sf-original-src=https://code.jquery.com/jquery.js src="data:application/javascript;base64,LyohCiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMTEuMQogKiBodHRwOi8vanF1ZXJ5LmNvbS8KICoKICogSW5jbHVkZXMgU2l6emxlLmpzCiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vCiAqCiAqIENvcHlyaWdodCAyMDA1LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnMKICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlCiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2UKICoKICogRGF0ZTogMjAxNC0wNS0wMVQxNzo0MloKICovCgooZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHsKCglpZiAoIHR5cGVvZiBtb2R1bGUgPT09ICJvYmplY3QiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gIm9iamVjdCIgKSB7CgkJLy8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciB3aW5kb3cgaXMgcHJlc2VudCwKCQkvLyBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5CgkJLy8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBpbmhlcmVudGx5IHBvc3NlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnQKCQkvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgalF1ZXJ5LW1ha2luZyBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzCgkJLy8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCB3aW5kb3cKCQkvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKCJqcXVlcnkiKSh3aW5kb3cpOwoJCS8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8KCQltb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/CgkJCWZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDoKCQkJZnVuY3Rpb24oIHcgKSB7CgkJCQlpZiAoICF3LmRvY3VtZW50ICkgewoJCQkJCXRocm93IG5ldyBFcnJvciggImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnQiICk7CgkJCQl9CgkJCQlyZXR1cm4gZmFjdG9yeSggdyApOwoJCQl9OwoJfSBlbHNlIHsKCQlmYWN0b3J5KCBnbG9iYWwgKTsKCX0KCi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0Cn0odHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHsKCi8vIENhbid0IGRvIHRoaXMgYmVjYXVzZSBzZXZlcmFsIGFwcHMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2UKLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmCi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCAidXNlIHN0cmljdCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpCi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrCi8vCgp2YXIgZGVsZXRlZElkcyA9IFtdOwoKdmFyIHNsaWNlID0gZGVsZXRlZElkcy5zbGljZTsKCnZhciBjb25jYXQgPSBkZWxldGVkSWRzLmNvbmNhdDsKCnZhciBwdXNoID0gZGVsZXRlZElkcy5wdXNoOwoKdmFyIGluZGV4T2YgPSBkZWxldGVkSWRzLmluZGV4T2Y7Cgp2YXIgY2xhc3MydHlwZSA9IHt9OwoKdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZzsKCnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5OwoKdmFyIHN1cHBvcnQgPSB7fTsKCgoKdmFyCgl2ZXJzaW9uID0gIjEuMTEuMSIsCgoJLy8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnkKCWpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHsKCQkvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCcKCQkvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKQoJCXJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7Cgl9LAoKCS8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBJRTw5CgkvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1AKCXJ0cmltID0gL15bXHNcdUZFRkZceEEwXSt8W1xzXHVGRUZGXHhBMF0rJC9nLAoKCS8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZwoJcm1zUHJlZml4ID0gL14tbXMtLywKCXJkYXNoQWxwaGEgPSAvLShbXGRhLXpdKS9naSwKCgkvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpCglmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkgewoJCXJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTsKCX07CgpqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0gewoJLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZAoJanF1ZXJ5OiB2ZXJzaW9uLAoKCWNvbnN0cnVjdG9yOiBqUXVlcnksCgoJLy8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvcgoJc2VsZWN0b3I6ICIiLAoKCS8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMAoJbGVuZ3RoOiAwLAoKCXRvQXJyYXk6IGZ1bmN0aW9uKCkgewoJCXJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7Cgl9LAoKCS8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1IKCS8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5CglnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7CgkJcmV0dXJuIG51bSAhPSBudWxsID8KCgkJCS8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXQKCQkJKCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOgoKCQkJLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheQoJCQlzbGljZS5jYWxsKCB0aGlzICk7Cgl9LAoKCS8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2sKCS8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KQoJcHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7CgoJCS8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0CgkJdmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApOwoKCQkvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKQoJCXJldC5wcmV2T2JqZWN0ID0gdGhpczsKCQlyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDsKCgkJLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXQKCQlyZXR1cm4gcmV0OwoJfSwKCgkvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LgoJLy8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXMKCS8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5LikKCWVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHsKCQlyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7Cgl9LAoKCW1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkgewoJCXJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHsKCQkJcmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTsKCQl9KSk7Cgl9LAoKCXNsaWNlOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApOwoJfSwKCglmaXJzdDogZnVuY3Rpb24oKSB7CgkJcmV0dXJuIHRoaXMuZXEoIDAgKTsKCX0sCgoJbGFzdDogZnVuY3Rpb24oKSB7CgkJcmV0dXJuIHRoaXMuZXEoIC0xICk7Cgl9LAoKCWVxOiBmdW5jdGlvbiggaSApIHsKCQl2YXIgbGVuID0gdGhpcy5sZW5ndGgsCgkJCWogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7CgkJcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTsKCX0sCgoJZW5kOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7Cgl9LAoKCS8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS4KCS8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLgoJcHVzaDogcHVzaCwKCXNvcnQ6IGRlbGV0ZWRJZHMuc29ydCwKCXNwbGljZTogZGVsZXRlZElkcy5zcGxpY2UKfTsKCmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7Cgl2YXIgc3JjLCBjb3B5SXNBcnJheSwgY29weSwgbmFtZSwgb3B0aW9ucywgY2xvbmUsCgkJdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LAoJCWkgPSAxLAoJCWxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsCgkJZGVlcCA9IGZhbHNlOwoKCS8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb24KCWlmICggdHlwZW9mIHRhcmdldCA9PT0gImJvb2xlYW4iICkgewoJCWRlZXAgPSB0YXJnZXQ7CgoJCS8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXQKCQl0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTsKCQlpKys7Cgl9CgoJLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpCglpZiAoIHR5cGVvZiB0YXJnZXQgIT09ICJvYmplY3QiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkgewoJCXRhcmdldCA9IHt9OwoJfQoKCS8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZAoJaWYgKCBpID09PSBsZW5ndGggKSB7CgkJdGFyZ2V0ID0gdGhpczsKCQlpLS07Cgl9CgoJZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7CgkJLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlcwoJCWlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHsKCQkJLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdAoJCQlmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7CgkJCQlzcmMgPSB0YXJnZXRbIG5hbWUgXTsKCQkJCWNvcHkgPSBvcHRpb25zWyBuYW1lIF07CgoJCQkJLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcAoJCQkJaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7CgkJCQkJY29udGludWU7CgkJCQl9CgoJCQkJLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzCgkJCQlpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkgewoJCQkJCWlmICggY29weUlzQXJyYXkgKSB7CgkJCQkJCWNvcHlJc0FycmF5ID0gZmFsc2U7CgkJCQkJCWNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTsKCgkJCQkJfSBlbHNlIHsKCQkJCQkJY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9OwoJCQkJCX0KCgkJCQkJLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtCgkJCQkJdGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApOwoKCQkJCS8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXMKCQkJCX0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHsKCQkJCQl0YXJnZXRbIG5hbWUgXSA9IGNvcHk7CgkJCQl9CgkJCX0KCQl9Cgl9CgoJLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3QKCXJldHVybiB0YXJnZXQ7Cn07CgpqUXVlcnkuZXh0ZW5kKHsKCS8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZQoJZXhwYW5kbzogImpRdWVyeSIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xEL2csICIiICksCgoJLy8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGUKCWlzUmVhZHk6IHRydWUsCgoJZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7CgkJdGhyb3cgbmV3IEVycm9yKCBtc2cgKTsKCX0sCgoJbm9vcDogZnVuY3Rpb24oKSB7fSwKCgkvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLgoJLy8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydAoJLy8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS4KCWlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7CgkJcmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09ICJmdW5jdGlvbiI7Cgl9LAoKCWlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oIG9iaiApIHsKCQlyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gImFycmF5IjsKCX0sCgoJaXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7CgkJLyoganNoaW50IGVxZXFlcTogZmFsc2UgKi8KCQlyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7Cgl9LAoKCWlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHsKCQkvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfCIiKQoJCS8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKCIweC4uLiIpCgkJLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOCgkJcmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgPj0gMDsKCX0sCgoJaXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHsKCQl2YXIgbmFtZTsKCQlmb3IgKCBuYW1lIGluIG9iaiApIHsKCQkJcmV0dXJuIGZhbHNlOwoJCX0KCQlyZXR1cm4gdHJ1ZTsKCX0sCgoJaXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHsKCQl2YXIga2V5OwoKCQkvLyBNdXN0IGJlIGFuIE9iamVjdC4KCQkvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS4KCQkvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbAoJCWlmICggIW9iaiB8fCBqUXVlcnkudHlwZShvYmopICE9PSAib2JqZWN0IiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHsKCQkJcmV0dXJuIGZhbHNlOwoJCX0KCgkJdHJ5IHsKCQkJLy8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdAoJCQlpZiAoIG9iai5jb25zdHJ1Y3RvciAmJgoJCQkJIWhhc093bi5jYWxsKG9iaiwgImNvbnN0cnVjdG9yIikgJiYKCQkJCSFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAiaXNQcm90b3R5cGVPZiIpICkgewoJCQkJcmV0dXJuIGZhbHNlOwoJCQl9CgkJfSBjYXRjaCAoIGUgKSB7CgkJCS8vIElFOCw5IFdpbGwgdGhyb3cgZXhjZXB0aW9ucyBvbiBjZXJ0YWluIGhvc3Qgb2JqZWN0cyAjOTg5NwoJCQlyZXR1cm4gZmFsc2U7CgkJfQoKCQkvLyBTdXBwb3J0OiBJRTw5CgkJLy8gSGFuZGxlIGl0ZXJhdGlvbiBvdmVyIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBvd24gcHJvcGVydGllcy4KCQlpZiAoIHN1cHBvcnQub3duTGFzdCApIHsKCQkJZm9yICgga2V5IGluIG9iaiApIHsKCQkJCXJldHVybiBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTsKCQkJfQoJCX0KCgkJLy8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsCgkJLy8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uCgkJZm9yICgga2V5IGluIG9iaiApIHt9CgoJCXJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTsKCX0sCgoJdHlwZTogZnVuY3Rpb24oIG9iaiApIHsKCQlpZiAoIG9iaiA9PSBudWxsICkgewoJCQlyZXR1cm4gb2JqICsgIiI7CgkJfQoJCXJldHVybiB0eXBlb2Ygb2JqID09PSAib2JqZWN0IiB8fCB0eXBlb2Ygb2JqID09PSAiZnVuY3Rpb24iID8KCQkJY2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgIm9iamVjdCIgOgoJCQl0eXBlb2Ygb2JqOwoJfSwKCgkvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dAoJLy8gV29ya2Fyb3VuZHMgYmFzZWQgb24gZmluZGluZ3MgYnkgSmltIERyaXNjb2xsCgkvLyBodHRwOi8vd2VibG9ncy5qYXZhLm5ldC9ibG9nL2RyaXNjb2xsL2FyY2hpdmUvMjAwOS8wOS8wOC9ldmFsLWphdmFzY3JpcHQtZ2xvYmFsLWNvbnRleHQKCWdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBkYXRhICkgewoJCWlmICggZGF0YSAmJiBqUXVlcnkudHJpbSggZGF0YSApICkgewoJCQkvLyBXZSB1c2UgZXhlY1NjcmlwdCBvbiBJbnRlcm5ldCBFeHBsb3JlcgoJCQkvLyBXZSB1c2UgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHNvIHRoYXQgY29udGV4dCBpcyB3aW5kb3cKCQkJLy8gcmF0aGVyIHRoYW4galF1ZXJ5IGluIEZpcmVmb3gKCQkJKCB3aW5kb3cuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiggZGF0YSApIHsKCQkJCXdpbmRvd1sgImV2YWwiIF0uY2FsbCggd2luZG93LCBkYXRhICk7CgkJCX0gKSggZGF0YSApOwoJCX0KCX0sCgoJLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlcwoJLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKQoJY2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkgewoJCXJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCAibXMtIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTsKCX0sCgoJbm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkgewoJCXJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpOwoJfSwKCgkvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5CgllYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjaywgYXJncyApIHsKCQl2YXIgdmFsdWUsCgkJCWkgPSAwLAoJCQlsZW5ndGggPSBvYmoubGVuZ3RoLAoJCQlpc0FycmF5ID0gaXNBcnJheWxpa2UoIG9iaiApOwoKCQlpZiAoIGFyZ3MgKSB7CgkJCWlmICggaXNBcnJheSApIHsKCQkJCWZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkgewoJCQkJCXZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7CgoJCQkJCWlmICggdmFsdWUgPT09IGZhbHNlICkgewoJCQkJCQlicmVhazsKCQkJCQl9CgkJCQl9CgkJCX0gZWxzZSB7CgkJCQlmb3IgKCBpIGluIG9iaiApIHsKCQkJCQl2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApOwoKCQkJCQlpZiAoIHZhbHVlID09PSBmYWxzZSApIHsKCQkJCQkJYnJlYWs7CgkJCQkJfQoJCQkJfQoJCQl9CgoJCS8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoCgkJfSBlbHNlIHsKCQkJaWYgKCBpc0FycmF5ICkgewoJCQkJZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7CgkJCQkJdmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTsKCgkJCQkJaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7CgkJCQkJCWJyZWFrOwoJCQkJCX0KCQkJCX0KCQkJfSBlbHNlIHsKCQkJCWZvciAoIGkgaW4gb2JqICkgewoJCQkJCXZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7CgoJCQkJCWlmICggdmFsdWUgPT09IGZhbHNlICkgewoJCQkJCQlicmVhazsKCQkJCQl9CgkJCQl9CgkJCX0KCQl9CgoJCXJldHVybiBvYmo7Cgl9LAoKCS8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBJRTw5Cgl0cmltOiBmdW5jdGlvbiggdGV4dCApIHsKCQlyZXR1cm4gdGV4dCA9PSBudWxsID8KCQkJIiIgOgoJCQkoIHRleHQgKyAiIiApLnJlcGxhY2UoIHJ0cmltLCAiIiApOwoJfSwKCgkvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5CgltYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7CgkJdmFyIHJldCA9IHJlc3VsdHMgfHwgW107CgoJCWlmICggYXJyICE9IG51bGwgKSB7CgkJCWlmICggaXNBcnJheWxpa2UoIE9iamVjdChhcnIpICkgKSB7CgkJCQlqUXVlcnkubWVyZ2UoIHJldCwKCQkJCQl0eXBlb2YgYXJyID09PSAic3RyaW5nIiA/CgkJCQkJWyBhcnIgXSA6IGFycgoJCQkJKTsKCQkJfSBlbHNlIHsKCQkJCXB1c2guY2FsbCggcmV0LCBhcnIgKTsKCQkJfQoJCX0KCgkJcmV0dXJuIHJldDsKCX0sCgoJaW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHsKCQl2YXIgbGVuOwoKCQlpZiAoIGFyciApIHsKCQkJaWYgKCBpbmRleE9mICkgewoJCQkJcmV0dXJuIGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7CgkJCX0KCgkJCWxlbiA9IGFyci5sZW5ndGg7CgkJCWkgPSBpID8gaSA8IDAgPyBNYXRoLm1heCggMCwgbGVuICsgaSApIDogaSA6IDA7CgoJCQlmb3IgKCA7IGkgPCBsZW47IGkrKyApIHsKCQkJCS8vIFNraXAgYWNjZXNzaW5nIGluIHNwYXJzZSBhcnJheXMKCQkJCWlmICggaSBpbiBhcnIgJiYgYXJyWyBpIF0gPT09IGVsZW0gKSB7CgkJCQkJcmV0dXJuIGk7CgkJCQl9CgkJCX0KCQl9CgoJCXJldHVybiAtMTsKCX0sCgoJbWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkgewoJCXZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCwKCQkJaiA9IDAsCgkJCWkgPSBmaXJzdC5sZW5ndGg7CgoJCXdoaWxlICggaiA8IGxlbiApIHsKCQkJZmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqKysgXTsKCQl9CgoJCS8vIFN1cHBvcnQ6IElFPDkKCQkvLyBXb3JrYXJvdW5kIGNhc3Rpbmcgb2YgLmxlbmd0aCB0byBOYU4gb24gb3RoZXJ3aXNlIGFycmF5bGlrZSBvYmplY3RzIChlLmcuLCBOb2RlTGlzdHMpCgkJaWYgKCBsZW4gIT09IGxlbiApIHsKCQkJd2hpbGUgKCBzZWNvbmRbal0gIT09IHVuZGVmaW5lZCApIHsKCQkJCWZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07CgkJCX0KCQl9CgoJCWZpcnN0Lmxlbmd0aCA9IGk7CgoJCXJldHVybiBmaXJzdDsKCX0sCgoJZ3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkgewoJCXZhciBjYWxsYmFja0ludmVyc2UsCgkJCW1hdGNoZXMgPSBbXSwKCQkJaSA9IDAsCgkJCWxlbmd0aCA9IGVsZW1zLmxlbmd0aCwKCQkJY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0OwoKCQkvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zCgkJLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb24KCQlmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHsKCQkJY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7CgkJCWlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHsKCQkJCW1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApOwoJCQl9CgkJfQoKCQlyZXR1cm4gbWF0Y2hlczsKCX0sCgoJLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5CgltYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHsKCQl2YXIgdmFsdWUsCgkJCWkgPSAwLAoJCQlsZW5ndGggPSBlbGVtcy5sZW5ndGgsCgkJCWlzQXJyYXkgPSBpc0FycmF5bGlrZSggZWxlbXMgKSwKCQkJcmV0ID0gW107CgoJCS8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzCgkJaWYgKCBpc0FycmF5ICkgewoJCQlmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHsKCQkJCXZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApOwoKCQkJCWlmICggdmFsdWUgIT0gbnVsbCApIHsKCQkJCQlyZXQucHVzaCggdmFsdWUgKTsKCQkJCX0KCQkJfQoKCQkvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LAoJCX0gZWxzZSB7CgkJCWZvciAoIGkgaW4gZWxlbXMgKSB7CgkJCQl2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTsKCgkJCQlpZiAoIHZhbHVlICE9IG51bGwgKSB7CgkJCQkJcmV0LnB1c2goIHZhbHVlICk7CgkJCQl9CgkJCX0KCQl9CgoJCS8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXMKCQlyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7Cgl9LAoKCS8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0cwoJZ3VpZDogMSwKCgkvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnkKCS8vIGFyZ3VtZW50cy4KCXByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7CgkJdmFyIGFyZ3MsIHByb3h5LCB0bXA7CgoJCWlmICggdHlwZW9mIGNvbnRleHQgPT09ICJzdHJpbmciICkgewoJCQl0bXAgPSBmblsgY29udGV4dCBdOwoJCQljb250ZXh0ID0gZm47CgkJCWZuID0gdG1wOwoJCX0KCgkJLy8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWMKCQkvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLgoJCWlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkgewoJCQlyZXR1cm4gdW5kZWZpbmVkOwoJCX0KCgkJLy8gU2ltdWxhdGVkIGJpbmQKCQlhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7CgkJcHJveHkgPSBmdW5jdGlvbigpIHsKCQkJcmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7CgkJfTsKCgkJLy8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkCgkJcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7CgoJCXJldHVybiBwcm94eTsKCX0sCgoJbm93OiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gKyggbmV3IERhdGUoKSApOwoJfSwKCgkvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXIKCS8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuCglzdXBwb3J0OiBzdXBwb3J0Cn0pOwoKLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwCmpRdWVyeS5lYWNoKCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIi5zcGxpdCgiICIpLCBmdW5jdGlvbihpLCBuYW1lKSB7CgljbGFzczJ0eXBlWyAiW29iamVjdCAiICsgbmFtZSArICJdIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpOwp9KTsKCmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7Cgl2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aCwKCQl0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApOwoKCWlmICggdHlwZSA9PT0gImZ1bmN0aW9uIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkgewoJCXJldHVybiBmYWxzZTsKCX0KCglpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7CgkJcmV0dXJuIHRydWU7Cgl9CgoJcmV0dXJuIHR5cGUgPT09ICJhcnJheSIgfHwgbGVuZ3RoID09PSAwIHx8CgkJdHlwZW9mIGxlbmd0aCA9PT0gIm51bWJlciIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7Cn0KdmFyIFNpenpsZSA9Ci8qIQogKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2MS4xMC4xOQogKiBodHRwOi8vc2l6emxlanMuY29tLwogKgogKiBDb3B5cmlnaHQgMjAxMyBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzCiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZQogKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlCiAqCiAqIERhdGU6IDIwMTQtMDQtMTgKICovCihmdW5jdGlvbiggd2luZG93ICkgewoKdmFyIGksCglzdXBwb3J0LAoJRXhwciwKCWdldFRleHQsCglpc1hNTCwKCXRva2VuaXplLAoJY29tcGlsZSwKCXNlbGVjdCwKCW91dGVybW9zdENvbnRleHQsCglzb3J0SW5wdXQsCgloYXNEdXBsaWNhdGUsCgoJLy8gTG9jYWwgZG9jdW1lbnQgdmFycwoJc2V0RG9jdW1lbnQsCglkb2N1bWVudCwKCWRvY0VsZW0sCglkb2N1bWVudElzSFRNTCwKCXJidWdneVFTQSwKCXJidWdneU1hdGNoZXMsCgltYXRjaGVzLAoJY29udGFpbnMsCgoJLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YQoJZXhwYW5kbyA9ICJzaXp6bGUiICsgLShuZXcgRGF0ZSgpKSwKCXByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCwKCWRpcnJ1bnMgPSAwLAoJZG9uZSA9IDAsCgljbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSwKCXRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLAoJY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksCglzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHsKCQlpZiAoIGEgPT09IGIgKSB7CgkJCWhhc0R1cGxpY2F0ZSA9IHRydWU7CgkJfQoJCXJldHVybiAwOwoJfSwKCgkvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzCglzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkLAoJTUFYX05FR0FUSVZFID0gMSA8PCAzMSwKCgkvLyBJbnN0YW5jZSBtZXRob2RzCgloYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LAoJYXJyID0gW10sCglwb3AgPSBhcnIucG9wLAoJcHVzaF9uYXRpdmUgPSBhcnIucHVzaCwKCXB1c2ggPSBhcnIucHVzaCwKCXNsaWNlID0gYXJyLnNsaWNlLAoJLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGlmIHdlIGNhbid0IHVzZSBhIG5hdGl2ZSBvbmUKCWluZGV4T2YgPSBhcnIuaW5kZXhPZiB8fCBmdW5jdGlvbiggZWxlbSApIHsKCQl2YXIgaSA9IDAsCgkJCWxlbiA9IHRoaXMubGVuZ3RoOwoJCWZvciAoIDsgaSA8IGxlbjsgaSsrICkgewoJCQlpZiAoIHRoaXNbaV0gPT09IGVsZW0gKSB7CgkJCQlyZXR1cm4gaTsKCQkJfQoJCX0KCQlyZXR1cm4gLTE7Cgl9LAoKCWJvb2xlYW5zID0gImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkIiwKCgkvLyBSZWd1bGFyIGV4cHJlc3Npb25zCgoJLy8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlCgl3aGl0ZXNwYWNlID0gIltcXHgyMFxcdFxcclxcblxcZl0iLAoJLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2NoYXJhY3RlcnMKCWNoYXJhY3RlckVuY29kaW5nID0gIig/OlxcXFwufFtcXHctXXxbXlxceDAwLVxceGEwXSkrIiwKCgkvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVycwoJLy8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnMKCS8vIFByb3BlciBzeW50YXg6IGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllcgoJaWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoICJ3IiwgIncjIiApLAoKCS8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9ycwoJYXR0cmlidXRlcyA9ICJcXFsiICsgd2hpdGVzcGFjZSArICIqKCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArICIpKD86IiArIHdoaXRlc3BhY2UgKwoJCS8vIE9wZXJhdG9yIChjYXB0dXJlIDIpCgkJIiooWypeJHwhfl0/PSkiICsgd2hpdGVzcGFjZSArCgkJLy8gIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF0iCgkJIiooPzonKCg/OlxcXFwufFteXFxcXCddKSopJ3xcIigoPzpcXFxcLnxbXlxcXFxcIl0pKilcInwoIiArIGlkZW50aWZpZXIgKyAiKSl8KSIgKyB3aGl0ZXNwYWNlICsKCQkiKlxcXSIsCgoJcHNldWRvcyA9ICI6KCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArICIpKD86XFwoKCIgKwoJCS8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6CgkJLy8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpCgkJIignKCg/OlxcXFwufFteXFxcXCddKSopJ3xcIigoPzpcXFxcLnxbXlxcXFxcIl0pKilcIil8IiArCgkJLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpCgkJIigoPzpcXFxcLnxbXlxcXFwoKVtcXF1dfCIgKyBhdHRyaWJ1dGVzICsgIikqKXwiICsKCQkvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpCgkJIi4qIiArCgkJIilcXCl8KSIsCgoJLy8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlcgoJcnRyaW0gPSBuZXcgUmVnRXhwKCAiXiIgKyB3aGl0ZXNwYWNlICsgIit8KCg/Ol58W15cXFxcXSkoPzpcXFxcLikqKSIgKyB3aGl0ZXNwYWNlICsgIiskIiwgImciICksCgoJcmNvbW1hID0gbmV3IFJlZ0V4cCggIl4iICsgd2hpdGVzcGFjZSArICIqLCIgKyB3aGl0ZXNwYWNlICsgIioiICksCglyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCAiXiIgKyB3aGl0ZXNwYWNlICsgIiooWz4rfl18IiArIHdoaXRlc3BhY2UgKyAiKSIgKyB3aGl0ZXNwYWNlICsgIioiICksCgoJcmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoICI9IiArIHdoaXRlc3BhY2UgKyAiKihbXlxcXSdcIl0qPykiICsgd2hpdGVzcGFjZSArICIqXFxdIiwgImciICksCgoJcnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSwKCXJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggIl4iICsgaWRlbnRpZmllciArICIkIiApLAoKCW1hdGNoRXhwciA9IHsKCQkiSUQiOiBuZXcgUmVnRXhwKCAiXiMoIiArIGNoYXJhY3RlckVuY29kaW5nICsgIikiICksCgkJIkNMQVNTIjogbmV3IFJlZ0V4cCggIl5cXC4oIiArIGNoYXJhY3RlckVuY29kaW5nICsgIikiICksCgkJIlRBRyI6IG5ldyBSZWdFeHAoICJeKCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCAidyIsICJ3KiIgKSArICIpIiApLAoJCSJBVFRSIjogbmV3IFJlZ0V4cCggIl4iICsgYXR0cmlidXRlcyApLAoJCSJQU0VVRE8iOiBuZXcgUmVnRXhwKCAiXiIgKyBwc2V1ZG9zICksCgkJIkNISUxEIjogbmV3IFJlZ0V4cCggIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcKCIgKyB3aGl0ZXNwYWNlICsKCQkJIiooZXZlbnxvZGR8KChbKy1dfCkoXFxkKilufCkiICsgd2hpdGVzcGFjZSArICIqKD86KFsrLV18KSIgKyB3aGl0ZXNwYWNlICsKCQkJIiooXFxkKyl8KSkiICsgd2hpdGVzcGFjZSArICIqXFwpfCkiLCAiaSIgKSwKCQkiYm9vbCI6IG5ldyBSZWdFeHAoICJeKD86IiArIGJvb2xlYW5zICsgIikkIiwgImkiICksCgkJLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpCgkJLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YAoJCSJuZWVkc0NvbnRleHQiOiBuZXcgUmVnRXhwKCAiXiIgKyB3aGl0ZXNwYWNlICsgIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcKCIgKwoJCQl3aGl0ZXNwYWNlICsgIiooKD86LVxcZCk/XFxkKikiICsgd2hpdGVzcGFjZSArICIqXFwpfCkoPz1bXi1dfCQpIiwgImkiICkKCX0sCgoJcmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksCglyaGVhZGVyID0gL15oXGQkL2ksCgoJcm5hdGl2ZSA9IC9eW157XStce1xzKlxbbmF0aXZlIFx3LywKCgkvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnMKCXJxdWlja0V4cHIgPSAvXig/OiMoW1x3LV0rKXwoXHcrKXxcLihbXHctXSspKSQvLAoKCXJzaWJsaW5nID0gL1srfl0vLAoJcmVzY2FwZSA9IC8nfFxcL2csCgoJLy8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVycwoJcnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggIlxcXFwoW1xcZGEtZl17MSw2fSIgKyB3aGl0ZXNwYWNlICsgIj98KCIgKyB3aGl0ZXNwYWNlICsgIil8LikiLCAiaWciICksCglmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7CgkJdmFyIGhpZ2ggPSAiMHgiICsgZXNjYXBlZCAtIDB4MTAwMDA7CgkJLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnQKCQkvLyBTdXBwb3J0OiBGaXJlZm94PDI0CgkJLy8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArIjB4IgoJCXJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID8KCQkJZXNjYXBlZCA6CgkJCWhpZ2ggPCAwID8KCQkJCS8vIEJNUCBjb2RlcG9pbnQKCQkJCVN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOgoJCQkJLy8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpCgkJCQlTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTsKCX07CgovLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKQp0cnkgewoJcHVzaC5hcHBseSgKCQkoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksCgkJcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMKCSk7CgkvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMAoJLy8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseQoJYXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTsKfSBjYXRjaCAoIGUgKSB7CglwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/CgoJCS8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlCgkJZnVuY3Rpb24oIHRhcmdldCwgZWxzICkgewoJCQlwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTsKCQl9IDoKCgkJLy8gU3VwcG9ydDogSUU8OQoJCS8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHkKCQlmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7CgkJCXZhciBqID0gdGFyZ2V0Lmxlbmd0aCwKCQkJCWkgPSAwOwoJCQkvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGgKCQkJd2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fQoJCQl0YXJnZXQubGVuZ3RoID0gaiAtIDE7CgkJfQoJfTsKfQoKZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHsKCXZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsCgkJLy8gUVNBIHZhcnMKCQlpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjsKCglpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkgewoJCXNldERvY3VtZW50KCBjb250ZXh0ICk7Cgl9CgoJY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7CglyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTsKCglpZiAoICFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09ICJzdHJpbmciICkgewoJCXJldHVybiByZXN1bHRzOwoJfQoKCWlmICggKG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZSkgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgKSB7CgkJcmV0dXJuIFtdOwoJfQoKCWlmICggZG9jdW1lbnRJc0hUTUwgJiYgIXNlZWQgKSB7CgoJCS8vIFNob3J0Y3V0cwoJCWlmICggKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHsKCQkJLy8gU3BlZWQtdXA6IFNpenpsZSgiI0lEIikKCQkJaWYgKCAobSA9IG1hdGNoWzFdKSApIHsKCQkJCWlmICggbm9kZVR5cGUgPT09IDkgKSB7CgkJCQkJZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTsKCQkJCQkvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJucwoJCQkJCS8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2MykKCQkJCQlpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkgewoJCQkJCQkvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUsIE9wZXJhLCBhbmQgV2Via2l0IHJldHVybiBpdGVtcwoJCQkJCQkvLyBieSBuYW1lIGluc3RlYWQgb2YgSUQKCQkJCQkJaWYgKCBlbGVtLmlkID09PSBtICkgewoJCQkJCQkJcmVzdWx0cy5wdXNoKCBlbGVtICk7CgkJCQkJCQlyZXR1cm4gcmVzdWx0czsKCQkJCQkJfQoJCQkJCX0gZWxzZSB7CgkJCQkJCXJldHVybiByZXN1bHRzOwoJCQkJCX0KCQkJCX0gZWxzZSB7CgkJCQkJLy8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudAoJCQkJCWlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmCgkJCQkJCWNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHsKCQkJCQkJcmVzdWx0cy5wdXNoKCBlbGVtICk7CgkJCQkJCXJldHVybiByZXN1bHRzOwoJCQkJCX0KCQkJCX0KCgkJCS8vIFNwZWVkLXVwOiBTaXp6bGUoIlRBRyIpCgkJCX0gZWxzZSBpZiAoIG1hdGNoWzJdICkgewoJCQkJcHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApOwoJCQkJcmV0dXJuIHJlc3VsdHM7CgoJCQkvLyBTcGVlZC11cDogU2l6emxlKCIuQ0xBU1MiKQoJCQl9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkgewoJCQkJcHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTsKCQkJCXJldHVybiByZXN1bHRzOwoJCQl9CgkJfQoKCQkvLyBRU0EgcGF0aAoJCWlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHsKCQkJbmlkID0gb2xkID0gZXhwYW5kbzsKCQkJbmV3Q29udGV4dCA9IGNvbnRleHQ7CgkJCW5ld1NlbGVjdG9yID0gbm9kZVR5cGUgPT09IDkgJiYgc2VsZWN0b3I7CgoJCQkvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXMKCQkJLy8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdAoJCQkvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSkKCQkJLy8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzCgkJCWlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAib2JqZWN0IiApIHsKCQkJCWdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApOwoKCQkJCWlmICggKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCJpZCIpKSApIHsKCQkJCQluaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgIlxcJCYiICk7CgkJCQl9IGVsc2UgewoJCQkJCWNvbnRleHQuc2V0QXR0cmlidXRlKCAiaWQiLCBuaWQgKTsKCQkJCX0KCQkJCW5pZCA9ICJbaWQ9JyIgKyBuaWQgKyAiJ10gIjsKCgkJCQlpID0gZ3JvdXBzLmxlbmd0aDsKCQkJCXdoaWxlICggaS0tICkgewoJCQkJCWdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApOwoJCQkJfQoJCQkJbmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7CgkJCQluZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCIsIik7CgkJCX0KCgkJCWlmICggbmV3U2VsZWN0b3IgKSB7CgkJCQl0cnkgewoJCQkJCXB1c2guYXBwbHkoIHJlc3VsdHMsCgkJCQkJCW5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKQoJCQkJCSk7CgkJCQkJcmV0dXJuIHJlc3VsdHM7CgkJCQl9IGNhdGNoKHFzYUVycm9yKSB7CgkJCQl9IGZpbmFsbHkgewoJCQkJCWlmICggIW9sZCApIHsKCQkJCQkJY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoImlkIik7CgkJCQkJfQoJCQkJfQoJCQl9CgkJfQoJfQoKCS8vIEFsbCBvdGhlcnMKCXJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCAiJDEiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTsKfQoKLyoqCiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZQogKiBAcmV0dXJucyB7RnVuY3Rpb24oc3RyaW5nLCBPYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoCiAqCXByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpCiAqCWRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnkKICovCmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkgewoJdmFyIGtleXMgPSBbXTsKCglmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHsKCQkvLyBVc2UgKGtleSArICIgIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NykKCQlpZiAoIGtleXMucHVzaCgga2V5ICsgIiAiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkgewoJCQkvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXMKCQkJZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTsKCQl9CgkJcmV0dXJuIChjYWNoZVsga2V5ICsgIiAiIF0gPSB2YWx1ZSk7Cgl9CglyZXR1cm4gY2FjaGU7Cn0KCi8qKgogKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFyawogKi8KZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHsKCWZuWyBleHBhbmRvIF0gPSB0cnVlOwoJcmV0dXJuIGZuOwp9CgovKioKICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnQKICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0CiAqLwpmdW5jdGlvbiBhc3NlcnQoIGZuICkgewoJdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwoKCXRyeSB7CgkJcmV0dXJuICEhZm4oIGRpdiApOwoJfSBjYXRjaCAoZSkgewoJCXJldHVybiBmYWxzZTsKCX0gZmluYWxseSB7CgkJLy8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0CgkJaWYgKCBkaXYucGFyZW50Tm9kZSApIHsKCQkJZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApOwoJCX0KCQkvLyByZWxlYXNlIG1lbW9yeSBpbiBJRQoJCWRpdiA9IG51bGw7Cgl9Cn0KCi8qKgogKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzCiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXMKICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkCiAqLwpmdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkgewoJdmFyIGFyciA9IGF0dHJzLnNwbGl0KCJ8IiksCgkJaSA9IGF0dHJzLmxlbmd0aDsKCgl3aGlsZSAoIGktLSApIHsKCQlFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjsKCX0KfQoKLyoqCiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3MKICogQHBhcmFtIHtFbGVtZW50fSBhCiAqIEBwYXJhbSB7RWxlbWVudH0gYgogKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGIKICovCmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHsKCXZhciBjdXIgPSBiICYmIGEsCgkJZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiYKCQkJKCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtCgkJCSggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7CgoJLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzCglpZiAoIGRpZmYgKSB7CgkJcmV0dXJuIGRpZmY7Cgl9CgoJLy8gQ2hlY2sgaWYgYiBmb2xsb3dzIGEKCWlmICggY3VyICkgewoJCXdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7CgkJCWlmICggY3VyID09PSBiICkgewoJCQkJcmV0dXJuIC0xOwoJCQl9CgkJfQoJfQoKCXJldHVybiBhID8gMSA6IC0xOwp9CgovKioKICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlcwogKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogKi8KZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7CglyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7CgkJdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CgkJcmV0dXJuIG5hbWUgPT09ICJpbnB1dCIgJiYgZWxlbS50eXBlID09PSB0eXBlOwoJfTsKfQoKLyoqCiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9ucwogKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogKi8KZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkgewoJcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkgewoJCXZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOwoJCXJldHVybiAobmFtZSA9PT0gImlucHV0IiB8fCBuYW1lID09PSAiYnV0dG9uIikgJiYgZWxlbS50eXBlID09PSB0eXBlOwoJfTsKfQoKLyoqCiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHMKICogQHBhcmFtIHtGdW5jdGlvbn0gZm4KICovCmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkgewoJcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7CgkJYXJndW1lbnQgPSArYXJndW1lbnQ7CgkJcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHsKCQkJdmFyIGosCgkJCQltYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLAoJCQkJaSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7CgoJCQkvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXMKCQkJd2hpbGUgKCBpLS0gKSB7CgkJCQlpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkgewoJCQkJCXNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTsKCQkJCX0KCQkJfQoJCX0pOwoJfSk7Cn0KCi8qKgogKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0CiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0CiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZQogKi8KZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7CglyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkICYmIGNvbnRleHQ7Cn0KCi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlCnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9OwoKLyoqCiAqIERldGVjdHMgWE1MIG5vZGVzCiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50CiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGUKICovCmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7CgkvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0CgkvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMykKCXZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50OwoJcmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gIkhUTUwiIDogZmFsc2U7Cn07CgovKioKICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50CiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50CiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnQKICovCnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7Cgl2YXIgaGFzQ29tcGFyZSwKCQlkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2MsCgkJcGFyZW50ID0gZG9jLmRlZmF1bHRWaWV3OwoKCS8vIElmIG5vIGRvY3VtZW50IGFuZCBkb2N1bWVudEVsZW1lbnQgaXMgYXZhaWxhYmxlLCByZXR1cm4KCWlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7CgkJcmV0dXJuIGRvY3VtZW50OwoJfQoKCS8vIFNldCBvdXIgZG9jdW1lbnQKCWRvY3VtZW50ID0gZG9jOwoJZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7CgoJLy8gU3VwcG9ydCB0ZXN0cwoJZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvYyApOwoKCS8vIFN1cHBvcnQ6IElFPjgKCS8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byAiZG9jdW1lbnQiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsCgkvLyBJRSB3aWxsIHRocm93ICJwZXJtaXNzaW9uIGRlbmllZCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgImRvY3VtZW50IiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzYKCS8vIElFNi04IGRvIG5vdCBzdXBwb3J0IHRoZSBkZWZhdWx0VmlldyBwcm9wZXJ0eSBzbyBwYXJlbnQgd2lsbCBiZSB1bmRlZmluZWQKCWlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHsKCQkvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlcgoJCWlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7CgkJCXBhcmVudC5hZGRFdmVudExpc3RlbmVyKCAidW5sb2FkIiwgZnVuY3Rpb24oKSB7CgkJCQlzZXREb2N1bWVudCgpOwoJCQl9LCBmYWxzZSApOwoJCX0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHsKCQkJcGFyZW50LmF0dGFjaEV2ZW50KCAib251bmxvYWQiLCBmdW5jdGlvbigpIHsKCQkJCXNldERvY3VtZW50KCk7CgkJCX0pOwoJCX0KCX0KCgkvKiBBdHRyaWJ1dGVzCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovCgoJLy8gU3VwcG9ydDogSUU8OAoJLy8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKQoJc3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7CgkJZGl2LmNsYXNzTmFtZSA9ICJpIjsKCQlyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIpOwoJfSk7CgoJLyogZ2V0RWxlbWVudChzKUJ5KgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqLwoKCS8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKCIqIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzCglzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7CgkJZGl2LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlQ29tbWVudCgiIikgKTsKCQlyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiKiIpLmxlbmd0aDsKCX0pOwoKCS8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgY2FuIGJlIHRydXN0ZWQKCXN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSAmJiBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHsKCQlkaXYuaW5uZXJIVE1MID0gIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+IjsKCgkJLy8gU3VwcG9ydDogU2FmYXJpPDQKCQkvLyBDYXRjaCBjbGFzcyBvdmVyLWNhY2hpbmcKCQlkaXYuZmlyc3RDaGlsZC5jbGFzc05hbWUgPSAiaSI7CgkJLy8gU3VwcG9ydDogT3BlcmE8MTAKCQkvLyBDYXRjaCBnRUJDTiBmYWlsdXJlIHRvIGZpbmQgbm9uLWxlYWRpbmcgY2xhc3NlcwoJCXJldHVybiBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgiaSIpLmxlbmd0aCA9PT0gMjsKCX0pOwoKCS8vIFN1cHBvcnQ6IElFPDEwCgkvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWUKCS8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsCgkvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3QKCXN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkgewoJCWRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbzsKCQlyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoOwoJfSk7CgoJLy8gSUQgZmluZCBhbmQgZmlsdGVyCglpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHsKCQlFeHByLmZpbmRbIklEIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7CgkJCWlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCApIHsKCQkJCXZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTsKCQkJCS8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zCgkJCQkvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzCgkJCQlyZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbIG0gXSA6IFtdOwoJCQl9CgkJfTsKCQlFeHByLmZpbHRlclsiSUQiXSA9IGZ1bmN0aW9uKCBpZCApIHsKCQkJdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7CgkJCXJldHVybiBmdW5jdGlvbiggZWxlbSApIHsKCQkJCXJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSgiaWQiKSA9PT0gYXR0cklkOwoJCQl9OwoJCX07Cgl9IGVsc2UgewoJCS8vIFN1cHBvcnQ6IElFNi83CgkJLy8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dAoJCWRlbGV0ZSBFeHByLmZpbmRbIklEIl07CgoJCUV4cHIuZmlsdGVyWyJJRCJdID0gIGZ1bmN0aW9uKCBpZCApIHsKCQkJdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7CgkJCXJldHVybiBmdW5jdGlvbiggZWxlbSApIHsKCQkJCXZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gc3RydW5kZWZpbmVkICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSgiaWQiKTsKCQkJCXJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDsKCQkJfTsKCQl9OwoJfQoKCS8vIFRhZwoJRXhwci5maW5kWyJUQUciXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPwoJCWZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7CgkJCWlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IHN0cnVuZGVmaW5lZCApIHsKCQkJCXJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTsKCQkJfQoJCX0gOgoJCWZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7CgkJCXZhciBlbGVtLAoJCQkJdG1wID0gW10sCgkJCQlpID0gMCwKCQkJCXJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTsKCgkJCS8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHMKCQkJaWYgKCB0YWcgPT09ICIqIiApIHsKCQkJCXdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkgewoJCQkJCWlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHsKCQkJCQkJdG1wLnB1c2goIGVsZW0gKTsKCQkJCQl9CgkJCQl9CgoJCQkJcmV0dXJuIHRtcDsKCQkJfQoJCQlyZXR1cm4gcmVzdWx0czsKCQl9OwoKCS8vIENsYXNzCglFeHByLmZpbmRbIkNMQVNTIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHsKCQlpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCApIHsKCQkJcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7CgkJfQoJfTsKCgkvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovCgoJLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydAoKCS8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpCglyYnVnZ3lNYXRjaGVzID0gW107CgoJLy8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSkKCS8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvcgoJLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZQoJLy8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3IKCS8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OAoJcmJ1Z2d5UVNBID0gW107CgoJaWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkgewoJCS8vIEJ1aWxkIFFTQSByZWdleAoJCS8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmkKCQlhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHsKCQkJLy8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZQoJCQkvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHkKCQkJLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsCgkJCS8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoCgkJCS8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5CgkJCWRpdi5pbm5lckhUTUwgPSAiPHNlbGVjdCBtc2FsbG93Y2xpcD0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PiI7CgoJCQkvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2CgkJCS8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj0KCQkJLy8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgInNhZmUiIGZvciBXaW5SVAoJCQkvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvbgoJCQlpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKCJbbXNhbGxvd2NsaXBePScnXSIpLmxlbmd0aCApIHsKCQkJCXJidWdneVFTQS5wdXNoKCAiWypeJF09IiArIHdoaXRlc3BhY2UgKyAiKig/OicnfFwiXCIpIiApOwoJCQl9CgoJCQkvLyBTdXBwb3J0OiBJRTgKCQkJLy8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCAidmFsdWUiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHkKCQkJaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIltzZWxlY3RlZF0iKS5sZW5ndGggKSB7CgkJCQlyYnVnZ3lRU0EucHVzaCggIlxcWyIgKyB3aGl0ZXNwYWNlICsgIiooPzp2YWx1ZXwiICsgYm9vbGVhbnMgKyAiKSIgKTsKCQkJfQoKCQkJLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHMKCQkJLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWQKCQkJLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHMKCQkJaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIjpjaGVja2VkIikubGVuZ3RoICkgewoJCQkJcmJ1Z2d5UVNBLnB1c2goIjpjaGVja2VkIik7CgkJCX0KCQl9KTsKCgkJYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7CgkJCS8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwcwoJCQkvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnQKCQkJdmFyIGlucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7CgkJCWlucHV0LnNldEF0dHJpYnV0ZSggInR5cGUiLCAiaGlkZGVuIiApOwoJCQlkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCAibmFtZSIsICJEIiApOwoKCQkJLy8gU3VwcG9ydDogSUU4CgkJCS8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZQoJCQlpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKCJbbmFtZT1kXSIpLmxlbmd0aCApIHsKCQkJCXJidWdneVFTQS5wdXNoKCAibmFtZSIgKyB3aGl0ZXNwYWNlICsgIipbKl4kfCF+XT89IiApOwoJCQl9CgoJCQkvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKQoJCQkvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0cwoJCQlpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCgiOmVuYWJsZWQiKS5sZW5ndGggKSB7CgkJCQlyYnVnZ3lRU0EucHVzaCggIjplbmFibGVkIiwgIjpkaXNhYmxlZCIgKTsKCQkJfQoKCQkJLy8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3MKCQkJZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIiosOngiKTsKCQkJcmJ1Z2d5UVNBLnB1c2goIiwuKjoiKTsKCQl9KTsKCX0KCglpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHwKCQlkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fAoJCWRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8CgkJZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8CgkJZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7CgoJCWFzc2VydChmdW5jdGlvbiggZGl2ICkgewoJCQkvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3IKCQkJLy8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSkKCQkJc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCAiZGl2IiApOwoKCQkJLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvbgoJCQkvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkCgkJCW1hdGNoZXMuY2FsbCggZGl2LCAiW3MhPScnXTp4IiApOwoJCQlyYnVnZ3lNYXRjaGVzLnB1c2goICIhPSIsIHBzZXVkb3MgKTsKCQl9KTsKCX0KCglyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCJ8IikgKTsKCXJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oInwiKSApOwoKCS8qIENvbnRhaW5zCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovCgloYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7CgoJLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyCgkvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50CgkvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZgoJY29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID8KCQlmdW5jdGlvbiggYSwgYiApIHsKCQkJdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSwKCQkJCWJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlOwoJCQlyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmICgKCQkJCWFkb3duLmNvbnRhaW5zID8KCQkJCQlhZG93bi5jb250YWlucyggYnVwICkgOgoJCQkJCWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNgoJCQkpKTsKCQl9IDoKCQlmdW5jdGlvbiggYSwgYiApIHsKCQkJaWYgKCBiICkgewoJCQkJd2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7CgkJCQkJaWYgKCBiID09PSBhICkgewoJCQkJCQlyZXR1cm4gdHJ1ZTsKCQkJCQl9CgkJCQl9CgkJCX0KCQkJcmV0dXJuIGZhbHNlOwoJCX07CgoJLyogU29ydGluZwoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqLwoKCS8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmcKCXNvcnRPcmRlciA9IGhhc0NvbXBhcmUgPwoJZnVuY3Rpb24oIGEsIGIgKSB7CgoJCS8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsCgkJaWYgKCBhID09PSBiICkgewoJCQloYXNEdXBsaWNhdGUgPSB0cnVlOwoJCQlyZXR1cm4gMDsKCQl9CgoJCS8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb24KCQl2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247CgkJaWYgKCBjb21wYXJlICkgewoJCQlyZXR1cm4gY29tcGFyZTsKCQl9CgoJCS8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnQKCQljb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgPwoJCQlhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOgoKCQkJLy8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkCgkJCTE7CgoJCS8vIERpc2Nvbm5lY3RlZCBub2RlcwoJCWlmICggY29tcGFyZSAmIDEgfHwKCQkJKCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkgewoKCQkJLy8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50CgkJCWlmICggYSA9PT0gZG9jIHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7CgkJCQlyZXR1cm4gLTE7CgkJCX0KCQkJaWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHsKCQkJCXJldHVybiAxOwoJCQl9CgoJCQkvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlcgoJCQlyZXR1cm4gc29ydElucHV0ID8KCQkJCSggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6CgkJCQkwOwoJCX0KCgkJcmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxOwoJfSA6CglmdW5jdGlvbiggYSwgYiApIHsKCQkvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsCgkJaWYgKCBhID09PSBiICkgewoJCQloYXNEdXBsaWNhdGUgPSB0cnVlOwoJCQlyZXR1cm4gMDsKCQl9CgoJCXZhciBjdXIsCgkJCWkgPSAwLAoJCQlhdXAgPSBhLnBhcmVudE5vZGUsCgkJCWJ1cCA9IGIucGFyZW50Tm9kZSwKCQkJYXAgPSBbIGEgXSwKCQkJYnAgPSBbIGIgXTsKCgkJLy8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWQKCQlpZiAoICFhdXAgfHwgIWJ1cCApIHsKCQkJcmV0dXJuIGEgPT09IGRvYyA/IC0xIDoKCQkJCWIgPT09IGRvYyA/IDEgOgoJCQkJYXVwID8gLTEgOgoJCQkJYnVwID8gMSA6CgkJCQlzb3J0SW5wdXQgPwoJCQkJKCBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGIgKSApIDoKCQkJCTA7CgoJCS8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrCgkJfSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7CgkJCXJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTsKCQl9CgoJCS8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uCgkJY3VyID0gYTsKCQl3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7CgkJCWFwLnVuc2hpZnQoIGN1ciApOwoJCX0KCQljdXIgPSBiOwoJCXdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHsKCQkJYnAudW5zaGlmdCggY3VyICk7CgkJfQoKCQkvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeQoJCXdoaWxlICggYXBbaV0gPT09IGJwW2ldICkgewoJCQlpKys7CgkJfQoKCQlyZXR1cm4gaSA/CgkJCS8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvcgoJCQlzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDoKCgkJCS8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdAoJCQlhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOgoJCQlicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6CgkJCTA7Cgl9OwoKCXJldHVybiBkb2M7Cn07CgpTaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHsKCXJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7Cn07CgpTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7CgkvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWQKCWlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHsKCQlzZXREb2N1bWVudCggZWxlbSApOwoJfQoKCS8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZAoJZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgIj0nJDEnXSIgKTsKCglpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmCgkJKCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJgoJCSggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHsKCgkJdHJ5IHsKCQkJdmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApOwoKCQkJLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2RlcwoJCQlpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8CgkJCQkJLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnQKCQkJCQkvLyBmcmFnbWVudCBpbiBJRSA5CgkJCQkJZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHsKCQkJCXJldHVybiByZXQ7CgkJCX0KCQl9IGNhdGNoKGUpIHt9Cgl9CgoJcmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDsKfTsKClNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkgewoJLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkCglpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7CgkJc2V0RG9jdW1lbnQoIGNvbnRleHQgKTsKCX0KCXJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApOwp9OwoKU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHsKCS8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZAoJaWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkgewoJCXNldERvY3VtZW50KCBlbGVtICk7Cgl9CgoJdmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSwKCQkvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNykKCQl2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/CgkJCWZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6CgkJCXVuZGVmaW5lZDsKCglyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPwoJCXZhbCA6CgkJc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/CgkJCWVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOgoJCQkodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID8KCQkJCXZhbC52YWx1ZSA6CgkJCQludWxsOwp9OwoKU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHsKCXRocm93IG5ldyBFcnJvciggIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246ICIgKyBtc2cgKTsKfTsKCi8qKgogKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzCiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzCiAqLwpTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkgewoJdmFyIGVsZW0sCgkJZHVwbGljYXRlcyA9IFtdLAoJCWogPSAwLAoJCWkgPSAwOwoKCS8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2UKCWhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7Cglzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTsKCXJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7CgoJaWYgKCBoYXNEdXBsaWNhdGUgKSB7CgkJd2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7CgkJCWlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkgewoJCQkJaiA9IGR1cGxpY2F0ZXMucHVzaCggaSApOwoJCQl9CgkJfQoJCXdoaWxlICggai0tICkgewoJCQlyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7CgkJfQoJfQoKCS8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzCgkvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjUKCXNvcnRJbnB1dCA9IG51bGw7CgoJcmV0dXJuIHJlc3VsdHM7Cn07CgovKioKICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXMKICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtCiAqLwpnZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHsKCXZhciBub2RlLAoJCXJldCA9ICIiLAoJCWkgPSAwLAoJCW5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTsKCglpZiAoICFub2RlVHlwZSApIHsKCQkvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheQoJCXdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkgewoJCQkvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2RlcwoJCQlyZXQgKz0gZ2V0VGV4dCggbm9kZSApOwoJCX0KCX0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHsKCQkvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzCgkJLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MykKCQlpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSAic3RyaW5nIiApIHsKCQkJcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7CgkJfSBlbHNlIHsKCQkJLy8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuCgkJCWZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkgewoJCQkJcmV0ICs9IGdldFRleHQoIGVsZW0gKTsKCQkJfQoJCX0KCX0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkgewoJCXJldHVybiBlbGVtLm5vZGVWYWx1ZTsKCX0KCS8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2RlcwoKCXJldHVybiByZXQ7Cn07CgpFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHsKCgkvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXIKCWNhY2hlTGVuZ3RoOiA1MCwKCgljcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbiwKCgltYXRjaDogbWF0Y2hFeHByLAoKCWF0dHJIYW5kbGU6IHt9LAoKCWZpbmQ6IHt9LAoKCXJlbGF0aXZlOiB7CgkJIj4iOiB7IGRpcjogInBhcmVudE5vZGUiLCBmaXJzdDogdHJ1ZSB9LAoJCSIgIjogeyBkaXI6ICJwYXJlbnROb2RlIiB9LAoJCSIrIjogeyBkaXI6ICJwcmV2aW91c1NpYmxpbmciLCBmaXJzdDogdHJ1ZSB9LAoJCSJ+IjogeyBkaXI6ICJwcmV2aW91c1NpYmxpbmciIH0KCX0sCgoJcHJlRmlsdGVyOiB7CgkJIkFUVFIiOiBmdW5jdGlvbiggbWF0Y2ggKSB7CgkJCW1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTsKCgkJCS8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkCgkJCW1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCAiIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7CgoJCQlpZiAoIG1hdGNoWzJdID09PSAifj0iICkgewoJCQkJbWF0Y2hbM10gPSAiICIgKyBtYXRjaFszXSArICIgIjsKCQkJfQoKCQkJcmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7CgkJfSwKCgkJIkNISUxEIjogZnVuY3Rpb24oIG1hdGNoICkgewoJCQkvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByWyJDSElMRCJdCgkJCQkxIHR5cGUgKG9ubHl8bnRofC4uLikKCQkJCTIgd2hhdCAoY2hpbGR8b2YtdHlwZSkKCQkJCTMgYXJndW1lbnQgKGV2ZW58b2RkfFxkKnxcZCpuKFsrLV1cZCspP3wuLi4pCgkJCQk0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xkKm58KQoJCQkJNSBzaWduIG9mIHhuLWNvbXBvbmVudAoJCQkJNiB4IG9mIHhuLWNvbXBvbmVudAoJCQkJNyBzaWduIG9mIHktY29tcG9uZW50CgkJCQk4IHkgb2YgeS1jb21wb25lbnQKCQkJKi8KCQkJbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpOwoKCQkJaWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSAibnRoIiApIHsKCQkJCS8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50CgkJCQlpZiAoICFtYXRjaFszXSApIHsKCQkJCQlTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7CgkJCQl9CgoJCQkJLy8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxECgkJCQkvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xCgkJCQltYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gImV2ZW4iIHx8IG1hdGNoWzNdID09PSAib2RkIiApICk7CgkJCQltYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSAib2RkIiApOwoKCQkJLy8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzCgkJCX0gZWxzZSBpZiAoIG1hdGNoWzNdICkgewoJCQkJU2l6emxlLmVycm9yKCBtYXRjaFswXSApOwoJCQl9CgoJCQlyZXR1cm4gbWF0Y2g7CgkJfSwKCgkJIlBTRVVETyI6IGZ1bmN0aW9uKCBtYXRjaCApIHsKCQkJdmFyIGV4Y2VzcywKCQkJCXVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdOwoKCQkJaWYgKCBtYXRjaEV4cHJbIkNISUxEIl0udGVzdCggbWF0Y2hbMF0gKSApIHsKCQkJCXJldHVybiBudWxsOwoJCQl9CgoJCQkvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pcwoJCQlpZiAoIG1hdGNoWzNdICkgewoJCQkJbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCAiIjsKCgkJCS8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzCgkJCX0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJgoJCQkJLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSkKCQkJCShleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiYKCQkJCS8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpcwoJCQkJKGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoICIpIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkgewoKCQkJCS8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4CgkJCQltYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTsKCQkJCW1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApOwoJCQl9CgoJCQkvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudCkKCQkJcmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7CgkJfQoJfSwKCglmaWx0ZXI6IHsKCgkJIlRBRyI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkgewoJCQl2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTsKCQkJcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09ICIqIiA/CgkJCQlmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOgoJCQkJZnVuY3Rpb24oIGVsZW0gKSB7CgkJCQkJcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTsKCQkJCX07CgkJfSwKCgkJIkNMQVNTIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHsKCQkJdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyAiICIgXTsKCgkJCXJldHVybiBwYXR0ZXJuIHx8CgkJCQkocGF0dGVybiA9IG5ldyBSZWdFeHAoICIoXnwiICsgd2hpdGVzcGFjZSArICIpIiArIGNsYXNzTmFtZSArICIoIiArIHdoaXRlc3BhY2UgKyAifCQpIiApKSAmJgoJCQkJY2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHsKCQkJCQlyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09ICJzdHJpbmciICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gc3RydW5kZWZpbmVkICYmIGVsZW0uZ2V0QXR0cmlidXRlKCJjbGFzcyIpIHx8ICIiICk7CgkJCQl9KTsKCQl9LAoKCQkiQVRUUiI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7CgkJCXJldHVybiBmdW5jdGlvbiggZWxlbSApIHsKCQkJCXZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApOwoKCQkJCWlmICggcmVzdWx0ID09IG51bGwgKSB7CgkJCQkJcmV0dXJuIG9wZXJhdG9yID09PSAiIT0iOwoJCQkJfQoJCQkJaWYgKCAhb3BlcmF0b3IgKSB7CgkJCQkJcmV0dXJuIHRydWU7CgkJCQl9CgoJCQkJcmVzdWx0ICs9ICIiOwoKCQkJCXJldHVybiBvcGVyYXRvciA9PT0gIj0iID8gcmVzdWx0ID09PSBjaGVjayA6CgkJCQkJb3BlcmF0b3IgPT09ICIhPSIgPyByZXN1bHQgIT09IGNoZWNrIDoKCQkJCQlvcGVyYXRvciA9PT0gIl49IiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDoKCQkJCQlvcGVyYXRvciA9PT0gIio9IiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOgoJCQkJCW9wZXJhdG9yID09PSAiJD0iID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDoKCQkJCQlvcGVyYXRvciA9PT0gIn49IiA/ICggIiAiICsgcmVzdWx0ICsgIiAiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDoKCQkJCQlvcGVyYXRvciA9PT0gInw9IiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgIi0iIDoKCQkJCQlmYWxzZTsKCQkJfTsKCQl9LAoKCQkiQ0hJTEQiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkgewoJCQl2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSAibnRoIiwKCQkJCWZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSAibGFzdCIsCgkJCQlvZlR5cGUgPSB3aGF0ID09PSAib2YtdHlwZSI7CgoJCQlyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/CgoJCQkJLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKQoJCQkJZnVuY3Rpb24oIGVsZW0gKSB7CgkJCQkJcmV0dXJuICEhZWxlbS5wYXJlbnROb2RlOwoJCQkJfSA6CgoJCQkJZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHsKCQkJCQl2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIGRpZmYsIG5vZGVJbmRleCwgc3RhcnQsCgkJCQkJCWRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/ICJuZXh0U2libGluZyIgOiAicHJldmlvdXNTaWJsaW5nIiwKCQkJCQkJcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLAoJCQkJCQluYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwKCQkJCQkJdXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7CgoJCQkJCWlmICggcGFyZW50ICkgewoKCQkJCQkJLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKQoJCQkJCQlpZiAoIHNpbXBsZSApIHsKCQkJCQkJCXdoaWxlICggZGlyICkgewoJCQkJCQkJCW5vZGUgPSBlbGVtOwoJCQkJCQkJCXdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7CgkJCQkJCQkJCWlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHsKCQkJCQkJCQkJCXJldHVybiBmYWxzZTsKCQkJCQkJCQkJfQoJCQkJCQkJCX0KCQkJCQkJCQkvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbykKCQkJCQkJCQlzdGFydCA9IGRpciA9IHR5cGUgPT09ICJvbmx5IiAmJiAhc3RhcnQgJiYgIm5leHRTaWJsaW5nIjsKCQkJCQkJCX0KCQkJCQkJCXJldHVybiB0cnVlOwoJCQkJCQl9CgoJCQkJCQlzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdOwoKCQkJCQkJLy8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGAKCQkJCQkJaWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkgewoJCQkJCQkJLy8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4CgkJCQkJCQlvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pOwoJCQkJCQkJY2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107CgkJCQkJCQlub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTsKCQkJCQkJCWRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTsKCQkJCQkJCW5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdOwoKCQkJCQkJCXdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8CgoJCQkJCQkJCS8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0CgkJCQkJCQkJKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7CgoJCQkJCQkJCS8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrCgkJCQkJCQkJaWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkgewoJCQkJCQkJCQlvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdOwoJCQkJCQkJCQlicmVhazsKCQkJCQkJCQl9CgkJCQkJCQl9CgoJCQkJCQkvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGUKCQkJCQkJfSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHsKCQkJCQkJCWRpZmYgPSBjYWNoZVsxXTsKCgkJCQkJCS8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKQoJCQkJCQl9IGVsc2UgewoJCQkJCQkJLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnQKCQkJCQkJCXdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8CgkJCQkJCQkJKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7CgoJCQkJCQkJCWlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkgewoJCQkJCQkJCQkvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50CgkJCQkJCQkJCWlmICggdXNlQ2FjaGUgKSB7CgkJCQkJCQkJCQkobm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTsKCQkJCQkJCQkJfQoKCQkJCQkJCQkJaWYgKCBub2RlID09PSBlbGVtICkgewoJCQkJCQkJCQkJYnJlYWs7CgkJCQkJCQkJCX0KCQkJCQkJCQl9CgkJCQkJCQl9CgkJCQkJCX0KCgkJCQkJCS8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplCgkJCQkJCWRpZmYgLT0gbGFzdDsKCQkJCQkJcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7CgkJCQkJfQoJCQkJfTsKCQl9LAoKCQkiUFNFVURPIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7CgkJCS8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZQoJCQkvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzCgkJCS8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzCgkJCS8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3MKCQkJdmFyIGFyZ3MsCgkJCQlmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8CgkJCQkJU2l6emxlLmVycm9yKCAidW5zdXBwb3J0ZWQgcHNldWRvOiAiICsgcHNldWRvICk7CgoJCQkvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0CgkJCS8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uCgkJCS8vIGp1c3QgYXMgU2l6emxlIGRvZXMKCQkJaWYgKCBmblsgZXhwYW5kbyBdICkgewoJCQkJcmV0dXJuIGZuKCBhcmd1bWVudCApOwoJCQl9CgoJCQkvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXMKCQkJaWYgKCBmbi5sZW5ndGggPiAxICkgewoJCQkJYXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sICIiLCBhcmd1bWVudCBdOwoJCQkJcmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/CgkJCQkJbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkgewoJCQkJCQl2YXIgaWR4LAoJCQkJCQkJbWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLAoJCQkJCQkJaSA9IG1hdGNoZWQubGVuZ3RoOwoJCQkJCQl3aGlsZSAoIGktLSApIHsKCQkJCQkJCWlkeCA9IGluZGV4T2YuY2FsbCggc2VlZCwgbWF0Y2hlZFtpXSApOwoJCQkJCQkJc2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTsKCQkJCQkJfQoJCQkJCX0pIDoKCQkJCQlmdW5jdGlvbiggZWxlbSApIHsKCQkJCQkJcmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7CgkJCQkJfTsKCQkJfQoKCQkJcmV0dXJuIGZuOwoJCX0KCX0sCgoJcHNldWRvczogewoJCS8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvcwoJCSJub3QiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkgewoJCQkvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZQoJCQkvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZwoJCQkvLyBzcGFjZXMgYXMgY29tYmluYXRvcnMKCQkJdmFyIGlucHV0ID0gW10sCgkJCQlyZXN1bHRzID0gW10sCgkJCQltYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sICIkMSIgKSApOwoKCQkJcmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/CgkJCQltYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHsKCQkJCQl2YXIgZWxlbSwKCQkJCQkJdW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLAoJCQkJCQlpID0gc2VlZC5sZW5ndGg7CgoJCQkJCS8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmAKCQkJCQl3aGlsZSAoIGktLSApIHsKCQkJCQkJaWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7CgkJCQkJCQlzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7CgkJCQkJCX0KCQkJCQl9CgkJCQl9KSA6CgkJCQlmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkgewoJCQkJCWlucHV0WzBdID0gZWxlbTsKCQkJCQltYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7CgkJCQkJcmV0dXJuICFyZXN1bHRzLnBvcCgpOwoJCQkJfTsKCQl9KSwKCgkJImhhcyI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7CgkJCXJldHVybiBmdW5jdGlvbiggZWxlbSApIHsKCQkJCXJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDsKCQkJfTsKCQl9KSwKCgkJImNvbnRhaW5zIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkgewoJCQlyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7CgkJCQlyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xOwoJCQl9OwoJCX0pLAoKCQkvLyAiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvcgoJCS8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlCgkJLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQywKCQkvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5ICItIi4KCQkvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS4KCQkvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLiIKCQkvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvCgkJImxhbmciOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkgewoJCQkvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyCgkJCWlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCAiIikgKSB7CgkJCQlTaXp6bGUuZXJyb3IoICJ1bnN1cHBvcnRlZCBsYW5nOiAiICsgbGFuZyApOwoJCQl9CgkJCWxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTsKCQkJcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkgewoJCQkJdmFyIGVsZW1MYW5nOwoJCQkJZG8gewoJCQkJCWlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgPwoJCQkJCQllbGVtLmxhbmcgOgoJCQkJCQllbGVtLmdldEF0dHJpYnV0ZSgieG1sOmxhbmciKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSgibGFuZyIpKSApIHsKCgkJCQkJCWVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTsKCQkJCQkJcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyAiLSIgKSA9PT0gMDsKCQkJCQl9CgkJCQl9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTsKCQkJCXJldHVybiBmYWxzZTsKCQkJfTsKCQl9KSwKCgkJLy8gTWlzY2VsbGFuZW91cwoJCSJ0YXJnZXQiOiBmdW5jdGlvbiggZWxlbSApIHsKCQkJdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7CgkJCXJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDsKCQl9LAoKCQkicm9vdCI6IGZ1bmN0aW9uKCBlbGVtICkgewoJCQlyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTsKCQl9LAoKCQkiZm9jdXMiOiBmdW5jdGlvbiggZWxlbSApIHsKCQkJcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTsKCQl9LAoKCQkvLyBCb29sZWFuIHByb3BlcnRpZXMKCQkiZW5hYmxlZCI6IGZ1bmN0aW9uKCBlbGVtICkgewoJCQlyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7CgkJfSwKCgkJImRpc2FibGVkIjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCXJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlOwoJCX0sCgoJCSJjaGVja2VkIjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCS8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50cwoJCQkvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZAoJCQl2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CgkJCXJldHVybiAobm9kZU5hbWUgPT09ICJpbnB1dCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gIm9wdGlvbiIgJiYgISFlbGVtLnNlbGVjdGVkKTsKCQl9LAoKCQkic2VsZWN0ZWQiOiBmdW5jdGlvbiggZWxlbSApIHsKCQkJLy8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdAoJCQkvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5CgkJCWlmICggZWxlbS5wYXJlbnROb2RlICkgewoJCQkJZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7CgkJCX0KCgkJCXJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlOwoJCX0sCgoJCS8vIENvbnRlbnRzCgkJImVtcHR5IjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCS8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvCgkJCS8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSwKCQkJLy8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLikKCQkJLy8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlbgoJCQlmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHsKCQkJCWlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7CgkJCQkJcmV0dXJuIGZhbHNlOwoJCQkJfQoJCQl9CgkJCXJldHVybiB0cnVlOwoJCX0sCgoJCSJwYXJlbnQiOiBmdW5jdGlvbiggZWxlbSApIHsKCQkJcmV0dXJuICFFeHByLnBzZXVkb3NbImVtcHR5Il0oIGVsZW0gKTsKCQl9LAoKCQkvLyBFbGVtZW50L2lucHV0IHR5cGVzCgkJImhlYWRlciI6IGZ1bmN0aW9uKCBlbGVtICkgewoJCQlyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7CgkJfSwKCgkJImlucHV0IjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCXJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTsKCQl9LAoKCQkiYnV0dG9uIjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCXZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOwoJCQlyZXR1cm4gbmFtZSA9PT0gImlucHV0IiAmJiBlbGVtLnR5cGUgPT09ICJidXR0b24iIHx8IG5hbWUgPT09ICJidXR0b24iOwoJCX0sCgoJCSJ0ZXh0IjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCXZhciBhdHRyOwoJCQlyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAiaW5wdXQiICYmCgkJCQllbGVtLnR5cGUgPT09ICJ0ZXh0IiAmJgoKCQkJCS8vIFN1cHBvcnQ6IElFPDgKCQkJCS8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCAic2VhcmNoIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSAidGV4dCIKCQkJCSggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSgidHlwZSIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gInRleHQiICk7CgkJfSwKCgkJLy8gUG9zaXRpb24taW4tY29sbGVjdGlvbgoJCSJmaXJzdCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7CgkJCXJldHVybiBbIDAgXTsKCQl9KSwKCgkJImxhc3QiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHsKCQkJcmV0dXJuIFsgbGVuZ3RoIC0gMSBdOwoJCX0pLAoKCQkiZXEiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7CgkJCXJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTsKCQl9KSwKCgkJImV2ZW4iOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHsKCQkJdmFyIGkgPSAwOwoJCQlmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHsKCQkJCW1hdGNoSW5kZXhlcy5wdXNoKCBpICk7CgkJCX0KCQkJcmV0dXJuIG1hdGNoSW5kZXhlczsKCQl9KSwKCgkJIm9kZCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkgewoJCQl2YXIgaSA9IDE7CgkJCWZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkgewoJCQkJbWF0Y2hJbmRleGVzLnB1c2goIGkgKTsKCQkJfQoJCQlyZXR1cm4gbWF0Y2hJbmRleGVzOwoJCX0pLAoKCQkibHQiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7CgkJCXZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDsKCQkJZm9yICggOyAtLWkgPj0gMDsgKSB7CgkJCQltYXRjaEluZGV4ZXMucHVzaCggaSApOwoJCQl9CgkJCXJldHVybiBtYXRjaEluZGV4ZXM7CgkJfSksCgoJCSJndCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHsKCQkJdmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50OwoJCQlmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7CgkJCQltYXRjaEluZGV4ZXMucHVzaCggaSApOwoJCQl9CgkJCXJldHVybiBtYXRjaEluZGV4ZXM7CgkJfSkKCX0KfTsKCkV4cHIucHNldWRvc1sibnRoIl0gPSBFeHByLnBzZXVkb3NbImVxIl07CgovLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvcwpmb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHsKCUV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTsKfQpmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkgewoJRXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTsKfQoKLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzCmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fQpzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvczsKRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTsKCnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7Cgl2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSwKCQlzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLAoJCWNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgIiAiIF07CgoJaWYgKCBjYWNoZWQgKSB7CgkJcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTsKCX0KCglzb0ZhciA9IHNlbGVjdG9yOwoJZ3JvdXBzID0gW107CglwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7CgoJd2hpbGUgKCBzb0ZhciApIHsKCgkJLy8gQ29tbWEgYW5kIGZpcnN0IHJ1bgoJCWlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkgewoJCQlpZiAoIG1hdGNoICkgewoJCQkJLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWQKCQkJCXNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyOwoJCQl9CgkJCWdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7CgkJfQoKCQltYXRjaGVkID0gZmFsc2U7CgoJCS8vIENvbWJpbmF0b3JzCgkJaWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7CgkJCW1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpOwoJCQl0b2tlbnMucHVzaCh7CgkJCQl2YWx1ZTogbWF0Y2hlZCwKCQkJCS8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZQoJCQkJdHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sICIgIiApCgkJCX0pOwoJCQlzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApOwoJCX0KCgkJLy8gRmlsdGVycwoJCWZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7CgkJCWlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHwKCQkJCShtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkgewoJCQkJbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7CgkJCQl0b2tlbnMucHVzaCh7CgkJCQkJdmFsdWU6IG1hdGNoZWQsCgkJCQkJdHlwZTogdHlwZSwKCQkJCQltYXRjaGVzOiBtYXRjaAoJCQkJfSk7CgkJCQlzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApOwoJCQl9CgkJfQoKCQlpZiAoICFtYXRjaGVkICkgewoJCQlicmVhazsKCQl9Cgl9CgoJLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzCgkvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmcKCS8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2VucwoJcmV0dXJuIHBhcnNlT25seSA/CgkJc29GYXIubGVuZ3RoIDoKCQlzb0ZhciA/CgkJCVNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6CgkJCS8vIENhY2hlIHRoZSB0b2tlbnMKCQkJdG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7Cn07CgpmdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7Cgl2YXIgaSA9IDAsCgkJbGVuID0gdG9rZW5zLmxlbmd0aCwKCQlzZWxlY3RvciA9ICIiOwoJZm9yICggOyBpIDwgbGVuOyBpKysgKSB7CgkJc2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlOwoJfQoJcmV0dXJuIHNlbGVjdG9yOwp9CgpmdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkgewoJdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLAoJCWNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gInBhcmVudE5vZGUiLAoJCWRvbmVOYW1lID0gZG9uZSsrOwoKCXJldHVybiBjb21iaW5hdG9yLmZpcnN0ID8KCQkvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnQKCQlmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkgewoJCQl3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkgewoJCQkJaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7CgkJCQkJcmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApOwoJCQkJfQoJCQl9CgkJfSA6CgoJCS8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50cwoJCWZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7CgkJCXZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSwKCQkJCW5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdOwoKCQkJLy8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmcKCQkJaWYgKCB4bWwgKSB7CgkJCQl3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkgewoJCQkJCWlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkgewoJCQkJCQlpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgewoJCQkJCQkJcmV0dXJuIHRydWU7CgkJCQkJCX0KCQkJCQl9CgkJCQl9CgkJCX0gZWxzZSB7CgkJCQl3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkgewoJCQkJCWlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkgewoJCQkJCQlvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7CgkJCQkJCWlmICggKG9sZENhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0pICYmCgkJCQkJCQlvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkgewoKCQkJCQkJCS8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzCgkJCQkJCQlyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTsKCQkJCQkJfSBlbHNlIHsKCQkJCQkJCS8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHMKCQkJCQkJCW91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7CgoJCQkJCQkJLy8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nCgkJCQkJCQlpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkgewoJCQkJCQkJCXJldHVybiB0cnVlOwoJCQkJCQkJfQoJCQkJCQl9CgkJCQkJfQoJCQkJfQoJCQl9CgkJfTsKfQoKZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkgewoJcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgPwoJCWZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7CgkJCXZhciBpID0gbWF0Y2hlcnMubGVuZ3RoOwoJCQl3aGlsZSAoIGktLSApIHsKCQkJCWlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHsKCQkJCQlyZXR1cm4gZmFsc2U7CgkJCQl9CgkJCX0KCQkJcmV0dXJuIHRydWU7CgkJfSA6CgkJbWF0Y2hlcnNbMF07Cn0KCmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHsKCXZhciBpID0gMCwKCQlsZW4gPSBjb250ZXh0cy5sZW5ndGg7Cglmb3IgKCA7IGkgPCBsZW47IGkrKyApIHsKCQlTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApOwoJfQoJcmV0dXJuIHJlc3VsdHM7Cn0KCmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7Cgl2YXIgZWxlbSwKCQluZXdVbm1hdGNoZWQgPSBbXSwKCQlpID0gMCwKCQlsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLAoJCW1hcHBlZCA9IG1hcCAhPSBudWxsOwoKCWZvciAoIDsgaSA8IGxlbjsgaSsrICkgewoJCWlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkgewoJCQlpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHsKCQkJCW5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7CgkJCQlpZiAoIG1hcHBlZCApIHsKCQkJCQltYXAucHVzaCggaSApOwoJCQkJfQoJCQl9CgkJfQoJfQoKCXJldHVybiBuZXdVbm1hdGNoZWQ7Cn0KCmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHsKCWlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkgewoJCXBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7Cgl9CglpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHsKCQlwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7Cgl9CglyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7CgkJdmFyIHRlbXAsIGksIGVsZW0sCgkJCXByZU1hcCA9IFtdLAoJCQlwb3N0TWFwID0gW10sCgkJCXByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsCgoJCQkvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dAoJCQllbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgIioiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLAoKCQkJLy8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uCgkJCW1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgPwoJCQkJY29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOgoJCQkJZWxlbXMsCgoJCQltYXRjaGVyT3V0ID0gbWF0Y2hlciA/CgkJCQkvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLAoJCQkJcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgPwoKCQkJCQkvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnkKCQkJCQlbXSA6CgoJCQkJCS8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseQoJCQkJCXJlc3VsdHMgOgoJCQkJbWF0Y2hlckluOwoKCQkvLyBGaW5kIHByaW1hcnkgbWF0Y2hlcwoJCWlmICggbWF0Y2hlciApIHsKCQkJbWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTsKCQl9CgoJCS8vIEFwcGx5IHBvc3RGaWx0ZXIKCQlpZiAoIHBvc3RGaWx0ZXIgKSB7CgkJCXRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApOwoJCQlwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7CgoJCQkvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluCgkJCWkgPSB0ZW1wLmxlbmd0aDsKCQkJd2hpbGUgKCBpLS0gKSB7CgkJCQlpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7CgkJCQkJbWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pOwoJCQkJfQoJCQl9CgkJfQoKCQlpZiAoIHNlZWQgKSB7CgkJCWlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7CgkJCQlpZiAoIHBvc3RGaW5kZXIgKSB7CgkJCQkJLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzCgkJCQkJdGVtcCA9IFtdOwoJCQkJCWkgPSBtYXRjaGVyT3V0Lmxlbmd0aDsKCQkJCQl3aGlsZSAoIGktLSApIHsKCQkJCQkJaWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkgewoJCQkJCQkJLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2gKCQkJCQkJCXRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7CgkJCQkJCX0KCQkJCQl9CgkJCQkJcG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApOwoJCQkJfQoKCQkJCS8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkCgkJCQlpID0gbWF0Y2hlck91dC5sZW5ndGg7CgkJCQl3aGlsZSAoIGktLSApIHsKCQkJCQlpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiYKCQkJCQkJKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7CgoJCQkJCQlzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7CgkJCQkJfQoJCQkJfQoJCQl9CgoJCS8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZAoJCX0gZWxzZSB7CgkJCW1hdGNoZXJPdXQgPSBjb25kZW5zZSgKCQkJCW1hdGNoZXJPdXQgPT09IHJlc3VsdHMgPwoJCQkJCW1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6CgkJCQkJbWF0Y2hlck91dAoJCQkpOwoJCQlpZiAoIHBvc3RGaW5kZXIgKSB7CgkJCQlwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTsKCQkJfSBlbHNlIHsKCQkJCXB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTsKCQkJfQoJCX0KCX0pOwp9CgpmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkgewoJdmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaiwKCQlsZW4gPSB0b2tlbnMubGVuZ3RoLAoJCWxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sCgkJaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyIgIl0sCgkJaSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLAoKCQkvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKQoJCW1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkgewoJCQlyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0OwoJCX0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSwKCQltYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHsKCQkJcmV0dXJuIGluZGV4T2YuY2FsbCggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTsKCQl9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksCgkJbWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7CgkJCXJldHVybiAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKAoJCQkJKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID8KCQkJCQltYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDoKCQkJCQltYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7CgkJfSBdOwoKCWZvciAoIDsgaSA8IGxlbjsgaSsrICkgewoJCWlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHsKCQkJbWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07CgkJfSBlbHNlIHsKCQkJbWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApOwoKCQkJLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXIKCQkJaWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7CgkJCQkvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmcKCQkJCWogPSArK2k7CgkJCQlmb3IgKCA7IGogPCBsZW47IGorKyApIHsKCQkJCQlpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7CgkJCQkJCWJyZWFrOwoJCQkJCX0KCQkJCX0KCQkJCXJldHVybiBzZXRNYXRjaGVyKAoJCQkJCWkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLAoJCQkJCWkgPiAxICYmIHRvU2VsZWN0b3IoCgkJCQkJCS8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgCgkJCQkJCXRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09ICIgIiA/ICIqIiA6ICIiIH0pCgkJCQkJKS5yZXBsYWNlKCBydHJpbSwgIiQxIiApLAoJCQkJCW1hdGNoZXIsCgkJCQkJaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksCgkJCQkJaiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLAoJCQkJCWogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zICkKCQkJCSk7CgkJCX0KCQkJbWF0Y2hlcnMucHVzaCggbWF0Y2hlciApOwoJCX0KCX0KCglyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7Cn0KCmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHsKCXZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsCgkJYnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsCgkJc3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkgewoJCQl2YXIgZWxlbSwgaiwgbWF0Y2hlciwKCQkJCW1hdGNoZWRDb3VudCA9IDAsCgkJCQlpID0gIjAiLAoJCQkJdW5tYXRjaGVkID0gc2VlZCAmJiBbXSwKCQkJCXNldE1hdGNoZWQgPSBbXSwKCQkJCWNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LAoJCQkJLy8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dAoJCQkJZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbIlRBRyJdKCAiKiIsIG91dGVybW9zdCApLAoJCQkJLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXIKCQkJCWRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLAoJCQkJbGVuID0gZWxlbXMubGVuZ3RoOwoKCQkJaWYgKCBvdXRlcm1vc3QgKSB7CgkJCQlvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDsKCQkJfQoKCQkJLy8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHMKCQkJLy8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgIjAwIiBiZWxvdwoJCQkvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmkKCQkJLy8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6ICJsZW5ndGgiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZAoJCQlmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7CgkJCQlpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkgewoJCQkJCWogPSAwOwoJCQkJCXdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7CgkJCQkJCWlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7CgkJCQkJCQlyZXN1bHRzLnB1c2goIGVsZW0gKTsKCQkJCQkJCWJyZWFrOwoJCQkJCQl9CgkJCQkJfQoJCQkJCWlmICggb3V0ZXJtb3N0ICkgewoJCQkJCQlkaXJydW5zID0gZGlycnVuc1VuaXF1ZTsKCQkJCQl9CgkJCQl9CgoJCQkJLy8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVycwoJCQkJaWYgKCBieVNldCApIHsKCQkJCQkvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzCgkJCQkJaWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkgewoJCQkJCQltYXRjaGVkQ291bnQtLTsKCQkJCQl9CgoJCQkJCS8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3QKCQkJCQlpZiAoIHNlZWQgKSB7CgkJCQkJCXVubWF0Y2hlZC5wdXNoKCBlbGVtICk7CgkJCQkJfQoJCQkJfQoJCQl9CgoJCQkvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHMKCQkJbWF0Y2hlZENvdW50ICs9IGk7CgkJCWlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkgewoJCQkJaiA9IDA7CgkJCQl3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7CgkJCQkJbWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTsKCQkJCX0KCgkJCQlpZiAoIHNlZWQgKSB7CgkJCQkJLy8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZwoJCQkJCWlmICggbWF0Y2hlZENvdW50ID4gMCApIHsKCQkJCQkJd2hpbGUgKCBpLS0gKSB7CgkJCQkJCQlpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkgewoJCQkJCQkJCXNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApOwoJCQkJCQkJfQoJCQkJCQl9CgkJCQkJfQoKCQkJCQkvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlcwoJCQkJCXNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApOwoJCQkJfQoKCQkJCS8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHMKCQkJCXB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTsKCgkJCQkvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmcKCQkJCWlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJgoJCQkJCSggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkgewoKCQkJCQlTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApOwoJCQkJfQoJCQl9CgoJCQkvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnMKCQkJaWYgKCBvdXRlcm1vc3QgKSB7CgkJCQlkaXJydW5zID0gZGlycnVuc1VuaXF1ZTsKCQkJCW91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwOwoJCQl9CgoJCQlyZXR1cm4gdW5tYXRjaGVkOwoJCX07CgoJcmV0dXJuIGJ5U2V0ID8KCQltYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDoKCQlzdXBlck1hdGNoZXI7Cn0KCmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7Cgl2YXIgaSwKCQlzZXRNYXRjaGVycyA9IFtdLAoJCWVsZW1lbnRNYXRjaGVycyA9IFtdLAoJCWNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgIiAiIF07CgoJaWYgKCAhY2FjaGVkICkgewoJCS8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudAoJCWlmICggIW1hdGNoICkgewoJCQltYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApOwoJCX0KCQlpID0gbWF0Y2gubGVuZ3RoOwoJCXdoaWxlICggaS0tICkgewoJCQljYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTsKCQkJaWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHsKCQkJCXNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApOwoJCQl9IGVsc2UgewoJCQkJZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApOwoJCQl9CgkJfQoKCQkvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24KCQljYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTsKCgkJLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uCgkJY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7Cgl9CglyZXR1cm4gY2FjaGVkOwp9OwoKLyoqCiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWQKICogIHNlbGVjdG9yIGZ1bmN0aW9ucwogKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZAogKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZQogKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHQKICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdCiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0CiAqLwpzZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkgewoJdmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsCgkJY29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09ICJmdW5jdGlvbiIgJiYgc2VsZWN0b3IsCgkJbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7CgoJcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107CgoJLy8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXAKCWlmICggbWF0Y2gubGVuZ3RoID09PSAxICkgewoKCQkvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRAoJCXRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTsKCQlpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gIklEIiAmJgoJCQkJc3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYKCQkJCUV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7CgoJCQljb250ZXh0ID0gKCBFeHByLmZpbmRbIklEIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdOwoJCQlpZiAoICFjb250ZXh0ICkgewoJCQkJcmV0dXJuIHJlc3VsdHM7CgoJCQkvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsCgkJCX0gZWxzZSBpZiAoIGNvbXBpbGVkICkgewoJCQkJY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTsKCQkJfQoKCQkJc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7CgkJfQoKCQkvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nCgkJaSA9IG1hdGNoRXhwclsibmVlZHNDb250ZXh0Il0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoOwoJCXdoaWxlICggaS0tICkgewoJCQl0b2tlbiA9IHRva2Vuc1tpXTsKCgkJCS8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3IKCQkJaWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7CgkJCQlicmVhazsKCQkJfQoJCQlpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkgewoJCQkJLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzCgkJCQlpZiAoIChzZWVkID0gZmluZCgKCQkJCQl0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksCgkJCQkJcnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dAoJCQkJKSkgKSB7CgoJCQkJCS8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseQoJCQkJCXRva2Vucy5zcGxpY2UoIGksIDEgKTsKCQkJCQlzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApOwoJCQkJCWlmICggIXNlbGVjdG9yICkgewoJCQkJCQlwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7CgkJCQkJCXJldHVybiByZXN1bHRzOwoJCQkJCX0KCgkJCQkJYnJlYWs7CgkJCQl9CgkJCX0KCQl9Cgl9CgoJLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkCgkvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlCgkoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoCgkJc2VlZCwKCQljb250ZXh0LAoJCSFkb2N1bWVudElzSFRNTCwKCQlyZXN1bHRzLAoJCXJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQKCSk7CglyZXR1cm4gcmVzdWx0czsKfTsKCi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzCgovLyBTb3J0IHN0YWJpbGl0eQpzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCIiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCIiKSA9PT0gZXhwYW5kbzsKCi8vIFN1cHBvcnQ6IENocm9tZTwxNAovLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uCnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlOwoKLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50CnNldERvY3VtZW50KCk7CgovLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KQovLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcioKc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7CgkvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZykKCXJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSApICYgMTsKfSk7CgovLyBTdXBwb3J0OiBJRTw4Ci8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5ICJpbnRlcnBvbGF0aW9uIgovLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4CmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkgewoJZGl2LmlubmVySFRNTCA9ICI8YSBocmVmPScjJz48L2E+IjsKCXJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoImhyZWYiKSA9PT0gIiMiIDsKfSkgKSB7CglhZGRIYW5kbGUoICJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkgewoJCWlmICggIWlzWE1MICkgewoJCQlyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gInR5cGUiID8gMSA6IDIgKTsKCQl9Cgl9KTsKfQoKLy8gU3VwcG9ydDogSUU8OQovLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZSgidmFsdWUiKQppZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkgewoJZGl2LmlubmVySFRNTCA9ICI8aW5wdXQvPiI7CglkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoICJ2YWx1ZSIsICIiICk7CglyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCAidmFsdWUiICkgPT09ICIiOwp9KSApIHsKCWFkZEhhbmRsZSggInZhbHVlIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkgewoJCWlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gImlucHV0IiApIHsKCQkJcmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlOwoJCX0KCX0pOwp9CgovLyBTdXBwb3J0OiBJRTw5Ci8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXMKaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7CglyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZSgiZGlzYWJsZWQiKSA9PSBudWxsOwp9KSApIHsKCWFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHsKCQl2YXIgdmFsOwoJCWlmICggIWlzWE1MICkgewoJCQlyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDoKCQkJCQkodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgPwoJCQkJCXZhbC52YWx1ZSA6CgkJCQludWxsOwoJCX0KCX0pOwp9CgpyZXR1cm4gU2l6emxlOwoKfSkoIHdpbmRvdyApOwoKCgpqUXVlcnkuZmluZCA9IFNpenpsZTsKalF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzOwpqUXVlcnkuZXhwclsiOiJdID0galF1ZXJ5LmV4cHIucHNldWRvczsKalF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0OwpqUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0OwpqUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7CmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWluczsKCgoKdmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7Cgp2YXIgcnNpbmdsZVRhZyA9ICgvXjwoXHcrKVxzKlwvPz4oPzo8XC9cMT58KSQvKTsKCgoKdmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcW1wuLF0qJC87CgovLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdApmdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHsKCWlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkgewoJCXJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkgewoJCQkvKiBqc2hpbnQgLVcwMTggKi8KCQkJcmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90OwoJCX0pOwoKCX0KCglpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHsKCQlyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHsKCQkJcmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDsKCQl9KTsKCgl9CgoJaWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSAic3RyaW5nIiApIHsKCQlpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHsKCQkJcmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApOwoJCX0KCgkJcXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApOwoJfQoKCXJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkgewoJCXJldHVybiAoIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBxdWFsaWZpZXIgKSA+PSAwICkgIT09IG5vdDsKCX0pOwp9CgpqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7Cgl2YXIgZWxlbSA9IGVsZW1zWyAwIF07CgoJaWYgKCBub3QgKSB7CgkJZXhwciA9ICI6bm90KCIgKyBleHByICsgIikiOwoJfQoKCXJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/CgkJalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDoKCQlqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkgewoJCQlyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTsKCQl9KSk7Cn07CgpqUXVlcnkuZm4uZXh0ZW5kKHsKCWZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHsKCQl2YXIgaSwKCQkJcmV0ID0gW10sCgkJCXNlbGYgPSB0aGlzLAoJCQlsZW4gPSBzZWxmLmxlbmd0aDsKCgkJaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09ICJzdHJpbmciICkgewoJCQlyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7CgkJCQlmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkgewoJCQkJCWlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHsKCQkJCQkJcmV0dXJuIHRydWU7CgkJCQkJfQoJCQkJfQoJCQl9KSApOwoJCX0KCgkJZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHsKCQkJalF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApOwoJCX0KCgkJLy8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApCgkJcmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApOwoJCXJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgIiAiICsgc2VsZWN0b3IgOiBzZWxlY3RvcjsKCQlyZXR1cm4gcmV0OwoJfSwKCWZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkgewoJCXJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkgKTsKCX0sCglub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHsKCQlyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTsKCX0sCglpczogZnVuY3Rpb24oIHNlbGVjdG9yICkgewoJCXJldHVybiAhIXdpbm5vdygKCQkJdGhpcywKCgkJCS8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXQKCQkJLy8gc28gJCgicDpmaXJzdCIpLmlzKCJwOmxhc3QiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gInAiLgoJCQl0eXBlb2Ygc2VsZWN0b3IgPT09ICJzdHJpbmciICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/CgkJCQlqUXVlcnkoIHNlbGVjdG9yICkgOgoJCQkJc2VsZWN0b3IgfHwgW10sCgkJCWZhbHNlCgkJKS5sZW5ndGg7Cgl9Cn0pOwoKCi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0CgoKLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpCnZhciByb290alF1ZXJ5LAoKCS8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveCkKCWRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LAoKCS8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzCgkvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpCgkvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPCkKCXJxdWlja0V4cHIgPSAvXig/OlxzKig8W1x3XFddKz4pW14+XSp8IyhbXHctXSopKSQvLAoKCWluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHsKCQl2YXIgbWF0Y2gsIGVsZW07CgoJCS8vIEhBTkRMRTogJCgiIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSkKCQlpZiAoICFzZWxlY3RvciApIHsKCQkJcmV0dXJuIHRoaXM7CgkJfQoKCQkvLyBIYW5kbGUgSFRNTCBzdHJpbmdzCgkJaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICJzdHJpbmciICkgewoJCQlpZiAoIHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gIjwiICYmIHNlbGVjdG9yLmNoYXJBdCggc2VsZWN0b3IubGVuZ3RoIC0gMSApID09PSAiPiIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7CgkJCQkvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVjawoJCQkJbWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07CgoJCQl9IGVsc2UgewoJCQkJbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7CgkJCX0KCgkJCS8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWQKCQkJaWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkgewoKCQkJCS8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KQoJCQkJaWYgKCBtYXRjaFsxXSApIHsKCQkJCQljb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0OwoKCQkJCQkvLyBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0CgkJCQkJLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnQKCQkJCQlqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoCgkJCQkJCW1hdGNoWzFdLAoJCQkJCQljb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LAoJCQkJCQl0cnVlCgkJCQkJKSApOwoKCQkJCQkvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpCgkJCQkJaWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHsKCQkJCQkJZm9yICggbWF0Y2ggaW4gY29udGV4dCApIHsKCQkJCQkJCS8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGUKCQkJCQkJCWlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHsKCQkJCQkJCQl0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7CgoJCQkJCQkJLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlcwoJCQkJCQkJfSBlbHNlIHsKCQkJCQkJCQl0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7CgkJCQkJCQl9CgkJCQkJCX0KCQkJCQl9CgoJCQkJCXJldHVybiB0aGlzOwoKCQkJCS8vIEhBTkRMRTogJCgjaWQpCgkJCQl9IGVsc2UgewoJCQkJCWVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTsKCgkJCQkJLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnMKCQkJCQkvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzCgkJCQkJaWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHsKCQkJCQkJLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFIGFuZCBPcGVyYSByZXR1cm4gaXRlbXMKCQkJCQkJLy8gYnkgbmFtZSBpbnN0ZWFkIG9mIElECgkJCQkJCWlmICggZWxlbS5pZCAhPT0gbWF0Y2hbMl0gKSB7CgkJCQkJCQlyZXR1cm4gcm9vdGpRdWVyeS5maW5kKCBzZWxlY3RvciApOwoJCQkJCQl9CgoJCQkJCQkvLyBPdGhlcndpc2UsIHdlIGluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0CgkJCQkJCXRoaXMubGVuZ3RoID0gMTsKCQkJCQkJdGhpc1swXSA9IGVsZW07CgkJCQkJfQoKCQkJCQl0aGlzLmNvbnRleHQgPSBkb2N1bWVudDsKCQkJCQl0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7CgkJCQkJcmV0dXJuIHRoaXM7CgkJCQl9CgoJCQkvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKQoJCQl9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHsKCQkJCXJldHVybiAoIGNvbnRleHQgfHwgcm9vdGpRdWVyeSApLmZpbmQoIHNlbGVjdG9yICk7CgoJCQkvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dCkKCQkJLy8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpCgkJCX0gZWxzZSB7CgkJCQlyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7CgkJCX0KCgkJLy8gSEFORExFOiAkKERPTUVsZW1lbnQpCgkJfSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7CgkJCXRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3RvcjsKCQkJdGhpcy5sZW5ndGggPSAxOwoJCQlyZXR1cm4gdGhpczsKCgkJLy8gSEFORExFOiAkKGZ1bmN0aW9uKQoJCS8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeQoJCX0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkgewoJCQlyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09ICJ1bmRlZmluZWQiID8KCQkJCXJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICkgOgoJCQkJLy8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudAoJCQkJc2VsZWN0b3IoIGpRdWVyeSApOwoJCX0KCgkJaWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkgewoJCQl0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7CgkJCXRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7CgkJfQoKCQlyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTsKCX07CgovLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uCmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuOwoKLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZQpyb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApOwoKCnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLywKCS8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0CglndWFyYW50ZWVkVW5pcXVlID0gewoJCWNoaWxkcmVuOiB0cnVlLAoJCWNvbnRlbnRzOiB0cnVlLAoJCW5leHQ6IHRydWUsCgkJcHJldjogdHJ1ZQoJfTsKCmpRdWVyeS5leHRlbmQoewoJZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHsKCQl2YXIgbWF0Y2hlZCA9IFtdLAoJCQljdXIgPSBlbGVtWyBkaXIgXTsKCgkJd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KCBjdXIgKS5pcyggdW50aWwgKSkgKSB7CgkJCWlmICggY3VyLm5vZGVUeXBlID09PSAxICkgewoJCQkJbWF0Y2hlZC5wdXNoKCBjdXIgKTsKCQkJfQoJCQljdXIgPSBjdXJbZGlyXTsKCQl9CgkJcmV0dXJuIG1hdGNoZWQ7Cgl9LAoKCXNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkgewoJCXZhciByID0gW107CgoJCWZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7CgkJCWlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkgewoJCQkJci5wdXNoKCBuICk7CgkJCX0KCQl9CgoJCXJldHVybiByOwoJfQp9KTsKCmpRdWVyeS5mbi5leHRlbmQoewoJaGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkgewoJCXZhciBpLAoJCQl0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSwKCQkJbGVuID0gdGFyZ2V0cy5sZW5ndGg7CgoJCXJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHsKCQkJZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHsKCQkJCWlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzW2ldICkgKSB7CgkJCQkJcmV0dXJuIHRydWU7CgkJCQl9CgkJCX0KCQl9KTsKCX0sCgoJY2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHsKCQl2YXIgY3VyLAoJCQlpID0gMCwKCQkJbCA9IHRoaXMubGVuZ3RoLAoJCQltYXRjaGVkID0gW10sCgkJCXBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gInN0cmluZyIgPwoJCQkJalF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOgoJCQkJMDsKCgkJZm9yICggOyBpIDwgbDsgaSsrICkgewoJCQlmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHsKCQkJCS8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50cwoJCQkJaWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID8KCQkJCQlwb3MuaW5kZXgoY3VyKSA+IC0xIDoKCgkJCQkJLy8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlCgkJCQkJY3VyLm5vZGVUeXBlID09PSAxICYmCgkJCQkJCWpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkgewoKCQkJCQltYXRjaGVkLnB1c2goIGN1ciApOwoJCQkJCWJyZWFrOwoJCQkJfQoJCQl9CgkJfQoKCQlyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWUoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTsKCX0sCgoJLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbgoJLy8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzCglpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7CgoJCS8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50CgkJaWYgKCAhZWxlbSApIHsKCQkJcmV0dXJuICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7CgkJfQoKCQkvLyBpbmRleCBpbiBzZWxlY3RvcgoJCWlmICggdHlwZW9mIGVsZW0gPT09ICJzdHJpbmciICkgewoJCQlyZXR1cm4galF1ZXJ5LmluQXJyYXkoIHRoaXNbMF0sIGpRdWVyeSggZWxlbSApICk7CgkJfQoKCQkvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnQKCQlyZXR1cm4galF1ZXJ5LmluQXJyYXkoCgkJCS8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZAoJCQllbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtLCB0aGlzICk7Cgl9LAoKCWFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkgewoJCXJldHVybiB0aGlzLnB1c2hTdGFjaygKCQkJalF1ZXJ5LnVuaXF1ZSgKCQkJCWpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApICkKCQkJKQoJCSk7Cgl9LAoKCWFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHsKCQlyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgPwoJCQl0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKQoJCSk7Cgl9Cn0pOwoKZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7CglkbyB7CgkJY3VyID0gY3VyWyBkaXIgXTsKCX0gd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSAxICk7CgoJcmV0dXJuIGN1cjsKfQoKalF1ZXJ5LmVhY2goewoJcGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHsKCQl2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlOwoJCXJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7Cgl9LAoJcGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7CgkJcmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sICJwYXJlbnROb2RlIiApOwoJfSwKCXBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkgewoJCXJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCAicGFyZW50Tm9kZSIsIHVudGlsICk7Cgl9LAoJbmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7CgkJcmV0dXJuIHNpYmxpbmcoIGVsZW0sICJuZXh0U2libGluZyIgKTsKCX0sCglwcmV2OiBmdW5jdGlvbiggZWxlbSApIHsKCQlyZXR1cm4gc2libGluZyggZWxlbSwgInByZXZpb3VzU2libGluZyIgKTsKCX0sCgluZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHsKCQlyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgIm5leHRTaWJsaW5nIiApOwoJfSwKCXByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkgewoJCXJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCAicHJldmlvdXNTaWJsaW5nIiApOwoJfSwKCW5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkgewoJCXJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCAibmV4dFNpYmxpbmciLCB1bnRpbCApOwoJfSwKCXByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkgewoJCXJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCAicHJldmlvdXNTaWJsaW5nIiwgdW50aWwgKTsKCX0sCglzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7CgkJcmV0dXJuIGpRdWVyeS5zaWJsaW5nKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTsKCX0sCgljaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7CgkJcmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTsKCX0sCgljb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7CgkJcmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgImlmcmFtZSIgKSA/CgkJCWVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6CgkJCWpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApOwoJfQp9LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7CglqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7CgkJdmFyIHJldCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApOwoKCQlpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09ICJVbnRpbCIgKSB7CgkJCXNlbGVjdG9yID0gdW50aWw7CgkJfQoKCQlpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gInN0cmluZyIgKSB7CgkJCXJldCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCByZXQgKTsKCQl9CgoJCWlmICggdGhpcy5sZW5ndGggPiAxICkgewoJCQkvLyBSZW1vdmUgZHVwbGljYXRlcwoJCQlpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7CgkJCQlyZXQgPSBqUXVlcnkudW5pcXVlKCByZXQgKTsKCQkJfQoKCQkJLy8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXMKCQkJaWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkgewoJCQkJcmV0ID0gcmV0LnJldmVyc2UoKTsKCQkJfQoJCX0KCgkJcmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTsKCX07Cn0pOwp2YXIgcm5vdHdoaXRlID0gKC9cUysvZyk7CgoKCi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGUKdmFyIG9wdGlvbnNDYWNoZSA9IHt9OwoKLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlCmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7Cgl2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTsKCWpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7CgkJb2JqZWN0WyBmbGFnIF0gPSB0cnVlOwoJfSk7CglyZXR1cm4gb2JqZWN0Owp9CgovKgogKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczoKICoKICoJb3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvdwogKgkJCXRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3QKICoKICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmUKICogImZpcmVkIiBtdWx0aXBsZSB0aW1lcy4KICoKICogUG9zc2libGUgb3B0aW9uczoKICoKICoJb25jZToJCQl3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpCiAqCiAqCW1lbW9yeToJCQl3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkCiAqCQkJCQlhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCAibWVtb3JpemVkIgogKgkJCQkJdmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpCiAqCiAqCXVuaXF1ZToJCQl3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdCkKICoKICoJc3RvcE9uRmFsc2U6CWludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZQogKgogKi8KalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkgewoKCS8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWQKCS8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdCkKCW9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gInN0cmluZyIgPwoJCSggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOgoJCWpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7CgoJdmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmcKCQlmaXJpbmcsCgkJLy8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKQoJCW1lbW9yeSwKCQkvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZAoJCWZpcmVkLAoJCS8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZwoJCWZpcmluZ0xlbmd0aCwKCQkvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKQoJCWZpcmluZ0luZGV4LAoJCS8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKQoJCWZpcmluZ1N0YXJ0LAoJCS8vIEFjdHVhbCBjYWxsYmFjayBsaXN0CgkJbGlzdCA9IFtdLAoJCS8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHMKCQlzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sCgkJLy8gRmlyZSBjYWxsYmFja3MKCQlmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7CgkJCW1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7CgkJCWZpcmVkID0gdHJ1ZTsKCQkJZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwOwoJCQlmaXJpbmdTdGFydCA9IDA7CgkJCWZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoOwoJCQlmaXJpbmcgPSB0cnVlOwoJCQlmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7CgkJCQlpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7CgkJCQkJbWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGQKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCQlmaXJpbmcgPSBmYWxzZTsKCQkJaWYgKCBsaXN0ICkgewoJCQkJaWYgKCBzdGFjayApIHsKCQkJCQlpZiAoIHN0YWNrLmxlbmd0aCApIHsKCQkJCQkJZmlyZSggc3RhY2suc2hpZnQoKSApOwoJCQkJCX0KCQkJCX0gZWxzZSBpZiAoIG1lbW9yeSApIHsKCQkJCQlsaXN0ID0gW107CgkJCQl9IGVsc2UgewoJCQkJCXNlbGYuZGlzYWJsZSgpOwoJCQkJfQoJCQl9CgkJfSwKCQkvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdAoJCXNlbGYgPSB7CgkJCS8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3QKCQkJYWRkOiBmdW5jdGlvbigpIHsKCQkJCWlmICggbGlzdCApIHsKCQkJCQkvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGgKCQkJCQl2YXIgc3RhcnQgPSBsaXN0Lmxlbmd0aDsKCQkJCQkoZnVuY3Rpb24gYWRkKCBhcmdzICkgewoJCQkJCQlqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHsKCQkJCQkJCXZhciB0eXBlID0galF1ZXJ5LnR5cGUoIGFyZyApOwoJCQkJCQkJaWYgKCB0eXBlID09PSAiZnVuY3Rpb24iICkgewoJCQkJCQkJCWlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7CgkJCQkJCQkJCWxpc3QucHVzaCggYXJnICk7CgkJCQkJCQkJfQoJCQkJCQkJfSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gInN0cmluZyIgKSB7CgkJCQkJCQkJLy8gSW5zcGVjdCByZWN1cnNpdmVseQoJCQkJCQkJCWFkZCggYXJnICk7CgkJCQkJCQl9CgkJCQkJCX0pOwoJCQkJCX0pKCBhcmd1bWVudHMgKTsKCQkJCQkvLyBEbyB3ZSBuZWVkIHRvIGFkZCB0aGUgY2FsbGJhY2tzIHRvIHRoZQoJCQkJCS8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoPwoJCQkJCWlmICggZmlyaW5nICkgewoJCQkJCQlmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDsKCQkJCQkvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuCgkJCQkJLy8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheQoJCQkJCX0gZWxzZSBpZiAoIG1lbW9yeSApIHsKCQkJCQkJZmlyaW5nU3RhcnQgPSBzdGFydDsKCQkJCQkJZmlyZSggbWVtb3J5ICk7CgkJCQkJfQoJCQkJfQoJCQkJcmV0dXJuIHRoaXM7CgkJCX0sCgkJCS8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3QKCQkJcmVtb3ZlOiBmdW5jdGlvbigpIHsKCQkJCWlmICggbGlzdCApIHsKCQkJCQlqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkgewoJCQkJCQl2YXIgaW5kZXg7CgkJCQkJCXdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkgewoJCQkJCQkJbGlzdC5zcGxpY2UoIGluZGV4LCAxICk7CgkJCQkJCQkvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXMKCQkJCQkJCWlmICggZmlyaW5nICkgewoJCQkJCQkJCWlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkgewoJCQkJCQkJCQlmaXJpbmdMZW5ndGgtLTsKCQkJCQkJCQl9CgkJCQkJCQkJaWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHsKCQkJCQkJCQkJZmlyaW5nSW5kZXgtLTsKCQkJCQkJCQl9CgkJCQkJCQl9CgkJCQkJCX0KCQkJCQl9KTsKCQkJCX0KCQkJCXJldHVybiB0aGlzOwoJCQl9LAoJCQkvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LgoJCQkvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC4KCQkJaGFzOiBmdW5jdGlvbiggZm4gKSB7CgkJCQlyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTsKCQkJfSwKCQkJLy8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdAoJCQllbXB0eTogZnVuY3Rpb24oKSB7CgkJCQlsaXN0ID0gW107CgkJCQlmaXJpbmdMZW5ndGggPSAwOwoJCQkJcmV0dXJuIHRoaXM7CgkJCX0sCgkJCS8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlCgkJCWRpc2FibGU6IGZ1bmN0aW9uKCkgewoJCQkJbGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkOwoJCQkJcmV0dXJuIHRoaXM7CgkJCX0sCgkJCS8vIElzIGl0IGRpc2FibGVkPwoJCQlkaXNhYmxlZDogZnVuY3Rpb24oKSB7CgkJCQlyZXR1cm4gIWxpc3Q7CgkJCX0sCgkJCS8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGUKCQkJbG9jazogZnVuY3Rpb24oKSB7CgkJCQlzdGFjayA9IHVuZGVmaW5lZDsKCQkJCWlmICggIW1lbW9yeSApIHsKCQkJCQlzZWxmLmRpc2FibGUoKTsKCQkJCX0KCQkJCXJldHVybiB0aGlzOwoJCQl9LAoJCQkvLyBJcyBpdCBsb2NrZWQ/CgkJCWxvY2tlZDogZnVuY3Rpb24oKSB7CgkJCQlyZXR1cm4gIXN0YWNrOwoJCQl9LAoJCQkvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzCgkJCWZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHsKCQkJCWlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkgewoJCQkJCWFyZ3MgPSBhcmdzIHx8IFtdOwoJCQkJCWFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07CgkJCQkJaWYgKCBmaXJpbmcgKSB7CgkJCQkJCXN0YWNrLnB1c2goIGFyZ3MgKTsKCQkJCQl9IGVsc2UgewoJCQkJCQlmaXJlKCBhcmdzICk7CgkJCQkJfQoJCQkJfQoJCQkJcmV0dXJuIHRoaXM7CgkJCX0sCgkJCS8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzCgkJCWZpcmU6IGZ1bmN0aW9uKCkgewoJCQkJc2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7CgkJCQlyZXR1cm4gdGhpczsKCQkJfSwKCQkJLy8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlCgkJCWZpcmVkOiBmdW5jdGlvbigpIHsKCQkJCXJldHVybiAhIWZpcmVkOwoJCQl9CgkJfTsKCglyZXR1cm4gc2VsZjsKfTsKCgpqUXVlcnkuZXh0ZW5kKHsKCglEZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7CgkJdmFyIHR1cGxlcyA9IFsKCQkJCS8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZQoJCQkJWyAicmVzb2x2ZSIsICJkb25lIiwgalF1ZXJ5LkNhbGxiYWNrcygib25jZSBtZW1vcnkiKSwgInJlc29sdmVkIiBdLAoJCQkJWyAicmVqZWN0IiwgImZhaWwiLCBqUXVlcnkuQ2FsbGJhY2tzKCJvbmNlIG1lbW9yeSIpLCAicmVqZWN0ZWQiIF0sCgkJCQlbICJub3RpZnkiLCAicHJvZ3Jlc3MiLCBqUXVlcnkuQ2FsbGJhY2tzKCJtZW1vcnkiKSBdCgkJCV0sCgkJCXN0YXRlID0gInBlbmRpbmciLAoJCQlwcm9taXNlID0gewoJCQkJc3RhdGU6IGZ1bmN0aW9uKCkgewoJCQkJCXJldHVybiBzdGF0ZTsKCQkJCX0sCgkJCQlhbHdheXM6IGZ1bmN0aW9uKCkgewoJCQkJCWRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApOwoJCQkJCXJldHVybiB0aGlzOwoJCQkJfSwKCQkJCXRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHsKCQkJCQl2YXIgZm5zID0gYXJndW1lbnRzOwoJCQkJCXJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24oIG5ld0RlZmVyICkgewoJCQkJCQlqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7CgkJCQkJCQl2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTsKCQkJCQkJCS8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlcgoJCQkJCQkJZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7CgkJCQkJCQkJdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOwoJCQkJCQkJCWlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHsKCQkJCQkJCQkJcmV0dXJuZWQucHJvbWlzZSgpCgkJCQkJCQkJCQkuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApCgkJCQkJCQkJCQkuZmFpbCggbmV3RGVmZXIucmVqZWN0ICkKCQkJCQkJCQkJCS5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5ICk7CgkJCQkJCQkJfSBlbHNlIHsKCQkJCQkJCQkJbmV3RGVmZXJbIHR1cGxlWyAwIF0gKyAiV2l0aCIgXSggdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzICk7CgkJCQkJCQkJfQoJCQkJCQkJfSk7CgkJCQkJCX0pOwoJCQkJCQlmbnMgPSBudWxsOwoJCQkJCX0pLnByb21pc2UoKTsKCQkJCX0sCgkJCQkvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkCgkJCQkvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0CgkJCQlwcm9taXNlOiBmdW5jdGlvbiggb2JqICkgewoJCQkJCXJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTsKCQkJCX0KCQkJfSwKCQkJZGVmZXJyZWQgPSB7fTsKCgkJLy8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdAoJCXByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjsKCgkJLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kcwoJCWpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHsKCQkJdmFyIGxpc3QgPSB0dXBsZVsgMiBdLAoJCQkJc3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdOwoKCQkJLy8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGQKCQkJcHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkOwoKCQkJLy8gSGFuZGxlIHN0YXRlCgkJCWlmICggc3RhdGVTdHJpbmcgKSB7CgkJCQlsaXN0LmFkZChmdW5jdGlvbigpIHsKCQkJCQkvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdCgkJCQkJc3RhdGUgPSBzdGF0ZVN0cmluZzsKCgkJCQkvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrCgkJCQl9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTsKCQkJfQoKCQkJLy8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXQoJCQlkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkgewoJCQkJZGVmZXJyZWRbIHR1cGxlWzBdICsgIldpdGgiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApOwoJCQkJcmV0dXJuIHRoaXM7CgkJCX07CgkJCWRlZmVycmVkWyB0dXBsZVswXSArICJXaXRoIiBdID0gbGlzdC5maXJlV2l0aDsKCQl9KTsKCgkJLy8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlCgkJcHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApOwoKCQkvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55CgkJaWYgKCBmdW5jICkgewoJCQlmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApOwoJCX0KCgkJLy8gQWxsIGRvbmUhCgkJcmV0dXJuIGRlZmVycmVkOwoJfSwKCgkvLyBEZWZlcnJlZCBoZWxwZXIKCXdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkgewoJCXZhciBpID0gMCwKCQkJcmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLAoJCQlsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCwKCgkJCS8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXMKCQkJcmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCwKCgkJCS8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LgoJCQlkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksCgoJCQkvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzCgkJCXVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHsKCQkJCXJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7CgkJCQkJY29udGV4dHNbIGkgXSA9IHRoaXM7CgkJCQkJdmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7CgkJCQkJaWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkgewoJCQkJCQlkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7CgoJCQkJCX0gZWxzZSBpZiAoICEoLS1yZW1haW5pbmcpICkgewoJCQkJCQlkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApOwoJCQkJCX0KCQkJCX07CgkJCX0sCgoJCQlwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzOwoKCQkvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkCgkJaWYgKCBsZW5ndGggPiAxICkgewoJCQlwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7CgkJCXByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApOwoJCQlyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApOwoJCQlmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHsKCQkJCWlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkgewoJCQkJCXJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKCkKCQkJCQkJLmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApICkKCQkJCQkJLmZhaWwoIGRlZmVycmVkLnJlamVjdCApCgkJCQkJCS5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApOwoJCQkJfSBlbHNlIHsKCQkJCQktLXJlbWFpbmluZzsKCQkJCX0KCQkJfQoJCX0KCgkJLy8gaWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlcgoJCWlmICggIXJlbWFpbmluZyApIHsKCQkJZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApOwoJCX0KCgkJcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTsKCX0KfSk7CgoKLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5CnZhciByZWFkeUxpc3Q7CgpqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7CgkvLyBBZGQgdGhlIGNhbGxiYWNrCglqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7CgoJcmV0dXJuIHRoaXM7Cn07CgpqUXVlcnkuZXh0ZW5kKHsKCS8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuCglpc1JlYWR5OiBmYWxzZSwKCgkvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlCgkvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MQoJcmVhZHlXYWl0OiAxLAoKCS8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudAoJaG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHsKCQlpZiAoIGhvbGQgKSB7CgkJCWpRdWVyeS5yZWFkeVdhaXQrKzsKCQl9IGVsc2UgewoJCQlqUXVlcnkucmVhZHkoIHRydWUgKTsKCQl9Cgl9LAoKCS8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHkKCXJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHsKCgkJLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeQoJCWlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkgewoJCQlyZXR1cm47CgkJfQoKCQkvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuCgkJaWYgKCAhZG9jdW1lbnQuYm9keSApIHsKCQkJcmV0dXJuIHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApOwoJCX0KCgkJLy8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5CgkJalF1ZXJ5LmlzUmVhZHkgPSB0cnVlOwoKCQkvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZQoJCWlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkgewoJCQlyZXR1cm47CgkJfQoKCQkvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlCgkJcmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApOwoKCQkvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHMKCQlpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHsKCQkJalF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCAicmVhZHkiICk7CgkJCWpRdWVyeSggZG9jdW1lbnQgKS5vZmYoICJyZWFkeSIgKTsKCQl9Cgl9Cn0pOwoKLyoqCiAqIENsZWFuLXVwIG1ldGhvZCBmb3IgZG9tIHJlYWR5IGV2ZW50cwogKi8KZnVuY3Rpb24gZGV0YWNoKCkgewoJaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkgewoJCWRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICJET01Db250ZW50TG9hZGVkIiwgY29tcGxldGVkLCBmYWxzZSApOwoJCXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAibG9hZCIsIGNvbXBsZXRlZCwgZmFsc2UgKTsKCgl9IGVsc2UgewoJCWRvY3VtZW50LmRldGFjaEV2ZW50KCAib25yZWFkeXN0YXRlY2hhbmdlIiwgY29tcGxldGVkICk7CgkJd2luZG93LmRldGFjaEV2ZW50KCAib25sb2FkIiwgY29tcGxldGVkICk7Cgl9Cn0KCi8qKgogKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZAogKi8KZnVuY3Rpb24gY29tcGxldGVkKCkgewoJLy8gcmVhZHlTdGF0ZSA9PT0gImNvbXBsZXRlIiBpcyBnb29kIGVub3VnaCBmb3IgdXMgdG8gY2FsbCB0aGUgZG9tIHJlYWR5IGluIG9sZElFCglpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgfHwgZXZlbnQudHlwZSA9PT0gImxvYWQiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICJjb21wbGV0ZSIgKSB7CgkJZGV0YWNoKCk7CgkJalF1ZXJ5LnJlYWR5KCk7Cgl9Cn0KCmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHsKCWlmICggIXJlYWR5TGlzdCApIHsKCgkJcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7CgoJCS8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLgoJCS8vIHdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgImludGVyYWN0aXZlIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmUKCQkvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1CgkJaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAiY29tcGxldGUiICkgewoJCQkvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHkKCQkJc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7CgoJCS8vIFN0YW5kYXJkcy1iYXNlZCBicm93c2VycyBzdXBwb3J0IERPTUNvbnRlbnRMb2FkZWQKCQl9IGVsc2UgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkgewoJCQkvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrCgkJCWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICJET01Db250ZW50TG9hZGVkIiwgY29tcGxldGVkLCBmYWxzZSApOwoKCQkJLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmsKCQkJd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICJsb2FkIiwgY29tcGxldGVkLCBmYWxzZSApOwoKCQkvLyBJZiBJRSBldmVudCBtb2RlbCBpcyB1c2VkCgkJfSBlbHNlIHsKCQkJLy8gRW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLCBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXMKCQkJZG9jdW1lbnQuYXR0YWNoRXZlbnQoICJvbnJlYWR5c3RhdGVjaGFuZ2UiLCBjb21wbGV0ZWQgKTsKCgkJCS8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrCgkJCXdpbmRvdy5hdHRhY2hFdmVudCggIm9ubG9hZCIsIGNvbXBsZXRlZCApOwoKCQkJLy8gSWYgSUUgYW5kIG5vdCBhIGZyYW1lCgkJCS8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHkKCQkJdmFyIHRvcCA9IGZhbHNlOwoKCQkJdHJ5IHsKCQkJCXRvcCA9IHdpbmRvdy5mcmFtZUVsZW1lbnQgPT0gbnVsbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7CgkJCX0gY2F0Y2goZSkge30KCgkJCWlmICggdG9wICYmIHRvcC5kb1Njcm9sbCApIHsKCQkJCShmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkgewoJCQkJCWlmICggIWpRdWVyeS5pc1JlYWR5ICkgewoKCQkJCQkJdHJ5IHsKCQkJCQkJCS8vIFVzZSB0aGUgdHJpY2sgYnkgRGllZ28gUGVyaW5pCgkJCQkJCQkvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkLwoJCQkJCQkJdG9wLmRvU2Nyb2xsKCJsZWZ0Iik7CgkJCQkJCX0gY2F0Y2goZSkgewoJCQkJCQkJcmV0dXJuIHNldFRpbWVvdXQoIGRvU2Nyb2xsQ2hlY2ssIDUwICk7CgkJCQkJCX0KCgkJCQkJCS8vIGRldGFjaCBhbGwgZG9tIHJlYWR5IGV2ZW50cwoJCQkJCQlkZXRhY2goKTsKCgkJCQkJCS8vIGFuZCBleGVjdXRlIGFueSB3YWl0aW5nIGZ1bmN0aW9ucwoJCQkJCQlqUXVlcnkucmVhZHkoKTsKCQkJCQl9CgkJCQl9KSgpOwoJCQl9CgkJfQoJfQoJcmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTsKfTsKCgp2YXIgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZDsKCgoKLy8gU3VwcG9ydDogSUU8OQovLyBJdGVyYXRpb24gb3ZlciBvYmplY3QncyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgaXRzIG93bgp2YXIgaTsKZm9yICggaSBpbiBqUXVlcnkoIHN1cHBvcnQgKSApIHsKCWJyZWFrOwp9CnN1cHBvcnQub3duTGFzdCA9IGkgIT09ICIwIjsKCi8vIE5vdGU6IG1vc3Qgc3VwcG9ydCB0ZXN0cyBhcmUgZGVmaW5lZCBpbiB0aGVpciByZXNwZWN0aXZlIG1vZHVsZXMuCi8vIGZhbHNlIHVudGlsIHRoZSB0ZXN0IGlzIHJ1bgpzdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSBmYWxzZTsKCi8vIEV4ZWN1dGUgQVNBUCBpbiBjYXNlIHdlIG5lZWQgdG8gc2V0IGJvZHkuc3R5bGUuem9vbQpqUXVlcnkoZnVuY3Rpb24oKSB7CgkvLyBNaW5pZmllZDogdmFyIGEsYixjLGQKCXZhciB2YWwsIGRpdiwgYm9keSwgY29udGFpbmVyOwoKCWJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggImJvZHkiIClbIDAgXTsKCWlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7CgkJLy8gUmV0dXJuIGZvciBmcmFtZXNldCBkb2NzIHRoYXQgZG9uJ3QgaGF2ZSBhIGJvZHkKCQlyZXR1cm47Cgl9CgoJLy8gU2V0dXAKCWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICJkaXYiICk7Cgljb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiZGl2IiApOwoJY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSAicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHgiOwoJYm9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApOwoKCWlmICggdHlwZW9mIGRpdi5zdHlsZS56b29tICE9PSBzdHJ1bmRlZmluZWQgKSB7CgkJLy8gU3VwcG9ydDogSUU8OAoJCS8vIENoZWNrIGlmIG5hdGl2ZWx5IGJsb2NrLWxldmVsIGVsZW1lbnRzIGFjdCBsaWtlIGlubGluZS1ibG9jawoJCS8vIGVsZW1lbnRzIHdoZW4gc2V0dGluZyB0aGVpciBkaXNwbGF5IHRvICdpbmxpbmUnIGFuZCBnaXZpbmcKCQkvLyB0aGVtIGxheW91dAoJCWRpdi5zdHlsZS5jc3NUZXh0ID0gImRpc3BsYXk6aW5saW5lO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjEiOwoKCQlzdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSB2YWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM7CgkJaWYgKCB2YWwgKSB7CgkJCS8vIFByZXZlbnQgSUUgNiBmcm9tIGFmZmVjdGluZyBsYXlvdXQgZm9yIHBvc2l0aW9uZWQgZWxlbWVudHMgIzExMDQ4CgkJCS8vIFByZXZlbnQgSUUgZnJvbSBzaHJpbmtpbmcgdGhlIGJvZHkgaW4gSUUgNyBtb2RlICMxMjg2OQoJCQkvLyBTdXBwb3J0OiBJRTw4CgkJCWJvZHkuc3R5bGUuem9vbSA9IDE7CgkJfQoJfQoKCWJvZHkucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApOwp9KTsKCgoKCihmdW5jdGlvbigpIHsKCXZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiZGl2IiApOwoKCS8vIEV4ZWN1dGUgdGhlIHRlc3Qgb25seSBpZiBub3QgYWxyZWFkeSBleGVjdXRlZCBpbiBhbm90aGVyIG1vZHVsZS4KCWlmIChzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPT0gbnVsbCkgewoJCS8vIFN1cHBvcnQ6IElFPDkKCQlzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSB0cnVlOwoJCXRyeSB7CgkJCWRlbGV0ZSBkaXYudGVzdDsKCQl9IGNhdGNoKCBlICkgewoJCQlzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTsKCQl9Cgl9CgoJLy8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS4KCWRpdiA9IG51bGw7Cn0pKCk7CgoKLyoqCiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YQogKi8KalF1ZXJ5LmFjY2VwdERhdGEgPSBmdW5jdGlvbiggZWxlbSApIHsKCXZhciBub0RhdGEgPSBqUXVlcnkubm9EYXRhWyAoZWxlbS5ub2RlTmFtZSArICIgIikudG9Mb3dlckNhc2UoKSBdLAoJCW5vZGVUeXBlID0gK2VsZW0ubm9kZVR5cGUgfHwgMTsKCgkvLyBEbyBub3Qgc2V0IGRhdGEgb24gbm9uLWVsZW1lbnQgRE9NIG5vZGVzIGJlY2F1c2UgaXQgd2lsbCBub3QgYmUgY2xlYXJlZCAoIzgzMzUpLgoJcmV0dXJuIG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ID8KCQlmYWxzZSA6CgoJCS8vIE5vZGVzIGFjY2VwdCBkYXRhIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkOyByZWplY3Rpb24gY2FuIGJlIGNvbmRpdGlvbmFsCgkJIW5vRGF0YSB8fCBub0RhdGEgIT09IHRydWUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoImNsYXNzaWQiKSA9PT0gbm9EYXRhOwp9OwoKCnZhciByYnJhY2UgPSAvXig/Olx7W1x3XFddKlx9fFxbW1x3XFddKlxdKSQvLAoJcm11bHRpRGFzaCA9IC8oW0EtWl0pL2c7CgpmdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkgewoJLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueQoJLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlCglpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkgewoKCQl2YXIgbmFtZSA9ICJkYXRhLSIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgIi0kMSIgKS50b0xvd2VyQ2FzZSgpOwoKCQlkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTsKCgkJaWYgKCB0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIgKSB7CgkJCXRyeSB7CgkJCQlkYXRhID0gZGF0YSA9PT0gInRydWUiID8gdHJ1ZSA6CgkJCQkJZGF0YSA9PT0gImZhbHNlIiA/IGZhbHNlIDoKCQkJCQlkYXRhID09PSAibnVsbCIgPyBudWxsIDoKCQkJCQkvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZwoJCQkJCStkYXRhICsgIiIgPT09IGRhdGEgPyArZGF0YSA6CgkJCQkJcmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6CgkJCQkJZGF0YTsKCQkJfSBjYXRjaCggZSApIHt9CgoJCQkvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXIKCQkJalF1ZXJ5LmRhdGEoIGVsZW0sIGtleSwgZGF0YSApOwoKCQl9IGVsc2UgewoJCQlkYXRhID0gdW5kZWZpbmVkOwoJCX0KCX0KCglyZXR1cm4gZGF0YTsKfQoKLy8gY2hlY2tzIGEgY2FjaGUgb2JqZWN0IGZvciBlbXB0aW5lc3MKZnVuY3Rpb24gaXNFbXB0eURhdGFPYmplY3QoIG9iaiApIHsKCXZhciBuYW1lOwoJZm9yICggbmFtZSBpbiBvYmogKSB7CgoJCS8vIGlmIHRoZSBwdWJsaWMgZGF0YSBvYmplY3QgaXMgZW1wdHksIHRoZSBwcml2YXRlIGlzIHN0aWxsIGVtcHR5CgkJaWYgKCBuYW1lID09PSAiZGF0YSIgJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9ialtuYW1lXSApICkgewoJCQljb250aW51ZTsKCQl9CgkJaWYgKCBuYW1lICE9PSAidG9KU09OIiApIHsKCQkJcmV0dXJuIGZhbHNlOwoJCX0KCX0KCglyZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7CglpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkgewoJCXJldHVybjsKCX0KCgl2YXIgcmV0LCB0aGlzQ2FjaGUsCgkJaW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbywKCgkJLy8gV2UgaGF2ZSB0byBoYW5kbGUgRE9NIG5vZGVzIGFuZCBKUyBvYmplY3RzIGRpZmZlcmVudGx5IGJlY2F1c2UgSUU2LTcKCQkvLyBjYW4ndCBHQyBvYmplY3QgcmVmZXJlbmNlcyBwcm9wZXJseSBhY3Jvc3MgdGhlIERPTS1KUyBib3VuZGFyeQoJCWlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsCgoJCS8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzCgkJLy8gYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdCBzbyBHQyBjYW4gb2NjdXIgYXV0b21hdGljYWxseQoJCWNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSwKCgkJLy8gT25seSBkZWZpbmluZyBhbiBJRCBmb3IgSlMgb2JqZWN0cyBpZiBpdHMgY2FjaGUgYWxyZWFkeSBleGlzdHMgYWxsb3dzCgkJLy8gdGhlIGNvZGUgdG8gc2hvcnRjdXQgb24gdGhlIHNhbWUgcGF0aCBhcyBhIERPTSBub2RlIHdpdGggbm8gY2FjaGUKCQlpZCA9IGlzTm9kZSA/IGVsZW1bIGludGVybmFsS2V5IF0gOiBlbGVtWyBpbnRlcm5hbEtleSBdICYmIGludGVybmFsS2V5OwoKCS8vIEF2b2lkIGRvaW5nIGFueSBtb3JlIHdvcmsgdGhhbiB3ZSBuZWVkIHRvIHdoZW4gdHJ5aW5nIHRvIGdldCBkYXRhIG9uIGFuCgkvLyBvYmplY3QgdGhhdCBoYXMgbm8gZGF0YSBhdCBhbGwKCWlmICggKCFpZCB8fCAhY2FjaGVbaWRdIHx8ICghcHZ0ICYmICFjYWNoZVtpZF0uZGF0YSkpICYmIGRhdGEgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmFtZSA9PT0gInN0cmluZyIgKSB7CgkJcmV0dXJuOwoJfQoKCWlmICggIWlkICkgewoJCS8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgYSBuZXcgdW5pcXVlIElEIGZvciBlYWNoIGVsZW1lbnQgc2luY2UgdGhlaXIgZGF0YQoJCS8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZQoJCWlmICggaXNOb2RlICkgewoJCQlpZCA9IGVsZW1bIGludGVybmFsS2V5IF0gPSBkZWxldGVkSWRzLnBvcCgpIHx8IGpRdWVyeS5ndWlkKys7CgkJfSBlbHNlIHsKCQkJaWQgPSBpbnRlcm5hbEtleTsKCQl9Cgl9CgoJaWYgKCAhY2FjaGVbIGlkIF0gKSB7CgkJLy8gQXZvaWQgZXhwb3NpbmcgalF1ZXJ5IG1ldGFkYXRhIG9uIHBsYWluIEpTIG9iamVjdHMgd2hlbiB0aGUgb2JqZWN0CgkJLy8gaXMgc2VyaWFsaXplZCB1c2luZyBKU09OLnN0cmluZ2lmeQoJCWNhY2hlWyBpZCBdID0gaXNOb2RlID8ge30gOiB7IHRvSlNPTjogalF1ZXJ5Lm5vb3AgfTsKCX0KCgkvLyBBbiBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBqUXVlcnkuZGF0YSBpbnN0ZWFkIG9mIGEga2V5L3ZhbHVlIHBhaXI7IHRoaXMgZ2V0cwoJLy8gc2hhbGxvdyBjb3BpZWQgb3ZlciBvbnRvIHRoZSBleGlzdGluZyBjYWNoZQoJaWYgKCB0eXBlb2YgbmFtZSA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIG5hbWUgPT09ICJmdW5jdGlvbiIgKSB7CgkJaWYgKCBwdnQgKSB7CgkJCWNhY2hlWyBpZCBdID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0sIG5hbWUgKTsKCQl9IGVsc2UgewoJCQljYWNoZVsgaWQgXS5kYXRhID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0uZGF0YSwgbmFtZSApOwoJCX0KCX0KCgl0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTsKCgkvLyBqUXVlcnkgZGF0YSgpIGlzIHN0b3JlZCBpbiBhIHNlcGFyYXRlIG9iamVjdCBpbnNpZGUgdGhlIG9iamVjdCdzIGludGVybmFsIGRhdGEKCS8vIGNhY2hlIGluIG9yZGVyIHRvIGF2b2lkIGtleSBjb2xsaXNpb25zIGJldHdlZW4gaW50ZXJuYWwgZGF0YSBhbmQgdXNlci1kZWZpbmVkCgkvLyBkYXRhLgoJaWYgKCAhcHZ0ICkgewoJCWlmICggIXRoaXNDYWNoZS5kYXRhICkgewoJCQl0aGlzQ2FjaGUuZGF0YSA9IHt9OwoJCX0KCgkJdGhpc0NhY2hlID0gdGhpc0NhY2hlLmRhdGE7Cgl9CgoJaWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7CgkJdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXSA9IGRhdGE7Cgl9CgoJLy8gQ2hlY2sgZm9yIGJvdGggY29udmVydGVkLXRvLWNhbWVsIGFuZCBub24tY29udmVydGVkIGRhdGEgcHJvcGVydHkgbmFtZXMKCS8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkCglpZiAoIHR5cGVvZiBuYW1lID09PSAic3RyaW5nIiApIHsKCgkJLy8gRmlyc3QgVHJ5IHRvIGZpbmQgYXMtaXMgcHJvcGVydHkgZGF0YQoJCXJldCA9IHRoaXNDYWNoZVsgbmFtZSBdOwoKCQkvLyBUZXN0IGZvciBudWxsfHVuZGVmaW5lZCBwcm9wZXJ0eSBkYXRhCgkJaWYgKCByZXQgPT0gbnVsbCApIHsKCgkJCS8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5CgkJCXJldCA9IHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF07CgkJfQoJfSBlbHNlIHsKCQlyZXQgPSB0aGlzQ2FjaGU7Cgl9CgoJcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCBwdnQgKSB7CglpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkgewoJCXJldHVybjsKCX0KCgl2YXIgdGhpc0NhY2hlLCBpLAoJCWlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsCgoJCS8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvbgoJCWNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSwKCQlpZCA9IGlzTm9kZSA/IGVsZW1bIGpRdWVyeS5leHBhbmRvIF0gOiBqUXVlcnkuZXhwYW5kbzsKCgkvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm8KCS8vIHB1cnBvc2UgaW4gY29udGludWluZwoJaWYgKCAhY2FjaGVbIGlkIF0gKSB7CgkJcmV0dXJuOwoJfQoKCWlmICggbmFtZSApIHsKCgkJdGhpc0NhY2hlID0gcHZ0ID8gY2FjaGVbIGlkIF0gOiBjYWNoZVsgaWQgXS5kYXRhOwoKCQlpZiAoIHRoaXNDYWNoZSApIHsKCgkJCS8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzCgkJCWlmICggIWpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7CgoJCQkJLy8gdHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb24KCQkJCWlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7CgkJCQkJbmFtZSA9IFsgbmFtZSBdOwoJCQkJfSBlbHNlIHsKCgkJCQkJLy8gc3BsaXQgdGhlIGNhbWVsIGNhc2VkIHZlcnNpb24gYnkgc3BhY2VzIHVubGVzcyBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzCgkJCQkJbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTsKCQkJCQlpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkgewoJCQkJCQluYW1lID0gWyBuYW1lIF07CgkJCQkJfSBlbHNlIHsKCQkJCQkJbmFtZSA9IG5hbWUuc3BsaXQoIiAiKTsKCQkJCQl9CgkJCQl9CgkJCX0gZWxzZSB7CgkJCQkvLyBJZiAibmFtZSIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLgoJCQkJLy8gV2hlbiBkYXRhIGlzIGluaXRpYWxseSBjcmVhdGVkLCB2aWEgKCJrZXkiLCAidmFsIikgc2lnbmF0dXJlLAoJCQkJLy8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuCgkJCQkvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZQoJCQkJLy8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NgoJCQkJLy8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguCgkJCQluYW1lID0gbmFtZS5jb25jYXQoIGpRdWVyeS5tYXAoIG5hbWUsIGpRdWVyeS5jYW1lbENhc2UgKSApOwoJCQl9CgoJCQlpID0gbmFtZS5sZW5ndGg7CgkJCXdoaWxlICggaS0tICkgewoJCQkJZGVsZXRlIHRoaXNDYWNoZVsgbmFtZVtpXSBdOwoJCQl9CgoJCQkvLyBJZiB0aGVyZSBpcyBubyBkYXRhIGxlZnQgaW4gdGhlIGNhY2hlLCB3ZSB3YW50IHRvIGNvbnRpbnVlCgkJCS8vIGFuZCBsZXQgdGhlIGNhY2hlIG9iamVjdCBpdHNlbGYgZ2V0IGRlc3Ryb3llZAoJCQlpZiAoIHB2dCA/ICFpc0VtcHR5RGF0YU9iamVjdCh0aGlzQ2FjaGUpIDogIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHRoaXNDYWNoZSkgKSB7CgkJCQlyZXR1cm47CgkJCX0KCQl9Cgl9CgoJLy8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uCglpZiAoICFwdnQgKSB7CgkJZGVsZXRlIGNhY2hlWyBpZCBdLmRhdGE7CgoJCS8vIERvbid0IGRlc3Ryb3kgdGhlIHBhcmVudCBjYWNoZSB1bmxlc3MgdGhlIGludGVybmFsIGRhdGEgb2JqZWN0CgkJLy8gaGFkIGJlZW4gdGhlIG9ubHkgdGhpbmcgbGVmdCBpbiBpdAoJCWlmICggIWlzRW1wdHlEYXRhT2JqZWN0KCBjYWNoZVsgaWQgXSApICkgewoJCQlyZXR1cm47CgkJfQoJfQoKCS8vIERlc3Ryb3kgdGhlIGNhY2hlCglpZiAoIGlzTm9kZSApIHsKCQlqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSwgdHJ1ZSApOwoKCS8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKQoJLyoganNoaW50IGVxZXFlcTogZmFsc2UgKi8KCX0gZWxzZSBpZiAoIHN1cHBvcnQuZGVsZXRlRXhwYW5kbyB8fCBjYWNoZSAhPSBjYWNoZS53aW5kb3cgKSB7CgkJLyoganNoaW50IGVxZXFlcTogdHJ1ZSAqLwoJCWRlbGV0ZSBjYWNoZVsgaWQgXTsKCgkvLyBXaGVuIGFsbCBlbHNlIGZhaWxzLCBudWxsCgl9IGVsc2UgewoJCWNhY2hlWyBpZCBdID0gbnVsbDsKCX0KfQoKalF1ZXJ5LmV4dGVuZCh7CgljYWNoZToge30sCgoJLy8gVGhlIGZvbGxvd2luZyBlbGVtZW50cyAoc3BhY2Utc3VmZml4ZWQgdG8gYXZvaWQgT2JqZWN0LnByb3RvdHlwZSBjb2xsaXNpb25zKQoJLy8gdGhyb3cgdW5jYXRjaGFibGUgZXhjZXB0aW9ucyBpZiB5b3UgYXR0ZW1wdCB0byBzZXQgZXhwYW5kbyBwcm9wZXJ0aWVzCglub0RhdGE6IHsKCQkiYXBwbGV0ICI6IHRydWUsCgkJImVtYmVkICI6IHRydWUsCgkJLy8gLi4uYnV0IEZsYXNoIG9iamVjdHMgKHdoaWNoIGhhdmUgdGhpcyBjbGFzc2lkKSAqY2FuKiBoYW5kbGUgZXhwYW5kb3MKCQkib2JqZWN0ICI6ICJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDAiCgl9LAoKCWhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkgewoJCWVsZW0gPSBlbGVtLm5vZGVUeXBlID8galF1ZXJ5LmNhY2hlWyBlbGVtW2pRdWVyeS5leHBhbmRvXSBdIDogZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTsKCQlyZXR1cm4gISFlbGVtICYmICFpc0VtcHR5RGF0YU9iamVjdCggZWxlbSApOwoJfSwKCglkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHsKCQlyZXR1cm4gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhICk7Cgl9LAoKCXJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkgewoJCXJldHVybiBpbnRlcm5hbFJlbW92ZURhdGEoIGVsZW0sIG5hbWUgKTsKCX0sCgoJLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LgoJX2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkgewoJCXJldHVybiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEsIHRydWUgKTsKCX0sCgoJX3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkgewoJCXJldHVybiBpbnRlcm5hbFJlbW92ZURhdGEoIGVsZW0sIG5hbWUsIHRydWUgKTsKCX0KfSk7CgpqUXVlcnkuZm4uZXh0ZW5kKHsKCWRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkgewoJCXZhciBpLCBuYW1lLCBkYXRhLAoJCQllbGVtID0gdGhpc1swXSwKCQkJYXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlczsKCgkJLy8gU3BlY2lhbCBleHBlY3Rpb25zIG9mIC5kYXRhIGJhc2ljYWxseSB0aHdhcnQgalF1ZXJ5LmFjY2VzcywKCQkvLyBzbyBpbXBsZW1lbnQgdGhlIHJlbGV2YW50IGJlaGF2aW9yIG91cnNlbHZlcwoKCQkvLyBHZXRzIGFsbCB2YWx1ZXMKCQlpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkgewoJCQlpZiAoIHRoaXMubGVuZ3RoICkgewoJCQkJZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtICk7CgoJCQkJaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sICJwYXJzZWRBdHRycyIgKSApIHsKCQkJCQlpID0gYXR0cnMubGVuZ3RoOwoJCQkJCXdoaWxlICggaS0tICkgewoKCQkJCQkJLy8gU3VwcG9ydDogSUUxMSsKCQkJCQkJLy8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpCgkJCQkJCWlmICggYXR0cnNbIGkgXSApIHsKCQkJCQkJCW5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7CgkJCQkJCQlpZiAoIG5hbWUuaW5kZXhPZiggImRhdGEtIiApID09PSAwICkgewoJCQkJCQkJCW5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKDUpICk7CgkJCQkJCQkJZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApOwoJCQkJCQkJfQoJCQkJCQl9CgkJCQkJfQoJCQkJCWpRdWVyeS5fZGF0YSggZWxlbSwgInBhcnNlZEF0dHJzIiwgdHJ1ZSApOwoJCQkJfQoJCQl9CgoJCQlyZXR1cm4gZGF0YTsKCQl9CgoJCS8vIFNldHMgbXVsdGlwbGUgdmFsdWVzCgkJaWYgKCB0eXBlb2Yga2V5ID09PSAib2JqZWN0IiApIHsKCQkJcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsKCQkJCWpRdWVyeS5kYXRhKCB0aGlzLCBrZXkgKTsKCQkJfSk7CgkJfQoKCQlyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPwoKCQkJLy8gU2V0cyBvbmUgdmFsdWUKCQkJdGhpcy5lYWNoKGZ1bmN0aW9uKCkgewoJCQkJalF1ZXJ5LmRhdGEoIHRoaXMsIGtleSwgdmFsdWUgKTsKCQkJfSkgOgoKCQkJLy8gR2V0cyBvbmUgdmFsdWUKCQkJLy8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0CgkJCWVsZW0gPyBkYXRhQXR0ciggZWxlbSwga2V5LCBqUXVlcnkuZGF0YSggZWxlbSwga2V5ICkgKSA6IHVuZGVmaW5lZDsKCX0sCgoJcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHsKCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgewoJCQlqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7CgkJfSk7Cgl9Cn0pOwoKCmpRdWVyeS5leHRlbmQoewoJcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkgewoJCXZhciBxdWV1ZTsKCgkJaWYgKCBlbGVtICkgewoJCQl0eXBlID0gKCB0eXBlIHx8ICJmeCIgKSArICJxdWV1ZSI7CgkJCXF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICk7CgoJCQkvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwCgkJCWlmICggZGF0YSApIHsKCQkJCWlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpICkgewoJCQkJCXF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7CgkJCQl9IGVsc2UgewoJCQkJCXF1ZXVlLnB1c2goIGRhdGEgKTsKCQkJCX0KCQkJfQoJCQlyZXR1cm4gcXVldWUgfHwgW107CgkJfQoJfSwKCglkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHsKCQl0eXBlID0gdHlwZSB8fCAiZngiOwoKCQl2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSwKCQkJc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsCgkJCWZuID0gcXVldWUuc2hpZnQoKSwKCQkJaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSwKCQkJbmV4dCA9IGZ1bmN0aW9uKCkgewoJCQkJalF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTsKCQkJfTsKCgkJLy8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbAoJCWlmICggZm4gPT09ICJpbnByb2dyZXNzIiApIHsKCQkJZm4gPSBxdWV1ZS5zaGlmdCgpOwoJCQlzdGFydExlbmd0aC0tOwoJCX0KCgkJaWYgKCBmbiApIHsKCgkJCS8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmcKCQkJLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZAoJCQlpZiAoIHR5cGUgPT09ICJmeCIgKSB7CgkJCQlxdWV1ZS51bnNoaWZ0KCAiaW5wcm9ncmVzcyIgKTsKCQkJfQoKCQkJLy8gY2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvbgoJCQlkZWxldGUgaG9va3Muc3RvcDsKCQkJZm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTsKCQl9CgoJCWlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkgewoJCQlob29rcy5lbXB0eS5maXJlKCk7CgkJfQoJfSwKCgkvLyBub3QgaW50ZW5kZWQgZm9yIHB1YmxpYyBjb25zdW1wdGlvbiAtIGdlbmVyYXRlcyBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm5zIHRoZSBjdXJyZW50IG9uZQoJX3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkgewoJCXZhciBrZXkgPSB0eXBlICsgInF1ZXVlSG9va3MiOwoJCXJldHVybiBqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSApIHx8IGpRdWVyeS5fZGF0YSggZWxlbSwga2V5LCB7CgkJCWVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCJvbmNlIG1lbW9yeSIpLmFkZChmdW5jdGlvbigpIHsKCQkJCWpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgdHlwZSArICJxdWV1ZSIgKTsKCQkJCWpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwga2V5ICk7CgkJCX0pCgkJfSk7Cgl9Cn0pOwoKalF1ZXJ5LmZuLmV4dGVuZCh7CglxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7CgkJdmFyIHNldHRlciA9IDI7CgoJCWlmICggdHlwZW9mIHR5cGUgIT09ICJzdHJpbmciICkgewoJCQlkYXRhID0gdHlwZTsKCQkJdHlwZSA9ICJmeCI7CgkJCXNldHRlci0tOwoJCX0KCgkJaWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkgewoJCQlyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7CgkJfQoKCQlyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID8KCQkJdGhpcyA6CgkJCXRoaXMuZWFjaChmdW5jdGlvbigpIHsKCQkJCXZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApOwoKCQkJCS8vIGVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlCgkJCQlqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTsKCgkJCQlpZiAoIHR5cGUgPT09ICJmeCIgJiYgcXVldWVbMF0gIT09ICJpbnByb2dyZXNzIiApIHsKCQkJCQlqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApOwoJCQkJfQoJCQl9KTsKCX0sCglkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHsKCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgewoJCQlqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApOwoJCX0pOwoJfSwKCWNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkgewoJCXJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8ICJmeCIsIFtdICk7Cgl9LAoJLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZQoJLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpCglwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkgewoJCXZhciB0bXAsCgkJCWNvdW50ID0gMSwKCQkJZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSwKCQkJZWxlbWVudHMgPSB0aGlzLAoJCQlpID0gdGhpcy5sZW5ndGgsCgkJCXJlc29sdmUgPSBmdW5jdGlvbigpIHsKCQkJCWlmICggISggLS1jb3VudCApICkgewoJCQkJCWRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7CgkJCQl9CgkJCX07CgoJCWlmICggdHlwZW9mIHR5cGUgIT09ICJzdHJpbmciICkgewoJCQlvYmogPSB0eXBlOwoJCQl0eXBlID0gdW5kZWZpbmVkOwoJCX0KCQl0eXBlID0gdHlwZSB8fCAiZngiOwoKCQl3aGlsZSAoIGktLSApIHsKCQkJdG1wID0galF1ZXJ5Ll9kYXRhKCBlbGVtZW50c1sgaSBdLCB0eXBlICsgInF1ZXVlSG9va3MiICk7CgkJCWlmICggdG1wICYmIHRtcC5lbXB0eSApIHsKCQkJCWNvdW50Kys7CgkJCQl0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7CgkJCX0KCQl9CgkJcmVzb2x2ZSgpOwoJCXJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTsKCX0KfSk7CnZhciBwbnVtID0gKC9bKy1dPyg/OlxkKlwufClcZCsoPzpbZUVdWystXT9cZCt8KS8pLnNvdXJjZTsKCnZhciBjc3NFeHBhbmQgPSBbICJUb3AiLCAiUmlnaHQiLCAiQm90dG9tIiwgIkxlZnQiIF07Cgp2YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7CgkJLy8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjsKCQkvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnQKCQllbGVtID0gZWwgfHwgZWxlbTsKCQlyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgImRpc3BsYXkiICkgPT09ICJub25lIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTsKCX07CgoKCi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvbgovLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb24KdmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7Cgl2YXIgaSA9IDAsCgkJbGVuZ3RoID0gZWxlbXMubGVuZ3RoLAoJCWJ1bGsgPSBrZXkgPT0gbnVsbDsKCgkvLyBTZXRzIG1hbnkgdmFsdWVzCglpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gIm9iamVjdCIgKSB7CgkJY2hhaW5hYmxlID0gdHJ1ZTsKCQlmb3IgKCBpIGluIGtleSApIHsKCQkJalF1ZXJ5LmFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbaV0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTsKCQl9CgoJLy8gU2V0cyBvbmUgdmFsdWUKCX0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7CgkJY2hhaW5hYmxlID0gdHJ1ZTsKCgkJaWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7CgkJCXJhdyA9IHRydWU7CgkJfQoKCQlpZiAoIGJ1bGsgKSB7CgkJCS8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldAoJCQlpZiAoIHJhdyApIHsKCQkJCWZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApOwoJCQkJZm4gPSBudWxsOwoKCQkJLy8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlcwoJCQl9IGVsc2UgewoJCQkJYnVsayA9IGZuOwoJCQkJZm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHsKCQkJCQlyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTsKCQkJCX07CgkJCX0KCQl9CgoJCWlmICggZm4gKSB7CgkJCWZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkgewoJCQkJZm4oIGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbCggZWxlbXNbaV0sIGksIGZuKCBlbGVtc1tpXSwga2V5ICkgKSApOwoJCQl9CgkJfQoJfQoKCXJldHVybiBjaGFpbmFibGUgPwoJCWVsZW1zIDoKCgkJLy8gR2V0cwoJCWJ1bGsgPwoJCQlmbi5jYWxsKCBlbGVtcyApIDoKCQkJbGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0Owp9Owp2YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpOwoKCgooZnVuY3Rpb24oKSB7CgkvLyBNaW5pZmllZDogdmFyIGEsYixjCgl2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiaW5wdXQiICksCgkJZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggImRpdiIgKSwKCQlmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsKCgkvLyBTZXR1cAoJZGl2LmlubmVySFRNTCA9ICIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz4iOwoKCS8vIElFIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiAuaW5uZXJIVE1MIGlzIHVzZWQKCXN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgPSBkaXYuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMzsKCgkvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZAoJLy8gSUUgd2lsbCBpbnNlcnQgdGhlbSBpbnRvIGVtcHR5IHRhYmxlcwoJc3VwcG9ydC50Ym9keSA9ICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICJ0Ym9keSIgKS5sZW5ndGg7CgoJLy8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MCgkvLyBUaGlzIHJlcXVpcmVzIGEgd3JhcHBlciBlbGVtZW50IGluIElFCglzdXBwb3J0Lmh0bWxTZXJpYWxpemUgPSAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggImxpbmsiICkubGVuZ3RoOwoKCS8vIE1ha2VzIHN1cmUgY2xvbmluZyBhbiBodG1sNSBlbGVtZW50IGRvZXMgbm90IGNhdXNlIHByb2JsZW1zCgkvLyBXaGVyZSBvdXRlckhUTUwgaXMgdW5kZWZpbmVkLCB0aGlzIHN0aWxsIHdvcmtzCglzdXBwb3J0Lmh0bWw1Q2xvbmUgPQoJCWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICJuYXYiICkuY2xvbmVOb2RlKCB0cnVlICkub3V0ZXJIVE1MICE9PSAiPDpuYXY+PC86bmF2PiI7CgoJLy8gQ2hlY2sgaWYgYSBkaXNjb25uZWN0ZWQgY2hlY2tib3ggd2lsbCByZXRhaW4gaXRzIGNoZWNrZWQKCS8vIHZhbHVlIG9mIHRydWUgYWZ0ZXIgYXBwZW5kZWQgdG8gdGhlIERPTSAoSUU2LzcpCglpbnB1dC50eXBlID0gImNoZWNrYm94IjsKCWlucHV0LmNoZWNrZWQgPSB0cnVlOwoJZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGlucHV0ICk7CglzdXBwb3J0LmFwcGVuZENoZWNrZWQgPSBpbnB1dC5jaGVja2VkOwoKCS8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkCgkvLyBTdXBwb3J0OiBJRTYtSUUxMSsKCWRpdi5pbm5lckhUTUwgPSAiPHRleHRhcmVhPng8L3RleHRhcmVhPiI7CglzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTsKCgkvLyAjMTEyMTcgLSBXZWJLaXQgbG9zZXMgY2hlY2sgd2hlbiB0aGUgbmFtZSBpcyBhZnRlciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUKCWZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYgKTsKCWRpdi5pbm5lckhUTUwgPSAiPGlucHV0IHR5cGU9J3JhZGlvJyBjaGVja2VkPSdjaGVja2VkJyBuYW1lPSd0Jy8+IjsKCgkvLyBTdXBwb3J0OiBTYWZhcmkgNS4xLCBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjMKCS8vIG9sZCBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHMKCXN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDsKCgkvLyBTdXBwb3J0OiBJRTw5CgkvLyBPcGVyYSBkb2VzIG5vdCBjbG9uZSBldmVudHMgKGFuZCB0eXBlb2YgZGl2LmF0dGFjaEV2ZW50ID09PSB1bmRlZmluZWQpLgoJLy8gSUU5LTEwIGNsb25lcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50LCBidXQgdGhleSBkb24ndCB0cmlnZ2VyIHdpdGggLmNsaWNrKCkKCXN1cHBvcnQubm9DbG9uZUV2ZW50ID0gdHJ1ZTsKCWlmICggZGl2LmF0dGFjaEV2ZW50ICkgewoJCWRpdi5hdHRhY2hFdmVudCggIm9uY2xpY2siLCBmdW5jdGlvbigpIHsKCQkJc3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTsKCQl9KTsKCgkJZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsaWNrKCk7Cgl9CgoJLy8gRXhlY3V0ZSB0aGUgdGVzdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGV4ZWN1dGVkIGluIGFub3RoZXIgbW9kdWxlLgoJaWYgKHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9PSBudWxsKSB7CgkJLy8gU3VwcG9ydDogSUU8OQoJCXN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IHRydWU7CgkJdHJ5IHsKCQkJZGVsZXRlIGRpdi50ZXN0OwoJCX0gY2F0Y2goIGUgKSB7CgkJCXN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IGZhbHNlOwoJCX0KCX0KfSkoKTsKCgooZnVuY3Rpb24oKSB7Cgl2YXIgaSwgZXZlbnROYW1lLAoJCWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICJkaXYiICk7CgoJLy8gU3VwcG9ydDogSUU8OSAobGFjayBzdWJtaXQvY2hhbmdlIGJ1YmJsZSksIEZpcmVmb3ggMjMrIChsYWNrIGZvY3VzaW4gZXZlbnQpCglmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCBjaGFuZ2U6IHRydWUsIGZvY3VzaW46IHRydWUgfSkgewoJCWV2ZW50TmFtZSA9ICJvbiIgKyBpOwoKCQlpZiAoICEoc3VwcG9ydFsgaSArICJCdWJibGVzIiBdID0gZXZlbnROYW1lIGluIHdpbmRvdykgKSB7CgkJCS8vIEJld2FyZSBvZiBDU1AgcmVzdHJpY3Rpb25zIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9TZWN1cml0eS9DU1ApCgkJCWRpdi5zZXRBdHRyaWJ1dGUoIGV2ZW50TmFtZSwgInQiICk7CgkJCXN1cHBvcnRbIGkgKyAiQnViYmxlcyIgXSA9IGRpdi5hdHRyaWJ1dGVzWyBldmVudE5hbWUgXS5leHBhbmRvID09PSBmYWxzZTsKCQl9Cgl9CgoJLy8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS4KCWRpdiA9IG51bGw7Cn0pKCk7CgoKdmFyIHJmb3JtRWxlbXMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksCglya2V5RXZlbnQgPSAvXmtleS8sCglybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLAoJcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sCglydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlwuKC4rKXwpJC87CgpmdW5jdGlvbiByZXR1cm5UcnVlKCkgewoJcmV0dXJuIHRydWU7Cn0KCmZ1bmN0aW9uIHJldHVybkZhbHNlKCkgewoJcmV0dXJuIGZhbHNlOwp9CgpmdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHsKCXRyeSB7CgkJcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7Cgl9IGNhdGNoICggZXJyICkgeyB9Cn0KCi8qCiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4KICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy4KICovCmpRdWVyeS5ldmVudCA9IHsKCglnbG9iYWw6IHt9LAoKCWFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHsKCQl2YXIgdG1wLCBldmVudHMsIHQsIGhhbmRsZU9iakluLAoJCQlzcGVjaWFsLCBldmVudEhhbmRsZSwgaGFuZGxlT2JqLAoJCQloYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsCgkJCWVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICk7CgoJCS8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpCgkJaWYgKCAhZWxlbURhdGEgKSB7CgkJCXJldHVybjsKCQl9CgoJCS8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlcgoJCWlmICggaGFuZGxlci5oYW5kbGVyICkgewoJCQloYW5kbGVPYmpJbiA9IGhhbmRsZXI7CgkJCWhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyOwoJCQlzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yOwoJCX0KCgkJLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyCgkJaWYgKCAhaGFuZGxlci5ndWlkICkgewoJCQloYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrOwoJCX0KCgkJLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdAoJCWlmICggIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkgewoJCQlldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTsKCQl9CgkJaWYgKCAhKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSApIHsKCQkJZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHsKCQkJCS8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kCgkJCQkvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkCgkJCQlyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gc3RydW5kZWZpbmVkICYmICghZSB8fCBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUpID8KCQkJCQlqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGV2ZW50SGFuZGxlLmVsZW0sIGFyZ3VtZW50cyApIDoKCQkJCQl1bmRlZmluZWQ7CgkJCX07CgkJCS8vIEFkZCBlbGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSBmbiB0byBwcmV2ZW50IGEgbWVtb3J5IGxlYWsgd2l0aCBJRSBub24tbmF0aXZlIGV2ZW50cwoJCQlldmVudEhhbmRsZS5lbGVtID0gZWxlbTsKCQl9CgoJCS8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2UKCQl0eXBlcyA9ICggdHlwZXMgfHwgIiIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyAiIiBdOwoJCXQgPSB0eXBlcy5sZW5ndGg7CgkJd2hpbGUgKCB0LS0gKSB7CgkJCXRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107CgkJCXR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTsKCQkJbmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8ICIiICkuc3BsaXQoICIuIiApLnNvcnQoKTsKCgkJCS8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVycwoJCQlpZiAoICF0eXBlICkgewoJCQkJY29udGludWU7CgkJCX0KCgkJCS8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZQoJCQlzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTsKCgkJCS8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZQoJCQl0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7CgoJCQkvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlCgkJCXNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9OwoKCQkJLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnMKCQkJaGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCh7CgkJCQl0eXBlOiB0eXBlLAoJCQkJb3JpZ1R5cGU6IG9yaWdUeXBlLAoJCQkJZGF0YTogZGF0YSwKCQkJCWhhbmRsZXI6IGhhbmRsZXIsCgkJCQlndWlkOiBoYW5kbGVyLmd1aWQsCgkJCQlzZWxlY3Rvcjogc2VsZWN0b3IsCgkJCQluZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLAoJCQkJbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIi4iKQoJCQl9LCBoYW5kbGVPYmpJbiApOwoKCQkJLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3QKCQkJaWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkgewoJCQkJaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdOwoJCQkJaGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7CgoJCQkJLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lci9hdHRhY2hFdmVudCBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlCgkJCQlpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7CgkJCQkJLy8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQKCQkJCQlpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHsKCQkJCQkJZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTsKCgkJCQkJfSBlbHNlIGlmICggZWxlbS5hdHRhY2hFdmVudCApIHsKCQkJCQkJZWxlbS5hdHRhY2hFdmVudCggIm9uIiArIHR5cGUsIGV2ZW50SGFuZGxlICk7CgkJCQkJfQoJCQkJfQoJCQl9CgoJCQlpZiAoIHNwZWNpYWwuYWRkICkgewoJCQkJc3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7CgoJCQkJaWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHsKCQkJCQloYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkOwoJCQkJfQoJCQl9CgoJCQkvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udAoJCQlpZiAoIHNlbGVjdG9yICkgewoJCQkJaGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApOwoJCQl9IGVsc2UgewoJCQkJaGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7CgkJCX0KCgkJCS8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb24KCQkJalF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTsKCQl9CgoJCS8vIE51bGxpZnkgZWxlbSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRQoJCWVsZW0gPSBudWxsOwoJfSwKCgkvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnQKCXJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7CgkJdmFyIGosIGhhbmRsZU9iaiwgdG1wLAoJCQlvcmlnQ291bnQsIHQsIGV2ZW50cywKCQkJc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsCgkJCW5hbWVzcGFjZXMsIG9yaWdUeXBlLAoJCQllbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICk7CgoJCWlmICggIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHsKCQkJcmV0dXJuOwoJCX0KCgkJLy8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZAoJCXR5cGVzID0gKCB0eXBlcyB8fCAiIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbICIiIF07CgkJdCA9IHR5cGVzLmxlbmd0aDsKCQl3aGlsZSAoIHQtLSApIHsKCQkJdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTsKCQkJdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdOwoJCQluYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgIiIgKS5zcGxpdCggIi4iICkuc29ydCgpOwoKCQkJLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50CgkJCWlmICggIXR5cGUgKSB7CgkJCQlmb3IgKCB0eXBlIGluIGV2ZW50cyApIHsKCQkJCQlqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTsKCQkJCX0KCQkJCWNvbnRpbnVlOwoJCQl9CgoJCQlzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTsKCQkJdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlOwoJCQloYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdOwoJCQl0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cCggIihefFxcLikiICsgbmFtZXNwYWNlcy5qb2luKCJcXC4oPzouKlxcLnwpIikgKyAiKFxcLnwkKSIgKTsKCgkJCS8vIFJlbW92ZSBtYXRjaGluZyBldmVudHMKCQkJb3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDsKCQkJd2hpbGUgKCBqLS0gKSB7CgkJCQloYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdOwoKCQkJCWlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiYKCQkJCQkoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJgoJCQkJCSggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiYKCQkJCQkoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAiKioiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkgewoJCQkJCWhhbmRsZXJzLnNwbGljZSggaiwgMSApOwoKCQkJCQlpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHsKCQkJCQkJaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tOwoJCQkJCX0KCQkJCQlpZiAoIHNwZWNpYWwucmVtb3ZlICkgewoJCQkJCQlzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTsKCQkJCQl9CgkJCQl9CgkJCX0KCgkJCS8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3QKCQkJLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpCgkJCWlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7CgkJCQlpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkgewoJCQkJCWpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7CgkJCQl9CgoJCQkJZGVsZXRlIGV2ZW50c1sgdHlwZSBdOwoJCQl9CgkJfQoKCQkvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZAoJCWlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkgewoJCQlkZWxldGUgZWxlbURhdGEuaGFuZGxlOwoKCQkJLy8gcmVtb3ZlRGF0YSBhbHNvIGNoZWNrcyBmb3IgZW1wdGluZXNzIGFuZCBjbGVhcnMgdGhlIGV4cGFuZG8gaWYgZW1wdHkKCQkJLy8gc28gdXNlIGl0IGluc3RlYWQgb2YgZGVsZXRlCgkJCWpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgImV2ZW50cyIgKTsKCQl9Cgl9LAoKCXRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkgewoJCXZhciBoYW5kbGUsIG9udHlwZSwgY3VyLAoJCQlidWJibGVUeXBlLCBzcGVjaWFsLCB0bXAsIGksCgkJCWV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLAoJCQl0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCAidHlwZSIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCwKCQkJbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgIm5hbWVzcGFjZSIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCgiLiIpIDogW107CgoJCWN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50OwoKCQkvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2RlcwoJCWlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkgewoJCQlyZXR1cm47CgkJfQoKCQkvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3cKCQlpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7CgkJCXJldHVybjsKCQl9CgoJCWlmICggdHlwZS5pbmRleE9mKCIuIikgPj0gMCApIHsKCQkJLy8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKQoJCQluYW1lc3BhY2VzID0gdHlwZS5zcGxpdCgiLiIpOwoJCQl0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpOwoJCQluYW1lc3BhY2VzLnNvcnQoKTsKCQl9CgkJb250eXBlID0gdHlwZS5pbmRleE9mKCI6IikgPCAwICYmICJvbiIgKyB0eXBlOwoKCQkvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmcKCQlldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID8KCQkJZXZlbnQgOgoJCQluZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09ICJvYmplY3QiICYmIGV2ZW50ICk7CgoJCS8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSkKCQlldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMzsKCQlldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIi4iKTsKCQlldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2UgPwoJCQluZXcgUmVnRXhwKCAiKF58XFwuKSIgKyBuYW1lc3BhY2VzLmpvaW4oIlxcLig/Oi4qXFwufCkiKSArICIoXFwufCQpIiApIDoKCQkJbnVsbDsKCgkJLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkCgkJZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkOwoJCWlmICggIWV2ZW50LnRhcmdldCApIHsKCQkJZXZlbnQudGFyZ2V0ID0gZWxlbTsKCQl9CgoJCS8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3QKCQlkYXRhID0gZGF0YSA9PSBudWxsID8KCQkJWyBldmVudCBdIDoKCQkJalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7CgoJCS8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXMKCQlzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTsKCQlpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHsKCQkJcmV0dXJuOwoJCX0KCgkJLy8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpCgkJLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNCkKCQlpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkgewoKCQkJYnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7CgkJCWlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7CgkJCQljdXIgPSBjdXIucGFyZW50Tm9kZTsKCQkJfQoJCQlmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7CgkJCQlldmVudFBhdGgucHVzaCggY3VyICk7CgkJCQl0bXAgPSBjdXI7CgkJCX0KCgkJCS8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKQoJCQlpZiAoIHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgKSB7CgkJCQlldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7CgkJCX0KCQl9CgoJCS8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGgKCQlpID0gMDsKCQl3aGlsZSAoIChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7CgoJCQlldmVudC50eXBlID0gaSA+IDEgPwoJCQkJYnViYmxlVHlwZSA6CgkJCQlzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7CgoJCQkvLyBqUXVlcnkgaGFuZGxlcgoJCQloYW5kbGUgPSAoIGpRdWVyeS5fZGF0YSggY3VyLCAiZXZlbnRzIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBqUXVlcnkuX2RhdGEoIGN1ciwgImhhbmRsZSIgKTsKCQkJaWYgKCBoYW5kbGUgKSB7CgkJCQloYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApOwoJCQl9CgoJCQkvLyBOYXRpdmUgaGFuZGxlcgoJCQloYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTsKCQkJaWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGpRdWVyeS5hY2NlcHREYXRhKCBjdXIgKSApIHsKCQkJCWV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7CgkJCQlpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7CgkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCX0KCQkJfQoJCX0KCQlldmVudC50eXBlID0gdHlwZTsKCgkJLy8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vdwoJCWlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7CgoJCQlpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmCgkJCQlqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkgewoKCQkJCS8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC4KCQkJCS8vIENhbid0IHVzZSBhbiAuaXNGdW5jdGlvbigpIGNoZWNrIGhlcmUgYmVjYXVzZSBJRTYvNyBmYWlscyB0aGF0IHRlc3QuCgkJCQkvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApCgkJCQlpZiAoIG9udHlwZSAmJiBlbGVtWyB0eXBlIF0gJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkgewoKCQkJCQkvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kCgkJCQkJdG1wID0gZWxlbVsgb250eXBlIF07CgoJCQkJCWlmICggdG1wICkgewoJCQkJCQllbGVtWyBvbnR5cGUgXSA9IG51bGw7CgkJCQkJfQoKCQkJCQkvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZQoJCQkJCWpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlOwoJCQkJCXRyeSB7CgkJCQkJCWVsZW1bIHR5cGUgXSgpOwoJCQkJCX0gY2F0Y2ggKCBlICkgewoJCQkJCQkvLyBJRTw5IGRpZXMgb24gZm9jdXMvYmx1ciB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYsIzEyNTE4KQoJCQkJCQkvLyBvbmx5IHJlcHJvZHVjaWJsZSBvbiB3aW5YUCBJRTggbmF0aXZlLCBub3QgSUU5IGluIElFOCBtb2RlCgkJCQkJfQoJCQkJCWpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7CgoJCQkJCWlmICggdG1wICkgewoJCQkJCQllbGVtWyBvbnR5cGUgXSA9IHRtcDsKCQkJCQl9CgkJCQl9CgkJCX0KCQl9CgoJCXJldHVybiBldmVudC5yZXN1bHQ7Cgl9LAoKCWRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7CgoJCS8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdAoJCWV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTsKCgkJdmFyIGksIHJldCwgaGFuZGxlT2JqLCBtYXRjaGVkLCBqLAoJCQloYW5kbGVyUXVldWUgPSBbXSwKCQkJYXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLAoJCQloYW5kbGVycyA9ICggalF1ZXJ5Ll9kYXRhKCB0aGlzLCAiZXZlbnRzIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSwKCQkJc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307CgoJCS8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50CgkJYXJnc1swXSA9IGV2ZW50OwoJCWV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpczsKCgkJLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZAoJCWlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkgewoJCQlyZXR1cm47CgkJfQoKCQkvLyBEZXRlcm1pbmUgaGFuZGxlcnMKCQloYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7CgoJCS8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzCgkJaSA9IDA7CgkJd2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkgewoJCQlldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtOwoKCQkJaiA9IDA7CgkJCXdoaWxlICggKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHsKCgkJCQkvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yCgkJCQkvLyAyKSBoYXZlIG5hbWVzcGFjZShzKSBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS4KCQkJCWlmICggIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgewoKCQkJCQlldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7CgkJCQkJZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhOwoKCQkJCQlyZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApCgkJCQkJCQkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApOwoKCQkJCQlpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkgewoJCQkJCQlpZiAoIChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSApIHsKCQkJCQkJCWV2ZW50LnByZXZlbnREZWZhdWx0KCk7CgkJCQkJCQlldmVudC5zdG9wUHJvcGFnYXRpb24oKTsKCQkJCQkJfQoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCgkJLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZQoJCWlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7CgkJCXNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7CgkJfQoKCQlyZXR1cm4gZXZlbnQucmVzdWx0OwoJfSwKCgloYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHsKCQl2YXIgc2VsLCBoYW5kbGVPYmosIG1hdGNoZXMsIGksCgkJCWhhbmRsZXJRdWV1ZSA9IFtdLAoJCQlkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCwKCQkJY3VyID0gZXZlbnQudGFyZ2V0OwoKCQkvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzCgkJLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MCkKCQkvLyBBdm9pZCBub24tbGVmdC1jbGljayBidWJibGluZyBpbiBGaXJlZm94ICgjMzg2MSkKCQlpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmICghZXZlbnQuYnV0dG9uIHx8IGV2ZW50LnR5cGUgIT09ICJjbGljayIpICkgewoKCQkJLyoganNoaW50IGVxZXFlcTogZmFsc2UgKi8KCQkJZm9yICggOyBjdXIgIT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHsKCQkJCS8qIGpzaGludCBlcWVxZXE6IHRydWUgKi8KCgkJCQkvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOCkKCQkJCS8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KQoJCQkJaWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSAiY2xpY2siKSApIHsKCQkJCQltYXRjaGVzID0gW107CgkJCQkJZm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7CgkJCQkJCWhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07CgoJCQkJCQkvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKQoJCQkJCQlzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyAiICI7CgoJCQkJCQlpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7CgkJCQkJCQltYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgPwoJCQkJCQkJCWpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOgoJCQkJCQkJCWpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7CgkJCQkJCX0KCQkJCQkJaWYgKCBtYXRjaGVzWyBzZWwgXSApIHsKCQkJCQkJCW1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7CgkJCQkJCX0KCQkJCQl9CgkJCQkJaWYgKCBtYXRjaGVzLmxlbmd0aCApIHsKCQkJCQkJaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCgkJLy8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVycwoJCWlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHsKCQkJaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTsKCQl9CgoJCXJldHVybiBoYW5kbGVyUXVldWU7Cgl9LAoKCWZpeDogZnVuY3Rpb24oIGV2ZW50ICkgewoJCWlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7CgkJCXJldHVybiBldmVudDsKCQl9CgoJCS8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllcwoJCXZhciBpLCBwcm9wLCBjb3B5LAoJCQl0eXBlID0gZXZlbnQudHlwZSwKCQkJb3JpZ2luYWxFdmVudCA9IGV2ZW50LAoJCQlmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdOwoKCQlpZiAoICFmaXhIb29rICkgewoJCQl0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID0KCQkJCXJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6CgkJCQlya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6CgkJCQl7fTsKCQl9CgkJY29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wczsKCgkJZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7CgoJCWkgPSBjb3B5Lmxlbmd0aDsKCQl3aGlsZSAoIGktLSApIHsKCQkJcHJvcCA9IGNvcHlbIGkgXTsKCQkJZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTsKCQl9CgoJCS8vIFN1cHBvcnQ6IElFPDkKCQkvLyBGaXggdGFyZ2V0IHByb3BlcnR5ICgjMTkyNSkKCQlpZiAoICFldmVudC50YXJnZXQgKSB7CgkJCWV2ZW50LnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDsKCQl9CgoJCS8vIFN1cHBvcnQ6IENocm9tZSAyMyssIFNhZmFyaT8KCQkvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKQoJCWlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgewoJCQlldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTsKCQl9CgoJCS8vIFN1cHBvcnQ6IElFPDkKCQkvLyBGb3IgbW91c2Uva2V5IGV2ZW50cywgbWV0YUtleT09ZmFsc2UgaWYgaXQncyB1bmRlZmluZWQgKCMzMzY4LCAjMTEzMjgpCgkJZXZlbnQubWV0YUtleSA9ICEhZXZlbnQubWV0YUtleTsKCgkJcmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDsKCX0sCgoJLy8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQKCXByb3BzOiAiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoIi5zcGxpdCgiICIpLAoKCWZpeEhvb2tzOiB7fSwKCglrZXlIb29rczogewoJCXByb3BzOiAiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZSIuc3BsaXQoIiAiKSwKCQlmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7CgoJCQkvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHMKCQkJaWYgKCBldmVudC53aGljaCA9PSBudWxsICkgewoJCQkJZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlOwoJCQl9CgoJCQlyZXR1cm4gZXZlbnQ7CgkJfQoJfSwKCgltb3VzZUhvb2tzOiB7CgkJcHJvcHM6ICJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnQiLnNwbGl0KCIgIiksCgkJZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkgewoJCQl2YXIgYm9keSwgZXZlbnREb2MsIGRvYywKCQkJCWJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbiwKCQkJCWZyb21FbGVtZW50ID0gb3JpZ2luYWwuZnJvbUVsZW1lbnQ7CgoJCQkvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlCgkJCWlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7CgkJCQlldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50OwoJCQkJZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50OwoJCQkJYm9keSA9IGV2ZW50RG9jLmJvZHk7CgoJCQkJZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApOwoJCQkJZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICsgKCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApOwoJCQl9CgoJCQkvLyBBZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5CgkJCWlmICggIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZnJvbUVsZW1lbnQgKSB7CgkJCQlldmVudC5yZWxhdGVkVGFyZ2V0ID0gZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IG9yaWdpbmFsLnRvRWxlbWVudCA6IGZyb21FbGVtZW50OwoJCQl9CgoJCQkvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0CgkJCS8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0CgkJCWlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkgewoJCQkJZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApOwoJCQl9CgoJCQlyZXR1cm4gZXZlbnQ7CgkJfQoJfSwKCglzcGVjaWFsOiB7CgkJbG9hZDogewoJCQkvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkCgkJCW5vQnViYmxlOiB0cnVlCgkJfSwKCQlmb2N1czogewoJCQkvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3QKCQkJdHJpZ2dlcjogZnVuY3Rpb24oKSB7CgkJCQlpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHsKCQkJCQl0cnkgewoJCQkJCQl0aGlzLmZvY3VzKCk7CgkJCQkJCXJldHVybiBmYWxzZTsKCQkJCQl9IGNhdGNoICggZSApIHsKCQkJCQkJLy8gU3VwcG9ydDogSUU8OQoJCQkJCQkvLyBJZiB3ZSBlcnJvciBvbiBmb2N1cyB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYsICMxMjUxOCksCgkJCQkJCS8vIGxldCAudHJpZ2dlcigpIHJ1biB0aGUgaGFuZGxlcnMKCQkJCQl9CgkJCQl9CgkJCX0sCgkJCWRlbGVnYXRlVHlwZTogImZvY3VzaW4iCgkJfSwKCQlibHVyOiB7CgkJCXRyaWdnZXI6IGZ1bmN0aW9uKCkgewoJCQkJaWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHsKCQkJCQl0aGlzLmJsdXIoKTsKCQkJCQlyZXR1cm4gZmFsc2U7CgkJCQl9CgkJCX0sCgkJCWRlbGVnYXRlVHlwZTogImZvY3Vzb3V0IgoJCX0sCgkJY2xpY2s6IHsKCQkJLy8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHQKCQkJdHJpZ2dlcjogZnVuY3Rpb24oKSB7CgkJCQlpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgImlucHV0IiApICYmIHRoaXMudHlwZSA9PT0gImNoZWNrYm94IiAmJiB0aGlzLmNsaWNrICkgewoJCQkJCXRoaXMuY2xpY2soKTsKCQkJCQlyZXR1cm4gZmFsc2U7CgkJCQl9CgkJCX0sCgoJCQkvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3MKCQkJX2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHsKCQkJCXJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgImEiICk7CgkJCX0KCQl9LAoKCQliZWZvcmV1bmxvYWQ6IHsKCQkJcG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7CgoJCQkJLy8gU3VwcG9ydDogRmlyZWZveCAyMCsKCQkJCS8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC4KCQkJCWlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHsKCQkJCQlldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0OwoJCQkJfQoJCQl9CgkJfQoJfSwKCglzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7CgkJLy8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLgoJCS8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZQoJCS8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLgoJCXZhciBlID0galF1ZXJ5LmV4dGVuZCgKCQkJbmV3IGpRdWVyeS5FdmVudCgpLAoJCQlldmVudCwKCQkJewoJCQkJdHlwZTogdHlwZSwKCQkJCWlzU2ltdWxhdGVkOiB0cnVlLAoJCQkJb3JpZ2luYWxFdmVudDoge30KCQkJfQoJCSk7CgkJaWYgKCBidWJibGUgKSB7CgkJCWpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7CgkJfSBlbHNlIHsKCQkJalF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTsKCQl9CgkJaWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkgewoJCQlldmVudC5wcmV2ZW50RGVmYXVsdCgpOwoJCX0KCX0KfTsKCmpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgPwoJZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHsKCQlpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHsKCQkJZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7CgkJfQoJfSA6CglmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkgewoJCXZhciBuYW1lID0gIm9uIiArIHR5cGU7CgoJCWlmICggZWxlbS5kZXRhY2hFdmVudCApIHsKCgkJCS8vICM4NTQ1LCAjNzA1NCwgcHJldmVudGluZyBtZW1vcnkgbGVha3MgZm9yIGN1c3RvbSBldmVudHMgaW4gSUU2LTgKCQkJLy8gZGV0YWNoRXZlbnQgbmVlZGVkIHByb3BlcnR5IG9uIGVsZW1lbnQsIGJ5IG5hbWUgb2YgdGhhdCBldmVudCwgdG8gcHJvcGVybHkgZXhwb3NlIGl0IHRvIEdDCgkJCWlmICggdHlwZW9mIGVsZW1bIG5hbWUgXSA9PT0gc3RydW5kZWZpbmVkICkgewoJCQkJZWxlbVsgbmFtZSBdID0gbnVsbDsKCQkJfQoKCQkJZWxlbS5kZXRhY2hFdmVudCggbmFtZSwgaGFuZGxlICk7CgkJfQoJfTsKCmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkgewoJLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkCglpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7CgkJcmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTsKCX0KCgkvLyBFdmVudCBvYmplY3QKCWlmICggc3JjICYmIHNyYy50eXBlICkgewoJCXRoaXMub3JpZ2luYWxFdmVudCA9IHNyYzsKCQl0aGlzLnR5cGUgPSBzcmMudHlwZTsKCgkJLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWQKCQkvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS4KCQl0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8CgkJCQlzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmCgkJCQkvLyBTdXBwb3J0OiBJRSA8IDksIEFuZHJvaWQgPCA0LjAKCQkJCXNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgPwoJCQlyZXR1cm5UcnVlIDoKCQkJcmV0dXJuRmFsc2U7CgoJLy8gRXZlbnQgdHlwZQoJfSBlbHNlIHsKCQl0aGlzLnR5cGUgPSBzcmM7Cgl9CgoJLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3QKCWlmICggcHJvcHMgKSB7CgkJalF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTsKCX0KCgkvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZQoJdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7CgoJLy8gTWFyayBpdCBhcyBmaXhlZAoJdGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7Cn07CgovLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmcKLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sCmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7Cglpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLAoJaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLAoJaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLAoKCXByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHsKCQl2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDsKCgkJdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlOwoJCWlmICggIWUgKSB7CgkJCXJldHVybjsKCQl9CgoJCS8vIElmIHByZXZlbnREZWZhdWx0IGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudAoJCWlmICggZS5wcmV2ZW50RGVmYXVsdCApIHsKCQkJZS5wcmV2ZW50RGVmYXVsdCgpOwoKCQkvLyBTdXBwb3J0OiBJRQoJCS8vIE90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBmYWxzZQoJCX0gZWxzZSB7CgkJCWUucmV0dXJuVmFsdWUgPSBmYWxzZTsKCQl9Cgl9LAoJc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHsKCQl2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDsKCgkJdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7CgkJaWYgKCAhZSApIHsKCQkJcmV0dXJuOwoJCX0KCQkvLyBJZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzLCBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50CgkJaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHsKCQkJZS5zdG9wUHJvcGFnYXRpb24oKTsKCQl9CgoJCS8vIFN1cHBvcnQ6IElFCgkJLy8gU2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIHRydWUKCQllLmNhbmNlbEJ1YmJsZSA9IHRydWU7Cgl9LAoJc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHsKCQl2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDsKCgkJdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7CgoJCWlmICggZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiApIHsKCQkJZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsKCQl9CgoJCXRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7Cgl9Cn07CgovLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3MKalF1ZXJ5LmVhY2goewoJbW91c2VlbnRlcjogIm1vdXNlb3ZlciIsCgltb3VzZWxlYXZlOiAibW91c2VvdXQiLAoJcG9pbnRlcmVudGVyOiAicG9pbnRlcm92ZXIiLAoJcG9pbnRlcmxlYXZlOiAicG9pbnRlcm91dCIKfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHsKCWpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7CgkJZGVsZWdhdGVUeXBlOiBmaXgsCgkJYmluZFR5cGU6IGZpeCwKCgkJaGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCXZhciByZXQsCgkJCQl0YXJnZXQgPSB0aGlzLAoJCQkJcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsCgkJCQloYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7CgoJCQkvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuCgkJCS8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93CgkJCWlmICggIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSkgKSB7CgkJCQlldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlOwoJCQkJcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOwoJCQkJZXZlbnQudHlwZSA9IGZpeDsKCQkJfQoJCQlyZXR1cm4gcmV0OwoJCX0KCX07Cn0pOwoKLy8gSUUgc3VibWl0IGRlbGVnYXRpb24KaWYgKCAhc3VwcG9ydC5zdWJtaXRCdWJibGVzICkgewoKCWpRdWVyeS5ldmVudC5zcGVjaWFsLnN1Ym1pdCA9IHsKCQlzZXR1cDogZnVuY3Rpb24oKSB7CgkJCS8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzCgkJCWlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCAiZm9ybSIgKSApIHsKCQkJCXJldHVybiBmYWxzZTsKCQkJfQoKCQkJLy8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWQKCQkJalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdCIsIGZ1bmN0aW9uKCBlICkgewoJCQkJLy8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNykKCQkJCXZhciBlbGVtID0gZS50YXJnZXQsCgkJCQkJZm9ybSA9IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgImlucHV0IiApIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgImJ1dHRvbiIgKSA/IGVsZW0uZm9ybSA6IHVuZGVmaW5lZDsKCQkJCWlmICggZm9ybSAmJiAhalF1ZXJ5Ll9kYXRhKCBmb3JtLCAic3VibWl0QnViYmxlcyIgKSApIHsKCQkJCQlqUXVlcnkuZXZlbnQuYWRkKCBmb3JtLCAic3VibWl0Ll9zdWJtaXQiLCBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCQkJCWV2ZW50Ll9zdWJtaXRfYnViYmxlID0gdHJ1ZTsKCQkJCQl9KTsKCQkJCQlqUXVlcnkuX2RhdGEoIGZvcm0sICJzdWJtaXRCdWJibGVzIiwgdHJ1ZSApOwoJCQkJfQoJCQl9KTsKCQkJLy8gcmV0dXJuIHVuZGVmaW5lZCBzaW5jZSB3ZSBkb24ndCBuZWVkIGFuIGV2ZW50IGxpc3RlbmVyCgkJfSwKCgkJcG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCS8vIElmIGZvcm0gd2FzIHN1Ym1pdHRlZCBieSB0aGUgdXNlciwgYnViYmxlIHRoZSBldmVudCB1cCB0aGUgdHJlZQoJCQlpZiAoIGV2ZW50Ll9zdWJtaXRfYnViYmxlICkgewoJCQkJZGVsZXRlIGV2ZW50Ll9zdWJtaXRfYnViYmxlOwoJCQkJaWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHsKCQkJCQlqUXVlcnkuZXZlbnQuc2ltdWxhdGUoICJzdWJtaXQiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7CgkJCQl9CgkJCX0KCQl9LAoKCQl0ZWFyZG93bjogZnVuY3Rpb24oKSB7CgkJCS8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzCgkJCWlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCAiZm9ybSIgKSApIHsKCQkJCXJldHVybiBmYWxzZTsKCQkJfQoKCQkJLy8gUmVtb3ZlIGRlbGVnYXRlZCBoYW5kbGVyczsgY2xlYW5EYXRhIGV2ZW50dWFsbHkgcmVhcHMgc3VibWl0IGhhbmRsZXJzIGF0dGFjaGVkIGFib3ZlCgkJCWpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsICIuX3N1Ym1pdCIgKTsKCQl9Cgl9Owp9CgovLyBJRSBjaGFuZ2UgZGVsZWdhdGlvbiBhbmQgY2hlY2tib3gvcmFkaW8gZml4CmlmICggIXN1cHBvcnQuY2hhbmdlQnViYmxlcyApIHsKCglqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7CgoJCXNldHVwOiBmdW5jdGlvbigpIHsKCgkJCWlmICggcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICkgKSB7CgkJCQkvLyBJRSBkb2Vzbid0IGZpcmUgY2hhbmdlIG9uIGEgY2hlY2svcmFkaW8gdW50aWwgYmx1cjsgdHJpZ2dlciBpdCBvbiBjbGljawoJCQkJLy8gYWZ0ZXIgYSBwcm9wZXJ0eWNoYW5nZS4gRWF0IHRoZSBibHVyLWNoYW5nZSBpbiBzcGVjaWFsLmNoYW5nZS5oYW5kbGUuCgkJCQkvLyBUaGlzIHN0aWxsIGZpcmVzIG9uY2hhbmdlIGEgc2Vjb25kIHRpbWUgZm9yIGNoZWNrL3JhZGlvIGFmdGVyIGJsdXIuCgkJCQlpZiAoIHRoaXMudHlwZSA9PT0gImNoZWNrYm94IiB8fCB0aGlzLnR5cGUgPT09ICJyYWRpbyIgKSB7CgkJCQkJalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2UiLCBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCQkJCWlmICggZXZlbnQub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWUgPT09ICJjaGVja2VkIiApIHsKCQkJCQkJCXRoaXMuX2p1c3RfY2hhbmdlZCA9IHRydWU7CgkJCQkJCX0KCQkJCQl9KTsKCQkJCQlqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCAiY2xpY2suX2NoYW5nZSIsIGZ1bmN0aW9uKCBldmVudCApIHsKCQkJCQkJaWYgKCB0aGlzLl9qdXN0X2NoYW5nZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHsKCQkJCQkJCXRoaXMuX2p1c3RfY2hhbmdlZCA9IGZhbHNlOwoJCQkJCQl9CgkJCQkJCS8vIEFsbG93IHRyaWdnZXJlZCwgc2ltdWxhdGVkIGNoYW5nZSBldmVudHMgKCMxMTUwMCkKCQkJCQkJalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCAiY2hhbmdlIiwgdGhpcywgZXZlbnQsIHRydWUgKTsKCQkJCQl9KTsKCQkJCX0KCQkJCXJldHVybiBmYWxzZTsKCQkJfQoJCQkvLyBEZWxlZ2F0ZWQgZXZlbnQ7IGxhenktYWRkIGEgY2hhbmdlIGhhbmRsZXIgb24gZGVzY2VuZGFudCBpbnB1dHMKCQkJalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2UiLCBmdW5jdGlvbiggZSApIHsKCQkJCXZhciBlbGVtID0gZS50YXJnZXQ7CgoJCQkJaWYgKCByZm9ybUVsZW1zLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCAiY2hhbmdlQnViYmxlcyIgKSApIHsKCQkJCQlqUXVlcnkuZXZlbnQuYWRkKCBlbGVtLCAiY2hhbmdlLl9jaGFuZ2UiLCBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCQkJCWlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkgewoJCQkJCQkJalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCAiY2hhbmdlIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApOwoJCQkJCQl9CgkJCQkJfSk7CgkJCQkJalF1ZXJ5Ll9kYXRhKCBlbGVtLCAiY2hhbmdlQnViYmxlcyIsIHRydWUgKTsKCQkJCX0KCQkJfSk7CgkJfSwKCgkJaGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCXZhciBlbGVtID0gZXZlbnQudGFyZ2V0OwoKCQkJLy8gU3dhbGxvdyBuYXRpdmUgY2hhbmdlIGV2ZW50cyBmcm9tIGNoZWNrYm94L3JhZGlvLCB3ZSBhbHJlYWR5IHRyaWdnZXJlZCB0aGVtIGFib3ZlCgkJCWlmICggdGhpcyAhPT0gZWxlbSB8fCBldmVudC5pc1NpbXVsYXRlZCB8fCBldmVudC5pc1RyaWdnZXIgfHwgKGVsZW0udHlwZSAhPT0gInJhZGlvIiAmJiBlbGVtLnR5cGUgIT09ICJjaGVja2JveCIpICkgewoJCQkJcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTsKCQkJfQoJCX0sCgoJCXRlYXJkb3duOiBmdW5jdGlvbigpIHsKCQkJalF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgIi5fY2hhbmdlIiApOwoKCQkJcmV0dXJuICFyZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTsKCQl9Cgl9Owp9CgovLyBDcmVhdGUgImJ1YmJsaW5nIiBmb2N1cyBhbmQgYmx1ciBldmVudHMKaWYgKCAhc3VwcG9ydC5mb2N1c2luQnViYmxlcyApIHsKCWpRdWVyeS5lYWNoKHsgZm9jdXM6ICJmb2N1c2luIiwgYmx1cjogImZvY3Vzb3V0IiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkgewoKCQkvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dAoJCXZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkgewoJCQkJalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApOwoJCQl9OwoKCQlqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7CgkJCXNldHVwOiBmdW5jdGlvbigpIHsKCQkJCXZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcywKCQkJCQlhdHRhY2hlcyA9IGpRdWVyeS5fZGF0YSggZG9jLCBmaXggKTsKCgkJCQlpZiAoICFhdHRhY2hlcyApIHsKCQkJCQlkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApOwoJCQkJfQoJCQkJalF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7CgkJCX0sCgkJCXRlYXJkb3duOiBmdW5jdGlvbigpIHsKCQkJCXZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcywKCQkJCQlhdHRhY2hlcyA9IGpRdWVyeS5fZGF0YSggZG9jLCBmaXggKSAtIDE7CgoJCQkJaWYgKCAhYXR0YWNoZXMgKSB7CgkJCQkJZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTsKCQkJCQlqUXVlcnkuX3JlbW92ZURhdGEoIGRvYywgZml4ICk7CgkJCQl9IGVsc2UgewoJCQkJCWpRdWVyeS5fZGF0YSggZG9jLCBmaXgsIGF0dGFjaGVzICk7CgkJCQl9CgkJCX0KCQl9OwoJfSk7Cn0KCmpRdWVyeS5mbi5leHRlbmQoewoKCW9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgLypJTlRFUk5BTCovIG9uZSApIHsKCQl2YXIgdHlwZSwgb3JpZ0ZuOwoKCQkvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnMKCQlpZiAoIHR5cGVvZiB0eXBlcyA9PT0gIm9iamVjdCIgKSB7CgkJCS8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApCgkJCWlmICggdHlwZW9mIHNlbGVjdG9yICE9PSAic3RyaW5nIiApIHsKCQkJCS8vICggdHlwZXMtT2JqZWN0LCBkYXRhICkKCQkJCWRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yOwoJCQkJc2VsZWN0b3IgPSB1bmRlZmluZWQ7CgkJCX0KCQkJZm9yICggdHlwZSBpbiB0eXBlcyApIHsKCQkJCXRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTsKCQkJfQoJCQlyZXR1cm4gdGhpczsKCQl9CgoJCWlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7CgkJCS8vICggdHlwZXMsIGZuICkKCQkJZm4gPSBzZWxlY3RvcjsKCQkJZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkOwoJCX0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7CgkJCWlmICggdHlwZW9mIHNlbGVjdG9yID09PSAic3RyaW5nIiApIHsKCQkJCS8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApCgkJCQlmbiA9IGRhdGE7CgkJCQlkYXRhID0gdW5kZWZpbmVkOwoJCQl9IGVsc2UgewoJCQkJLy8gKCB0eXBlcywgZGF0YSwgZm4gKQoJCQkJZm4gPSBkYXRhOwoJCQkJZGF0YSA9IHNlbGVjdG9yOwoJCQkJc2VsZWN0b3IgPSB1bmRlZmluZWQ7CgkJCX0KCQl9CgkJaWYgKCBmbiA9PT0gZmFsc2UgKSB7CgkJCWZuID0gcmV0dXJuRmFsc2U7CgkJfSBlbHNlIGlmICggIWZuICkgewoJCQlyZXR1cm4gdGhpczsKCQl9CgoJCWlmICggb25lID09PSAxICkgewoJCQlvcmlnRm4gPSBmbjsKCQkJZm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7CgkJCQkvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm8KCQkJCWpRdWVyeSgpLm9mZiggZXZlbnQgKTsKCQkJCXJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOwoJCQl9OwoJCQkvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGbgoJCQlmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTsKCQl9CgkJcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7CgkJCWpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTsKCQl9KTsKCX0sCglvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkgewoJCXJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7Cgl9LAoJb2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHsKCQl2YXIgaGFuZGxlT2JqLCB0eXBlOwoJCWlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkgewoJCQkvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50CgkJCWhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajsKCQkJalF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZigKCQkJCWhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyAiLiIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDogaGFuZGxlT2JqLm9yaWdUeXBlLAoJCQkJaGFuZGxlT2JqLnNlbGVjdG9yLAoJCQkJaGFuZGxlT2JqLmhhbmRsZXIKCQkJKTsKCQkJcmV0dXJuIHRoaXM7CgkJfQoJCWlmICggdHlwZW9mIHR5cGVzID09PSAib2JqZWN0IiApIHsKCQkJLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdICkKCQkJZm9yICggdHlwZSBpbiB0eXBlcyApIHsKCQkJCXRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApOwoJCQl9CgkJCXJldHVybiB0aGlzOwoJCX0KCQlpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09ICJmdW5jdGlvbiIgKSB7CgkJCS8vICggdHlwZXMgWywgZm5dICkKCQkJZm4gPSBzZWxlY3RvcjsKCQkJc2VsZWN0b3IgPSB1bmRlZmluZWQ7CgkJfQoJCWlmICggZm4gPT09IGZhbHNlICkgewoJCQlmbiA9IHJldHVybkZhbHNlOwoJCX0KCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgewoJCQlqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7CgkJfSk7Cgl9LAoKCXRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkgewoJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7CgkJCWpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7CgkJfSk7Cgl9LAoJdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkgewoJCXZhciBlbGVtID0gdGhpc1swXTsKCQlpZiAoIGVsZW0gKSB7CgkJCXJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApOwoJCX0KCX0KfSk7CgoKZnVuY3Rpb24gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApIHsKCXZhciBsaXN0ID0gbm9kZU5hbWVzLnNwbGl0KCAifCIgKSwKCQlzYWZlRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsKCglpZiAoIHNhZmVGcmFnLmNyZWF0ZUVsZW1lbnQgKSB7CgkJd2hpbGUgKCBsaXN0Lmxlbmd0aCApIHsKCQkJc2FmZUZyYWcuY3JlYXRlRWxlbWVudCgKCQkJCWxpc3QucG9wKCkKCQkJKTsKCQl9Cgl9CglyZXR1cm4gc2FmZUZyYWc7Cn0KCnZhciBub2RlTmFtZXMgPSAiYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGJkaXxjYW52YXN8ZGF0YXxkYXRhbGlzdHxkZXRhaWxzfGZpZ2NhcHRpb258ZmlndXJlfGZvb3RlcnwiICsKCQkiaGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW8iLAoJcmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XGQrPSIoPzpudWxsfFxkKykiL2csCglybm9zaGltY2FjaGUgPSBuZXcgUmVnRXhwKCI8KD86IiArIG5vZGVOYW1lcyArICIpW1xccy8+XSIsICJpIiksCglybGVhZGluZ1doaXRlc3BhY2UgPSAvXlxzKy8sCglyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXHc6XSspW14+XSopXC8+L2dpLAoJcnRhZ05hbWUgPSAvPChbXHc6XSspLywKCXJ0Ym9keSA9IC88dGJvZHkvaSwKCXJodG1sID0gLzx8JiM/XHcrOy8sCglybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLAoJLy8gY2hlY2tlZD0iY2hlY2tlZCIgb3IgY2hlY2tlZAoJcmNoZWNrZWQgPSAvY2hlY2tlZFxzKig/OltePV18PVxzKi5jaGVja2VkLikvaSwKCXJzY3JpcHRUeXBlID0gL14kfFwvKD86amF2YXxlY21hKXNjcmlwdC9pLAoJcnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcLyguKikvLAoJcmNsZWFuU2NyaXB0ID0gL15ccyo8ISg/OlxbQ0RBVEFcW3wtLSl8KD86XF1cXXwtLSk+XHMqJC9nLAoKCS8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApCgl3cmFwTWFwID0gewoJCW9wdGlvbjogWyAxLCAiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPiIsICI8L3NlbGVjdD4iIF0sCgkJbGVnZW5kOiBbIDEsICI8ZmllbGRzZXQ+IiwgIjwvZmllbGRzZXQ+IiBdLAoJCWFyZWE6IFsgMSwgIjxtYXA+IiwgIjwvbWFwPiIgXSwKCQlwYXJhbTogWyAxLCAiPG9iamVjdD4iLCAiPC9vYmplY3Q+IiBdLAoJCXRoZWFkOiBbIDEsICI8dGFibGU+IiwgIjwvdGFibGU+IiBdLAoJCXRyOiBbIDIsICI8dGFibGU+PHRib2R5PiIsICI8L3Rib2R5PjwvdGFibGU+IiBdLAoJCWNvbDogWyAyLCAiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4iLCAiPC9jb2xncm91cD48L3RhYmxlPiIgXSwKCQl0ZDogWyAzLCAiPHRhYmxlPjx0Ym9keT48dHI+IiwgIjwvdHI+PC90Ym9keT48L3RhYmxlPiIgXSwKCgkJLy8gSUU2LTggY2FuJ3Qgc2VyaWFsaXplIGxpbmssIHNjcmlwdCwgc3R5bGUsIG9yIGFueSBodG1sNSAoTm9TY29wZSkgdGFncywKCQkvLyB1bmxlc3Mgd3JhcHBlZCBpbiBhIGRpdiB3aXRoIG5vbi1icmVha2luZyBjaGFyYWN0ZXJzIGluIGZyb250IG9mIGl0LgoJCV9kZWZhdWx0OiBzdXBwb3J0Lmh0bWxTZXJpYWxpemUgPyBbIDAsICIiLCAiIiBdIDogWyAxLCAiWDxkaXY+IiwgIjwvZGl2PiIgIF0KCX0sCglzYWZlRnJhZ21lbnQgPSBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICksCglmcmFnbWVudERpdiA9IHNhZmVGcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IikgKTsKCndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjsKd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDsKd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7CgpmdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHsKCXZhciBlbGVtcywgZWxlbSwKCQlpID0gMCwKCQlmb3VuZCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBzdHJ1bmRlZmluZWQgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgIioiICkgOgoJCQl0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBzdHJ1bmRlZmluZWQgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCAiKiIgKSA6CgkJCXVuZGVmaW5lZDsKCglpZiAoICFmb3VuZCApIHsKCQlmb3IgKCBmb3VuZCA9IFtdLCBlbGVtcyA9IGNvbnRleHQuY2hpbGROb2RlcyB8fCBjb250ZXh0OyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7CgkJCWlmICggIXRhZyB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIHRhZyApICkgewoJCQkJZm91bmQucHVzaCggZWxlbSApOwoJCQl9IGVsc2UgewoJCQkJalF1ZXJ5Lm1lcmdlKCBmb3VuZCwgZ2V0QWxsKCBlbGVtLCB0YWcgKSApOwoJCQl9CgkJfQoJfQoKCXJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/CgkJalF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgZm91bmQgKSA6CgkJZm91bmQ7Cn0KCi8vIFVzZWQgaW4gYnVpbGRGcmFnbWVudCwgZml4ZXMgdGhlIGRlZmF1bHRDaGVja2VkIHByb3BlcnR5CmZ1bmN0aW9uIGZpeERlZmF1bHRDaGVja2VkKCBlbGVtICkgewoJaWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbGVtLnR5cGUgKSApIHsKCQllbGVtLmRlZmF1bHRDaGVja2VkID0gZWxlbS5jaGVja2VkOwoJfQp9CgovLyBTdXBwb3J0OiBJRTw4Ci8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keQpmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7CglyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCAidGFibGUiICkgJiYKCQlqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgInRyIiApID8KCgkJZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgidGJvZHkiKVswXSB8fAoJCQllbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKSApIDoKCQllbGVtOwp9CgovLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uCmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7CgllbGVtLnR5cGUgPSAoalF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgInR5cGUiICkgIT09IG51bGwpICsgIi8iICsgZWxlbS50eXBlOwoJcmV0dXJuIGVsZW07Cn0KZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHsKCXZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApOwoJaWYgKCBtYXRjaCApIHsKCQllbGVtLnR5cGUgPSBtYXRjaFsxXTsKCX0gZWxzZSB7CgkJZWxlbS5yZW1vdmVBdHRyaWJ1dGUoInR5cGUiKTsKCX0KCXJldHVybiBlbGVtOwp9CgovLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWQKZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkgewoJdmFyIGVsZW0sCgkJaSA9IDA7Cglmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHsKCQlqUXVlcnkuX2RhdGEoIGVsZW0sICJnbG9iYWxFdmFsIiwgIXJlZkVsZW1lbnRzIHx8IGpRdWVyeS5fZGF0YSggcmVmRWxlbWVudHNbaV0sICJnbG9iYWxFdmFsIiApICk7Cgl9Cn0KCmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7CgoJaWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7CgkJcmV0dXJuOwoJfQoKCXZhciB0eXBlLCBpLCBsLAoJCW9sZERhdGEgPSBqUXVlcnkuX2RhdGEoIHNyYyApLAoJCWN1ckRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QsIG9sZERhdGEgKSwKCQlldmVudHMgPSBvbGREYXRhLmV2ZW50czsKCglpZiAoIGV2ZW50cyApIHsKCQlkZWxldGUgY3VyRGF0YS5oYW5kbGU7CgkJY3VyRGF0YS5ldmVudHMgPSB7fTsKCgkJZm9yICggdHlwZSBpbiBldmVudHMgKSB7CgkJCWZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkgewoJCQkJalF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApOwoJCQl9CgkJfQoJfQoKCS8vIG1ha2UgdGhlIGNsb25lZCBwdWJsaWMgZGF0YSBvYmplY3QgYSBjb3B5IGZyb20gdGhlIG9yaWdpbmFsCglpZiAoIGN1ckRhdGEuZGF0YSApIHsKCQljdXJEYXRhLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyRGF0YS5kYXRhICk7Cgl9Cn0KCmZ1bmN0aW9uIGZpeENsb25lTm9kZUlzc3Vlcyggc3JjLCBkZXN0ICkgewoJdmFyIG5vZGVOYW1lLCBlLCBkYXRhOwoKCS8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHMKCWlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHsKCQlyZXR1cm47Cgl9CgoJbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CgoJLy8gSUU2LTggY29waWVzIGV2ZW50cyBib3VuZCB2aWEgYXR0YWNoRXZlbnQgd2hlbiB1c2luZyBjbG9uZU5vZGUuCglpZiAoICFzdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiBkZXN0WyBqUXVlcnkuZXhwYW5kbyBdICkgewoJCWRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QgKTsKCgkJZm9yICggZSBpbiBkYXRhLmV2ZW50cyApIHsKCQkJalF1ZXJ5LnJlbW92ZUV2ZW50KCBkZXN0LCBlLCBkYXRhLmhhbmRsZSApOwoJCX0KCgkJLy8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG8gZ2V0cyBjb3BpZWQgdG9vCgkJZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7Cgl9CgoJLy8gSUUgYmxhbmtzIGNvbnRlbnRzIHdoZW4gY2xvbmluZyBzY3JpcHRzLCBhbmQgdHJpZXMgdG8gZXZhbHVhdGUgbmV3bHktc2V0IHRleHQKCWlmICggbm9kZU5hbWUgPT09ICJzY3JpcHQiICYmIGRlc3QudGV4dCAhPT0gc3JjLnRleHQgKSB7CgkJZGlzYWJsZVNjcmlwdCggZGVzdCApLnRleHQgPSBzcmMudGV4dDsKCQlyZXN0b3JlU2NyaXB0KCBkZXN0ICk7CgoJLy8gSUU2LTEwIGltcHJvcGVybHkgY2xvbmVzIGNoaWxkcmVuIG9mIG9iamVjdCBlbGVtZW50cyB1c2luZyBjbGFzc2lkLgoJLy8gSUUxMCB0aHJvd3MgTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgaWYgcGFyZW50IGlzIG51bGwsICMxMjEzMi4KCX0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSAib2JqZWN0IiApIHsKCQlpZiAoIGRlc3QucGFyZW50Tm9kZSApIHsKCQkJZGVzdC5vdXRlckhUTUwgPSBzcmMub3V0ZXJIVE1MOwoJCX0KCgkJLy8gVGhpcyBwYXRoIGFwcGVhcnMgdW5hdm9pZGFibGUgZm9yIElFOS4gV2hlbiBjbG9uaW5nIGFuIG9iamVjdAoJCS8vIGVsZW1lbnQgaW4gSUU5LCB0aGUgb3V0ZXJIVE1MIHN0cmF0ZWd5IGFib3ZlIGlzIG5vdCBzdWZmaWNpZW50LgoJCS8vIElmIHRoZSBzcmMgaGFzIGlubmVySFRNTCBhbmQgdGhlIGRlc3RpbmF0aW9uIGRvZXMgbm90LAoJCS8vIGNvcHkgdGhlIHNyYy5pbm5lckhUTUwgaW50byB0aGUgZGVzdC5pbm5lckhUTUwuICMxMDMyNAoJCWlmICggc3VwcG9ydC5odG1sNUNsb25lICYmICggc3JjLmlubmVySFRNTCAmJiAhalF1ZXJ5LnRyaW0oZGVzdC5pbm5lckhUTUwpICkgKSB7CgkJCWRlc3QuaW5uZXJIVE1MID0gc3JjLmlubmVySFRNTDsKCQl9CgoJfSBlbHNlIGlmICggbm9kZU5hbWUgPT09ICJpbnB1dCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHsKCQkvLyBJRTYtOCBmYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94CgkJLy8gb3IgcmFkaW8gYnV0dG9uLiBXb3JzZSwgSUU2LTcgZmFpbCB0byBnaXZlIHRoZSBjbG9uZWQgZWxlbWVudAoJCS8vIGEgY2hlY2tlZCBhcHBlYXJhbmNlIGlmIHRoZSBkZWZhdWx0Q2hlY2tlZCB2YWx1ZSBpc24ndCBhbHNvIHNldAoKCQlkZXN0LmRlZmF1bHRDaGVja2VkID0gZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7CgoJCS8vIElFNi03IGdldCBjb25mdXNlZCBhbmQgZW5kIHVwIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY2xvbmVkCgkJLy8gY2hlY2tib3gvcmFkaW8gYnV0dG9uIHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mICJvbiIKCQlpZiAoIGRlc3QudmFsdWUgIT09IHNyYy52YWx1ZSApIHsKCQkJZGVzdC52YWx1ZSA9IHNyYy52YWx1ZTsKCQl9CgoJLy8gSUU2LTggZmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQKCS8vIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zCgl9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gIm9wdGlvbiIgKSB7CgkJZGVzdC5kZWZhdWx0U2VsZWN0ZWQgPSBkZXN0LnNlbGVjdGVkID0gc3JjLmRlZmF1bHRTZWxlY3RlZDsKCgkvLyBJRTYtOCBmYWlscyB0byBzZXQgdGhlIGRlZmF1bHRWYWx1ZSB0byB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuCgkvLyBjbG9uaW5nIG90aGVyIHR5cGVzIG9mIGlucHV0IGZpZWxkcwoJfSBlbHNlIGlmICggbm9kZU5hbWUgPT09ICJpbnB1dCIgfHwgbm9kZU5hbWUgPT09ICJ0ZXh0YXJlYSIgKSB7CgkJZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlOwoJfQp9CgpqUXVlcnkuZXh0ZW5kKHsKCWNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7CgkJdmFyIGRlc3RFbGVtZW50cywgbm9kZSwgY2xvbmUsIGksIHNyY0VsZW1lbnRzLAoJCQlpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApOwoKCQlpZiAoIHN1cHBvcnQuaHRtbDVDbG9uZSB8fCBqUXVlcnkuaXNYTUxEb2MoZWxlbSkgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCAiPCIgKyBlbGVtLm5vZGVOYW1lICsgIj4iICkgKSB7CgkJCWNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKTsKCgkJLy8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2RlcwoJCX0gZWxzZSB7CgkJCWZyYWdtZW50RGl2LmlubmVySFRNTCA9IGVsZW0ub3V0ZXJIVE1MOwoJCQlmcmFnbWVudERpdi5yZW1vdmVDaGlsZCggY2xvbmUgPSBmcmFnbWVudERpdi5maXJzdENoaWxkICk7CgkJfQoKCQlpZiAoICghc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQpICYmCgkJCQkoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSApIHsKCgkJCS8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yCgkJCWRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTsKCQkJc3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTsKCgkJCS8vIEZpeCBhbGwgSUUgY2xvbmluZyBpc3N1ZXMKCQkJZm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7ICsraSApIHsKCQkJCS8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4NwoJCQkJaWYgKCBkZXN0RWxlbWVudHNbaV0gKSB7CgkJCQkJZml4Q2xvbmVOb2RlSXNzdWVzKCBub2RlLCBkZXN0RWxlbWVudHNbaV0gKTsKCQkJCX0KCQkJfQoJCX0KCgkJLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZQoJCWlmICggZGF0YUFuZEV2ZW50cyApIHsKCQkJaWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHsKCQkJCXNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7CgkJCQlkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApOwoKCQkJCWZvciAoIGkgPSAwOyAobm9kZSA9IHNyY0VsZW1lbnRzW2ldKSAhPSBudWxsOyBpKysgKSB7CgkJCQkJY2xvbmVDb3B5RXZlbnQoIG5vZGUsIGRlc3RFbGVtZW50c1tpXSApOwoJCQkJfQoJCQl9IGVsc2UgewoJCQkJY2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7CgkJCX0KCQl9CgoJCS8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnkKCQlkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCAic2NyaXB0IiApOwoJCWlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7CgkJCXNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sICJzY3JpcHQiICkgKTsKCQl9CgoJCWRlc3RFbGVtZW50cyA9IHNyY0VsZW1lbnRzID0gbm9kZSA9IG51bGw7CgoJCS8vIFJldHVybiB0aGUgY2xvbmVkIHNldAoJCXJldHVybiBjbG9uZTsKCX0sCgoJYnVpbGRGcmFnbWVudDogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24gKSB7CgkJdmFyIGosIGVsZW0sIGNvbnRhaW5zLAoJCQl0bXAsIHRhZywgdGJvZHksIHdyYXAsCgkJCWwgPSBlbGVtcy5sZW5ndGgsCgoJCQkvLyBFbnN1cmUgYSBzYWZlIGZyYWdtZW50CgkJCXNhZmUgPSBjcmVhdGVTYWZlRnJhZ21lbnQoIGNvbnRleHQgKSwKCgkJCW5vZGVzID0gW10sCgkJCWkgPSAwOwoKCQlmb3IgKCA7IGkgPCBsOyBpKysgKSB7CgkJCWVsZW0gPSBlbGVtc1sgaSBdOwoKCQkJaWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7CgoJCQkJLy8gQWRkIG5vZGVzIGRpcmVjdGx5CgkJCQlpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09ICJvYmplY3QiICkgewoJCQkJCWpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTsKCgkJCQkvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGUKCQkJCX0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7CgkJCQkJbm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7CgoJCQkJLy8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzCgkJCQl9IGVsc2UgewoJCQkJCXRtcCA9IHRtcCB8fCBzYWZlLmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoImRpdiIpICk7CgoJCQkJCS8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb24KCQkJCQl0YWcgPSAocnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgIiIsICIiIF0pWyAxIF0udG9Mb3dlckNhc2UoKTsKCQkJCQl3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDsKCgkJCQkJdG1wLmlubmVySFRNTCA9IHdyYXBbMV0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgIjwkMT48LyQyPiIgKSArIHdyYXBbMl07CgoJCQkJCS8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudAoJCQkJCWogPSB3cmFwWzBdOwoJCQkJCXdoaWxlICggai0tICkgewoJCQkJCQl0bXAgPSB0bXAubGFzdENoaWxkOwoJCQkJCX0KCgkJCQkJLy8gTWFudWFsbHkgYWRkIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkIGJ5IElFCgkJCQkJaWYgKCAhc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSAmJiBybGVhZGluZ1doaXRlc3BhY2UudGVzdCggZWxlbSApICkgewoJCQkJCQlub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyggZWxlbSApWzBdICkgKTsKCQkJCQl9CgoJCQkJCS8vIFJlbW92ZSBJRSdzIGF1dG9pbnNlcnRlZCA8dGJvZHk+IGZyb20gdGFibGUgZnJhZ21lbnRzCgkJCQkJaWYgKCAhc3VwcG9ydC50Ym9keSApIHsKCgkJCQkJCS8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT4KCQkJCQkJZWxlbSA9IHRhZyA9PT0gInRhYmxlIiAmJiAhcnRib2R5LnRlc3QoIGVsZW0gKSA/CgkJCQkJCQl0bXAuZmlyc3RDaGlsZCA6CgoJCQkJCQkJLy8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+CgkJCQkJCQl3cmFwWzFdID09PSAiPHRhYmxlPiIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgPwoJCQkJCQkJCXRtcCA6CgkJCQkJCQkJMDsKCgkJCQkJCWogPSBlbGVtICYmIGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7CgkJCQkJCXdoaWxlICggai0tICkgewoJCQkJCQkJaWYgKCBqUXVlcnkubm9kZU5hbWUoICh0Ym9keSA9IGVsZW0uY2hpbGROb2Rlc1tqXSksICJ0Ym9keSIgKSAmJiAhdGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggKSB7CgkJCQkJCQkJZWxlbS5yZW1vdmVDaGlsZCggdGJvZHkgKTsKCQkJCQkJCX0KCQkJCQkJfQoJCQkJCX0KCgkJCQkJalF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTsKCgkJCQkJLy8gRml4ICMxMjM5MiBmb3IgV2ViS2l0IGFuZCBJRSA+IDkKCQkJCQl0bXAudGV4dENvbnRlbnQgPSAiIjsKCgkJCQkJLy8gRml4ICMxMjM5MiBmb3Igb2xkSUUKCQkJCQl3aGlsZSAoIHRtcC5maXJzdENoaWxkICkgewoJCQkJCQl0bXAucmVtb3ZlQ2hpbGQoIHRtcC5maXJzdENoaWxkICk7CgkJCQkJfQoKCQkJCQkvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgcHJvcGVyIGNsZWFudXAKCQkJCQl0bXAgPSBzYWZlLmxhc3RDaGlsZDsKCQkJCX0KCQkJfQoJCX0KCgkJLy8gRml4ICMxMTM1NjogQ2xlYXIgZWxlbWVudHMgZnJvbSBmcmFnbWVudAoJCWlmICggdG1wICkgewoJCQlzYWZlLnJlbW92ZUNoaWxkKCB0bXAgKTsKCQl9CgoJCS8vIFJlc2V0IGRlZmF1bHRDaGVja2VkIGZvciBhbnkgcmFkaW9zIGFuZCBjaGVja2JveGVzCgkJLy8gYWJvdXQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIERPTSBpbiBJRSA2LzcgKCM4MDYwKQoJCWlmICggIXN1cHBvcnQuYXBwZW5kQ2hlY2tlZCApIHsKCQkJalF1ZXJ5LmdyZXAoIGdldEFsbCggbm9kZXMsICJpbnB1dCIgKSwgZml4RGVmYXVsdENoZWNrZWQgKTsKCQl9CgoJCWkgPSAwOwoJCXdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkgewoKCQkJLy8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXMKCQkJLy8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmcKCQkJaWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHsKCQkJCWNvbnRpbnVlOwoJCQl9CgoJCQljb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7CgoJCQkvLyBBcHBlbmQgdG8gZnJhZ21lbnQKCQkJdG1wID0gZ2V0QWxsKCBzYWZlLmFwcGVuZENoaWxkKCBlbGVtICksICJzY3JpcHQiICk7CgoJCQkvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5CgkJCWlmICggY29udGFpbnMgKSB7CgkJCQlzZXRHbG9iYWxFdmFsKCB0bXAgKTsKCQkJfQoKCQkJLy8gQ2FwdHVyZSBleGVjdXRhYmxlcwoJCQlpZiAoIHNjcmlwdHMgKSB7CgkJCQlqID0gMDsKCQkJCXdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHsKCQkJCQlpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCAiIiApICkgewoJCQkJCQlzY3JpcHRzLnB1c2goIGVsZW0gKTsKCQkJCQl9CgkJCQl9CgkJCX0KCQl9CgoJCXRtcCA9IG51bGw7CgoJCXJldHVybiBzYWZlOwoJfSwKCgljbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcywgLyogaW50ZXJuYWwgKi8gYWNjZXB0RGF0YSApIHsKCQl2YXIgZWxlbSwgdHlwZSwgaWQsIGRhdGEsCgkJCWkgPSAwLAoJCQlpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLAoJCQljYWNoZSA9IGpRdWVyeS5jYWNoZSwKCQkJZGVsZXRlRXhwYW5kbyA9IHN1cHBvcnQuZGVsZXRlRXhwYW5kbywKCQkJc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsOwoKCQlmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHsKCQkJaWYgKCBhY2NlcHREYXRhIHx8IGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7CgoJCQkJaWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdOwoJCQkJZGF0YSA9IGlkICYmIGNhY2hlWyBpZCBdOwoKCQkJCWlmICggZGF0YSApIHsKCQkJCQlpZiAoIGRhdGEuZXZlbnRzICkgewoJCQkJCQlmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkgewoJCQkJCQkJaWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7CgkJCQkJCQkJalF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApOwoKCQkJCQkJCS8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWQKCQkJCQkJCX0gZWxzZSB7CgkJCQkJCQkJalF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApOwoJCQkJCQkJfQoJCQkJCQl9CgkJCQkJfQoKCQkJCQkvLyBSZW1vdmUgY2FjaGUgb25seSBpZiBpdCB3YXMgbm90IGFscmVhZHkgcmVtb3ZlZCBieSBqUXVlcnkuZXZlbnQucmVtb3ZlCgkJCQkJaWYgKCBjYWNoZVsgaWQgXSApIHsKCgkJCQkJCWRlbGV0ZSBjYWNoZVsgaWQgXTsKCgkJCQkJCS8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2RlcywKCQkJCQkJLy8gbm9yIGRvZXMgaXQgaGF2ZSBhIHJlbW92ZUF0dHJpYnV0ZSBmdW5jdGlvbiBvbiBEb2N1bWVudCBub2RlczsKCQkJCQkJLy8gd2UgbXVzdCBoYW5kbGUgYWxsIG9mIHRoZXNlIGNhc2VzCgkJCQkJCWlmICggZGVsZXRlRXhwYW5kbyApIHsKCQkJCQkJCWRlbGV0ZSBlbGVtWyBpbnRlcm5hbEtleSBdOwoKCQkJCQkJfSBlbHNlIGlmICggdHlwZW9mIGVsZW0ucmVtb3ZlQXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgKSB7CgkJCQkJCQllbGVtLnJlbW92ZUF0dHJpYnV0ZSggaW50ZXJuYWxLZXkgKTsKCgkJCQkJCX0gZWxzZSB7CgkJCQkJCQllbGVtWyBpbnRlcm5hbEtleSBdID0gbnVsbDsKCQkJCQkJfQoKCQkJCQkJZGVsZXRlZElkcy5wdXNoKCBpZCApOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCX0KfSk7CgpqUXVlcnkuZm4uZXh0ZW5kKHsKCXRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHsKCQlyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7CgkJCXJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8KCQkJCWpRdWVyeS50ZXh0KCB0aGlzICkgOgoJCQkJdGhpcy5lbXB0eSgpLmFwcGVuZCggKCB0aGlzWzBdICYmIHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApLmNyZWF0ZVRleHROb2RlKCB2YWx1ZSApICk7CgkJfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTsKCX0sCgoJYXBwZW5kOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHsKCQkJaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7CgkJCQl2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7CgkJCQl0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTsKCQkJfQoJCX0pOwoJfSwKCglwcmVwZW5kOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHsKCQkJaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7CgkJCQl2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7CgkJCQl0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApOwoJCQl9CgkJfSk7Cgl9LAoKCWJlZm9yZTogZnVuY3Rpb24oKSB7CgkJcmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7CgkJCWlmICggdGhpcy5wYXJlbnROb2RlICkgewoJCQkJdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApOwoJCQl9CgkJfSk7Cgl9LAoKCWFmdGVyOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHsKCQkJaWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7CgkJCQl0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7CgkJCX0KCQl9KTsKCX0sCgoJcmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkgewoJCXZhciBlbGVtLAoJCQllbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsCgkJCWkgPSAwOwoKCQlmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHsKCgkJCWlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7CgkJCQlqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0gKSApOwoJCQl9CgoJCQlpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHsKCQkJCWlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHsKCQkJCQlzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sICJzY3JpcHQiICkgKTsKCQkJCX0KCQkJCWVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApOwoJCQl9CgkJfQoKCQlyZXR1cm4gdGhpczsKCX0sCgoJZW1wdHk6IGZ1bmN0aW9uKCkgewoJCXZhciBlbGVtLAoJCQlpID0gMDsKCgkJZm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHsKCQkJLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzCgkJCWlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHsKCQkJCWpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApOwoJCQl9CgoJCQkvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2RlcwoJCQl3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCApIHsKCQkJCWVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApOwoJCQl9CgoJCQkvLyBJZiB0aGlzIGlzIGEgc2VsZWN0LCBlbnN1cmUgdGhhdCBpdCBkaXNwbGF5cyBlbXB0eSAoIzEyMzM2KQoJCQkvLyBTdXBwb3J0OiBJRTw5CgkJCWlmICggZWxlbS5vcHRpb25zICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgInNlbGVjdCIgKSApIHsKCQkJCWVsZW0ub3B0aW9ucy5sZW5ndGggPSAwOwoJCQl9CgkJfQoKCQlyZXR1cm4gdGhpczsKCX0sCgoJY2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHsKCQlkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzOwoJCWRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50czsKCgkJcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkgewoJCQlyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApOwoJCX0pOwoJfSwKCglodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7CgkJcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkgewoJCQl2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSwKCQkJCWkgPSAwLAoJCQkJbCA9IHRoaXMubGVuZ3RoOwoKCQkJaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgewoJCQkJcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgPwoJCQkJCWVsZW0uaW5uZXJIVE1MLnJlcGxhY2UoIHJpbmxpbmVqUXVlcnksICIiICkgOgoJCQkJCXVuZGVmaW5lZDsKCQkJfQoKCQkJLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTAoJCQlpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmCgkJCQkoIHN1cHBvcnQuaHRtbFNlcmlhbGl6ZSB8fCAhcm5vc2hpbWNhY2hlLnRlc3QoIHZhbHVlICkgICkgJiYKCQkJCSggc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAhcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIHZhbHVlICkgKSAmJgoJCQkJIXdyYXBNYXBbIChydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgIiIsICIiIF0pWyAxIF0udG9Mb3dlckNhc2UoKSBdICkgewoKCQkJCXZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCAiPCQxPjwvJDI+IiApOwoKCQkJCXRyeSB7CgkJCQkJZm9yICg7IGkgPCBsOyBpKysgKSB7CgkJCQkJCS8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrcwoJCQkJCQllbGVtID0gdGhpc1tpXSB8fCB7fTsKCQkJCQkJaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkgewoJCQkJCQkJalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7CgkJCQkJCQllbGVtLmlubmVySFRNTCA9IHZhbHVlOwoJCQkJCQl9CgkJCQkJfQoKCQkJCQllbGVtID0gMDsKCgkJCQkvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2QKCQkJCX0gY2F0Y2goZSkge30KCQkJfQoKCQkJaWYgKCBlbGVtICkgewoJCQkJdGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTsKCQkJfQoJCX0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7Cgl9LAoKCXJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHsKCQl2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07CgoJCS8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudAoJCXRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7CgkJCWFyZyA9IHRoaXMucGFyZW50Tm9kZTsKCgkJCWpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7CgoJCQlpZiAoIGFyZyApIHsKCQkJCWFyZy5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTsKCQkJfQoJCX0pOwoKCQkvLyBGb3JjZSByZW1vdmFsIGlmIHRoZXJlIHdhcyBubyBuZXcgY29udGVudCAoZS5nLiwgZnJvbSBlbXB0eSBhcmd1bWVudHMpCgkJcmV0dXJuIGFyZyAmJiAoYXJnLmxlbmd0aCB8fCBhcmcubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCk7Cgl9LAoKCWRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkgewoJCXJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTsKCX0sCgoJZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCBjYWxsYmFjayApIHsKCgkJLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5cwoJCWFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7CgoJCXZhciBmaXJzdCwgbm9kZSwgaGFzU2NyaXB0cywKCQkJc2NyaXB0cywgZG9jLCBmcmFnbWVudCwKCQkJaSA9IDAsCgkJCWwgPSB0aGlzLmxlbmd0aCwKCQkJc2V0ID0gdGhpcywKCQkJaU5vQ2xvbmUgPSBsIC0gMSwKCQkJdmFsdWUgPSBhcmdzWzBdLAoJCQlpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7CgoJCS8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdAoJCWlmICggaXNGdW5jdGlvbiB8fAoJCQkJKCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciICYmCgkJCQkJIXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7CgkJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkgewoJCQkJdmFyIHNlbGYgPSBzZXQuZXEoIGluZGV4ICk7CgkJCQlpZiAoIGlzRnVuY3Rpb24gKSB7CgkJCQkJYXJnc1swXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApOwoJCQkJfQoJCQkJc2VsZi5kb21NYW5pcCggYXJncywgY2FsbGJhY2sgKTsKCQkJfSk7CgkJfQoKCQlpZiAoIGwgKSB7CgkJCWZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyApOwoJCQlmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7CgoJCQlpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkgewoJCQkJZnJhZ21lbnQgPSBmaXJzdDsKCQkJfQoKCQkJaWYgKCBmaXJzdCApIHsKCQkJCXNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCAic2NyaXB0IiApLCBkaXNhYmxlU2NyaXB0ICk7CgkJCQloYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7CgoJCQkJLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXAKCQkJCS8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuCgkJCQlmb3IgKCA7IGkgPCBsOyBpKysgKSB7CgkJCQkJbm9kZSA9IGZyYWdtZW50OwoKCQkJCQlpZiAoIGkgIT09IGlOb0Nsb25lICkgewoJCQkJCQlub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7CgoJCQkJCQkvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uCgkJCQkJCWlmICggaGFzU2NyaXB0cyApIHsKCQkJCQkJCWpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCAic2NyaXB0IiApICk7CgkJCQkJCX0KCQkJCQl9CgoJCQkJCWNhbGxiYWNrLmNhbGwoIHRoaXNbaV0sIG5vZGUsIGkgKTsKCQkJCX0KCgkJCQlpZiAoIGhhc1NjcmlwdHMgKSB7CgkJCQkJZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDsKCgkJCQkJLy8gUmVlbmFibGUgc2NyaXB0cwoJCQkJCWpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTsKCgkJCQkJLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvbgoJCQkJCWZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkgewoJCQkJCQlub2RlID0gc2NyaXB0c1sgaSBdOwoJCQkJCQlpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCAiIiApICYmCgkJCQkJCQkhalF1ZXJ5Ll9kYXRhKCBub2RlLCAiZ2xvYmFsRXZhbCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkgewoKCQkJCQkJCWlmICggbm9kZS5zcmMgKSB7CgkJCQkJCQkJLy8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnQKCQkJCQkJCQlpZiAoIGpRdWVyeS5fZXZhbFVybCApIHsKCQkJCQkJCQkJalF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApOwoJCQkJCQkJCX0KCQkJCQkJCX0gZWxzZSB7CgkJCQkJCQkJalF1ZXJ5Lmdsb2JhbEV2YWwoICggbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lckhUTUwgfHwgIiIgKS5yZXBsYWNlKCByY2xlYW5TY3JpcHQsICIiICkgKTsKCQkJCQkJCX0KCQkJCQkJfQoJCQkJCX0KCQkJCX0KCgkJCQkvLyBGaXggIzExODA5OiBBdm9pZCBsZWFraW5nIG1lbW9yeQoJCQkJZnJhZ21lbnQgPSBmaXJzdCA9IG51bGw7CgkJCX0KCQl9CgoJCXJldHVybiB0aGlzOwoJfQp9KTsKCmpRdWVyeS5lYWNoKHsKCWFwcGVuZFRvOiAiYXBwZW5kIiwKCXByZXBlbmRUbzogInByZXBlbmQiLAoJaW5zZXJ0QmVmb3JlOiAiYmVmb3JlIiwKCWluc2VydEFmdGVyOiAiYWZ0ZXIiLAoJcmVwbGFjZUFsbDogInJlcGxhY2VXaXRoIgp9LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7CglqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHsKCQl2YXIgZWxlbXMsCgkJCWkgPSAwLAoJCQlyZXQgPSBbXSwKCQkJaW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLAoJCQlsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDE7CgoJCWZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7CgkJCWVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpOwoJCQlqUXVlcnkoIGluc2VydFtpXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApOwoKCQkJLy8gTW9kZXJuIGJyb3dzZXJzIGNhbiBhcHBseSBqUXVlcnkgY29sbGVjdGlvbnMgYXMgYXJyYXlzLCBidXQgb2xkSUUgbmVlZHMgYSAuZ2V0KCkKCQkJcHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApOwoJCX0KCgkJcmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTsKCX07Cn0pOwoKCnZhciBpZnJhbWUsCgllbGVtZGlzcGxheSA9IHt9OwoKLyoqCiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnQKICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnQKICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3QKICovCi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5CmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHsKCXZhciBzdHlsZSwKCQllbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksCgoJCS8vIGdldERlZmF1bHRDb21wdXRlZFN0eWxlIG1pZ2h0IGJlIHJlbGlhYmx5IHVzZWQgb25seSBvbiBhdHRhY2hlZCBlbGVtZW50CgkJZGlzcGxheSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSAmJiAoIHN0eWxlID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKCBlbGVtWyAwIF0gKSApID8KCgkJCS8vIFVzZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBmaXggKG1vcmUgbGlrZSBvcHRtaXphdGlvbikgdW50aWwgc29tZXRoaW5nIGJldHRlciBjb21lcyBhbG9uZywKCQkJLy8gc2luY2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBzcGVjaWZpY2F0aW9uIGFuZCBzdXBwb3J0ZWQgb25seSBpbiBGRgoJCQlzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCAiZGlzcGxheSIgKTsKCgkvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCwKCS8vIHNvIHVzZSAiZGV0YWNoIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudAoJZWxlbS5kZXRhY2goKTsKCglyZXR1cm4gZGlzcGxheTsKfQoKLyoqCiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50CiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZQogKi8KZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkgewoJdmFyIGRvYyA9IGRvY3VtZW50LAoJCWRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTsKCglpZiAoICFkaXNwbGF5ICkgewoJCWRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7CgoJCS8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZQoJCWlmICggZGlzcGxheSA9PT0gIm5vbmUiIHx8ICFkaXNwbGF5ICkgewoKCQkJLy8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlCgkJCWlmcmFtZSA9IChpZnJhbWUgfHwgalF1ZXJ5KCAiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPiIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTsKCgkJCS8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZQoJCQlkb2MgPSAoIGlmcmFtZVsgMCBdLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50ICkuZG9jdW1lbnQ7CgoJCQkvLyBTdXBwb3J0OiBJRQoJCQlkb2Mud3JpdGUoKTsKCQkJZG9jLmNsb3NlKCk7CgoJCQlkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApOwoJCQlpZnJhbWUuZGV0YWNoKCk7CgkJfQoKCQkvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXkKCQllbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7Cgl9CgoJcmV0dXJuIGRpc3BsYXk7Cn0KCgooZnVuY3Rpb24oKSB7Cgl2YXIgc2hyaW5rV3JhcEJsb2Nrc1ZhbDsKCglzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgPSBmdW5jdGlvbigpIHsKCQlpZiAoIHNocmlua1dyYXBCbG9ja3NWYWwgIT0gbnVsbCApIHsKCQkJcmV0dXJuIHNocmlua1dyYXBCbG9ja3NWYWw7CgkJfQoKCQkvLyBXaWxsIGJlIGNoYW5nZWQgbGF0ZXIgaWYgbmVlZGVkLgoJCXNocmlua1dyYXBCbG9ja3NWYWwgPSBmYWxzZTsKCgkJLy8gTWluaWZpZWQ6IHZhciBiLGMsZAoJCXZhciBkaXYsIGJvZHksIGNvbnRhaW5lcjsKCgkJYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAiYm9keSIgKVsgMCBdOwoJCWlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7CgkJCS8vIFRlc3QgZmlyZWQgdG9vIGVhcmx5IG9yIGluIGFuIHVuc3VwcG9ydGVkIGVudmlyb25tZW50LCBleGl0LgoJCQlyZXR1cm47CgkJfQoKCQkvLyBTZXR1cAoJCWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICJkaXYiICk7CgkJY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggImRpdiIgKTsKCQljb250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweCI7CgkJYm9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApOwoKCQkvLyBTdXBwb3J0OiBJRTYKCQkvLyBDaGVjayBpZiBlbGVtZW50cyB3aXRoIGxheW91dCBzaHJpbmstd3JhcCB0aGVpciBjaGlsZHJlbgoJCWlmICggdHlwZW9mIGRpdi5zdHlsZS56b29tICE9PSBzdHJ1bmRlZmluZWQgKSB7CgkJCS8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXIKCQkJZGl2LnN0eWxlLmNzc1RleHQgPQoJCQkJLy8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjMKCQkJCS8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZwoJCQkJIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7IiArCgkJCQkiYm94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowOyIgKwoJCQkJInBhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjEiOwoJCQlkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICJkaXYiICkgKS5zdHlsZS53aWR0aCA9ICI1cHgiOwoJCQlzaHJpbmtXcmFwQmxvY2tzVmFsID0gZGl2Lm9mZnNldFdpZHRoICE9PSAzOwoJCX0KCgkJYm9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7CgoJCXJldHVybiBzaHJpbmtXcmFwQmxvY2tzVmFsOwoJfTsKCn0pKCk7CnZhciBybWFyZ2luID0gKC9ebWFyZ2luLyk7Cgp2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggIl4oIiArIHBudW0gKyAiKSg/IXB4KVthLXolXSskIiwgImkiICk7CgoKCnZhciBnZXRTdHlsZXMsIGN1ckNTUywKCXJwb3NpdGlvbiA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLzsKCmlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7CglnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHsKCQlyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTsKCX07CgoJY3VyQ1NTID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkgewoJCXZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsCgkJCXN0eWxlID0gZWxlbS5zdHlsZTsKCgkJY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTsKCgkJLy8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgaW4gSUU5LCBzZWUgIzEyNTM3CgkJcmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZDsKCgkJaWYgKCBjb21wdXRlZCApIHsKCgkJCWlmICggcmV0ID09PSAiIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHsKCQkJCXJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApOwoJCQl9CgoJCQkvLyBBIHRyaWJ1dGUgdG8gdGhlICJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzIgoJCQkvLyBDaHJvbWUgPCAxNyBhbmQgU2FmYXJpIDUuMCB1c2VzICJjb21wdXRlZCB2YWx1ZSIgaW5zdGVhZCBvZiAidXNlZCB2YWx1ZSIgZm9yIG1hcmdpbi1yaWdodAoJCQkvLyBTYWZhcmkgNS4xLjcgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMKCQkJLy8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzCgkJCWlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkgewoKCQkJCS8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXMKCQkJCXdpZHRoID0gc3R5bGUud2lkdGg7CgkJCQltaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoOwoJCQkJbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDsKCgkJCQkvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0CgkJCQlzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7CgkJCQlyZXQgPSBjb21wdXRlZC53aWR0aDsKCgkJCQkvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzCgkJCQlzdHlsZS53aWR0aCA9IHdpZHRoOwoJCQkJc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDsKCQkJCXN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7CgkJCX0KCQl9CgoJCS8vIFN1cHBvcnQ6IElFCgkJLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci4KCQlyZXR1cm4gcmV0ID09PSB1bmRlZmluZWQgPwoJCQlyZXQgOgoJCQlyZXQgKyAiIjsKCX07Cn0gZWxzZSBpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgKSB7CglnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHsKCQlyZXR1cm4gZWxlbS5jdXJyZW50U3R5bGU7Cgl9OwoKCWN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHsKCQl2YXIgbGVmdCwgcnMsIHJzTGVmdCwgcmV0LAoJCQlzdHlsZSA9IGVsZW0uc3R5bGU7CgoJCWNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7CgkJcmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkOwoKCQkvLyBBdm9pZCBzZXR0aW5nIHJldCB0byBlbXB0eSBzdHJpbmcgaGVyZQoJCS8vIHNvIHdlIGRvbid0IGRlZmF1bHQgdG8gYXV0bwoJCWlmICggcmV0ID09IG51bGwgJiYgc3R5bGUgJiYgc3R5bGVbIG5hbWUgXSApIHsKCQkJcmV0ID0gc3R5bGVbIG5hbWUgXTsKCQl9CgoJCS8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHMKCQkvLyBodHRwOi8vZXJpay5lYWUubmV0L2FyY2hpdmVzLzIwMDcvMDcvMjcvMTguNTQuMTUvI2NvbW1lbnQtMTAyMjkxCgoJCS8vIElmIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSByZWd1bGFyIHBpeGVsIG51bWJlcgoJCS8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVscwoJCS8vIGJ1dCBub3QgcG9zaXRpb24gY3NzIGF0dHJpYnV0ZXMsIGFzIHRob3NlIGFyZSBwcm9wb3J0aW9uYWwgdG8gdGhlIHBhcmVudCBlbGVtZW50IGluc3RlYWQKCQkvLyBhbmQgd2UgY2FuJ3QgbWVhc3VyZSB0aGUgcGFyZW50IGluc3RlYWQgYmVjYXVzZSBpdCBtaWdodCB0cmlnZ2VyIGEgInN0YWNraW5nIGRvbGxzIiBwcm9ibGVtCgkJaWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgIXJwb3NpdGlvbi50ZXN0KCBuYW1lICkgKSB7CgoJCQkvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzCgkJCWxlZnQgPSBzdHlsZS5sZWZ0OwoJCQlycyA9IGVsZW0ucnVudGltZVN0eWxlOwoJCQlyc0xlZnQgPSBycyAmJiBycy5sZWZ0OwoKCQkJLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dAoJCQlpZiAoIHJzTGVmdCApIHsKCQkJCXJzLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0OwoJCQl9CgkJCXN0eWxlLmxlZnQgPSBuYW1lID09PSAiZm9udFNpemUiID8gIjFlbSIgOiByZXQ7CgkJCXJldCA9IHN0eWxlLnBpeGVsTGVmdCArICJweCI7CgoJCQkvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzCgkJCXN0eWxlLmxlZnQgPSBsZWZ0OwoJCQlpZiAoIHJzTGVmdCApIHsKCQkJCXJzLmxlZnQgPSByc0xlZnQ7CgkJCX0KCQl9CgoJCS8vIFN1cHBvcnQ6IElFCgkJLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci4KCQlyZXR1cm4gcmV0ID09PSB1bmRlZmluZWQgPwoJCQlyZXQgOgoJCQlyZXQgKyAiIiB8fCAiYXV0byI7Cgl9Owp9CgoKCgpmdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7CgkvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLgoJcmV0dXJuIHsKCQlnZXQ6IGZ1bmN0aW9uKCkgewoJCQl2YXIgY29uZGl0aW9uID0gY29uZGl0aW9uRm4oKTsKCgkJCWlmICggY29uZGl0aW9uID09IG51bGwgKSB7CgkJCQkvLyBUaGUgdGVzdCB3YXMgbm90IHJlYWR5IGF0IHRoaXMgcG9pbnQ7IHNjcmV3IHRoZSBob29rIHRoaXMgdGltZQoJCQkJLy8gYnV0IGNoZWNrIGFnYWluIHdoZW4gbmVlZGVkIG5leHQgdGltZS4KCQkJCXJldHVybjsKCQkJfQoKCQkJaWYgKCBjb25kaXRpb24gKSB7CgkJCQkvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWUgdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwKCQkJCS8vIHJlbW92ZSBpdC4KCQkJCS8vIFNpbmNlIHRoZXJlIGFyZSBubyBvdGhlciBob29rcyBmb3IgbWFyZ2luUmlnaHQsIHJlbW92ZSB0aGUgd2hvbGUgb2JqZWN0LgoJCQkJZGVsZXRlIHRoaXMuZ2V0OwoJCQkJcmV0dXJuOwoJCQl9CgoJCQkvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi4KCgkJCXJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTsKCQl9Cgl9Owp9CgoKKGZ1bmN0aW9uKCkgewoJLy8gTWluaWZpZWQ6IHZhciBiLGMsZCxlLGYsZywgaCxpCgl2YXIgZGl2LCBzdHlsZSwgYSwgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsCgkJcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsLCByZWxpYWJsZU1hcmdpblJpZ2h0VmFsOwoKCS8vIFNldHVwCglkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiZGl2IiApOwoJZGl2LmlubmVySFRNTCA9ICIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz4iOwoJYSA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggImEiIClbIDAgXTsKCXN0eWxlID0gYSAmJiBhLnN0eWxlOwoKCS8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzCglpZiAoICFzdHlsZSApIHsKCQlyZXR1cm47Cgl9CgoJc3R5bGUuY3NzVGV4dCA9ICJmbG9hdDpsZWZ0O29wYWNpdHk6LjUiOwoKCS8vIFN1cHBvcnQ6IElFPDkKCS8vIE1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQgb3BhY2l0eSBleGlzdHMgKGFzIG9wcG9zZWQgdG8gZmlsdGVyKQoJc3VwcG9ydC5vcGFjaXR5ID0gc3R5bGUub3BhY2l0eSA9PT0gIjAuNSI7CgoJLy8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZQoJLy8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KQoJc3VwcG9ydC5jc3NGbG9hdCA9ICEhc3R5bGUuY3NzRmxvYXQ7CgoJZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gImNvbnRlbnQtYm94IjsKCWRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9ICIiOwoJc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09ICJjb250ZW50LWJveCI7CgoJLy8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjMKCS8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZwoJc3VwcG9ydC5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgPT09ICIiIHx8IHN0eWxlLk1vekJveFNpemluZyA9PT0gIiIgfHwKCQlzdHlsZS5XZWJraXRCb3hTaXppbmcgPT09ICIiOwoKCWpRdWVyeS5leHRlbmQoc3VwcG9ydCwgewoJCXJlbGlhYmxlSGlkZGVuT2Zmc2V0czogZnVuY3Rpb24oKSB7CgkJCWlmICggcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsID09IG51bGwgKSB7CgkJCQljb21wdXRlU3R5bGVUZXN0cygpOwoJCQl9CgkJCXJldHVybiByZWxpYWJsZUhpZGRlbk9mZnNldHNWYWw7CgkJfSwKCgkJYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkgewoJCQlpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7CgkJCQljb21wdXRlU3R5bGVUZXN0cygpOwoJCQl9CgkJCXJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDsKCQl9LAoKCQlwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHsKCQkJaWYgKCBwaXhlbFBvc2l0aW9uVmFsID09IG51bGwgKSB7CgkJCQljb21wdXRlU3R5bGVUZXN0cygpOwoJCQl9CgkJCXJldHVybiBwaXhlbFBvc2l0aW9uVmFsOwoJCX0sCgoJCS8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zCgkJcmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7CgkJCWlmICggcmVsaWFibGVNYXJnaW5SaWdodFZhbCA9PSBudWxsICkgewoJCQkJY29tcHV0ZVN0eWxlVGVzdHMoKTsKCQkJfQoJCQlyZXR1cm4gcmVsaWFibGVNYXJnaW5SaWdodFZhbDsKCQl9Cgl9KTsKCglmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHsKCQkvLyBNaW5pZmllZDogdmFyIGIsYyxkLGoKCQl2YXIgZGl2LCBib2R5LCBjb250YWluZXIsIGNvbnRlbnRzOwoKCQlib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICJib2R5IiApWyAwIF07CgkJaWYgKCAhYm9keSB8fCAhYm9keS5zdHlsZSApIHsKCQkJLy8gVGVzdCBmaXJlZCB0b28gZWFybHkgb3IgaW4gYW4gdW5zdXBwb3J0ZWQgZW52aXJvbm1lbnQsIGV4aXQuCgkJCXJldHVybjsKCQl9CgoJCS8vIFNldHVwCgkJZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggImRpdiIgKTsKCQljb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiZGl2IiApOwoJCWNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gInBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4IjsKCQlib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7CgoJCWRpdi5zdHlsZS5jc3NUZXh0ID0KCQkJLy8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjMKCQkJLy8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nCgkJCSItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDsiICsKCQkJImJveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElOyIgKwoJCQkiYm9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGUiOwoKCQkvLyBTdXBwb3J0OiBJRTw5CgkJLy8gQXNzdW1lIHJlYXNvbmFibGUgdmFsdWVzIGluIHRoZSBhYnNlbmNlIG9mIGdldENvbXB1dGVkU3R5bGUKCQlwaXhlbFBvc2l0aW9uVmFsID0gYm94U2l6aW5nUmVsaWFibGVWYWwgPSBmYWxzZTsKCQlyZWxpYWJsZU1hcmdpblJpZ2h0VmFsID0gdHJ1ZTsKCgkJLy8gQ2hlY2sgZm9yIGdldENvbXB1dGVkU3R5bGUgc28gdGhhdCB0aGlzIGNvZGUgaXMgbm90IHJ1biBpbiBJRTw5LgoJCWlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7CgkJCXBpeGVsUG9zaXRpb25WYWwgPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7fSApLnRvcCAhPT0gIjElIjsKCQkJYm94U2l6aW5nUmVsaWFibGVWYWwgPQoJCQkJKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICkgfHwgeyB3aWR0aDogIjRweCIgfSApLndpZHRoID09PSAiNHB4IjsKCgkJCS8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zCgkJCS8vIERpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHkKCQkJLy8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyICgjMzMzMykKCQkJLy8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0CgkJCWNvbnRlbnRzID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiZGl2IiApICk7CgoJCQkvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nCgkJCWNvbnRlbnRzLnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9CgkJCQkvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuMwoJCQkJLy8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nCgkJCQkiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDsiICsKCQkJCSJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowIjsKCQkJY29udGVudHMuc3R5bGUubWFyZ2luUmlnaHQgPSBjb250ZW50cy5zdHlsZS53aWR0aCA9ICIwIjsKCQkJZGl2LnN0eWxlLndpZHRoID0gIjFweCI7CgoJCQlyZWxpYWJsZU1hcmdpblJpZ2h0VmFsID0KCQkJCSFwYXJzZUZsb2F0KCAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjb250ZW50cywgbnVsbCApIHx8IHt9ICkubWFyZ2luUmlnaHQgKTsKCQl9CgoJCS8vIFN1cHBvcnQ6IElFOAoJCS8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0CgkJLy8gdG8gZGlzcGxheTpub25lIGFuZCB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdmlzaWJsZSB0YWJsZSBjZWxscyBpbiBhCgkJLy8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuCgkJLy8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmcKCQkvLyBkaXNwbGF5Om5vbmUgKGl0IGlzIHN0aWxsIHNhZmUgdG8gdXNlIG9mZnNldHMgaWYgYSBwYXJlbnQgZWxlbWVudCBpcwoJCS8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS4KCQlkaXYuaW5uZXJIVE1MID0gIjx0YWJsZT48dHI+PHRkPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT4iOwoJCWNvbnRlbnRzID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAidGQiICk7CgkJY29udGVudHNbIDAgXS5zdHlsZS5jc3NUZXh0ID0gIm1hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MDtkaXNwbGF5Om5vbmUiOwoJCXJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCA9IGNvbnRlbnRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwOwoJCWlmICggcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsICkgewoJCQljb250ZW50c1sgMCBdLnN0eWxlLmRpc3BsYXkgPSAiIjsKCQkJY29udGVudHNbIDEgXS5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwoJCQlyZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwgPSBjb250ZW50c1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMDsKCQl9CgoJCWJvZHkucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApOwoJfQoKfSkoKTsKCgovLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLgpqUXVlcnkuc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHsKCXZhciByZXQsIG5hbWUsCgkJb2xkID0ge307CgoJLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzCglmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7CgkJb2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07CgkJZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdOwoJfQoKCXJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7CgoJLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzCglmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7CgkJZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07Cgl9CgoJcmV0dXJuIHJldDsKfTsKCgp2YXIKCQlyYWxwaGEgPSAvYWxwaGFcKFteKV0qXCkvaSwKCXJvcGFjaXR5ID0gL29wYWNpdHlccyo9XHMqKFteKV0qKS8sCgoJLy8gc3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgInRhYmxlIiwgInRhYmxlLWNlbGwiLCBvciAidGFibGUtY2FwdGlvbiIKCS8vIHNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheQoJcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLAoJcm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggIl4oIiArIHBudW0gKyAiKSguKikkIiwgImkiICksCglycmVsTnVtID0gbmV3IFJlZ0V4cCggIl4oWystXSk9KCIgKyBwbnVtICsgIikiLCAiaSIgKSwKCgljc3NTaG93ID0geyBwb3NpdGlvbjogImFic29sdXRlIiwgdmlzaWJpbGl0eTogImhpZGRlbiIsIGRpc3BsYXk6ICJibG9jayIgfSwKCWNzc05vcm1hbFRyYW5zZm9ybSA9IHsKCQlsZXR0ZXJTcGFjaW5nOiAiMCIsCgkJZm9udFdlaWdodDogIjQwMCIKCX0sCgoJY3NzUHJlZml4ZXMgPSBbICJXZWJraXQiLCAiTyIsICJNb3oiLCAibXMiIF07CgoKLy8gcmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eQpmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG5hbWUgKSB7CgoJLy8gc2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWQKCWlmICggbmFtZSBpbiBzdHlsZSApIHsKCQlyZXR1cm4gbmFtZTsKCX0KCgkvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzCgl2YXIgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLAoJCW9yaWdOYW1lID0gbmFtZSwKCQlpID0gY3NzUHJlZml4ZXMubGVuZ3RoOwoKCXdoaWxlICggaS0tICkgewoJCW5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTsKCQlpZiAoIG5hbWUgaW4gc3R5bGUgKSB7CgkJCXJldHVybiBuYW1lOwoJCX0KCX0KCglyZXR1cm4gb3JpZ05hbWU7Cn0KCmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHsKCXZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sCgkJdmFsdWVzID0gW10sCgkJaW5kZXggPSAwLAoJCWxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDsKCglmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkgewoJCWVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTsKCQlpZiAoICFlbGVtLnN0eWxlICkgewoJCQljb250aW51ZTsKCQl9CgoJCXZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgIm9sZGRpc3BsYXkiICk7CgkJZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTsKCQlpZiAoIHNob3cgKSB7CgkJCS8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXMKCQkJLy8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdAoJCQlpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gIm5vbmUiICkgewoJCQkJZWxlbS5zdHlsZS5kaXNwbGF5ID0gIiI7CgkJCX0KCgkJCS8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmUKCQkJLy8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXMKCQkJLy8gZm9yIHN1Y2ggYW4gZWxlbWVudAoJCQlpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gIiIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHsKCQkJCXZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgIm9sZGRpc3BsYXkiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApOwoJCQl9CgkJfSBlbHNlIHsKCQkJaGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTsKCgkJCWlmICggZGlzcGxheSAmJiBkaXNwbGF5ICE9PSAibm9uZSIgfHwgIWhpZGRlbiApIHsKCQkJCWpRdWVyeS5fZGF0YSggZWxlbSwgIm9sZGRpc3BsYXkiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgImRpc3BsYXkiICkgKTsKCQkJfQoJCX0KCX0KCgkvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcAoJLy8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvdwoJZm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHsKCQllbGVtID0gZWxlbWVudHNbIGluZGV4IF07CgkJaWYgKCAhZWxlbS5zdHlsZSApIHsKCQkJY29udGludWU7CgkJfQoJCWlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSAibm9uZSIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSAiIiApIHsKCQkJZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCAiIiA6ICJub25lIjsKCQl9Cgl9CgoJcmV0dXJuIGVsZW1lbnRzOwp9CgpmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkgewoJdmFyIG1hdGNoZXMgPSBybnVtc3BsaXQuZXhlYyggdmFsdWUgKTsKCXJldHVybiBtYXRjaGVzID8KCQkvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCAic3VidHJhY3QiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3MKCQlNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8ICJweCIgKSA6CgkJdmFsdWU7Cn0KCmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHsKCXZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyAiYm9yZGVyIiA6ICJjb250ZW50IiApID8KCQkvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb24KCQk0IDoKCQkvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzCgkJbmFtZSA9PT0gIndpZHRoIiA/IDEgOiAwLAoKCQl2YWwgPSAwOwoKCWZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHsKCQkvLyBib3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0CgkJaWYgKCBleHRyYSA9PT0gIm1hcmdpbiIgKSB7CgkJCXZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTsKCQl9CgoJCWlmICggaXNCb3JkZXJCb3ggKSB7CgkJCS8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudAoJCQlpZiAoIGV4dHJhID09PSAiY29udGVudCIgKSB7CgkJCQl2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgInBhZGRpbmciICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApOwoJCQl9CgoJCQkvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlcgoJCQlpZiAoIGV4dHJhICE9PSAibWFyZ2luIiApIHsKCQkJCXZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCAiYm9yZGVyIiArIGNzc0V4cGFuZFsgaSBdICsgIldpZHRoIiwgdHJ1ZSwgc3R5bGVzICk7CgkJCX0KCQl9IGVsc2UgewoJCQkvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZwoJCQl2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgInBhZGRpbmciICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApOwoKCQkJLy8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlcgoJCQlpZiAoIGV4dHJhICE9PSAicGFkZGluZyIgKSB7CgkJCQl2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgImJvcmRlciIgKyBjc3NFeHBhbmRbIGkgXSArICJXaWR0aCIsIHRydWUsIHN0eWxlcyApOwoJCQl9CgkJfQoJfQoKCXJldHVybiB2YWw7Cn0KCmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkgewoKCS8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlCgl2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsCgkJdmFsID0gbmFtZSA9PT0gIndpZHRoIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCwKCQlzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSwKCQlpc0JvcmRlckJveCA9IHN1cHBvcnQuYm94U2l6aW5nICYmIGpRdWVyeS5jc3MoIGVsZW0sICJib3hTaXppbmciLCBmYWxzZSwgc3R5bGVzICkgPT09ICJib3JkZXItYm94IjsKCgkvLyBzb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWQKCS8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NQoJLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4CglpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkgewoJCS8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeQoJCXZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7CgkJaWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkgewoJCQl2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07CgkJfQoKCQkvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLgoJCWlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHsKCQkJcmV0dXJuIHZhbDsKCQl9CgoJCS8vIHdlIG5lZWQgdGhlIGNoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzCgkJLy8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZQoJCXZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiAoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApOwoKCQkvLyBOb3JtYWxpemUgIiIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYQoJCXZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7Cgl9CgoJLy8gdXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXMKCXJldHVybiAoIHZhbCArCgkJYXVnbWVudFdpZHRoT3JIZWlnaHQoCgkJCWVsZW0sCgkJCW5hbWUsCgkJCWV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyAiYm9yZGVyIiA6ICJjb250ZW50IiApLAoJCQl2YWx1ZUlzQm9yZGVyQm94LAoJCQlzdHlsZXMKCQkpCgkpICsgInB4IjsKfQoKalF1ZXJ5LmV4dGVuZCh7CgkvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQKCS8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eQoJY3NzSG9va3M6IHsKCQlvcGFjaXR5OiB7CgkJCWdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkgewoJCQkJaWYgKCBjb21wdXRlZCApIHsKCQkJCQkvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eQoJCQkJCXZhciByZXQgPSBjdXJDU1MoIGVsZW0sICJvcGFjaXR5IiApOwoJCQkJCXJldHVybiByZXQgPT09ICIiID8gIjEiIDogcmV0OwoJCQkJfQoJCQl9CgkJfQoJfSwKCgkvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCAicHgiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXMKCWNzc051bWJlcjogewoJCSJjb2x1bW5Db3VudCI6IHRydWUsCgkJImZpbGxPcGFjaXR5IjogdHJ1ZSwKCQkiZmxleEdyb3ciOiB0cnVlLAoJCSJmbGV4U2hyaW5rIjogdHJ1ZSwKCQkiZm9udFdlaWdodCI6IHRydWUsCgkJImxpbmVIZWlnaHQiOiB0cnVlLAoJCSJvcGFjaXR5IjogdHJ1ZSwKCQkib3JkZXIiOiB0cnVlLAoJCSJvcnBoYW5zIjogdHJ1ZSwKCQkid2lkb3dzIjogdHJ1ZSwKCQkiekluZGV4IjogdHJ1ZSwKCQkiem9vbSI6IHRydWUKCX0sCgoJLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZQoJLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZQoJY3NzUHJvcHM6IHsKCQkvLyBub3JtYWxpemUgZmxvYXQgY3NzIHByb3BlcnR5CgkJImZsb2F0Ijogc3VwcG9ydC5jc3NGbG9hdCA/ICJjc3NGbG9hdCIgOiAic3R5bGVGbG9hdCIKCX0sCgoJLy8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGUKCXN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkgewoJCS8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2RlcwoJCWlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkgewoJCQlyZXR1cm47CgkJfQoKCQkvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUKCQl2YXIgcmV0LCB0eXBlLCBob29rcywKCQkJb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksCgkJCXN0eWxlID0gZWxlbS5zdHlsZTsKCgkJbmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBzdHlsZSwgb3JpZ05hbWUgKSApOwoKCQkvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uCgkJLy8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvbgoJCWhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdOwoKCQkvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWUKCQlpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7CgkJCXR5cGUgPSB0eXBlb2YgdmFsdWU7CgoJCQkvLyBjb252ZXJ0IHJlbGF0aXZlIG51bWJlciBzdHJpbmdzICgrPSBvciAtPSkgdG8gcmVsYXRpdmUgbnVtYmVycy4gIzczNDUKCQkJaWYgKCB0eXBlID09PSAic3RyaW5nIiAmJiAocmV0ID0gcnJlbE51bS5leGVjKCB2YWx1ZSApKSApIHsKCQkJCXZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTsKCQkJCS8vIEZpeGVzIGJ1ZyAjOTIzNwoJCQkJdHlwZSA9ICJudW1iZXIiOwoJCQl9CgoJCQkvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTYKCQkJaWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHsKCQkJCXJldHVybjsKCQkJfQoKCQkJLy8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpCgkJCWlmICggdHlwZSA9PT0gIm51bWJlciIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7CgkJCQl2YWx1ZSArPSAicHgiOwoJCQl9CgoJCQkvLyBGaXhlcyAjODkwOCwgaXQgY2FuIGJlIGRvbmUgbW9yZSBjb3JyZWN0bHkgYnkgc3BlY2lmaW5nIHNldHRlcnMgaW4gY3NzSG9va3MsCgkJCS8vIGJ1dCBpdCB3b3VsZCBtZWFuIHRvIGRlZmluZSBlaWdodCAoZm9yIGV2ZXJ5IHByb2JsZW1hdGljIHByb3BlcnR5KSBpZGVudGljYWwgZnVuY3Rpb25zCgkJCWlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSAiIiAmJiBuYW1lLmluZGV4T2YoImJhY2tncm91bmQiKSA9PT0gMCApIHsKCQkJCXN0eWxlWyBuYW1lIF0gPSAiaW5oZXJpdCI7CgkJCX0KCgkJCS8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZQoJCQlpZiAoICFob29rcyB8fCAhKCJzZXQiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkgewoKCQkJCS8vIFN1cHBvcnQ6IElFCgkJCQkvLyBTd2FsbG93IGVycm9ycyBmcm9tICdpbnZhbGlkJyBDU1MgdmFsdWVzICgjNTUwOSkKCQkJCXRyeSB7CgkJCQkJc3R5bGVbIG5hbWUgXSA9IHZhbHVlOwoJCQkJfSBjYXRjaChlKSB7fQoJCQl9CgoJCX0gZWxzZSB7CgkJCS8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZQoJCQlpZiAoIGhvb2tzICYmICJnZXQiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkgewoJCQkJcmV0dXJuIHJldDsKCQkJfQoKCQkJLy8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3QKCQkJcmV0dXJuIHN0eWxlWyBuYW1lIF07CgkJfQoJfSwKCgljc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkgewoJCXZhciBudW0sIHZhbCwgaG9va3MsCgkJCW9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApOwoKCQkvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUKCQluYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTsKCgkJLy8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbgoJCS8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb24KCQlob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTsKCgkJLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmUKCQlpZiAoIGhvb2tzICYmICJnZXQiIGluIGhvb2tzICkgewoJCQl2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7CgkJfQoKCQkvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdAoJCWlmICggdmFsID09PSB1bmRlZmluZWQgKSB7CgkJCXZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7CgkJfQoKCQkvL2NvbnZlcnQgIm5vcm1hbCIgdG8gY29tcHV0ZWQgdmFsdWUKCQlpZiAoIHZhbCA9PT0gIm5vcm1hbCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7CgkJCXZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdOwoJCX0KCgkJLy8gUmV0dXJuLCBjb252ZXJ0aW5nIHRvIG51bWJlciBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpYwoJCWlmICggZXh0cmEgPT09ICIiIHx8IGV4dHJhICkgewoJCQludW0gPSBwYXJzZUZsb2F0KCB2YWwgKTsKCQkJcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7CgkJfQoJCXJldHVybiB2YWw7Cgl9Cn0pOwoKalF1ZXJ5LmVhY2goWyAiaGVpZ2h0IiwgIndpZHRoIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHsKCWpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0gewoJCWdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHsKCQkJaWYgKCBjb21wdXRlZCApIHsKCQkJCS8vIGNlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbQoJCQkJLy8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXMKCQkJCXJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgImRpc3BsYXkiICkgKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID8KCQkJCQlqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7CgkJCQkJCXJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApOwoJCQkJCX0pIDoKCQkJCQlnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApOwoJCQl9CgkJfSwKCgkJc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkgewoJCQl2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7CgkJCXJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID8KCQkJCWF1Z21lbnRXaWR0aE9ySGVpZ2h0KAoJCQkJCWVsZW0sCgkJCQkJbmFtZSwKCQkJCQlleHRyYSwKCQkJCQlzdXBwb3J0LmJveFNpemluZyAmJiBqUXVlcnkuY3NzKCBlbGVtLCAiYm94U2l6aW5nIiwgZmFsc2UsIHN0eWxlcyApID09PSAiYm9yZGVyLWJveCIsCgkJCQkJc3R5bGVzCgkJCQkpIDogMAoJCQkpOwoJCX0KCX07Cn0pOwoKaWYgKCAhc3VwcG9ydC5vcGFjaXR5ICkgewoJalF1ZXJ5LmNzc0hvb2tzLm9wYWNpdHkgPSB7CgkJZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7CgkJCS8vIElFIHVzZXMgZmlsdGVycyBmb3Igb3BhY2l0eQoJCQlyZXR1cm4gcm9wYWNpdHkudGVzdCggKGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID8gZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDogZWxlbS5zdHlsZS5maWx0ZXIpIHx8ICIiICkgPwoJCQkJKCAwLjAxICogcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgKSArICIiIDoKCQkJCWNvbXB1dGVkID8gIjEiIDogIiI7CgkJfSwKCgkJc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7CgkJCXZhciBzdHlsZSA9IGVsZW0uc3R5bGUsCgkJCQljdXJyZW50U3R5bGUgPSBlbGVtLmN1cnJlbnRTdHlsZSwKCQkJCW9wYWNpdHkgPSBqUXVlcnkuaXNOdW1lcmljKCB2YWx1ZSApID8gImFscGhhKG9wYWNpdHk9IiArIHZhbHVlICogMTAwICsgIikiIDogIiIsCgkJCQlmaWx0ZXIgPSBjdXJyZW50U3R5bGUgJiYgY3VycmVudFN0eWxlLmZpbHRlciB8fCBzdHlsZS5maWx0ZXIgfHwgIiI7CgoJCQkvLyBJRSBoYXMgdHJvdWJsZSB3aXRoIG9wYWNpdHkgaWYgaXQgZG9lcyBub3QgaGF2ZSBsYXlvdXQKCQkJLy8gRm9yY2UgaXQgYnkgc2V0dGluZyB0aGUgem9vbSBsZXZlbAoJCQlzdHlsZS56b29tID0gMTsKCgkJCS8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtIGF0dGVtcHQgdG8gcmVtb3ZlIGZpbHRlciBhdHRyaWJ1dGUgIzY2NTIKCQkJLy8gaWYgdmFsdWUgPT09ICIiLCB0aGVuIHJlbW92ZSBpbmxpbmUgb3BhY2l0eSAjMTI2ODUKCQkJaWYgKCAoIHZhbHVlID49IDEgfHwgdmFsdWUgPT09ICIiICkgJiYKCQkJCQlqUXVlcnkudHJpbSggZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgIiIgKSApID09PSAiIiAmJgoJCQkJCXN0eWxlLnJlbW92ZUF0dHJpYnV0ZSApIHsKCgkJCQkvLyBTZXR0aW5nIHN0eWxlLmZpbHRlciB0byBudWxsLCAiIiAmICIgIiBzdGlsbCBsZWF2ZSAiZmlsdGVyOiIgaW4gdGhlIGNzc1RleHQKCQkJCS8vIGlmICJmaWx0ZXI6IiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXMKCQkJCS8vIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSBpcyBJRSBPbmx5LCBidXQgc28gYXBwYXJlbnRseSBpcyB0aGlzIGNvZGUgcGF0aC4uLgoJCQkJc3R5bGUucmVtb3ZlQXR0cmlidXRlKCAiZmlsdGVyIiApOwoKCQkJCS8vIGlmIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGUgb3IgdW5zZXQgaW5saW5lIG9wYWNpdHksIHdlIGFyZSBkb25lCgkJCQlpZiAoIHZhbHVlID09PSAiIiB8fCBjdXJyZW50U3R5bGUgJiYgIWN1cnJlbnRTdHlsZS5maWx0ZXIgKSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoJCQl9CgoJCQkvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlcwoJCQlzdHlsZS5maWx0ZXIgPSByYWxwaGEudGVzdCggZmlsdGVyICkgPwoJCQkJZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDoKCQkJCWZpbHRlciArICIgIiArIG9wYWNpdHk7CgkJfQoJfTsKfQoKalF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsCglmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7CgkJaWYgKCBjb21wdXRlZCApIHsKCQkJLy8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0CgkJCS8vIFdvcmsgYXJvdW5kIGJ5IHRlbXBvcmFyaWx5IHNldHRpbmcgZWxlbWVudCBkaXNwbGF5IHRvIGlubGluZS1ibG9jawoJCQlyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgImRpc3BsYXkiOiAiaW5saW5lLWJsb2NrIiB9LAoJCQkJY3VyQ1NTLCBbIGVsZW0sICJtYXJnaW5SaWdodCIgXSApOwoJCX0KCX0KKTsKCi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXMKalF1ZXJ5LmVhY2goewoJbWFyZ2luOiAiIiwKCXBhZGRpbmc6ICIiLAoJYm9yZGVyOiAiV2lkdGgiCn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHsKCWpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7CgkJZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7CgkJCXZhciBpID0gMCwKCQkJCWV4cGFuZGVkID0ge30sCgoJCQkJLy8gYXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nCgkJCQlwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIgPyB2YWx1ZS5zcGxpdCgiICIpIDogWyB2YWx1ZSBdOwoKCQkJZm9yICggOyBpIDwgNDsgaSsrICkgewoJCQkJZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPQoJCQkJCXBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTsKCQkJfQoKCQkJcmV0dXJuIGV4cGFuZGVkOwoJCX0KCX07CgoJaWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHsKCQlqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyOwoJfQp9KTsKCmpRdWVyeS5mbi5leHRlbmQoewoJY3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7CgkJcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkgewoJCQl2YXIgc3R5bGVzLCBsZW4sCgkJCQltYXAgPSB7fSwKCQkJCWkgPSAwOwoKCQkJaWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkgewoJCQkJc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7CgkJCQlsZW4gPSBuYW1lLmxlbmd0aDsKCgkJCQlmb3IgKCA7IGkgPCBsZW47IGkrKyApIHsKCQkJCQltYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7CgkJCQl9CgoJCQkJcmV0dXJuIG1hcDsKCQkJfQoKCQkJcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPwoJCQkJalF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDoKCQkJCWpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTsKCQl9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTsKCX0sCglzaG93OiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTsKCX0sCgloaWRlOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTsKCX0sCgl0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHsKCQlpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gImJvb2xlYW4iICkgewoJCQlyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpOwoJCX0KCgkJcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsKCQkJaWYgKCBpc0hpZGRlbiggdGhpcyApICkgewoJCQkJalF1ZXJ5KCB0aGlzICkuc2hvdygpOwoJCQl9IGVsc2UgewoJCQkJalF1ZXJ5KCB0aGlzICkuaGlkZSgpOwoJCQl9CgkJfSk7Cgl9Cn0pOwoKCmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHsKCXJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7Cn0KalF1ZXJ5LlR3ZWVuID0gVHdlZW47CgpUd2Vlbi5wcm90b3R5cGUgPSB7Cgljb25zdHJ1Y3RvcjogVHdlZW4sCglpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7CgkJdGhpcy5lbGVtID0gZWxlbTsKCQl0aGlzLnByb3AgPSBwcm9wOwoJCXRoaXMuZWFzaW5nID0gZWFzaW5nIHx8ICJzd2luZyI7CgkJdGhpcy5vcHRpb25zID0gb3B0aW9uczsKCQl0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpOwoJCXRoaXMuZW5kID0gZW5kOwoJCXRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyAiIiA6ICJweCIgKTsKCX0sCgljdXI6IGZ1bmN0aW9uKCkgewoJCXZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07CgoJCXJldHVybiBob29rcyAmJiBob29rcy5nZXQgPwoJCQlob29rcy5nZXQoIHRoaXMgKSA6CgkJCVR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTsKCX0sCglydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkgewoJCXZhciBlYXNlZCwKCQkJaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdOwoKCQlpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHsKCQkJdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oCgkJCQlwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24KCQkJKTsKCQl9IGVsc2UgewoJCQl0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDsKCQl9CgkJdGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0OwoKCQlpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkgewoJCQl0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7CgkJfQoKCQlpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHsKCQkJaG9va3Muc2V0KCB0aGlzICk7CgkJfSBlbHNlIHsKCQkJVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApOwoJCX0KCQlyZXR1cm4gdGhpczsKCX0KfTsKClR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTsKClR3ZWVuLnByb3BIb29rcyA9IHsKCV9kZWZhdWx0OiB7CgkJZ2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7CgkJCXZhciByZXN1bHQ7CgoJCQlpZiAoIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmCgkJCQkoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkgewoJCQkJcmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTsKCQkJfQoKCQkJLy8gcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5CgkJCS8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMKCQkJLy8gc28sIHNpbXBsZSB2YWx1ZXMgc3VjaCBhcyAiMTBweCIgYXJlIHBhcnNlZCB0byBGbG9hdC4KCQkJLy8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyAicm90YXRlKDFyYWQpIiBhcmUgcmV0dXJuZWQgYXMgaXMuCgkJCXJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsICIiICk7CgkJCS8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgImF1dG8iIGFyZSBjb252ZXJ0ZWQgdG8gMC4KCQkJcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSAiYXV0byIgPyAwIDogcmVzdWx0OwoJCX0sCgkJc2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7CgkJCS8vIHVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0IC0gdXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlIC0gdXNlIC5zdHlsZSBpZiBpdHMKCQkJLy8gYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUKCQkJaWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkgewoJCQkJalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTsKCQkJfSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkgewoJCQkJalF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7CgkJCX0gZWxzZSB7CgkJCQl0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7CgkJCX0KCQl9Cgl9Cn07CgovLyBTdXBwb3J0OiBJRSA8PTkKLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzCgpUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7CglzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHsKCQlpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkgewoJCQl0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7CgkJfQoJfQp9OwoKalF1ZXJ5LmVhc2luZyA9IHsKCWxpbmVhcjogZnVuY3Rpb24oIHAgKSB7CgkJcmV0dXJuIHA7Cgl9LAoJc3dpbmc6IGZ1bmN0aW9uKCBwICkgewoJCXJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7Cgl9Cn07CgpqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDsKCi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50CmpRdWVyeS5meC5zdGVwID0ge307CgoKCgp2YXIKCWZ4Tm93LCB0aW1lcklkLAoJcmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sCglyZnhudW0gPSBuZXcgUmVnRXhwKCAiXig/OihbKy1dKT18KSgiICsgcG51bSArICIpKFthLXolXSopJCIsICJpIiApLAoJcnJ1biA9IC9xdWV1ZUhvb2tzJC8sCglhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sCgl0d2VlbmVycyA9IHsKCQkiKiI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkgewoJCQl2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLAoJCQkJdGFyZ2V0ID0gdHdlZW4uY3VyKCksCgkJCQlwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLAoJCQkJdW5pdCA9IHBhcnRzICYmIHBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyAiIiA6ICJweCIgKSwKCgkJCQkvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlcwoJCQkJc3RhcnQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSAicHgiICYmICt0YXJnZXQgKSAmJgoJCQkJCXJmeG51bS5leGVjKCBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCBwcm9wICkgKSwKCQkJCXNjYWxlID0gMSwKCQkJCW1heEl0ZXJhdGlvbnMgPSAyMDsKCgkJCWlmICggc3RhcnQgJiYgc3RhcnRbIDMgXSAhPT0gdW5pdCApIHsKCQkJCS8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3MKCQkJCXVuaXQgPSB1bml0IHx8IHN0YXJ0WyAzIF07CgoJCQkJLy8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvbgoJCQkJcGFydHMgPSBwYXJ0cyB8fCBbXTsKCgkJCQkvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludAoJCQkJc3RhcnQgPSArdGFyZ2V0IHx8IDE7CgoJCQkJZG8gewoJCQkJCS8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqCgkJCQkJLy8gVXNlIGEgc3RyaW5nIGZvciBkb3VibGluZyBmYWN0b3Igc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3cKCQkJCQlzY2FsZSA9IHNjYWxlIHx8ICIuNSI7CgoJCQkJCS8vIEFkanVzdCBhbmQgYXBwbHkKCQkJCQlzdGFydCA9IHN0YXJ0IC8gc2NhbGU7CgkJCQkJalF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCBwcm9wLCBzdGFydCArIHVuaXQgKTsKCgkJCQkvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKQoJCQkJLy8gQW5kIGJyZWFraW5nIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2gKCQkJCX0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApOwoJCQl9CgoJCQkvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllcwoJCQlpZiAoIHBhcnRzICkgewoJCQkJc3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7CgkJCQl0d2Vlbi51bml0ID0gdW5pdDsKCQkJCS8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvbgoJCQkJdHdlZW4uZW5kID0gcGFydHNbIDEgXSA/CgkJCQkJc3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDoKCQkJCQkrcGFydHNbIDIgXTsKCQkJfQoKCQkJcmV0dXJuIHR3ZWVuOwoJCX0gXQoJfTsKCi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHkKZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7CglzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewoJCWZ4Tm93ID0gdW5kZWZpbmVkOwoJfSk7CglyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApOwp9CgovLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvbgpmdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkgewoJdmFyIHdoaWNoLAoJCWF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfSwKCQlpID0gMDsKCgkvLyBpZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsCgkvLyBpZiB3ZSBkb24ndCBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0CglpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDsKCWZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7CgkJd2hpY2ggPSBjc3NFeHBhbmRbIGkgXTsKCQlhdHRyc1sgIm1hcmdpbiIgKyB3aGljaCBdID0gYXR0cnNbICJwYWRkaW5nIiArIHdoaWNoIF0gPSB0eXBlOwoJfQoKCWlmICggaW5jbHVkZVdpZHRoICkgewoJCWF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7Cgl9CgoJcmV0dXJuIGF0dHJzOwp9CgpmdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHsKCXZhciB0d2VlbiwKCQljb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgIioiIF0gKSwKCQlpbmRleCA9IDAsCgkJbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7Cglmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkgewoJCWlmICggKHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkpICkgewoKCQkJLy8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHkKCQkJcmV0dXJuIHR3ZWVuOwoJCX0KCX0KfQoKZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7CgkvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovCgl2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksCgkJYW5pbSA9IHRoaXMsCgkJb3JpZyA9IHt9LAoJCXN0eWxlID0gZWxlbS5zdHlsZSwKCQloaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksCgkJZGF0YVNob3cgPSBqUXVlcnkuX2RhdGEoIGVsZW0sICJmeHNob3ciICk7CgoJLy8gaGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlcwoJaWYgKCAhb3B0cy5xdWV1ZSApIHsKCQlob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgImZ4IiApOwoJCWlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHsKCQkJaG9va3MudW5xdWV1ZWQgPSAwOwoJCQlvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTsKCQkJaG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkgewoJCQkJaWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7CgkJCQkJb2xkZmlyZSgpOwoJCQkJfQoJCQl9OwoJCX0KCQlob29rcy51bnF1ZXVlZCsrOwoKCQlhbmltLmFsd2F5cyhmdW5jdGlvbigpIHsKCQkJLy8gZG9pbmcgdGhpcyBtYWtlcyBzdXJlIHRoYXQgdGhlIGNvbXBsZXRlIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQKCQkJLy8gYmVmb3JlIHRoaXMgY29tcGxldGVzCgkJCWFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkgewoJCQkJaG9va3MudW5xdWV1ZWQtLTsKCQkJCWlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgImZ4IiApLmxlbmd0aCApIHsKCQkJCQlob29rcy5lbXB0eS5maXJlKCk7CgkJCQl9CgkJCX0pOwoJCX0pOwoJfQoKCS8vIGhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzCglpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCAiaGVpZ2h0IiBpbiBwcm9wcyB8fCAid2lkdGgiIGluIHByb3BzICkgKSB7CgkJLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0CgkJLy8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdAoJCS8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZAoJCS8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlCgkJb3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07CgoJCS8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoCgkJLy8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZAoJCWRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCAiZGlzcGxheSIgKTsKCgkJLy8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgIm5vbmUiCgkJY2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gIm5vbmUiID8KCQkJalF1ZXJ5Ll9kYXRhKCBlbGVtLCAib2xkZGlzcGxheSIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTsKCgkJaWYgKCBjaGVja0Rpc3BsYXkgPT09ICJpbmxpbmUiICYmIGpRdWVyeS5jc3MoIGVsZW0sICJmbG9hdCIgKSA9PT0gIm5vbmUiICkgewoKCQkJLy8gaW5saW5lLWxldmVsIGVsZW1lbnRzIGFjY2VwdCBpbmxpbmUtYmxvY2s7CgkJCS8vIGJsb2NrLWxldmVsIGVsZW1lbnRzIG5lZWQgdG8gYmUgaW5saW5lIHdpdGggbGF5b3V0CgkJCWlmICggIXN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApID09PSAiaW5saW5lIiApIHsKCQkJCXN0eWxlLmRpc3BsYXkgPSAiaW5saW5lLWJsb2NrIjsKCQkJfSBlbHNlIHsKCQkJCXN0eWxlLnpvb20gPSAxOwoJCQl9CgkJfQoJfQoKCWlmICggb3B0cy5vdmVyZmxvdyApIHsKCQlzdHlsZS5vdmVyZmxvdyA9ICJoaWRkZW4iOwoJCWlmICggIXN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcygpICkgewoJCQlhbmltLmFsd2F5cyhmdW5jdGlvbigpIHsKCQkJCXN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdOwoJCQkJc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdOwoJCQkJc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdOwoJCQl9KTsKCQl9Cgl9CgoJLy8gc2hvdy9oaWRlIHBhc3MKCWZvciAoIHByb3AgaW4gcHJvcHMgKSB7CgkJdmFsdWUgPSBwcm9wc1sgcHJvcCBdOwoJCWlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHsKCQkJZGVsZXRlIHByb3BzWyBwcm9wIF07CgkJCXRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gInRvZ2dsZSI7CgkJCWlmICggdmFsdWUgPT09ICggaGlkZGVuID8gImhpZGUiIDogInNob3ciICkgKSB7CgoJCQkJLy8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW4KCQkJCWlmICggdmFsdWUgPT09ICJzaG93IiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7CgkJCQkJaGlkZGVuID0gdHJ1ZTsKCQkJCX0gZWxzZSB7CgkJCQkJY29udGludWU7CgkJCQl9CgkJCX0KCQkJb3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTsKCgkJLy8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZQoJCX0gZWxzZSB7CgkJCWRpc3BsYXkgPSB1bmRlZmluZWQ7CgkJfQoJfQoKCWlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7CgkJaWYgKCBkYXRhU2hvdyApIHsKCQkJaWYgKCAiaGlkZGVuIiBpbiBkYXRhU2hvdyApIHsKCQkJCWhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjsKCQkJfQoJCX0gZWxzZSB7CgkJCWRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCAiZnhzaG93Iiwge30gKTsKCQl9CgoJCS8vIHN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gInJldmVyc2UiCgkJaWYgKCB0b2dnbGUgKSB7CgkJCWRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47CgkJfQoJCWlmICggaGlkZGVuICkgewoJCQlqUXVlcnkoIGVsZW0gKS5zaG93KCk7CgkJfSBlbHNlIHsKCQkJYW5pbS5kb25lKGZ1bmN0aW9uKCkgewoJCQkJalF1ZXJ5KCBlbGVtICkuaGlkZSgpOwoJCQl9KTsKCQl9CgkJYW5pbS5kb25lKGZ1bmN0aW9uKCkgewoJCQl2YXIgcHJvcDsKCQkJalF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCAiZnhzaG93IiApOwoJCQlmb3IgKCBwcm9wIGluIG9yaWcgKSB7CgkJCQlqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApOwoJCQl9CgkJfSk7CgkJZm9yICggcHJvcCBpbiBvcmlnICkgewoJCQl0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApOwoKCQkJaWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7CgkJCQlkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7CgkJCQlpZiAoIGhpZGRlbiApIHsKCQkJCQl0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDsKCQkJCQl0d2Vlbi5zdGFydCA9IHByb3AgPT09ICJ3aWR0aCIgfHwgcHJvcCA9PT0gImhlaWdodCIgPyAxIDogMDsKCQkJCX0KCQkJfQoJCX0KCgkvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWUKCX0gZWxzZSBpZiAoIChkaXNwbGF5ID09PSAibm9uZSIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSkgPT09ICJpbmxpbmUiICkgewoJCXN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5OwoJfQp9CgpmdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHsKCXZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7CgoJLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzCglmb3IgKCBpbmRleCBpbiBwcm9wcyApIHsKCQluYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTsKCQllYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07CgkJdmFsdWUgPSBwcm9wc1sgaW5kZXggXTsKCQlpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkgewoJCQllYXNpbmcgPSB2YWx1ZVsgMSBdOwoJCQl2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTsKCQl9CgoJCWlmICggaW5kZXggIT09IG5hbWUgKSB7CgkJCXByb3BzWyBuYW1lIF0gPSB2YWx1ZTsKCQkJZGVsZXRlIHByb3BzWyBpbmRleCBdOwoJCX0KCgkJaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTsKCQlpZiAoIGhvb2tzICYmICJleHBhbmQiIGluIGhvb2tzICkgewoJCQl2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTsKCQkJZGVsZXRlIHByb3BzWyBuYW1lIF07CgoJCQkvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuCgkJCS8vIGFsc28gLSByZXVzaW5nICdpbmRleCcgZnJvbSBhYm92ZSBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgIm5hbWUiCgkJCWZvciAoIGluZGV4IGluIHZhbHVlICkgewoJCQkJaWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkgewoJCQkJCXByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07CgkJCQkJc3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZzsKCQkJCX0KCQkJfQoJCX0gZWxzZSB7CgkJCXNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZzsKCQl9Cgl9Cn0KCmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHsKCXZhciByZXN1bHQsCgkJc3RvcHBlZCwKCQlpbmRleCA9IDAsCgkJbGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsCgkJZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkgewoJCQkvLyBkb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3IKCQkJZGVsZXRlIHRpY2suZWxlbTsKCQl9KSwKCQl0aWNrID0gZnVuY3Rpb24oKSB7CgkJCWlmICggc3RvcHBlZCApIHsKCQkJCXJldHVybiBmYWxzZTsKCQkJfQoJCQl2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLAoJCQkJcmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLAoJCQkJLy8gYXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIDEgLSAoIDAuNSB8fCAwICkgKCMxMjQ5NykKCQkJCXRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCwKCQkJCXBlcmNlbnQgPSAxIC0gdGVtcCwKCQkJCWluZGV4ID0gMCwKCQkJCWxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoOwoKCQkJZm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7CgkJCQlhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApOwoJCQl9CgoJCQlkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0pOwoKCQkJaWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7CgkJCQlyZXR1cm4gcmVtYWluaW5nOwoJCQl9IGVsc2UgewoJCQkJZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTsKCQkJCXJldHVybiBmYWxzZTsKCQkJfQoJCX0sCgkJYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7CgkJCWVsZW06IGVsZW0sCgkJCXByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLAoJCQlvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSwKCQkJb3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLAoJCQlvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsCgkJCXN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSwKCQkJZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sCgkJCXR3ZWVuczogW10sCgkJCWNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkgewoJCQkJdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLAoJCQkJCQlhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7CgkJCQlhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7CgkJCQlyZXR1cm4gdHdlZW47CgkJCX0sCgkJCXN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkgewoJCQkJdmFyIGluZGV4ID0gMCwKCQkJCQkvLyBpZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnMKCQkJCQkvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnQKCQkJCQlsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwOwoJCQkJaWYgKCBzdG9wcGVkICkgewoJCQkJCXJldHVybiB0aGlzOwoJCQkJfQoJCQkJc3RvcHBlZCA9IHRydWU7CgkJCQlmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHsKCQkJCQlhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApOwoJCQkJfQoKCQkJCS8vIHJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWUKCQkJCS8vIG90aGVyd2lzZSwgcmVqZWN0CgkJCQlpZiAoIGdvdG9FbmQgKSB7CgkJCQkJZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTsKCQkJCX0gZWxzZSB7CgkJCQkJZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApOwoJCQkJfQoJCQkJcmV0dXJuIHRoaXM7CgkJCX0KCQl9KSwKCQlwcm9wcyA9IGFuaW1hdGlvbi5wcm9wczsKCglwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApOwoKCWZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkgewoJCXJlc3VsdCA9IGFuaW1hdGlvblByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTsKCQlpZiAoIHJlc3VsdCApIHsKCQkJcmV0dXJuIHJlc3VsdDsKCQl9Cgl9CgoJalF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTsKCglpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkgewoJCWFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApOwoJfQoKCWpRdWVyeS5meC50aW1lcigKCQlqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7CgkJCWVsZW06IGVsZW0sCgkJCWFuaW06IGFuaW1hdGlvbiwKCQkJcXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlCgkJfSkKCSk7CgoJLy8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnMKCXJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzICkKCQkuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKQoJCS5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsICkKCQkuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTsKfQoKalF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwgewoJdHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHsKCQlpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkgewoJCQljYWxsYmFjayA9IHByb3BzOwoJCQlwcm9wcyA9IFsgIioiIF07CgkJfSBlbHNlIHsKCQkJcHJvcHMgPSBwcm9wcy5zcGxpdCgiICIpOwoJCX0KCgkJdmFyIHByb3AsCgkJCWluZGV4ID0gMCwKCQkJbGVuZ3RoID0gcHJvcHMubGVuZ3RoOwoKCQlmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHsKCQkJcHJvcCA9IHByb3BzWyBpbmRleCBdOwoJCQl0d2VlbmVyc1sgcHJvcCBdID0gdHdlZW5lcnNbIHByb3AgXSB8fCBbXTsKCQkJdHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApOwoJCX0KCX0sCgoJcHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7CgkJaWYgKCBwcmVwZW5kICkgewoJCQlhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7CgkJfSBlbHNlIHsKCQkJYW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApOwoJCX0KCX0KfSk7CgpqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7Cgl2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSAib2JqZWN0IiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDogewoJCWNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8CgkJCWpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLAoJCWR1cmF0aW9uOiBzcGVlZCwKCQllYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmcKCX07CgoJb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSAibnVtYmVyIiA/IG9wdC5kdXJhdGlvbiA6CgkJb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7CgoJLy8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gImZ4IgoJaWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7CgkJb3B0LnF1ZXVlID0gImZ4IjsKCX0KCgkvLyBRdWV1ZWluZwoJb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTsKCglvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHsKCQlpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7CgkJCW9wdC5vbGQuY2FsbCggdGhpcyApOwoJCX0KCgkJaWYgKCBvcHQucXVldWUgKSB7CgkJCWpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTsKCQl9Cgl9OwoKCXJldHVybiBvcHQ7Cn07CgpqUXVlcnkuZm4uZXh0ZW5kKHsKCWZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHsKCgkJLy8gc2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwCgkJcmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggIm9wYWNpdHkiLCAwICkuc2hvdygpCgoJCQkvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWQKCQkJLmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApOwoJfSwKCWFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHsKCQl2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLAoJCQlvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksCgkJCWRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7CgkJCQkvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdAoJCQkJdmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApOwoKCQkJCS8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseQoJCQkJaWYgKCBlbXB0eSB8fCBqUXVlcnkuX2RhdGEoIHRoaXMsICJmaW5pc2giICkgKSB7CgkJCQkJYW5pbS5zdG9wKCB0cnVlICk7CgkJCQl9CgkJCX07CgkJCWRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uOwoKCQlyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/CgkJCXRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6CgkJCXRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTsKCX0sCglzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHsKCQl2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkgewoJCQl2YXIgc3RvcCA9IGhvb2tzLnN0b3A7CgkJCWRlbGV0ZSBob29rcy5zdG9wOwoJCQlzdG9wKCBnb3RvRW5kICk7CgkJfTsKCgkJaWYgKCB0eXBlb2YgdHlwZSAhPT0gInN0cmluZyIgKSB7CgkJCWdvdG9FbmQgPSBjbGVhclF1ZXVlOwoJCQljbGVhclF1ZXVlID0gdHlwZTsKCQkJdHlwZSA9IHVuZGVmaW5lZDsKCQl9CgkJaWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkgewoJCQl0aGlzLnF1ZXVlKCB0eXBlIHx8ICJmeCIsIFtdICk7CgkJfQoKCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgewoJCQl2YXIgZGVxdWV1ZSA9IHRydWUsCgkJCQlpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgInF1ZXVlSG9va3MiLAoJCQkJdGltZXJzID0galF1ZXJ5LnRpbWVycywKCQkJCWRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKTsKCgkJCWlmICggaW5kZXggKSB7CgkJCQlpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkgewoJCQkJCXN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApOwoJCQkJfQoJCQl9IGVsc2UgewoJCQkJZm9yICggaW5kZXggaW4gZGF0YSApIHsKCQkJCQlpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHsKCQkJCQkJc3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7CgkJCQkJfQoJCQkJfQoJCQl9CgoJCQlmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkgewoJCQkJaWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7CgkJCQkJdGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApOwoJCQkJCWRlcXVldWUgPSBmYWxzZTsKCQkJCQl0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApOwoJCQkJfQoJCQl9CgoJCQkvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkCgkJCS8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlCgkJCS8vIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kCgkJCWlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHsKCQkJCWpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7CgkJCX0KCQl9KTsKCX0sCglmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkgewoJCWlmICggdHlwZSAhPT0gZmFsc2UgKSB7CgkJCXR5cGUgPSB0eXBlIHx8ICJmeCI7CgkJfQoJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7CgkJCXZhciBpbmRleCwKCQkJCWRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKSwKCQkJCXF1ZXVlID0gZGF0YVsgdHlwZSArICJxdWV1ZSIgXSwKCQkJCWhvb2tzID0gZGF0YVsgdHlwZSArICJxdWV1ZUhvb2tzIiBdLAoJCQkJdGltZXJzID0galF1ZXJ5LnRpbWVycywKCQkJCWxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDsKCgkJCS8vIGVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGEKCQkJZGF0YS5maW5pc2ggPSB0cnVlOwoKCQkJLy8gZW1wdHkgdGhlIHF1ZXVlIGZpcnN0CgkJCWpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTsKCgkJCWlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHsKCQkJCWhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApOwoJCQl9CgoJCQkvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbQoJCQlmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkgewoJCQkJaWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7CgkJCQkJdGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApOwoJCQkJCXRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7CgkJCQl9CgkJCX0KCgkJCS8vIGxvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtCgkJCWZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7CgkJCQlpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHsKCQkJCQlxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApOwoJCQkJfQoJCQl9CgoJCQkvLyB0dXJuIG9mZiBmaW5pc2hpbmcgZmxhZwoJCQlkZWxldGUgZGF0YS5maW5pc2g7CgkJfSk7Cgl9Cn0pOwoKalF1ZXJ5LmVhY2goWyAidG9nZ2xlIiwgInNob3ciLCAiaGlkZSIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7Cgl2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTsKCWpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkgewoJCXJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gImJvb2xlYW4iID8KCQkJY3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDoKCQkJdGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApOwoJfTsKfSk7CgovLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zCmpRdWVyeS5lYWNoKHsKCXNsaWRlRG93bjogZ2VuRngoInNob3ciKSwKCXNsaWRlVXA6IGdlbkZ4KCJoaWRlIiksCglzbGlkZVRvZ2dsZTogZ2VuRngoInRvZ2dsZSIpLAoJZmFkZUluOiB7IG9wYWNpdHk6ICJzaG93IiB9LAoJZmFkZU91dDogeyBvcGFjaXR5OiAiaGlkZSIgfSwKCWZhZGVUb2dnbGU6IHsgb3BhY2l0eTogInRvZ2dsZSIgfQp9LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7CglqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHsKCQlyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTsKCX07Cn0pOwoKalF1ZXJ5LnRpbWVycyA9IFtdOwpqUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkgewoJdmFyIHRpbWVyLAoJCXRpbWVycyA9IGpRdWVyeS50aW1lcnMsCgkJaSA9IDA7CgoJZnhOb3cgPSBqUXVlcnkubm93KCk7CgoJZm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkgewoJCXRpbWVyID0gdGltZXJzWyBpIF07CgkJLy8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkCgkJaWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7CgkJCXRpbWVycy5zcGxpY2UoIGktLSwgMSApOwoJCX0KCX0KCglpZiAoICF0aW1lcnMubGVuZ3RoICkgewoJCWpRdWVyeS5meC5zdG9wKCk7Cgl9CglmeE5vdyA9IHVuZGVmaW5lZDsKfTsKCmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHsKCWpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTsKCWlmICggdGltZXIoKSApIHsKCQlqUXVlcnkuZnguc3RhcnQoKTsKCX0gZWxzZSB7CgkJalF1ZXJ5LnRpbWVycy5wb3AoKTsKCX0KfTsKCmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzOwoKalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7CglpZiAoICF0aW1lcklkICkgewoJCXRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApOwoJfQp9OwoKalF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHsKCWNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTsKCXRpbWVySWQgPSBudWxsOwp9OwoKalF1ZXJ5LmZ4LnNwZWVkcyA9IHsKCXNsb3c6IDYwMCwKCWZhc3Q6IDIwMCwKCS8vIERlZmF1bHQgc3BlZWQKCV9kZWZhdWx0OiA0MDAKfTsKCgovLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uCi8vIGh0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS8KalF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7Cgl0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lOwoJdHlwZSA9IHR5cGUgfHwgImZ4IjsKCglyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkgewoJCXZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApOwoJCWhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHsKCQkJY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7CgkJfTsKCX0pOwp9OwoKCihmdW5jdGlvbigpIHsKCS8vIE1pbmlmaWVkOiB2YXIgYSxiLGMsZCxlCgl2YXIgaW5wdXQsIGRpdiwgc2VsZWN0LCBhLCBvcHQ7CgoJLy8gU2V0dXAKCWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICJkaXYiICk7CglkaXYuc2V0QXR0cmlidXRlKCAiY2xhc3NOYW1lIiwgInQiICk7CglkaXYuaW5uZXJIVE1MID0gIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPiI7CglhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJhIilbIDAgXTsKCgkvLyBGaXJzdCBiYXRjaCBvZiB0ZXN0cy4KCXNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpOwoJb3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKSApOwoJaW5wdXQgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImlucHV0IilbIDAgXTsKCglhLnN0eWxlLmNzc1RleHQgPSAidG9wOjFweCI7CgoJLy8gVGVzdCBzZXRBdHRyaWJ1dGUgb24gY2FtZWxDYXNlIGNsYXNzLiBJZiBpdCB3b3Jrcywgd2UgbmVlZCBhdHRyRml4ZXMgd2hlbiBkb2luZyBnZXQvc2V0QXR0cmlidXRlIChpZTYvNykKCXN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlID0gZGl2LmNsYXNzTmFtZSAhPT0gInQiOwoKCS8vIEdldCB0aGUgc3R5bGUgaW5mb3JtYXRpb24gZnJvbSBnZXRBdHRyaWJ1dGUKCS8vIChJRSB1c2VzIC5jc3NUZXh0IGluc3RlYWQpCglzdXBwb3J0LnN0eWxlID0gL3RvcC8udGVzdCggYS5nZXRBdHRyaWJ1dGUoInN0eWxlIikgKTsKCgkvLyBNYWtlIHN1cmUgdGhhdCBVUkxzIGFyZW4ndCBtYW5pcHVsYXRlZAoJLy8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdCkKCXN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgPSBhLmdldEF0dHJpYnV0ZSgiaHJlZiIpID09PSAiL2EiOwoKCS8vIENoZWNrIHRoZSBkZWZhdWx0IGNoZWNrYm94L3JhZGlvIHZhbHVlICgiIiBvbiBXZWJLaXQ7ICJvbiIgZWxzZXdoZXJlKQoJc3VwcG9ydC5jaGVja09uID0gISFpbnB1dC52YWx1ZTsKCgkvLyBNYWtlIHN1cmUgdGhhdCBhIHNlbGVjdGVkLWJ5LWRlZmF1bHQgb3B0aW9uIGhhcyBhIHdvcmtpbmcgc2VsZWN0ZWQgcHJvcGVydHkuCgkvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIGZhbHNlIGluc3RlYWQgb2YgdHJ1ZSwgSUUgdG9vLCBpZiBpdCdzIGluIGFuIG9wdGdyb3VwKQoJc3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDsKCgkvLyBUZXN0cyBmb3IgZW5jdHlwZSBzdXBwb3J0IG9uIGEgZm9ybSAoIzY3NDMpCglzdXBwb3J0LmVuY3R5cGUgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImZvcm0iKS5lbmN0eXBlOwoKCS8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWQKCS8vIChXZWJLaXQgbWFya3MgdGhlbSBhcyBkaXNhYmxlZCkKCXNlbGVjdC5kaXNhYmxlZCA9IHRydWU7CglzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDsKCgkvLyBTdXBwb3J0OiBJRTggb25seQoJLy8gQ2hlY2sgaWYgd2UgY2FuIHRydXN0IGdldEF0dHJpYnV0ZSgidmFsdWUiKQoJaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAiaW5wdXQiICk7CglpbnB1dC5zZXRBdHRyaWJ1dGUoICJ2YWx1ZSIsICIiICk7CglzdXBwb3J0LmlucHV0ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCAidmFsdWUiICkgPT09ICIiOwoKCS8vIENoZWNrIGlmIGFuIGlucHV0IG1haW50YWlucyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpbwoJaW5wdXQudmFsdWUgPSAidCI7CglpbnB1dC5zZXRBdHRyaWJ1dGUoICJ0eXBlIiwgInJhZGlvIiApOwoJc3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09ICJ0IjsKfSkoKTsKCgp2YXIgcnJldHVybiA9IC9cci9nOwoKalF1ZXJ5LmZuLmV4dGVuZCh7Cgl2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHsKCQl2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbiwKCQkJZWxlbSA9IHRoaXNbMF07CgoJCWlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7CgkJCWlmICggZWxlbSApIHsKCQkJCWhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdOwoKCQkJCWlmICggaG9va3MgJiYgImdldCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgInZhbHVlIiApKSAhPT0gdW5kZWZpbmVkICkgewoJCQkJCXJldHVybiByZXQ7CgkJCQl9CgoJCQkJcmV0ID0gZWxlbS52YWx1ZTsKCgkJCQlyZXR1cm4gdHlwZW9mIHJldCA9PT0gInN0cmluZyIgPwoJCQkJCS8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXMKCQkJCQlyZXQucmVwbGFjZShycmV0dXJuLCAiIikgOgoJCQkJCS8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlcgoJCQkJCXJldCA9PSBudWxsID8gIiIgOiByZXQ7CgkJCX0KCgkJCXJldHVybjsKCQl9CgoJCWlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTsKCgkJcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHsKCQkJdmFyIHZhbDsKCgkJCWlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHsKCQkJCXJldHVybjsKCQkJfQoKCQkJaWYgKCBpc0Z1bmN0aW9uICkgewoJCQkJdmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTsKCQkJfSBlbHNlIHsKCQkJCXZhbCA9IHZhbHVlOwoJCQl9CgoJCQkvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyAiIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZwoJCQlpZiAoIHZhbCA9PSBudWxsICkgewoJCQkJdmFsID0gIiI7CgkJCX0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09ICJudW1iZXIiICkgewoJCQkJdmFsICs9ICIiOwoJCQl9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7CgkJCQl2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHsKCQkJCQlyZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICIiIDogdmFsdWUgKyAiIjsKCQkJCX0pOwoJCQl9CgoJCQlob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTsKCgkJCS8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nCgkJCWlmICggIWhvb2tzIHx8ICEoInNldCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCAidmFsdWUiICkgPT09IHVuZGVmaW5lZCApIHsKCQkJCXRoaXMudmFsdWUgPSB2YWw7CgkJCX0KCQl9KTsKCX0KfSk7CgpqUXVlcnkuZXh0ZW5kKHsKCXZhbEhvb2tzOiB7CgkJb3B0aW9uOiB7CgkJCWdldDogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCQl2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgInZhbHVlIiApOwoJCQkJcmV0dXJuIHZhbCAhPSBudWxsID8KCQkJCQl2YWwgOgoJCQkJCS8vIFN1cHBvcnQ6IElFMTAtMTErCgkJCQkJLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KQoJCQkJCWpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICk7CgkJCX0KCQl9LAoJCXNlbGVjdDogewoJCQlnZXQ6IGZ1bmN0aW9uKCBlbGVtICkgewoJCQkJdmFyIHZhbHVlLCBvcHRpb24sCgkJCQkJb3B0aW9ucyA9IGVsZW0ub3B0aW9ucywKCQkJCQlpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCwKCQkJCQlvbmUgPSBlbGVtLnR5cGUgPT09ICJzZWxlY3Qtb25lIiB8fCBpbmRleCA8IDAsCgkJCQkJdmFsdWVzID0gb25lID8gbnVsbCA6IFtdLAoJCQkJCW1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLAoJCQkJCWkgPSBpbmRleCA8IDAgPwoJCQkJCQltYXggOgoJCQkJCQlvbmUgPyBpbmRleCA6IDA7CgoJCQkJLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9ucwoJCQkJZm9yICggOyBpIDwgbWF4OyBpKysgKSB7CgkJCQkJb3B0aW9uID0gb3B0aW9uc1sgaSBdOwoKCQkJCQkvLyBvbGRJRSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSkKCQkJCQlpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiYKCQkJCQkJCS8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXAKCQkJCQkJCSggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCJkaXNhYmxlZCIpID09PSBudWxsICkgJiYKCQkJCQkJCSggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCAib3B0Z3JvdXAiICkgKSApIHsKCgkJCQkJCS8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb24KCQkJCQkJdmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpOwoKCQkJCQkJLy8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHMKCQkJCQkJaWYgKCBvbmUgKSB7CgkJCQkJCQlyZXR1cm4gdmFsdWU7CgkJCQkJCX0KCgkJCQkJCS8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5CgkJCQkJCXZhbHVlcy5wdXNoKCB2YWx1ZSApOwoJCQkJCX0KCQkJCX0KCgkJCQlyZXR1cm4gdmFsdWVzOwoJCQl9LAoKCQkJc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7CgkJCQl2YXIgb3B0aW9uU2V0LCBvcHRpb24sCgkJCQkJb3B0aW9ucyA9IGVsZW0ub3B0aW9ucywKCQkJCQl2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLAoJCQkJCWkgPSBvcHRpb25zLmxlbmd0aDsKCgkJCQl3aGlsZSAoIGktLSApIHsKCQkJCQlvcHRpb24gPSBvcHRpb25zWyBpIF07CgoJCQkJCWlmICggalF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPj0gMCApIHsKCgkJCQkJCS8vIFN1cHBvcnQ6IElFNgoJCQkJCQkvLyBXaGVuIG5ldyBvcHRpb24gZWxlbWVudCBpcyBhZGRlZCB0byBzZWxlY3QgYm94IHdlIG5lZWQgdG8KCQkJCQkJLy8gZm9yY2UgcmVmbG93IG9mIG5ld2x5IGFkZGVkIG5vZGUgaW4gb3JkZXIgdG8gd29ya2Fyb3VuZCBkZWxheQoJCQkJCQkvLyBvZiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzCgkJCQkJCXRyeSB7CgkJCQkJCQlvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb25TZXQgPSB0cnVlOwoKCQkJCQkJfSBjYXRjaCAoIF8gKSB7CgoJCQkJCQkJLy8gV2lsbCBiZSBleGVjdXRlZCBvbmx5IGluIElFNgoJCQkJCQkJb3B0aW9uLnNjcm9sbEhlaWdodDsKCQkJCQkJfQoKCQkJCQl9IGVsc2UgewoJCQkJCQlvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTsKCQkJCQl9CgkJCQl9CgoJCQkJLy8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXQKCQkJCWlmICggIW9wdGlvblNldCApIHsKCQkJCQllbGVtLnNlbGVjdGVkSW5kZXggPSAtMTsKCQkJCX0KCgkJCQlyZXR1cm4gb3B0aW9uczsKCQkJfQoJCX0KCX0KfSk7CgovLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlcgpqUXVlcnkuZWFjaChbICJyYWRpbyIsICJjaGVja2JveCIgXSwgZnVuY3Rpb24oKSB7CglqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHsKCQlzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHsKCQkJaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHsKCQkJCXJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApOwoJCQl9CgkJfQoJfTsKCWlmICggIXN1cHBvcnQuY2hlY2tPbiApIHsKCQlqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHsKCQkJLy8gU3VwcG9ydDogV2Via2l0CgkJCS8vICIiIGlzIHJldHVybmVkIGluc3RlYWQgb2YgIm9uIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZAoJCQlyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoInZhbHVlIikgPT09IG51bGwgPyAib24iIDogZWxlbS52YWx1ZTsKCQl9OwoJfQp9KTsKCgoKCnZhciBub2RlSG9vaywgYm9vbEhvb2ssCglhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZSwKCXJ1c2VEZWZhdWx0ID0gL14oPzpjaGVja2VkfHNlbGVjdGVkKSQvaSwKCWdldFNldEF0dHJpYnV0ZSA9IHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLAoJZ2V0U2V0SW5wdXQgPSBzdXBwb3J0LmlucHV0OwoKalF1ZXJ5LmZuLmV4dGVuZCh7CglhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7CgkJcmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApOwoJfSwKCglyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHsKCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgewoJCQlqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApOwoJCX0pOwoJfQp9KTsKCmpRdWVyeS5leHRlbmQoewoJYXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkgewoJCXZhciBob29rcywgcmV0LAoJCQluVHlwZSA9IGVsZW0ubm9kZVR5cGU7CgoJCS8vIGRvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXMKCQlpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkgewoJCQlyZXR1cm47CgkJfQoKCQkvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZAoJCWlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBzdHJ1bmRlZmluZWQgKSB7CgkJCXJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTsKCQl9CgoJCS8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2UKCQkvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkCgkJaWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7CgkJCW5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7CgkJCWhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8CgkJCQkoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApOwoJCX0KCgkJaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgewoKCQkJaWYgKCB2YWx1ZSA9PT0gbnVsbCApIHsKCQkJCWpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7CgoJCQl9IGVsc2UgaWYgKCBob29rcyAmJiAic2V0IiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkgewoJCQkJcmV0dXJuIHJldDsKCgkJCX0gZWxzZSB7CgkJCQllbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyAiIiApOwoJCQkJcmV0dXJuIHZhbHVlOwoJCQl9CgoJCX0gZWxzZSBpZiAoIGhvb2tzICYmICJnZXQiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7CgkJCXJldHVybiByZXQ7CgoJCX0gZWxzZSB7CgkJCXJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTsKCgkJCS8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkCgkJCXJldHVybiByZXQgPT0gbnVsbCA/CgkJCQl1bmRlZmluZWQgOgoJCQkJcmV0OwoJCX0KCX0sCgoJcmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkgewoJCXZhciBuYW1lLCBwcm9wTmFtZSwKCQkJaSA9IDAsCgkJCWF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTsKCgkJaWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHsKCQkJd2hpbGUgKCAobmFtZSA9IGF0dHJOYW1lc1tpKytdKSApIHsKCQkJCXByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lOwoKCQkJCS8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MCkKCQkJCWlmICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgKSB7CgkJCQkJLy8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2UKCQkJCQlpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkgewoJCQkJCQllbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7CgkJCQkJLy8gU3VwcG9ydDogSUU8OQoJCQkJCS8vIEFsc28gY2xlYXIgZGVmYXVsdENoZWNrZWQvZGVmYXVsdFNlbGVjdGVkIChpZiBhcHByb3ByaWF0ZSkKCQkJCQl9IGVsc2UgewoJCQkJCQllbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCAiZGVmYXVsdC0iICsgbmFtZSApIF0gPQoJCQkJCQkJZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlOwoJCQkJCX0KCgkJCQkvLyBTZWUgIzk2OTkgZm9yIGV4cGxhbmF0aW9uIG9mIHRoaXMgYXBwcm9hY2ggKHNldHRpbmcgZmlyc3QsIHRoZW4gcmVtb3ZhbCkKCQkJCX0gZWxzZSB7CgkJCQkJalF1ZXJ5LmF0dHIoIGVsZW0sIG5hbWUsICIiICk7CgkJCQl9CgoJCQkJZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGdldFNldEF0dHJpYnV0ZSA/IG5hbWUgOiBwcm9wTmFtZSApOwoJCQl9CgkJfQoJfSwKCglhdHRySG9va3M6IHsKCQl0eXBlOiB7CgkJCXNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkgewoJCQkJaWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSAicmFkaW8iICYmIGpRdWVyeS5ub2RlTmFtZShlbGVtLCAiaW5wdXQiKSApIHsKCQkJCQkvLyBTZXR0aW5nIHRoZSB0eXBlIG9uIGEgcmFkaW8gYnV0dG9uIGFmdGVyIHRoZSB2YWx1ZSByZXNldHMgdGhlIHZhbHVlIGluIElFNi05CgkJCQkJLy8gUmVzZXQgdmFsdWUgdG8gZGVmYXVsdCBpbiBjYXNlIHR5cGUgaXMgc2V0IGFmdGVyIHZhbHVlIGR1cmluZyBjcmVhdGlvbgoJCQkJCXZhciB2YWwgPSBlbGVtLnZhbHVlOwoJCQkJCWVsZW0uc2V0QXR0cmlidXRlKCAidHlwZSIsIHZhbHVlICk7CgkJCQkJaWYgKCB2YWwgKSB7CgkJCQkJCWVsZW0udmFsdWUgPSB2YWw7CgkJCQkJfQoJCQkJCXJldHVybiB2YWx1ZTsKCQkJCX0KCQkJfQoJCX0KCX0KfSk7CgovLyBIb29rIGZvciBib29sZWFuIGF0dHJpYnV0ZXMKYm9vbEhvb2sgPSB7CglzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHsKCQlpZiAoIHZhbHVlID09PSBmYWxzZSApIHsKCQkJLy8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZQoJCQlqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApOwoJCX0gZWxzZSBpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkgewoJCQkvLyBJRTw4IG5lZWRzIHRoZSAqcHJvcGVydHkqIG5hbWUKCQkJZWxlbS5zZXRBdHRyaWJ1dGUoICFnZXRTZXRBdHRyaWJ1dGUgJiYgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lLCBuYW1lICk7CgoJCS8vIFVzZSBkZWZhdWx0Q2hlY2tlZCBhbmQgZGVmYXVsdFNlbGVjdGVkIGZvciBvbGRJRQoJCX0gZWxzZSB7CgkJCWVsZW1bIGpRdWVyeS5jYW1lbENhc2UoICJkZWZhdWx0LSIgKyBuYW1lICkgXSA9IGVsZW1bIG5hbWUgXSA9IHRydWU7CgkJfQoKCQlyZXR1cm4gbmFtZTsKCX0KfTsKCi8vIFJldHJpZXZlIGJvb2xlYW5zIHNwZWNpYWxseQpqUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHsKCgl2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7CgoJYXR0ckhhbmRsZVsgbmFtZSBdID0gZ2V0U2V0SW5wdXQgJiYgZ2V0U2V0QXR0cmlidXRlIHx8ICFydXNlRGVmYXVsdC50ZXN0KCBuYW1lICkgPwoJCWZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHsKCQkJdmFyIHJldCwgaGFuZGxlOwoJCQlpZiAoICFpc1hNTCApIHsKCQkJCS8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXIKCQkJCWhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTsKCQkJCWF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDsKCQkJCXJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID8KCQkJCQluYW1lLnRvTG93ZXJDYXNlKCkgOgoJCQkJCW51bGw7CgkJCQlhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7CgkJCX0KCQkJcmV0dXJuIHJldDsKCQl9IDoKCQlmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7CgkJCWlmICggIWlzWE1MICkgewoJCQkJcmV0dXJuIGVsZW1bIGpRdWVyeS5jYW1lbENhc2UoICJkZWZhdWx0LSIgKyBuYW1lICkgXSA/CgkJCQkJbmFtZS50b0xvd2VyQ2FzZSgpIDoKCQkJCQludWxsOwoJCQl9CgkJfTsKfSk7CgovLyBmaXggb2xkSUUgYXR0cm9wZXJ0aWVzCmlmICggIWdldFNldElucHV0IHx8ICFnZXRTZXRBdHRyaWJ1dGUgKSB7CglqUXVlcnkuYXR0ckhvb2tzLnZhbHVlID0gewoJCXNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkgewoJCQlpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgImlucHV0IiApICkgewoJCQkJLy8gRG9lcyBub3QgcmV0dXJuIHNvIHRoYXQgc2V0QXR0cmlidXRlIGlzIGFsc28gdXNlZAoJCQkJZWxlbS5kZWZhdWx0VmFsdWUgPSB2YWx1ZTsKCQkJfSBlbHNlIHsKCQkJCS8vIFVzZSBub2RlSG9vayBpZiBkZWZpbmVkICgjMTk1NCk7IG90aGVyd2lzZSBzZXRBdHRyaWJ1dGUgaXMgZmluZQoJCQkJcmV0dXJuIG5vZGVIb29rICYmIG5vZGVIb29rLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKTsKCQkJfQoJCX0KCX07Cn0KCi8vIElFNi83IGRvIG5vdCBzdXBwb3J0IGdldHRpbmcvc2V0dGluZyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBnZXQvc2V0QXR0cmlidXRlCmlmICggIWdldFNldEF0dHJpYnV0ZSApIHsKCgkvLyBVc2UgdGhpcyBmb3IgYW55IGF0dHJpYnV0ZSBpbiBJRTYvNwoJLy8gVGhpcyBmaXhlcyBhbG1vc3QgZXZlcnkgSUU2LzcgaXNzdWUKCW5vZGVIb29rID0gewoJCXNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkgewoJCQkvLyBTZXQgdGhlIGV4aXN0aW5nIG9yIGNyZWF0ZSBhIG5ldyBhdHRyaWJ1dGUgbm9kZQoJCQl2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7CgkJCWlmICggIXJldCApIHsKCQkJCWVsZW0uc2V0QXR0cmlidXRlTm9kZSgKCQkJCQkocmV0ID0gZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSggbmFtZSApKQoJCQkJKTsKCQkJfQoKCQkJcmV0LnZhbHVlID0gdmFsdWUgKz0gIiI7CgoJCQkvLyBCcmVhayBhc3NvY2lhdGlvbiB3aXRoIGNsb25lZCBlbGVtZW50cyBieSBhbHNvIHVzaW5nIHNldEF0dHJpYnV0ZSAoIzk2NDYpCgkJCWlmICggbmFtZSA9PT0gInZhbHVlIiB8fCB2YWx1ZSA9PT0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSApIHsKCQkJCXJldHVybiB2YWx1ZTsKCQkJfQoJCX0KCX07CgoJLy8gU29tZSBhdHRyaWJ1dGVzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoIGVtcHR5LXN0cmluZyB2YWx1ZXMgd2hlbiBub3QgZGVmaW5lZAoJYXR0ckhhbmRsZS5pZCA9IGF0dHJIYW5kbGUubmFtZSA9IGF0dHJIYW5kbGUuY29vcmRzID0KCQlmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7CgkJCXZhciByZXQ7CgkJCWlmICggIWlzWE1MICkgewoJCQkJcmV0dXJuIChyZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgcmV0LnZhbHVlICE9PSAiIiA/CgkJCQkJcmV0LnZhbHVlIDoKCQkJCQludWxsOwoJCQl9CgkJfTsKCgkvLyBGaXhpbmcgdmFsdWUgcmV0cmlldmFsIG9uIGEgYnV0dG9uIHJlcXVpcmVzIHRoaXMgbW9kdWxlCglqUXVlcnkudmFsSG9va3MuYnV0dG9uID0gewoJCWdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7CgkJCXZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTsKCQkJaWYgKCByZXQgJiYgcmV0LnNwZWNpZmllZCApIHsKCQkJCXJldHVybiByZXQudmFsdWU7CgkJCX0KCQl9LAoJCXNldDogbm9kZUhvb2suc2V0Cgl9OwoKCS8vIFNldCBjb250ZW50ZWRpdGFibGUgdG8gZmFsc2Ugb24gcmVtb3ZhbHMoIzEwNDI5KQoJLy8gU2V0dGluZyB0byBlbXB0eSBzdHJpbmcgdGhyb3dzIGFuIGVycm9yIGFzIGFuIGludmFsaWQgdmFsdWUKCWpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0gewoJCXNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkgewoJCQlub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlID09PSAiIiA/IGZhbHNlIDogdmFsdWUsIG5hbWUgKTsKCQl9Cgl9OwoKCS8vIFNldCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGF1dG8gaW5zdGVhZCBvZiAwIG9uIGVtcHR5IHN0cmluZyggQnVnICM4MTUwICkKCS8vIFRoaXMgaXMgZm9yIHJlbW92YWxzCglqUXVlcnkuZWFjaChbICJ3aWR0aCIsICJoZWlnaHQiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkgewoJCWpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IHsKCQkJc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7CgkJCQlpZiAoIHZhbHVlID09PSAiIiApIHsKCQkJCQllbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgImF1dG8iICk7CgkJCQkJcmV0dXJuIHZhbHVlOwoJCQkJfQoJCQl9CgkJfTsKCX0pOwp9CgppZiAoICFzdXBwb3J0LnN0eWxlICkgewoJalF1ZXJ5LmF0dHJIb29rcy5zdHlsZSA9IHsKCQlnZXQ6IGZ1bmN0aW9uKCBlbGVtICkgewoJCQkvLyBSZXR1cm4gdW5kZWZpbmVkIGluIHRoZSBjYXNlIG9mIGVtcHR5IHN0cmluZwoJCQkvLyBOb3RlOiBJRSB1cHBlcmNhc2VzIGNzcyBwcm9wZXJ0eSBuYW1lcywgYnV0IGlmIHdlIHdlcmUgdG8gLnRvTG93ZXJDYXNlKCkKCQkJLy8gLmNzc1RleHQsIHRoYXQgd291bGQgZGVzdHJveSBjYXNlIHNlbnN0aXRpdml0eSBpbiBVUkwncywgbGlrZSBpbiAiYmFja2dyb3VuZCIKCQkJcmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dCB8fCB1bmRlZmluZWQ7CgkJfSwKCQlzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHsKCQkJcmV0dXJuICggZWxlbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgKyAiIiApOwoJCX0KCX07Cn0KCgoKCnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkL2ksCglyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pOwoKalF1ZXJ5LmZuLmV4dGVuZCh7Cglwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7CgkJcmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApOwoJfSwKCglyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHsKCQluYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lOwoJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7CgkJCS8vIHRyeS9jYXRjaCBoYW5kbGVzIGNhc2VzIHdoZXJlIElFIGJhbGtzIChzdWNoIGFzIHJlbW92aW5nIGEgcHJvcGVydHkgb24gd2luZG93KQoJCQl0cnkgewoJCQkJdGhpc1sgbmFtZSBdID0gdW5kZWZpbmVkOwoJCQkJZGVsZXRlIHRoaXNbIG5hbWUgXTsKCQkJfSBjYXRjaCggZSApIHt9CgkJfSk7Cgl9Cn0pOwoKalF1ZXJ5LmV4dGVuZCh7Cglwcm9wRml4OiB7CgkJImZvciI6ICJodG1sRm9yIiwKCQkiY2xhc3MiOiAiY2xhc3NOYW1lIgoJfSwKCglwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7CgkJdmFyIHJldCwgaG9va3MsIG5vdHhtbCwKCQkJblR5cGUgPSBlbGVtLm5vZGVUeXBlOwoKCQkvLyBkb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzCgkJaWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHsKCQkJcmV0dXJuOwoJCX0KCgkJbm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApOwoKCQlpZiAoIG5vdHhtbCApIHsKCQkJLy8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rcwoJCQluYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lOwoJCQlob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTsKCQl9CgoJCWlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHsKCQkJcmV0dXJuIGhvb2tzICYmICJzZXQiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgPwoJCQkJcmV0IDoKCQkJCSggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTsKCgkJfSBlbHNlIHsKCQkJcmV0dXJuIGhvb2tzICYmICJnZXQiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgPwoJCQkJcmV0IDoKCQkJCWVsZW1bIG5hbWUgXTsKCQl9Cgl9LAoKCXByb3BIb29rczogewoJCXRhYkluZGV4OiB7CgkJCWdldDogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCQkvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0CgkJCQkvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0LwoJCQkJLy8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3MikKCQkJCXZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sICJ0YWJpbmRleCIgKTsKCgkJCQlyZXR1cm4gdGFiaW5kZXggPwoJCQkJCXBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6CgkJCQkJcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID8KCQkJCQkJMCA6CgkJCQkJCS0xOwoJCQl9CgkJfQoJfQp9KTsKCi8vIFNvbWUgYXR0cmlidXRlcyByZXF1aXJlIGEgc3BlY2lhbCBjYWxsIG9uIElFCi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHgKaWYgKCAhc3VwcG9ydC5ocmVmTm9ybWFsaXplZCApIHsKCS8vIGhyZWYvc3JjIHByb3BlcnR5IHNob3VsZCBnZXQgdGhlIGZ1bGwgbm9ybWFsaXplZCBVUkwgKCMxMDI5OS8jMTI5MTUpCglqUXVlcnkuZWFjaChbICJocmVmIiwgInNyYyIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7CgkJalF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdID0gewoJCQlnZXQ6IGZ1bmN0aW9uKCBlbGVtICkgewoJCQkJcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCA0ICk7CgkJCX0KCQl9OwoJfSk7Cn0KCi8vIFN1cHBvcnQ6IFNhZmFyaSwgSUU5KwovLyBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb24KLy8gQWNjZXNzaW5nIHRoZSBwYXJlbnQncyBzZWxlY3RlZEluZGV4IHByb3BlcnR5IGZpeGVzIGl0CmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7CglqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0gewoJCWdldDogZnVuY3Rpb24oIGVsZW0gKSB7CgkJCXZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7CgoJCQlpZiAoIHBhcmVudCApIHsKCQkJCXBhcmVudC5zZWxlY3RlZEluZGV4OwoKCQkJCS8vIE1ha2Ugc3VyZSB0aGF0IGl0IGFsc28gd29ya3Mgd2l0aCBvcHRncm91cHMsIHNlZSAjNTcwMQoJCQkJaWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHsKCQkJCQlwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4OwoJCQkJfQoJCQl9CgkJCXJldHVybiBudWxsOwoJCX0KCX07Cn0KCmpRdWVyeS5lYWNoKFsKCSJ0YWJJbmRleCIsCgkicmVhZE9ubHkiLAoJIm1heExlbmd0aCIsCgkiY2VsbFNwYWNpbmciLAoJImNlbGxQYWRkaW5nIiwKCSJyb3dTcGFuIiwKCSJjb2xTcGFuIiwKCSJ1c2VNYXAiLAoJImZyYW1lQm9yZGVyIiwKCSJjb250ZW50RWRpdGFibGUiCl0sIGZ1bmN0aW9uKCkgewoJalF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpczsKfSk7CgovLyBJRTYvNyBjYWxsIGVuY3R5cGUgZW5jb2RpbmcKaWYgKCAhc3VwcG9ydC5lbmN0eXBlICkgewoJalF1ZXJ5LnByb3BGaXguZW5jdHlwZSA9ICJlbmNvZGluZyI7Cn0KCgoKCnZhciByY2xhc3MgPSAvW1x0XHJcblxmXS9nOwoKalF1ZXJ5LmZuLmV4dGVuZCh7CglhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkgewoJCXZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLAoJCQlpID0gMCwKCQkJbGVuID0gdGhpcy5sZW5ndGgsCgkJCXByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciICYmIHZhbHVlOwoKCQlpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkgewoJCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkgewoJCQkJalF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTsKCQkJfSk7CgkJfQoKCQlpZiAoIHByb2NlZWQgKSB7CgkJCS8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpCgkJCWNsYXNzZXMgPSAoIHZhbHVlIHx8ICIiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdOwoKCQkJZm9yICggOyBpIDwgbGVuOyBpKysgKSB7CgkJCQllbGVtID0gdGhpc1sgaSBdOwoJCQkJY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID8KCQkJCQkoICIgIiArIGVsZW0uY2xhc3NOYW1lICsgIiAiICkucmVwbGFjZSggcmNsYXNzLCAiICIgKSA6CgkJCQkJIiAiCgkJCQkpOwoKCQkJCWlmICggY3VyICkgewoJCQkJCWogPSAwOwoJCQkJCXdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHsKCQkJCQkJaWYgKCBjdXIuaW5kZXhPZiggIiAiICsgY2xhenogKyAiICIgKSA8IDAgKSB7CgkJCQkJCQljdXIgKz0gY2xhenogKyAiICI7CgkJCQkJCX0KCQkJCQl9CgoJCQkJCS8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuCgkJCQkJZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTsKCQkJCQlpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkgewoJCQkJCQllbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7CgkJCQkJfQoJCQkJfQoJCQl9CgkJfQoKCQlyZXR1cm4gdGhpczsKCX0sCgoJcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHsKCQl2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSwKCQkJaSA9IDAsCgkJCWxlbiA9IHRoaXMubGVuZ3RoLAoJCQlwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciICYmIHZhbHVlOwoKCQlpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkgewoJCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkgewoJCQkJalF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTsKCQkJfSk7CgkJfQoJCWlmICggcHJvY2VlZCApIHsKCQkJY2xhc3NlcyA9ICggdmFsdWUgfHwgIiIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107CgoJCQlmb3IgKCA7IGkgPCBsZW47IGkrKyApIHsKCQkJCWVsZW0gPSB0aGlzWyBpIF07CgkJCQkvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKQoJCQkJY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID8KCQkJCQkoICIgIiArIGVsZW0uY2xhc3NOYW1lICsgIiAiICkucmVwbGFjZSggcmNsYXNzLCAiICIgKSA6CgkJCQkJIiIKCQkJCSk7CgoJCQkJaWYgKCBjdXIgKSB7CgkJCQkJaiA9IDA7CgkJCQkJd2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkgewoJCQkJCQkvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzCgkJCQkJCXdoaWxlICggY3VyLmluZGV4T2YoICIgIiArIGNsYXp6ICsgIiAiICkgPj0gMCApIHsKCQkJCQkJCWN1ciA9IGN1ci5yZXBsYWNlKCAiICIgKyBjbGF6eiArICIgIiwgIiAiICk7CgkJCQkJCX0KCQkJCQl9CgoJCQkJCS8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuCgkJCQkJZmluYWxWYWx1ZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGN1ciApIDogIiI7CgkJCQkJaWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHsKCQkJCQkJZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCgkJcmV0dXJuIHRoaXM7Cgl9LAoKCXRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkgewoJCXZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwoKCQlpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gImJvb2xlYW4iICYmIHR5cGUgPT09ICJzdHJpbmciICkgewoJCQlyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTsKCQl9CgoJCWlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7CgkJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7CgkJCQlqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApOwoJCQl9KTsKCQl9CgoJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7CgkJCWlmICggdHlwZSA9PT0gInN0cmluZyIgKSB7CgkJCQkvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lcwoJCQkJdmFyIGNsYXNzTmFtZSwKCQkJCQlpID0gMCwKCQkJCQlzZWxmID0galF1ZXJ5KCB0aGlzICksCgkJCQkJY2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTsKCgkJCQl3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7CgkJCQkJLy8gY2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0CgkJCQkJaWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHsKCQkJCQkJc2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7CgkJCQkJfSBlbHNlIHsKCQkJCQkJc2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7CgkJCQkJfQoJCQkJfQoKCQkJLy8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWUKCQkJfSBlbHNlIGlmICggdHlwZSA9PT0gc3RydW5kZWZpbmVkIHx8IHR5cGUgPT09ICJib29sZWFuIiApIHsKCQkJCWlmICggdGhpcy5jbGFzc05hbWUgKSB7CgkJCQkJLy8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldAoJCQkJCWpRdWVyeS5fZGF0YSggdGhpcywgIl9fY2xhc3NOYW1lX18iLCB0aGlzLmNsYXNzTmFtZSApOwoJCQkJfQoKCQkJCS8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkICJmYWxzZSIsCgkJCQkvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLgoJCQkJLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSwKCQkJCS8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC4KCQkJCXRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gIiIgOiBqUXVlcnkuX2RhdGEoIHRoaXMsICJfX2NsYXNzTmFtZV9fIiApIHx8ICIiOwoJCQl9CgkJfSk7Cgl9LAoKCWhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7CgkJdmFyIGNsYXNzTmFtZSA9ICIgIiArIHNlbGVjdG9yICsgIiAiLAoJCQlpID0gMCwKCQkJbCA9IHRoaXMubGVuZ3RoOwoJCWZvciAoIDsgaSA8IGw7IGkrKyApIHsKCQkJaWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmICgiICIgKyB0aGlzW2ldLmNsYXNzTmFtZSArICIgIikucmVwbGFjZShyY2xhc3MsICIgIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPj0gMCApIHsKCQkJCXJldHVybiB0cnVlOwoJCQl9CgkJfQoKCQlyZXR1cm4gZmFsc2U7Cgl9Cn0pOwoKCgoKLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvbgoKCmpRdWVyeS5lYWNoKCAoImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrICIgKwoJIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlICIgKwoJImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnUiKS5zcGxpdCgiICIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHsKCgkvLyBIYW5kbGUgZXZlbnQgYmluZGluZwoJalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7CgkJcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID8KCQkJdGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6CgkJCXRoaXMudHJpZ2dlciggbmFtZSApOwoJfTsKfSk7CgpqUXVlcnkuZm4uZXh0ZW5kKHsKCWhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHsKCQlyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTsKCX0sCgoJYmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHsKCQlyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7Cgl9LAoJdW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkgewoJCXJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7Cgl9LAoKCWRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHsKCQlyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApOwoJfSwKCXVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkgewoJCS8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dICkKCQlyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMub2ZmKCBzZWxlY3RvciwgIioqIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCAiKioiLCBmbiApOwoJfQp9KTsKCgp2YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7Cgp2YXIgcnF1ZXJ5ID0gKC9cPy8pOwoKCgp2YXIgcnZhbGlkdG9rZW5zID0gLygsKXwoXFt8eyl8KH18XSl8Iig/OlteIlxcXHJcbl18XFxbIlxcXC9iZm5ydF18XFx1W1xkYS1mQS1GXXs0fSkqIlxzKjo/fHRydWV8ZmFsc2V8bnVsbHwtPyg/ITBcZClcZCsoPzpcLlxkK3wpKD86W2VFXVsrLV0/XGQrfCkvZzsKCmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHsKCS8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdAoJaWYgKCB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSApIHsKCQkvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMwoJCS8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0CgkJcmV0dXJuIHdpbmRvdy5KU09OLnBhcnNlKCBkYXRhICsgIiIgKTsKCX0KCgl2YXIgcmVxdWlyZU5vbkNvbW1hLAoJCWRlcHRoID0gbnVsbCwKCQlzdHIgPSBqUXVlcnkudHJpbSggZGF0YSArICIiICk7CgoJLy8gR3VhcmQgYWdhaW5zdCBpbnZhbGlkIChhbmQgcG9zc2libHkgZGFuZ2Vyb3VzKSBpbnB1dCBieSBlbnN1cmluZyB0aGF0IG5vdGhpbmcgcmVtYWlucwoJLy8gYWZ0ZXIgcmVtb3ZpbmcgdmFsaWQgdG9rZW5zCglyZXR1cm4gc3RyICYmICFqUXVlcnkudHJpbSggc3RyLnJlcGxhY2UoIHJ2YWxpZHRva2VucywgZnVuY3Rpb24oIHRva2VuLCBjb21tYSwgb3BlbiwgY2xvc2UgKSB7CgoJCS8vIEZvcmNlIHRlcm1pbmF0aW9uIGlmIHdlIHNlZSBhIG1pc3BsYWNlZCBjb21tYQoJCWlmICggcmVxdWlyZU5vbkNvbW1hICYmIGNvbW1hICkgewoJCQlkZXB0aCA9IDA7CgkJfQoKCQkvLyBQZXJmb3JtIG5vIG1vcmUgcmVwbGFjZW1lbnRzIGFmdGVyIHJldHVybmluZyB0byBvdXRlcm1vc3QgZGVwdGgKCQlpZiAoIGRlcHRoID09PSAwICkgewoJCQlyZXR1cm4gdG9rZW47CgkJfQoKCQkvLyBDb21tYXMgbXVzdCBub3QgZm9sbG93ICJbIiwgInsiLCBvciAiLCIKCQlyZXF1aXJlTm9uQ29tbWEgPSBvcGVuIHx8IGNvbW1hOwoKCQkvLyBEZXRlcm1pbmUgbmV3IGRlcHRoCgkJLy8gYXJyYXkvb2JqZWN0IG9wZW4gKCJbIiBvciAieyIpOiBkZXB0aCArPSB0cnVlIC0gZmFsc2UgKGluY3JlbWVudCkKCQkvLyBhcnJheS9vYmplY3QgY2xvc2UgKCJdIiBvciAifSIpOiBkZXB0aCArPSBmYWxzZSAtIHRydWUgKGRlY3JlbWVudCkKCQkvLyBvdGhlciBjYXNlcyAoIiwiIG9yIHByaW1pdGl2ZSk6IGRlcHRoICs9IHRydWUgLSB0cnVlIChudW1lcmljIGNhc3QpCgkJZGVwdGggKz0gIWNsb3NlIC0gIW9wZW47CgoJCS8vIFJlbW92ZSB0aGlzIHRva2VuCgkJcmV0dXJuICIiOwoJfSkgKSA/CgkJKCBGdW5jdGlvbiggInJldHVybiAiICsgc3RyICkgKSgpIDoKCQlqUXVlcnkuZXJyb3IoICJJbnZhbGlkIEpTT046ICIgKyBkYXRhICk7Cn07CgoKLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZwpqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHsKCXZhciB4bWwsIHRtcDsKCWlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICJzdHJpbmciICkgewoJCXJldHVybiBudWxsOwoJfQoJdHJ5IHsKCQlpZiAoIHdpbmRvdy5ET01QYXJzZXIgKSB7IC8vIFN0YW5kYXJkCgkJCXRtcCA9IG5ldyBET01QYXJzZXIoKTsKCQkJeG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgInRleHQveG1sIiApOwoJCX0gZWxzZSB7IC8vIElFCgkJCXhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCAiTWljcm9zb2Z0LlhNTERPTSIgKTsKCQkJeG1sLmFzeW5jID0gImZhbHNlIjsKCQkJeG1sLmxvYWRYTUwoIGRhdGEgKTsKCQl9Cgl9IGNhdGNoKCBlICkgewoJCXhtbCA9IHVuZGVmaW5lZDsKCX0KCWlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICJwYXJzZXJlcnJvciIgKS5sZW5ndGggKSB7CgkJalF1ZXJ5LmVycm9yKCAiSW52YWxpZCBYTUw6ICIgKyBkYXRhICk7Cgl9CglyZXR1cm4geG1sOwp9OwoKCnZhcgoJLy8gRG9jdW1lbnQgbG9jYXRpb24KCWFqYXhMb2NQYXJ0cywKCWFqYXhMb2NhdGlvbiwKCglyaGFzaCA9IC8jLiokLywKCXJ0cyA9IC8oWz8mXSlfPVteJl0qLywKCXJoZWFkZXJzID0gL14oLio/KTpbIFx0XSooW15cclxuXSopXHI/JC9tZywgLy8gSUUgbGVhdmVzIGFuIFxyIGNoYXJhY3RlciBhdCBFT0wKCS8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvbgoJcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLywKCXJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLAoJcnByb3RvY29sID0gL15cL1wvLywKCXJ1cmwgPSAvXihbXHcuKy1dKzopKD86XC9cLyg/OlteXC8/I10qQHwpKFteXC8/IzpdKikoPzo6KFxkKyl8KXwpLywKCgkvKiBQcmVmaWx0ZXJzCgkgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKQoJICogMikgVGhlc2UgYXJlIGNhbGxlZDoKCSAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnQKCSAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSkKCSAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGUKCSAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgIioiIGNhbiBiZSB1c2VkCgkgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvICIqIiBpZiBuZWVkZWQKCSAqLwoJcHJlZmlsdGVycyA9IHt9LAoKCS8qIFRyYW5zcG9ydHMgYmluZGluZ3MKCSAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGUKCSAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgIioiIGNhbiBiZSB1c2VkCgkgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byAiKiIgaWYgbmVlZGVkCgkgKi8KCXRyYW5zcG9ydHMgPSB7fSwKCgkvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb24KCWFsbFR5cGVzID0gIiovIi5jb25jYXQoIioiKTsKCi8vICM4MTM4LCBJRSBtYXkgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nCi8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldAp0cnkgewoJYWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjsKfSBjYXRjaCggZSApIHsKCS8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50CgkvLyBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvbgoJYWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggImEiICk7CglhamF4TG9jYXRpb24uaHJlZiA9ICIiOwoJYWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7Cn0KCi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0cwphamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoIGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpICkgfHwgW107CgovLyBCYXNlICJjb25zdHJ1Y3RvciIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydApmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHsKCgkvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICIqIgoJcmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7CgoJCWlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gInN0cmluZyIgKSB7CgkJCWZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247CgkJCWRhdGFUeXBlRXhwcmVzc2lvbiA9ICIqIjsKCQl9CgoJCXZhciBkYXRhVHlwZSwKCQkJaSA9IDAsCgkJCWRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTsKCgkJaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkgewoJCQkvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uCgkJCXdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkgewoJCQkJLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWQKCQkJCWlmICggZGF0YVR5cGUuY2hhckF0KCAwICkgPT09ICIrIiApIHsKCQkJCQlkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgIioiOwoJCQkJCShzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnVuc2hpZnQoIGZ1bmMgKTsKCgkJCQkvLyBPdGhlcndpc2UgYXBwZW5kCgkJCQl9IGVsc2UgewoJCQkJCShzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTsKCQkJCX0KCQkJfQoJCX0KCX07Cn0KCi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0cwpmdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkgewoKCXZhciBpbnNwZWN0ZWQgPSB7fSwKCQlzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTsKCglmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHsKCQl2YXIgc2VsZWN0ZWQ7CgkJaW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTsKCQlqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkgewoJCQl2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApOwoJCQlpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSAic3RyaW5nIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7CgkJCQlvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7CgkJCQlpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7CgkJCQlyZXR1cm4gZmFsc2U7CgkJCX0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7CgkJCQlyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7CgkJCX0KCQl9KTsKCQlyZXR1cm4gc2VsZWN0ZWQ7Cgl9CgoJcmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyAiKiIgXSAmJiBpbnNwZWN0KCAiKiIgKTsKfQoKLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zCi8vIHRoYXQgdGFrZXMgImZsYXQiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKQovLyBGaXhlcyAjOTg4NwpmdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHsKCXZhciBkZWVwLCBrZXksCgkJZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9OwoKCWZvciAoIGtleSBpbiBzcmMgKSB7CgkJaWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7CgkJCSggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8IChkZWVwID0ge30pICkgKVsga2V5IF0gPSBzcmNbIGtleSBdOwoJCX0KCX0KCWlmICggZGVlcCApIHsKCQlqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTsKCX0KCglyZXR1cm4gdGFyZ2V0Owp9CgovKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6CiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpCiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZQogKi8KZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHsKCXZhciBmaXJzdERhdGFUeXBlLCBjdCwgZmluYWxEYXRhVHlwZSwgdHlwZSwKCQljb250ZW50cyA9IHMuY29udGVudHMsCgkJZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7CgoJLy8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3MKCXdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09ICIqIiApIHsKCQlkYXRhVHlwZXMuc2hpZnQoKTsKCQlpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7CgkJCWN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcigiQ29udGVudC1UeXBlIik7CgkJfQoJfQoKCS8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZQoJaWYgKCBjdCApIHsKCQlmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkgewoJCQlpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkgewoJCQkJZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJfQoKCS8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZQoJaWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7CgkJZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdOwoJfSBlbHNlIHsKCQkvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzCgkJZm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7CgkJCWlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArICIgIiArIGRhdGFUeXBlc1swXSBdICkgewoJCQkJZmluYWxEYXRhVHlwZSA9IHR5cGU7CgkJCQlicmVhazsKCQkJfQoJCQlpZiAoICFmaXJzdERhdGFUeXBlICkgewoJCQkJZmlyc3REYXRhVHlwZSA9IHR5cGU7CgkJCX0KCQl9CgkJLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lCgkJZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTsKCX0KCgkvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlCgkvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZAoJLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZQoJaWYgKCBmaW5hbERhdGFUeXBlICkgewoJCWlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7CgkJCWRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7CgkJfQoJCXJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTsKCX0KfQoKLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZQogKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2UKICovCmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHsKCXZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LAoJCWNvbnZlcnRlcnMgPSB7fSwKCQkvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uCgkJZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTsKCgkvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXMKCWlmICggZGF0YVR5cGVzWyAxIF0gKSB7CgkJZm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7CgkJCWNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07CgkJfQoJfQoKCWN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTsKCgkvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZQoJd2hpbGUgKCBjdXJyZW50ICkgewoKCQlpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHsKCQkJanFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7CgkJfQoKCQkvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZAoJCWlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHsKCQkJcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7CgkJfQoKCQlwcmV2ID0gY3VycmVudDsKCQljdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7CgoJCWlmICggY3VycmVudCApIHsKCgkJCS8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG8KCQkJaWYgKCBjdXJyZW50ID09PSAiKiIgKSB7CgoJCQkJY3VycmVudCA9IHByZXY7CgoJCQkvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50CgkJCX0gZWxzZSBpZiAoIHByZXYgIT09ICIqIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkgewoKCQkJCS8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyCgkJCQljb252ID0gY29udmVydGVyc1sgcHJldiArICIgIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyAiKiAiICsgY3VycmVudCBdOwoKCQkJCS8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyCgkJCQlpZiAoICFjb252ICkgewoJCQkJCWZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7CgoJCQkJCQkvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnQKCQkJCQkJdG1wID0gY29udjIuc3BsaXQoICIgIiApOwoJCQkJCQlpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkgewoKCQkJCQkJCS8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dAoJCQkJCQkJY29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyAiICIgKyB0bXBbIDAgXSBdIHx8CgkJCQkJCQkJY29udmVydGVyc1sgIiogIiArIHRtcFsgMCBdIF07CgkJCQkJCQlpZiAoIGNvbnYgKSB7CgkJCQkJCQkJLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVycwoJCQkJCQkJCWlmICggY29udiA9PT0gdHJ1ZSApIHsKCQkJCQkJCQkJY29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07CgoJCQkJCQkJCS8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGUKCQkJCQkJCQl9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkgewoJCQkJCQkJCQljdXJyZW50ID0gdG1wWyAwIF07CgkJCQkJCQkJCWRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApOwoJCQkJCQkJCX0KCQkJCQkJCQlicmVhazsKCQkJCQkJCX0KCQkJCQkJfQoJCQkJCX0KCQkJCX0KCgkJCQkvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSkKCQkJCWlmICggY29udiAhPT0gdHJ1ZSApIHsKCgkJCQkJLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbQoJCQkJCWlmICggY29udiAmJiBzWyAidGhyb3dzIiBdICkgewoJCQkJCQlyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7CgkJCQkJfSBlbHNlIHsKCQkJCQkJdHJ5IHsKCQkJCQkJCXJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTsKCQkJCQkJfSBjYXRjaCAoIGUgKSB7CgkJCQkJCQlyZXR1cm4geyBzdGF0ZTogInBhcnNlcmVycm9yIiwgZXJyb3I6IGNvbnYgPyBlIDogIk5vIGNvbnZlcnNpb24gZnJvbSAiICsgcHJldiArICIgdG8gIiArIGN1cnJlbnQgfTsKCQkJCQkJfQoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCX0KCglyZXR1cm4geyBzdGF0ZTogInN1Y2Nlc3MiLCBkYXRhOiByZXNwb25zZSB9Owp9CgpqUXVlcnkuZXh0ZW5kKHsKCgkvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXMKCWFjdGl2ZTogMCwKCgkvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0CglsYXN0TW9kaWZpZWQ6IHt9LAoJZXRhZzoge30sCgoJYWpheFNldHRpbmdzOiB7CgkJdXJsOiBhamF4TG9jYXRpb24sCgkJdHlwZTogIkdFVCIsCgkJaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSwKCQlnbG9iYWw6IHRydWUsCgkJcHJvY2Vzc0RhdGE6IHRydWUsCgkJYXN5bmM6IHRydWUsCgkJY29udGVudFR5cGU6ICJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgiLAoJCS8qCgkJdGltZW91dDogMCwKCQlkYXRhOiBudWxsLAoJCWRhdGFUeXBlOiBudWxsLAoJCXVzZXJuYW1lOiBudWxsLAoJCXBhc3N3b3JkOiBudWxsLAoJCWNhY2hlOiBudWxsLAoJCXRocm93czogZmFsc2UsCgkJdHJhZGl0aW9uYWw6IGZhbHNlLAoJCWhlYWRlcnM6IHt9LAoJCSovCgoJCWFjY2VwdHM6IHsKCQkJIioiOiBhbGxUeXBlcywKCQkJdGV4dDogInRleHQvcGxhaW4iLAoJCQlodG1sOiAidGV4dC9odG1sIiwKCQkJeG1sOiAiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCIsCgkJCWpzb246ICJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQiCgkJfSwKCgkJY29udGVudHM6IHsKCQkJeG1sOiAveG1sLywKCQkJaHRtbDogL2h0bWwvLAoJCQlqc29uOiAvanNvbi8KCQl9LAoKCQlyZXNwb25zZUZpZWxkczogewoJCQl4bWw6ICJyZXNwb25zZVhNTCIsCgkJCXRleHQ6ICJyZXNwb25zZVRleHQiLAoJCQlqc29uOiAicmVzcG9uc2VKU09OIgoJCX0sCgoJCS8vIERhdGEgY29udmVydGVycwoJCS8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCAiKiIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlCgkJY29udmVydGVyczogewoKCQkJLy8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0CgkJCSIqIHRleHQiOiBTdHJpbmcsCgoJCQkvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbikKCQkJInRleHQgaHRtbCI6IHRydWUsCgoJCQkvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uCgkJCSJ0ZXh0IGpzb24iOiBqUXVlcnkucGFyc2VKU09OLAoKCQkJLy8gUGFyc2UgdGV4dCBhcyB4bWwKCQkJInRleHQgeG1sIjogalF1ZXJ5LnBhcnNlWE1MCgkJfSwKCgkJLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDoKCQkvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmCgkJLy8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmUKCQkvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZCkKCQlmbGF0T3B0aW9uczogewoJCQl1cmw6IHRydWUsCgkJCWNvbnRleHQ6IHRydWUKCQl9Cgl9LAoKCS8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0CgkvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuCgkvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLgoJYWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHsKCQlyZXR1cm4gc2V0dGluZ3MgPwoKCQkJLy8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3QKCQkJYWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOgoKCQkJLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5ncwoJCQlhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTsKCX0sCgoJYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksCglhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSwKCgkvLyBNYWluIG1ldGhvZAoJYWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHsKCgkJLy8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmUKCQlpZiAoIHR5cGVvZiB1cmwgPT09ICJvYmplY3QiICkgewoJCQlvcHRpb25zID0gdXJsOwoJCQl1cmwgPSB1bmRlZmluZWQ7CgkJfQoKCQkvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdAoJCW9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwoKCQl2YXIgLy8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzCgkJCXBhcnRzLAoJCQkvLyBMb29wIHZhcmlhYmxlCgkJCWksCgkJCS8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW0KCQkJY2FjaGVVUkwsCgkJCS8vIFJlc3BvbnNlIGhlYWRlcnMgYXMgc3RyaW5nCgkJCXJlc3BvbnNlSGVhZGVyc1N0cmluZywKCQkJLy8gdGltZW91dCBoYW5kbGUKCQkJdGltZW91dFRpbWVyLAoKCQkJLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkCgkJCWZpcmVHbG9iYWxzLAoKCQkJdHJhbnNwb3J0LAoJCQkvLyBSZXNwb25zZSBoZWFkZXJzCgkJCXJlc3BvbnNlSGVhZGVycywKCQkJLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdAoJCQlzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSwKCQkJLy8gQ2FsbGJhY2tzIGNvbnRleHQKCQkJY2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsCgkJCS8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb24KCQkJZ2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/CgkJCQlqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDoKCQkJCWpRdWVyeS5ldmVudCwKCQkJLy8gRGVmZXJyZWRzCgkJCWRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksCgkJCWNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCJvbmNlIG1lbW9yeSIpLAoJCQkvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrcwoJCQlzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LAoJCQkvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKQoJCQlyZXF1ZXN0SGVhZGVycyA9IHt9LAoJCQlyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sCgkJCS8vIFRoZSBqcVhIUiBzdGF0ZQoJCQlzdGF0ZSA9IDAsCgkJCS8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZQoJCQlzdHJBYm9ydCA9ICJjYW5jZWxlZCIsCgkJCS8vIEZha2UgeGhyCgkJCWpxWEhSID0gewoJCQkJcmVhZHlTdGF0ZTogMCwKCgkJCQkvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkCgkJCQlnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHsKCQkJCQl2YXIgbWF0Y2g7CgkJCQkJaWYgKCBzdGF0ZSA9PT0gMiApIHsKCQkJCQkJaWYgKCAhcmVzcG9uc2VIZWFkZXJzICkgewoJCQkJCQkJcmVzcG9uc2VIZWFkZXJzID0ge307CgkJCQkJCQl3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHsKCQkJCQkJCQlyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07CgkJCQkJCQl9CgkJCQkJCX0KCQkJCQkJbWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07CgkJCQkJfQoJCQkJCXJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoOwoJCQkJfSwKCgkJCQkvLyBSYXcgc3RyaW5nCgkJCQlnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkgewoJCQkJCXJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7CgkJCQl9LAoKCQkJCS8vIENhY2hlcyB0aGUgaGVhZGVyCgkJCQlzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7CgkJCQkJdmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpOwoJCQkJCWlmICggIXN0YXRlICkgewoJCQkJCQluYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTsKCQkJCQkJcmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlOwoJCQkJCX0KCQkJCQlyZXR1cm4gdGhpczsKCQkJCX0sCgoJCQkJLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXIKCQkJCW92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkgewoJCQkJCWlmICggIXN0YXRlICkgewoJCQkJCQlzLm1pbWVUeXBlID0gdHlwZTsKCQkJCQl9CgkJCQkJcmV0dXJuIHRoaXM7CgkJCQl9LAoKCQkJCS8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzCgkJCQlzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkgewoJCQkJCXZhciBjb2RlOwoJCQkJCWlmICggbWFwICkgewoJCQkJCQlpZiAoIHN0YXRlIDwgMiApIHsKCQkJCQkJCWZvciAoIGNvZGUgaW4gbWFwICkgewoJCQkJCQkJCS8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXMKCQkJCQkJCQlzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTsKCQkJCQkJCX0KCQkJCQkJfSBlbHNlIHsKCQkJCQkJCS8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrcwoJCQkJCQkJanFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7CgkJCQkJCX0KCQkJCQl9CgkJCQkJcmV0dXJuIHRoaXM7CgkJCQl9LAoKCQkJCS8vIENhbmNlbCB0aGUgcmVxdWVzdAoJCQkJYWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkgewoJCQkJCXZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0OwoJCQkJCWlmICggdHJhbnNwb3J0ICkgewoJCQkJCQl0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApOwoJCQkJCX0KCQkJCQlkb25lKCAwLCBmaW5hbFRleHQgKTsKCQkJCQlyZXR1cm4gdGhpczsKCQkJCX0KCQkJfTsKCgkJLy8gQXR0YWNoIGRlZmVycmVkcwoJCWRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDsKCQlqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTsKCQlqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7CgoJCS8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKQoJCS8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKCM1ODY2OiBJRTcgaXNzdWUgd2l0aCBwcm90b2NvbC1sZXNzIHVybHMpCgkJLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSkKCQkvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGUKCQlzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyAiIiApLnJlcGxhY2UoIHJoYXNoLCAiIiApLnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyAiLy8iICk7CgoJCS8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNAoJCXMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7CgoJCS8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3QKCQlzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8ICIqIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgIiIgXTsKCgkJLy8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2gKCQlpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHsKCQkJcGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTsKCQkJcy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJgoJCQkJKCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fAoJCQkJCSggcGFydHNbIDMgXSB8fCAoIHBhcnRzWyAxIF0gPT09ICJodHRwOiIgPyAiODAiIDogIjQ0MyIgKSApICE9PQoJCQkJCQkoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09ICJodHRwOiIgPyAiODAiIDogIjQ0MyIgKSApICkKCQkJKTsKCQl9CgoJCS8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZwoJCWlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gInN0cmluZyIgKSB7CgkJCXMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7CgkJfQoKCQkvLyBBcHBseSBwcmVmaWx0ZXJzCgkJaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7CgoJCS8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlCgkJaWYgKCBzdGF0ZSA9PT0gMiApIHsKCQkJcmV0dXJuIGpxWEhSOwoJCX0KCgkJLy8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG8KCQlmaXJlR2xvYmFscyA9IHMuZ2xvYmFsOwoKCQkvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzCgkJaWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7CgkJCWpRdWVyeS5ldmVudC50cmlnZ2VyKCJhamF4U3RhcnQiKTsKCQl9CgoJCS8vIFVwcGVyY2FzZSB0aGUgdHlwZQoJCXMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpOwoKCQkvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudAoJCXMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApOwoKCQkvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2UKCQkvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb24KCQljYWNoZVVSTCA9IHMudXJsOwoKCQkvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudAoJCWlmICggIXMuaGFzQ29udGVudCApIHsKCgkJCS8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmwKCQkJaWYgKCBzLmRhdGEgKSB7CgkJCQljYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/ICImIiA6ICI/IiApICsgcy5kYXRhICk7CgkJCQkvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5CgkJCQlkZWxldGUgcy5kYXRhOwoJCQl9CgoJCQkvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkCgkJCWlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7CgkJCQlzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID8KCgkJCQkJLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWUKCQkJCQljYWNoZVVSTC5yZXBsYWNlKCBydHMsICIkMV89IiArIG5vbmNlKysgKSA6CgoJCQkJCS8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmQKCQkJCQljYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyAiJiIgOiAiPyIgKSArICJfPSIgKyBub25jZSsrOwoJCQl9CgkJfQoKCQkvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLgoJCWlmICggcy5pZk1vZGlmaWVkICkgewoJCQlpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7CgkJCQlqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCAiSWYtTW9kaWZpZWQtU2luY2UiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7CgkJCX0KCQkJaWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHsKCQkJCWpxWEhSLnNldFJlcXVlc3RIZWFkZXIoICJJZi1Ob25lLU1hdGNoIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTsKCQkJfQoJCX0KCgkJLy8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50CgkJaWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7CgkJCWpxWEhSLnNldFJlcXVlc3RIZWFkZXIoICJDb250ZW50LVR5cGUiLCBzLmNvbnRlbnRUeXBlICk7CgkJfQoKCQkvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlCgkJanFYSFIuc2V0UmVxdWVzdEhlYWRlcigKCQkJIkFjY2VwdCIsCgkJCXMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID8KCQkJCXMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSArICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gIioiID8gIiwgIiArIGFsbFR5cGVzICsgIjsgcT0wLjAxIiA6ICIiICkgOgoJCQkJcy5hY2NlcHRzWyAiKiIgXQoJCSk7CgoJCS8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvbgoJCWZvciAoIGkgaW4gcy5oZWFkZXJzICkgewoJCQlqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApOwoJCX0KCgkJLy8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydAoJCWlmICggcy5iZWZvcmVTZW5kICYmICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHsKCQkJLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuCgkJCXJldHVybiBqcVhIUi5hYm9ydCgpOwoJCX0KCgkJLy8gYWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uCgkJc3RyQWJvcnQgPSAiYWJvcnQiOwoKCQkvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHMKCQlmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7CgkJCWpxWEhSWyBpIF0oIHNbIGkgXSApOwoJCX0KCgkJLy8gR2V0IHRyYW5zcG9ydAoJCXRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApOwoKCQkvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnQKCQlpZiAoICF0cmFuc3BvcnQgKSB7CgkJCWRvbmUoIC0xLCAiTm8gVHJhbnNwb3J0IiApOwoJCX0gZWxzZSB7CgkJCWpxWEhSLnJlYWR5U3RhdGUgPSAxOwoKCQkJLy8gU2VuZCBnbG9iYWwgZXZlbnQKCQkJaWYgKCBmaXJlR2xvYmFscyApIHsKCQkJCWdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCAiYWpheFNlbmQiLCBbIGpxWEhSLCBzIF0gKTsKCQkJfQoJCQkvLyBUaW1lb3V0CgkJCWlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkgewoJCQkJdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsKCQkJCQlqcVhIUi5hYm9ydCgidGltZW91dCIpOwoJCQkJfSwgcy50aW1lb3V0ICk7CgkJCX0KCgkJCXRyeSB7CgkJCQlzdGF0ZSA9IDE7CgkJCQl0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTsKCQkJfSBjYXRjaCAoIGUgKSB7CgkJCQkvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lCgkJCQlpZiAoIHN0YXRlIDwgMiApIHsKCQkJCQlkb25lKCAtMSwgZSApOwoJCQkJLy8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlCgkJCQl9IGVsc2UgewoJCQkJCXRocm93IGU7CgkJCQl9CgkJCX0KCQl9CgoJCS8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZQoJCWZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkgewoJCQl2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLAoJCQkJc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7CgoJCQkvLyBDYWxsZWQgb25jZQoJCQlpZiAoIHN0YXRlID09PSAyICkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQkvLyBTdGF0ZSBpcyAiZG9uZSIgbm93CgkJCXN0YXRlID0gMjsKCgkJCS8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzCgkJCWlmICggdGltZW91dFRpbWVyICkgewoJCQkJY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTsKCQkJfQoKCQkJLy8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb24KCQkJLy8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZCkKCQkJdHJhbnNwb3J0ID0gdW5kZWZpbmVkOwoKCQkJLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVycwoJCQlyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8ICIiOwoKCQkJLy8gU2V0IHJlYWR5U3RhdGUKCQkJanFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDsKCgkJCS8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsCgkJCWlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0OwoKCQkJLy8gR2V0IHJlc3BvbnNlIGRhdGEKCQkJaWYgKCByZXNwb25zZXMgKSB7CgkJCQlyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTsKCQkJfQoKCQkJLy8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KQoJCQlyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApOwoKCQkJLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmcKCQkJaWYgKCBpc1N1Y2Nlc3MgKSB7CgoJCQkJLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS4KCQkJCWlmICggcy5pZk1vZGlmaWVkICkgewoJCQkJCW1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIkxhc3QtTW9kaWZpZWQiKTsKCQkJCQlpZiAoIG1vZGlmaWVkICkgewoJCQkJCQlqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7CgkJCQkJfQoJCQkJCW1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoImV0YWciKTsKCQkJCQlpZiAoIG1vZGlmaWVkICkgewoJCQkJCQlqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkOwoJCQkJCX0KCQkJCX0KCgkJCQkvLyBpZiBubyBjb250ZW50CgkJCQlpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gIkhFQUQiICkgewoJCQkJCXN0YXR1c1RleHQgPSAibm9jb250ZW50IjsKCgkJCQkvLyBpZiBub3QgbW9kaWZpZWQKCQkJCX0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkgewoJCQkJCXN0YXR1c1RleHQgPSAibm90bW9kaWZpZWQiOwoKCQkJCS8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdAoJCQkJfSBlbHNlIHsKCQkJCQlzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7CgkJCQkJc3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7CgkJCQkJZXJyb3IgPSByZXNwb25zZS5lcnJvcjsKCQkJCQlpc1N1Y2Nlc3MgPSAhZXJyb3I7CgkJCQl9CgkJCX0gZWxzZSB7CgkJCQkvLyBXZSBleHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dAoJCQkJLy8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzCgkJCQllcnJvciA9IHN0YXR1c1RleHQ7CgkJCQlpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHsKCQkJCQlzdGF0dXNUZXh0ID0gImVycm9yIjsKCQkJCQlpZiAoIHN0YXR1cyA8IDAgKSB7CgkJCQkJCXN0YXR1cyA9IDA7CgkJCQkJfQoJCQkJfQoJCQl9CgoJCQkvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdAoJCQlqcVhIUi5zdGF0dXMgPSBzdGF0dXM7CgkJCWpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgIiI7CgoJCQkvLyBTdWNjZXNzL0Vycm9yCgkJCWlmICggaXNTdWNjZXNzICkgewoJCQkJZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7CgkJCX0gZWxzZSB7CgkJCQlkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTsKCQkJfQoKCQkJLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3MKCQkJanFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApOwoJCQlzdGF0dXNDb2RlID0gdW5kZWZpbmVkOwoKCQkJaWYgKCBmaXJlR2xvYmFscyApIHsKCQkJCWdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyAiYWpheFN1Y2Nlc3MiIDogImFqYXhFcnJvciIsCgkJCQkJWyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTsKCQkJfQoKCQkJLy8gQ29tcGxldGUKCQkJY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTsKCgkJCWlmICggZmlyZUdsb2JhbHMgKSB7CgkJCQlnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggImFqYXhDb21wbGV0ZSIsIFsganFYSFIsIHMgXSApOwoJCQkJLy8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyCgkJCQlpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkgewoJCQkJCWpRdWVyeS5ldmVudC50cmlnZ2VyKCJhamF4U3RvcCIpOwoJCQkJfQoJCQl9CgkJfQoKCQlyZXR1cm4ganFYSFI7Cgl9LAoKCWdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkgewoJCXJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCAianNvbiIgKTsKCX0sCgoJZ2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHsKCQlyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCAic2NyaXB0IiApOwoJfQp9KTsKCmpRdWVyeS5lYWNoKCBbICJnZXQiLCAicG9zdCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHsKCWpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHsKCQkvLyBzaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZAoJCWlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHsKCQkJdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7CgkJCWNhbGxiYWNrID0gZGF0YTsKCQkJZGF0YSA9IHVuZGVmaW5lZDsKCQl9CgoJCXJldHVybiBqUXVlcnkuYWpheCh7CgkJCXVybDogdXJsLAoJCQl0eXBlOiBtZXRob2QsCgkJCWRhdGFUeXBlOiB0eXBlLAoJCQlkYXRhOiBkYXRhLAoJCQlzdWNjZXNzOiBjYWxsYmFjawoJCX0pOwoJfTsKfSk7CgovLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50cwpqUXVlcnkuZWFjaCggWyAiYWpheFN0YXJ0IiwgImFqYXhTdG9wIiwgImFqYXhDb21wbGV0ZSIsICJhamF4RXJyb3IiLCAiYWpheFN1Y2Nlc3MiLCAiYWpheFNlbmQiIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkgewoJalF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7CgkJcmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7Cgl9Owp9KTsKCgpqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkgewoJcmV0dXJuIGpRdWVyeS5hamF4KHsKCQl1cmw6IHVybCwKCQl0eXBlOiAiR0VUIiwKCQlkYXRhVHlwZTogInNjcmlwdCIsCgkJYXN5bmM6IGZhbHNlLAoJCWdsb2JhbDogZmFsc2UsCgkJInRocm93cyI6IHRydWUKCX0pOwp9OwoKCmpRdWVyeS5mbi5leHRlbmQoewoJd3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7CgkJaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkgewoJCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHsKCQkJCWpRdWVyeSh0aGlzKS53cmFwQWxsKCBodG1sLmNhbGwodGhpcywgaSkgKTsKCQkJfSk7CgkJfQoKCQlpZiAoIHRoaXNbMF0gKSB7CgkJCS8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kCgkJCXZhciB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQgKS5lcSgwKS5jbG9uZSh0cnVlKTsKCgkJCWlmICggdGhpc1swXS5wYXJlbnROb2RlICkgewoJCQkJd3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbMF0gKTsKCQkJfQoKCQkJd3JhcC5tYXAoZnVuY3Rpb24oKSB7CgkJCQl2YXIgZWxlbSA9IHRoaXM7CgoJCQkJd2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgJiYgZWxlbS5maXJzdENoaWxkLm5vZGVUeXBlID09PSAxICkgewoJCQkJCWVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7CgkJCQl9CgoJCQkJcmV0dXJuIGVsZW07CgkJCX0pLmFwcGVuZCggdGhpcyApOwoJCX0KCgkJcmV0dXJuIHRoaXM7Cgl9LAoKCXdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7CgkJaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkgewoJCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHsKCQkJCWpRdWVyeSh0aGlzKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApOwoJCQl9KTsKCQl9CgoJCXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7CgkJCXZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksCgkJCQljb250ZW50cyA9IHNlbGYuY29udGVudHMoKTsKCgkJCWlmICggY29udGVudHMubGVuZ3RoICkgewoJCQkJY29udGVudHMud3JhcEFsbCggaHRtbCApOwoKCQkJfSBlbHNlIHsKCQkJCXNlbGYuYXBwZW5kKCBodG1sICk7CgkJCX0KCQl9KTsKCX0sCgoJd3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7CgkJdmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApOwoKCQlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHsKCQkJalF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTsKCQl9KTsKCX0sCgoJdW53cmFwOiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkgewoJCQlpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsICJib2R5IiApICkgewoJCQkJalF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApOwoJCQl9CgkJfSkuZW5kKCk7Cgl9Cn0pOwoKCmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7CgkvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMgoJLy8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50cwoJcmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwIHx8CgkJKCFzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cygpICYmCgkJCSgoZWxlbS5zdHlsZSAmJiBlbGVtLnN0eWxlLmRpc3BsYXkpIHx8IGpRdWVyeS5jc3MoIGVsZW0sICJkaXNwbGF5IiApKSA9PT0gIm5vbmUiKTsKfTsKCmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkgewoJcmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApOwp9OwoKCgoKdmFyIHIyMCA9IC8lMjAvZywKCXJicmFja2V0ID0gL1xbXF0kLywKCXJDUkxGID0gL1xyP1xuL2csCglyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksCglyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7CgpmdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7Cgl2YXIgbmFtZTsKCglpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHsKCQkvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS4KCQlqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHsKCQkJaWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHsKCQkJCS8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci4KCQkJCWFkZCggcHJlZml4LCB2ICk7CgoJCQl9IGVsc2UgewoJCQkJLy8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguCgkJCQlidWlsZFBhcmFtcyggcHJlZml4ICsgIlsiICsgKCB0eXBlb2YgdiA9PT0gIm9iamVjdCIgPyBpIDogIiIgKSArICJdIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApOwoJCQl9CgkJfSk7CgoJfSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gIm9iamVjdCIgKSB7CgkJLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLgoJCWZvciAoIG5hbWUgaW4gb2JqICkgewoJCQlidWlsZFBhcmFtcyggcHJlZml4ICsgIlsiICsgbmFtZSArICJdIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTsKCQl9CgoJfSBlbHNlIHsKCQkvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uCgkJYWRkKCBwcmVmaXgsIG9iaiApOwoJfQp9CgovLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZgovLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmcKalF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkgewoJdmFyIHByZWZpeCwKCQlzID0gW10sCgkJYWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7CgkJCS8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZQoJCQl2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/ICIiIDogdmFsdWUgKTsKCQkJc1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyAiPSIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7CgkJfTsKCgkvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLgoJaWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkgewoJCXRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsOwoJfQoKCS8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuCglpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkgewoJCS8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50cwoJCWpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHsKCQkJYWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTsKCQl9KTsKCgl9IGVsc2UgewoJCS8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlICJvbGQiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlcgoJCS8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LgoJCWZvciAoIHByZWZpeCBpbiBhICkgewoJCQlidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApOwoJCX0KCX0KCgkvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uCglyZXR1cm4gcy5qb2luKCAiJiIgKS5yZXBsYWNlKCByMjAsICIrIiApOwp9OwoKalF1ZXJ5LmZuLmV4dGVuZCh7CglzZXJpYWxpemU6IGZ1bmN0aW9uKCkgewoJCXJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApOwoJfSwKCXNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7CgkJCS8vIENhbiBhZGQgcHJvcEhvb2sgZm9yICJlbGVtZW50cyIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzCgkJCXZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCAiZWxlbWVudHMiICk7CgkJCXJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzOwoJCX0pCgkJLmZpbHRlcihmdW5jdGlvbigpIHsKCQkJdmFyIHR5cGUgPSB0aGlzLnR5cGU7CgkJCS8vIFVzZSAuaXMoIjpkaXNhYmxlZCIpIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzCgkJCXJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCAiOmRpc2FibGVkIiApICYmCgkJCQlyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmCgkJCQkoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7CgkJfSkKCQkubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkgewoJCQl2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7CgoJCQlyZXR1cm4gdmFsID09IG51bGwgPwoJCQkJbnVsbCA6CgkJCQlqUXVlcnkuaXNBcnJheSggdmFsICkgPwoJCQkJCWpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHsKCQkJCQkJcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCAiXHJcbiIgKSB9OwoJCQkJCX0pIDoKCQkJCQl7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgIlxyXG4iICkgfTsKCQl9KS5nZXQoKTsKCX0KfSk7CgoKLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdAovLyAoVGhpcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBhamF4U2V0dGluZ3MgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpCmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgIT09IHVuZGVmaW5lZCA/CgkvLyBTdXBwb3J0OiBJRTYrCglmdW5jdGlvbigpIHsKCgkJLy8gWEhSIGNhbm5vdCBhY2Nlc3MgbG9jYWwgZmlsZXMsIGFsd2F5cyB1c2UgQWN0aXZlWCBmb3IgdGhhdCBjYXNlCgkJcmV0dXJuICF0aGlzLmlzTG9jYWwgJiYKCgkJCS8vIFN1cHBvcnQ6IElFNy04CgkJCS8vIG9sZElFIFhIUiBkb2VzIG5vdCBzdXBwb3J0IG5vbi1SRkMyNjE2IG1ldGhvZHMgKCMxMzI0MCkKCQkJLy8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNjY0OCh2PXZzLjg1KS5hc3B4CgkJCS8vIGFuZCBodHRwOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzkuaHRtbCNzZWM5CgkJCS8vIEFsdGhvdWdoIHRoaXMgY2hlY2sgZm9yIHNpeCBtZXRob2RzIGluc3RlYWQgb2YgZWlnaHQKCQkJLy8gc2luY2UgSUUgYWxzbyBkb2VzIG5vdCBzdXBwb3J0ICJ0cmFjZSIgYW5kICJjb25uZWN0IgoJCQkvXihnZXR8cG9zdHxoZWFkfHB1dHxkZWxldGV8b3B0aW9ucykkL2kudGVzdCggdGhpcy50eXBlICkgJiYKCgkJCWNyZWF0ZVN0YW5kYXJkWEhSKCkgfHwgY3JlYXRlQWN0aXZlWEhSKCk7Cgl9IDoKCS8vIEZvciBhbGwgb3RoZXIgYnJvd3NlcnMsIHVzZSB0aGUgc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0CgljcmVhdGVTdGFuZGFyZFhIUjsKCnZhciB4aHJJZCA9IDAsCgl4aHJDYWxsYmFja3MgPSB7fSwKCXhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7CgovLyBTdXBwb3J0OiBJRTwxMAovLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKQppZiAoIHdpbmRvdy5BY3RpdmVYT2JqZWN0ICkgewoJalF1ZXJ5KCB3aW5kb3cgKS5vbiggInVubG9hZCIsIGZ1bmN0aW9uKCkgewoJCWZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkgewoJCQl4aHJDYWxsYmFja3NbIGtleSBdKCB1bmRlZmluZWQsIHRydWUgKTsKCQl9Cgl9KTsKfQoKLy8gRGV0ZXJtaW5lIHN1cHBvcnQgcHJvcGVydGllcwpzdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoICJ3aXRoQ3JlZGVudGlhbHMiIGluIHhoclN1cHBvcnRlZCApOwp4aHJTdXBwb3J0ZWQgPSBzdXBwb3J0LmFqYXggPSAhIXhoclN1cHBvcnRlZDsKCi8vIENyZWF0ZSB0cmFuc3BvcnQgaWYgdGhlIGJyb3dzZXIgY2FuIHByb3ZpZGUgYW4geGhyCmlmICggeGhyU3VwcG9ydGVkICkgewoKCWpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBvcHRpb25zICkgewoJCS8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3QKCQlpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluIHx8IHN1cHBvcnQuY29ycyApIHsKCgkJCXZhciBjYWxsYmFjazsKCgkJCXJldHVybiB7CgkJCQlzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7CgkJCQkJdmFyIGksCgkJCQkJCXhociA9IG9wdGlvbnMueGhyKCksCgkJCQkJCWlkID0gKyt4aHJJZDsKCgkJCQkJLy8gT3BlbiB0aGUgc29ja2V0CgkJCQkJeGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTsKCgkJCQkJLy8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZAoJCQkJCWlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7CgkJCQkJCWZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7CgkJCQkJCQl4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07CgkJCQkJCX0KCQkJCQl9CgoJCQkJCS8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWQKCQkJCQlpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7CgkJCQkJCXhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7CgkJCQkJfQoKCQkJCQkvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlcgoJCQkJCS8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmUKCQkJCQkvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLgoJCQkJCS8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKQoJCQkJCS8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLgoJCQkJCWlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIlgtUmVxdWVzdGVkLVdpdGgiXSApIHsKCQkJCQkJaGVhZGVyc1siWC1SZXF1ZXN0ZWQtV2l0aCJdID0gIlhNTEh0dHBSZXF1ZXN0IjsKCQkJCQl9CgoJCQkJCS8vIFNldCBoZWFkZXJzCgkJCQkJZm9yICggaSBpbiBoZWFkZXJzICkgewoJCQkJCQkvLyBTdXBwb3J0OiBJRTw5CgkJCQkJCS8vIElFJ3MgQWN0aXZlWE9iamVjdCB0aHJvd3MgYSAnVHlwZSBNaXNtYXRjaCcgZXhjZXB0aW9uIHdoZW4gc2V0dGluZwoJCQkJCQkvLyByZXF1ZXN0IGhlYWRlciB0byBhIG51bGwtdmFsdWUuCgkJCQkJCS8vCgkJCQkJCS8vIFRvIGtlZXAgY29uc2lzdGVudCB3aXRoIG90aGVyIFhIUiBpbXBsZW1lbnRhdGlvbnMsIGNhc3QgdGhlIHZhbHVlCgkJCQkJCS8vIHRvIHN0cmluZyBhbmQgaWdub3JlIGB1bmRlZmluZWRgLgoJCQkJCQlpZiAoIGhlYWRlcnNbIGkgXSAhPT0gdW5kZWZpbmVkICkgewoJCQkJCQkJeGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSArICIiICk7CgkJCQkJCX0KCQkJCQl9CgoJCQkJCS8vIERvIHNlbmQgdGhlIHJlcXVlc3QKCQkJCQkvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHkKCQkJCQkvLyBoYW5kbGVkIGluIGpRdWVyeS5hamF4IChzbyBubyB0cnkvY2F0Y2ggaGVyZSkKCQkJCQl4aHIuc2VuZCggKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhICkgfHwgbnVsbCApOwoKCQkJCQkvLyBMaXN0ZW5lcgoJCQkJCWNhbGxiYWNrID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7CgkJCQkJCXZhciBzdGF0dXMsIHN0YXR1c1RleHQsIHJlc3BvbnNlczsKCgkJCQkJCS8vIFdhcyBuZXZlciBjYWxsZWQgYW5kIGlzIGFib3J0ZWQgb3IgY29tcGxldGUKCQkJCQkJaWYgKCBjYWxsYmFjayAmJiAoIGlzQWJvcnQgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDQgKSApIHsKCQkJCQkJCS8vIENsZWFuIHVwCgkJCQkJCQlkZWxldGUgeGhyQ2FsbGJhY2tzWyBpZCBdOwoJCQkJCQkJY2FsbGJhY2sgPSB1bmRlZmluZWQ7CgkJCQkJCQl4aHIub25yZWFkeXN0YXRlY2hhbmdlID0galF1ZXJ5Lm5vb3A7CgoJCQkJCQkJLy8gQWJvcnQgbWFudWFsbHkgaWYgbmVlZGVkCgkJCQkJCQlpZiAoIGlzQWJvcnQgKSB7CgkJCQkJCQkJaWYgKCB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHsKCQkJCQkJCQkJeGhyLmFib3J0KCk7CgkJCQkJCQkJfQoJCQkJCQkJfSBlbHNlIHsKCQkJCQkJCQlyZXNwb25zZXMgPSB7fTsKCQkJCQkJCQlzdGF0dXMgPSB4aHIuc3RhdHVzOwoKCQkJCQkJCQkvLyBTdXBwb3J0OiBJRTwxMAoJCQkJCQkJCS8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvbgoJCQkJCQkJCS8vICgjMTE0MjYpCgkJCQkJCQkJaWYgKCB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gInN0cmluZyIgKSB7CgkJCQkJCQkJCXJlc3BvbnNlcy50ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDsKCQkJCQkJCQl9CgoJCQkJCQkJCS8vIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZwoJCQkJCQkJCS8vIHN0YXR1c1RleHQgZm9yIGZhdWx0eSBjcm9zcy1kb21haW4gcmVxdWVzdHMKCQkJCQkJCQl0cnkgewoJCQkJCQkJCQlzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHQ7CgkJCQkJCQkJfSBjYXRjaCggZSApIHsKCQkJCQkJCQkJLy8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0CgkJCQkJCQkJCXN0YXR1c1RleHQgPSAiIjsKCQkJCQkJCQl9CgoJCQkJCQkJCS8vIEZpbHRlciBzdGF0dXMgZm9yIG5vbiBzdGFuZGFyZCBiZWhhdmlvcnMKCgkJCQkJCQkJLy8gSWYgdGhlIHJlcXVlc3QgaXMgbG9jYWwgYW5kIHdlIGhhdmUgZGF0YTogYXNzdW1lIGEgc3VjY2VzcwoJCQkJCQkJCS8vIChzdWNjZXNzIHdpdGggbm8gZGF0YSB3b24ndCBnZXQgbm90aWZpZWQsIHRoYXQncyB0aGUgYmVzdCB3ZQoJCQkJCQkJCS8vIGNhbiBkbyBnaXZlbiBjdXJyZW50IGltcGxlbWVudGF0aW9ucykKCQkJCQkJCQlpZiAoICFzdGF0dXMgJiYgb3B0aW9ucy5pc0xvY2FsICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkgewoJCQkJCQkJCQlzdGF0dXMgPSByZXNwb25zZXMudGV4dCA/IDIwMCA6IDQwNDsKCQkJCQkJCQkvLyBJRSAtICMxNDUwOiBzb21ldGltZXMgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNAoJCQkJCQkJCX0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMTIyMyApIHsKCQkJCQkJCQkJc3RhdHVzID0gMjA0OwoJCQkJCQkJCX0KCQkJCQkJCX0KCQkJCQkJfQoKCQkJCQkJLy8gQ2FsbCBjb21wbGV0ZSBpZiBuZWVkZWQKCQkJCQkJaWYgKCByZXNwb25zZXMgKSB7CgkJCQkJCQljb21wbGV0ZSggc3RhdHVzLCBzdGF0dXNUZXh0LCByZXNwb25zZXMsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSApOwoJCQkJCQl9CgkJCQkJfTsKCgkJCQkJaWYgKCAhb3B0aW9ucy5hc3luYyApIHsKCQkJCQkJLy8gaWYgd2UncmUgaW4gc3luYyBtb2RlIHdlIGZpcmUgdGhlIGNhbGxiYWNrCgkJCQkJCWNhbGxiYWNrKCk7CgkJCQkJfSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7CgkJCQkJCS8vIChJRTYgJiBJRTcpIGlmIGl0J3MgaW4gY2FjaGUgYW5kIGhhcyBiZWVuCgkJCQkJCS8vIHJldHJpZXZlZCBkaXJlY3RseSB3ZSBuZWVkIHRvIGZpcmUgdGhlIGNhbGxiYWNrCgkJCQkJCXNldFRpbWVvdXQoIGNhbGxiYWNrICk7CgkJCQkJfSBlbHNlIHsKCQkJCQkJLy8gQWRkIHRvIHRoZSBsaXN0IG9mIGFjdGl2ZSB4aHIgY2FsbGJhY2tzCgkJCQkJCXhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHJDYWxsYmFja3NbIGlkIF0gPSBjYWxsYmFjazsKCQkJCQl9CgkJCQl9LAoKCQkJCWFib3J0OiBmdW5jdGlvbigpIHsKCQkJCQlpZiAoIGNhbGxiYWNrICkgewoJCQkJCQljYWxsYmFjayggdW5kZWZpbmVkLCB0cnVlICk7CgkJCQkJfQoJCQkJfQoJCQl9OwoJCX0KCX0pOwp9CgovLyBGdW5jdGlvbnMgdG8gY3JlYXRlIHhocnMKZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRYSFIoKSB7Cgl0cnkgewoJCXJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7Cgl9IGNhdGNoKCBlICkge30KfQoKZnVuY3Rpb24gY3JlYXRlQWN0aXZlWEhSKCkgewoJdHJ5IHsKCQlyZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCAiTWljcm9zb2Z0LlhNTEhUVFAiICk7Cgl9IGNhdGNoKCBlICkge30KfQoKCgoKLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGUKalF1ZXJ5LmFqYXhTZXR1cCh7CglhY2NlcHRzOiB7CgkJc2NyaXB0OiAidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHQiCgl9LAoJY29udGVudHM6IHsKCQlzY3JpcHQ6IC8oPzpqYXZhfGVjbWEpc2NyaXB0LwoJfSwKCWNvbnZlcnRlcnM6IHsKCQkidGV4dCBzY3JpcHQiOiBmdW5jdGlvbiggdGV4dCApIHsKCQkJalF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTsKCQkJcmV0dXJuIHRleHQ7CgkJfQoJfQp9KTsKCi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgZ2xvYmFsCmpRdWVyeS5hamF4UHJlZmlsdGVyKCAic2NyaXB0IiwgZnVuY3Rpb24oIHMgKSB7CglpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHsKCQlzLmNhY2hlID0gZmFsc2U7Cgl9CglpZiAoIHMuY3Jvc3NEb21haW4gKSB7CgkJcy50eXBlID0gIkdFVCI7CgkJcy5nbG9iYWwgPSBmYWxzZTsKCX0KfSk7CgovLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnQKalF1ZXJ5LmFqYXhUcmFuc3BvcnQoICJzY3JpcHQiLCBmdW5jdGlvbihzKSB7CgoJLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0cwoJaWYgKCBzLmNyb3NzRG9tYWluICkgewoKCQl2YXIgc2NyaXB0LAoJCQloZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBqUXVlcnkoImhlYWQiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7CgoJCXJldHVybiB7CgoJCQlzZW5kOiBmdW5jdGlvbiggXywgY2FsbGJhY2sgKSB7CgoJCQkJc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7CgoJCQkJc2NyaXB0LmFzeW5jID0gdHJ1ZTsKCgkJCQlpZiAoIHMuc2NyaXB0Q2hhcnNldCApIHsKCQkJCQlzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDsKCQkJCX0KCgkJCQlzY3JpcHQuc3JjID0gcy51cmw7CgoJCQkJLy8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnMKCQkJCXNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7CgoJCQkJCWlmICggaXNBYm9ydCB8fCAhc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdCggc2NyaXB0LnJlYWR5U3RhdGUgKSApIHsKCgkJCQkJCS8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRQoJCQkJCQlzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7CgoJCQkJCQkvLyBSZW1vdmUgdGhlIHNjcmlwdAoJCQkJCQlpZiAoIHNjcmlwdC5wYXJlbnROb2RlICkgewoJCQkJCQkJc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApOwoJCQkJCQl9CgoJCQkJCQkvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0CgkJCQkJCXNjcmlwdCA9IG51bGw7CgoJCQkJCQkvLyBDYWxsYmFjayBpZiBub3QgYWJvcnQKCQkJCQkJaWYgKCAhaXNBYm9ydCApIHsKCQkJCQkJCWNhbGxiYWNrKCAyMDAsICJzdWNjZXNzIiApOwoJCQkJCQl9CgkJCQkJfQoJCQkJfTsKCgkJCQkvLyBDaXJjdW12ZW50IElFNiBidWdzIHdpdGggYmFzZSBlbGVtZW50cyAoIzI3MDkgYW5kICM0Mzc4KSBieSBwcmVwZW5kaW5nCgkJCQkvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnkKCQkJCWhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApOwoJCQl9LAoKCQkJYWJvcnQ6IGZ1bmN0aW9uKCkgewoJCQkJaWYgKCBzY3JpcHQgKSB7CgkJCQkJc2NyaXB0Lm9ubG9hZCggdW5kZWZpbmVkLCB0cnVlICk7CgkJCQl9CgkJCX0KCQl9OwoJfQp9KTsKCgoKCnZhciBvbGRDYWxsYmFja3MgPSBbXSwKCXJqc29ucCA9IC8oPSlcPyg/PSZ8JCl8XD9cPy87CgovLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzCmpRdWVyeS5hamF4U2V0dXAoewoJanNvbnA6ICJjYWxsYmFjayIsCglqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHsKCQl2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArICJfIiArICggbm9uY2UrKyApICk7CgkJdGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7CgkJcmV0dXJuIGNhbGxiYWNrOwoJfQp9KTsKCi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0cwpqUXVlcnkuYWpheFByZWZpbHRlciggImpzb24ganNvbnAiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7CgoJdmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLAoJCWpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/CgkJCSJ1cmwiIDoKCQkJdHlwZW9mIHMuZGF0YSA9PT0gInN0cmluZyIgJiYgISggcy5jb250ZW50VHlwZSB8fCAiIiApLmluZGV4T2YoImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiAiZGF0YSIKCQkpOwoKCS8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyAianNvbnAiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0CglpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09ICJqc29ucCIgKSB7CgoJCS8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXQKCQljYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgPwoJCQlzLmpzb25wQ2FsbGJhY2soKSA6CgkJCXMuanNvbnBDYWxsYmFjazsKCgkJLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YQoJCWlmICgganNvblByb3AgKSB7CgkJCXNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgIiQxIiArIGNhbGxiYWNrTmFtZSApOwoJCX0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkgewoJCQlzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gIiYiIDogIj8iICkgKyBzLmpzb25wICsgIj0iICsgY2FsbGJhY2tOYW1lOwoJCX0KCgkJLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvbgoJCXMuY29udmVydGVyc1sic2NyaXB0IGpzb24iXSA9IGZ1bmN0aW9uKCkgewoJCQlpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHsKCQkJCWpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgIiB3YXMgbm90IGNhbGxlZCIgKTsKCQkJfQoJCQlyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTsKCQl9OwoKCQkvLyBmb3JjZSBqc29uIGRhdGFUeXBlCgkJcy5kYXRhVHlwZXNbIDAgXSA9ICJqc29uIjsKCgkJLy8gSW5zdGFsbCBjYWxsYmFjawoJCW92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTsKCQl3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7CgkJCXJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzOwoJCX07CgoJCS8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKQoJCWpxWEhSLmFsd2F5cyhmdW5jdGlvbigpIHsKCQkJLy8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZQoJCQl3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47CgoJCQkvLyBTYXZlIGJhY2sgYXMgZnJlZQoJCQlpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkgewoJCQkJLy8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kCgkJCQlzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7CgoJCQkJLy8gc2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZQoJCQkJb2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApOwoJCQl9CgoJCQkvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2UKCQkJaWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHsKCQkJCW92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7CgkJCX0KCgkJCXJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7CgkJfSk7CgoJCS8vIERlbGVnYXRlIHRvIHNjcmlwdAoJCXJldHVybiAic2NyaXB0IjsKCX0KfSk7CgoKCgovLyBkYXRhOiBzdHJpbmcgb2YgaHRtbAovLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsIGRlZmF1bHRzIHRvIGRvY3VtZW50Ci8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmcKalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHsKCWlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICJzdHJpbmciICkgewoJCXJldHVybiBudWxsOwoJfQoJaWYgKCB0eXBlb2YgY29udGV4dCA9PT0gImJvb2xlYW4iICkgewoJCWtlZXBTY3JpcHRzID0gY29udGV4dDsKCQljb250ZXh0ID0gZmFsc2U7Cgl9Cgljb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDsKCgl2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksCgkJc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTsKCgkvLyBTaW5nbGUgdGFnCglpZiAoIHBhcnNlZCApIHsKCQlyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07Cgl9CgoJcGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7CgoJaWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkgewoJCWpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpOwoJfQoKCXJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApOwp9OwoKCi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2QKdmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7CgovKioKICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZQogKi8KalF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkgewoJaWYgKCB0eXBlb2YgdXJsICE9PSAic3RyaW5nIiAmJiBfbG9hZCApIHsKCQlyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOwoJfQoKCXZhciBzZWxlY3RvciwgcmVzcG9uc2UsIHR5cGUsCgkJc2VsZiA9IHRoaXMsCgkJb2ZmID0gdXJsLmluZGV4T2YoIiAiKTsKCglpZiAoIG9mZiA+PSAwICkgewoJCXNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmLCB1cmwubGVuZ3RoICkgKTsKCQl1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApOwoJfQoKCS8vIElmIGl0J3MgYSBmdW5jdGlvbgoJaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7CgoJCS8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrCgkJY2FsbGJhY2sgPSBwYXJhbXM7CgkJcGFyYW1zID0gdW5kZWZpbmVkOwoKCS8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmcKCX0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSAib2JqZWN0IiApIHsKCQl0eXBlID0gIlBPU1QiOwoJfQoKCS8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0CglpZiAoIHNlbGYubGVuZ3RoID4gMCApIHsKCQlqUXVlcnkuYWpheCh7CgkJCXVybDogdXJsLAoKCQkJLy8gaWYgInR5cGUiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiAiR0VUIiBtZXRob2Qgd2lsbCBiZSB1c2VkCgkJCXR5cGU6IHR5cGUsCgkJCWRhdGFUeXBlOiAiaHRtbCIsCgkJCWRhdGE6IHBhcmFtcwoJCX0pLmRvbmUoZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHsKCgkJCS8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFjawoJCQlyZXNwb25zZSA9IGFyZ3VtZW50czsKCgkJCXNlbGYuaHRtbCggc2VsZWN0b3IgPwoKCQkJCS8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdgoJCQkJLy8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzCgkJCQlqUXVlcnkoIjxkaXY+IikuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOgoKCQkJCS8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0CgkJCQlyZXNwb25zZVRleHQgKTsKCgkJfSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkgewoJCQlzZWxmLmVhY2goIGNhbGxiYWNrLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7CgkJfSk7Cgl9CgoJcmV0dXJuIHRoaXM7Cn07CgoKCgpqUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7CglyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkgewoJCXJldHVybiBlbGVtID09PSBmbi5lbGVtOwoJfSkubGVuZ3RoOwp9OwoKCgoKCnZhciBkb2NFbGVtID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsKCi8qKgogKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudAogKi8KZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkgewoJcmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8KCQllbGVtIDoKCQllbGVtLm5vZGVUeXBlID09PSA5ID8KCQkJZWxlbS5kZWZhdWx0VmlldyB8fCBlbGVtLnBhcmVudFdpbmRvdyA6CgkJCWZhbHNlOwp9CgpqUXVlcnkub2Zmc2V0ID0gewoJc2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHsKCQl2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLAoJCQlwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sICJwb3NpdGlvbiIgKSwKCQkJY3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLAoJCQlwcm9wcyA9IHt9OwoKCQkvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtCgkJaWYgKCBwb3NpdGlvbiA9PT0gInN0YXRpYyIgKSB7CgkJCWVsZW0uc3R5bGUucG9zaXRpb24gPSAicmVsYXRpdmUiOwoJCX0KCgkJY3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTsKCQljdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCAidG9wIiApOwoJCWN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCAibGVmdCIgKTsKCQljYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09ICJhYnNvbHV0ZSIgfHwgcG9zaXRpb24gPT09ICJmaXhlZCIgKSAmJgoJCQlqUXVlcnkuaW5BcnJheSgiYXV0byIsIFsgY3VyQ1NTVG9wLCBjdXJDU1NMZWZ0IF0gKSA+IC0xOwoKCQkvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWQKCQlpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkgewoJCQljdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTsKCQkJY3VyVG9wID0gY3VyUG9zaXRpb24udG9wOwoJCQljdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDsKCQl9IGVsc2UgewoJCQljdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwOwoJCQljdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7CgkJfQoKCQlpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7CgkJCW9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApOwoJCX0KCgkJaWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkgewoJCQlwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wOwoJCX0KCQlpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkgewoJCQlwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDsKCQl9CgoJCWlmICggInVzaW5nIiBpbiBvcHRpb25zICkgewoJCQlvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7CgkJfSBlbHNlIHsKCQkJY3VyRWxlbS5jc3MoIHByb3BzICk7CgkJfQoJfQp9OwoKalF1ZXJ5LmZuLmV4dGVuZCh7CglvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkgewoJCWlmICggYXJndW1lbnRzLmxlbmd0aCApIHsKCQkJcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/CgkJCQl0aGlzIDoKCQkJCXRoaXMuZWFjaChmdW5jdGlvbiggaSApIHsKCQkJCQlqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApOwoJCQkJfSk7CgkJfQoKCQl2YXIgZG9jRWxlbSwgd2luLAoJCQlib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LAoJCQllbGVtID0gdGhpc1sgMCBdLAoJCQlkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDsKCgkJaWYgKCAhZG9jICkgewoJCQlyZXR1cm47CgkJfQoKCQlkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDsKCgkJLy8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlCgkJaWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7CgkJCXJldHVybiBib3g7CgkJfQoKCQkvLyBJZiB3ZSBkb24ndCBoYXZlIGdCQ1IsIGp1c3QgdXNlIDAsMCByYXRoZXIgdGhhbiBlcnJvcgoJCS8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkKCQlpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gc3RydW5kZWZpbmVkICkgewoJCQlib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwoJCX0KCQl3aW4gPSBnZXRXaW5kb3coIGRvYyApOwoJCXJldHVybiB7CgkJCXRvcDogYm94LnRvcCAgKyAoIHdpbi5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCApICAtICggZG9jRWxlbS5jbGllbnRUb3AgIHx8IDAgKSwKCQkJbGVmdDogYm94LmxlZnQgKyAoIHdpbi5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQgKSAtICggZG9jRWxlbS5jbGllbnRMZWZ0IHx8IDAgKQoJCX07Cgl9LAoKCXBvc2l0aW9uOiBmdW5jdGlvbigpIHsKCQlpZiAoICF0aGlzWyAwIF0gKSB7CgkJCXJldHVybjsKCQl9CgoJCXZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwKCQkJcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSwKCQkJZWxlbSA9IHRoaXNbIDAgXTsKCgkJLy8gZml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50CgkJaWYgKCBqUXVlcnkuY3NzKCBlbGVtLCAicG9zaXRpb24iICkgPT09ICJmaXhlZCIgKSB7CgkJCS8vIHdlIGFzc3VtZSB0aGF0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBhdmFpbGFibGUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZAoJCQlvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwoJCX0gZWxzZSB7CgkJCS8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50CgkJCW9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7CgoJCQkvLyBHZXQgY29ycmVjdCBvZmZzZXRzCgkJCW9mZnNldCA9IHRoaXMub2Zmc2V0KCk7CgkJCWlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sICJodG1sIiApICkgewoJCQkJcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpOwoJCQl9CgoJCQkvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnMKCQkJcGFyZW50T2Zmc2V0LnRvcCAgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sICJib3JkZXJUb3BXaWR0aCIsIHRydWUgKTsKCQkJcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sICJib3JkZXJMZWZ0V2lkdGgiLCB0cnVlICk7CgkJfQoKCQkvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zCgkJLy8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnQKCQkvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMAoJCXJldHVybiB7CgkJCXRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sICJtYXJnaW5Ub3AiLCB0cnVlICksCgkJCWxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCAibWFyZ2luTGVmdCIsIHRydWUpCgkJfTsKCX0sCgoJb2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHsKCQlyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7CgkJCXZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtOwoKCQkJd2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnQsICJodG1sIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgInBvc2l0aW9uIiApID09PSAic3RhdGljIiApICkgewoJCQkJb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDsKCQkJfQoJCQlyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07CgkJfSk7Cgl9Cn0pOwoKLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzCmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6ICJwYWdlWE9mZnNldCIsIHNjcm9sbFRvcDogInBhZ2VZT2Zmc2V0IiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkgewoJdmFyIHRvcCA9IC9ZLy50ZXN0KCBwcm9wICk7CgoJalF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7CgkJcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkgewoJCQl2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7CgoJCQlpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkgewoJCQkJcmV0dXJuIHdpbiA/IChwcm9wIGluIHdpbikgPyB3aW5bIHByb3AgXSA6CgkJCQkJd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgbWV0aG9kIF0gOgoJCQkJCWVsZW1bIG1ldGhvZCBdOwoJCQl9CgoJCQlpZiAoIHdpbiApIHsKCQkJCXdpbi5zY3JvbGxUbygKCQkJCQkhdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxMZWZ0KCksCgkJCQkJdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKQoJCQkJKTsKCgkJCX0gZWxzZSB7CgkJCQllbGVtWyBtZXRob2QgXSA9IHZhbDsKCQkJfQoJCX0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoLCBudWxsICk7Cgl9Owp9KTsKCi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uCi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NAovLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0Ci8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCB3ZSBqdXN0IGNoZWNrIGZvciBpdCBoZXJlCmpRdWVyeS5lYWNoKCBbICJ0b3AiLCAibGVmdCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7CglqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLAoJCWZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHsKCQkJaWYgKCBjb21wdXRlZCApIHsKCQkJCWNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7CgkJCQkvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXQKCQkJCXJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/CgkJCQkJalF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgInB4IiA6CgkJCQkJY29tcHV0ZWQ7CgkJCX0KCQl9CgkpOwp9KTsKCgovLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHMKalF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiAiaGVpZ2h0IiwgV2lkdGg6ICJ3aWR0aCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7CglqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiAiaW5uZXIiICsgbmFtZSwgY29udGVudDogdHlwZSwgIiI6ICJvdXRlciIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkgewoJCS8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aAoJCWpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkgewoJCQl2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSAiYm9vbGVhbiIgKSwKCQkJCWV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gIm1hcmdpbiIgOiAiYm9yZGVyIiApOwoKCQkJcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkgewoJCQkJdmFyIGRvYzsKCgkJCQlpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkgewoJCQkJCS8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlCgkJCQkJLy8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOgoJCQkJCS8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0CgkJCQkJcmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyAiY2xpZW50IiArIG5hbWUgXTsKCQkJCX0KCgkJCQkvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0CgkJCQlpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7CgkJCQkJZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7CgoJCQkJCS8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSwgd2hpY2hldmVyIGlzIGdyZWF0ZXN0CgkJCQkJLy8gdW5mb3J0dW5hdGVseSwgdGhpcyBjYXVzZXMgYnVnICMzODM4IGluIElFNi84IG9ubHksIGJ1dCB0aGVyZSBpcyBjdXJyZW50bHkgbm8gZ29vZCwgc21hbGwgd2F5IHRvIGZpeCBpdC4KCQkJCQlyZXR1cm4gTWF0aC5tYXgoCgkJCQkJCWVsZW0uYm9keVsgInNjcm9sbCIgKyBuYW1lIF0sIGRvY1sgInNjcm9sbCIgKyBuYW1lIF0sCgkJCQkJCWVsZW0uYm9keVsgIm9mZnNldCIgKyBuYW1lIF0sIGRvY1sgIm9mZnNldCIgKyBuYW1lIF0sCgkJCQkJCWRvY1sgImNsaWVudCIgKyBuYW1lIF0KCQkJCQkpOwoJCQkJfQoKCQkJCXJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8KCQkJCQkvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0CgkJCQkJalF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6CgoJCQkJCS8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQKCQkJCQlqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApOwoJCQl9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApOwoJCX07Cgl9KTsKfSk7CgoKLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQKalF1ZXJ5LmZuLnNpemUgPSBmdW5jdGlvbigpIHsKCXJldHVybiB0aGlzLmxlbmd0aDsKfTsKCmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7CgoKCgovLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXIKLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdAovLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3QKLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZQovLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2UKLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzCi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay4KCi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkCi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW4KLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUKLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vbgoKaWYgKCB0eXBlb2YgZGVmaW5lID09PSAiZnVuY3Rpb24iICYmIGRlZmluZS5hbWQgKSB7CglkZWZpbmUoICJqcXVlcnkiLCBbXSwgZnVuY3Rpb24oKSB7CgkJcmV0dXJuIGpRdWVyeTsKCX0pOwp9CgoKCgp2YXIKCS8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZQoJX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksCgoJLy8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGUKCV8kID0gd2luZG93LiQ7CgpqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkgewoJaWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkgewoJCXdpbmRvdy4kID0gXyQ7Cgl9CgoJaWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHsKCQl3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTsKCX0KCglyZXR1cm4galF1ZXJ5Owp9OwoKLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbgovLyBBTUQgKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KQovLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpCmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBzdHJ1bmRlZmluZWQgKSB7Cgl3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7Cn0KCgoKCnJldHVybiBqUXVlcnk7Cgp9KSk7Cg=="></script>
 <script data-sf-original-src=js/nav.js src=data:application/javascript;base64,JChmdW5jdGlvbiAoKSB7CiAgdmFyICRzaWRlYmFyID0gJCgnI3NpZGViYXItd3JhcHBlcicpOwogIHZhciAkdG9nZ2xlID0gJCgnI3RvZ2dsZS1zaWRlYmFyJyk7CgogICR0b2dnbGUuY2xpY2soZnVuY3Rpb24gKCkgewogICAgJHNpZGViYXIudG9nZ2xlQ2xhc3MoJ2V4cGFuZGVkJyk7CiAgfSk7CgogICRzaWRlYmFyLmZpbmQoJy5zaWRlYmFyLW5hdicpLmNsaWNrKGZ1bmN0aW9uICgpIHsKICAgICRzaWRlYmFyLnJlbW92ZUNsYXNzKCdleHBhbmRlZCcpOwogIH0pOwp9KTsK></script>
 
Providence Salumu
<script>document.currentScript.remove();!function(){"use strict";(t=>{const n="singlefile-infobar",e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8H+DhhoQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJJJREFUOI3t070NRCEMA2CnYAOyDyPwpHj/Va7hJ3FzV7zy3ET5JIwoAF6Jk4wzAJAkzxAYG9YRTgB+24wBgKmfrGAKTcEfAY4KRlRoIeBTgKOCERVaCPgU4Khge2GqKOBTgKOCERVaAEC/4PNcnyoSWHpjqkhwKxbcig0Q6AorXYF/+A6eIYD1lVbwG/jdA6/kA2THRAURVubcAAAAAElFTkSuQmCC",o="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8VC4EQ6QAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJtJREFUOI3NkrsBgCAMRLFwBPdxBArcfxXFkO8rbKWAAJfHJ9faf9vuYX/749T5NmShm3bEwbe2SxeuM4+2oxDL1cDoKtVUjRy+tH78Cv2CS+wIiQNC1AEhk4AQeUTMWUJMfUJMSEJMSEY8kIx4IONroaYAimNxsXp1PA7PxwfVL8QnowwoVC0lig07wDDVUjAdbAnjwtow/z/bDW7eI4M2KruJAAAAAElFTkSuQmCC",i="SingleFile",A="single-file-ui-element",r="\n\t.infobar {\n\t\tbackground-color: #737373;\n\t\tcolor: white;\n\t\tdisplay: flex;\n\t\tposition: fixed;\n\t\ttop: 16px;\n\t\tright: 16px;\n\t\theight: auto;\n\t\twidth: auto;\n\t\tmin-height: 24px;\n\t\tmin-width: 24px;\n\t\tbackground-position: center;\n\t\tbackground-repeat: no-repeat;\n\t\tz-index: 2147483647;\n\t\tmargin: 0 0 0 16px;\n\t\tbackground-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHADIRLMaOHwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAPUExURQAAAIqKioyNjY2OjvDw8L2y1DEAAAABdFJOUwBA5thmAAAAAWJLR0QB/wIt3gAAAGNJREFUSMdjYCAJsLi4OBCQx6/CBQwIGIDPCBcXAkYQUsACU+AwlBVQHg6Eg5pgZBGOboIJZugDFwRwoJECJCUOhJI1wZwzqmBUwagCuipgIqTABG9h7YIKaKGAURAFEF/6AQAO4HqSoDP8bgAAAABJRU5ErkJggg==);\n\t\tborder-radius: 16px;\n\t\tuser-select: none;\n\t\t-moz-user-select: none;\n\t\topacity: .7;\n\t\tcursor: pointer;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tpadding-top: 0;\n\t\tpadding-bottom: 0;\n\t\tborder: 2px solid #eee;\n\t\tbackground-size: 70% 70%;\n\t\ttransition: all 250ms;\n\t\tfont-size: 13px;\n\t}\n\t.infobar:hover {\n\t\topacity: 1;\n\t}\n\t.infobar-open {\n\t\topacity: 1;\n\t\tbackground-color: #f9f9f9;\n\t\tcursor: auto;\n\t\tcolor: #2d2d2d;\n\t\tpadding-top: 2px;\n\t\tpadding-bottom: 2px;\n\t\tborder: 2px solid #878787;\n\t\tbackground-image: none;\n\t\tborder-radius: 8px;\n\t\tuser-select: initial;\n\t\t-moz-user-select: initial;\n\t}\n\t.infobar-close-button {\n\t\tdisplay: none;\n\t\topacity: .7;\n\t\tpadding-top: 4px;\n\t\tpadding-left: 8px;\n\t\tpadding-right: 8px;\n\t\tcursor: pointer;\n\t\ttransition: opacity 250ms;\n\t\theight: 16px;\n\t}\n\t.infobar-close-button:hover {\n\t\topacity: 1;\n\t}\n\t.infobar-content {\n\t\tdisplay: none;\n\t\tfont-family: Arial;\n\t\tfont-size: 14px;\n\t\tline-height: 22px;\n\t\tword-break: break-word;\n\t\twhite-space: pre-wrap;\n\t\tposition: relative;\n\t\ttop: 1px;\n\t\ttext-align: left;\n\t}\n\t.infobar-link {\n\t\tdisplay: none;\n\t\tpadding-left: 8px;\n\t\tpadding-right: 8px;\n\t\tline-height: 11px;\n\t\tcursor: pointer;\n\t\tuser-select: none;\n\t\toutline: 0;\n\t}\n\t.infobar-link-icon {\n\t\tpadding-top: 4px;\n\t\tpadding-left: 2px;\n\t\tcursor: pointer;\n\t\topacity: .7;\n\t\ttransition: opacity 250ms;\n\t\theight: 16px;\n\t}\n\t.infobar-link-icon:hover {\n\t\topacity: 1;\n\t}\n\t.infobar-open .infobar-close-button, .infobar-open .infobar-content, .infobar-open .infobar-link {\n\t\tdisplay: inline-block;\n\t}";let a=!0;const c=t.browser;async function s(){const t=document.evaluate("//comment()",document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null);let s=t&&t.singleNodeValue;if(s&&((p=s).nodeType==Node.COMMENT_NODE&&p.textContent.includes(i))){const t=s.textContent.split("\n"),[,,i,...p]=t,g=i.match(/^ url: (.*) $/),h=g&&g[1];if(h){let t;if(c&&c.runtime&&c.runtime.sendMessage)try{t=await c.runtime.sendMessage({method:"tabs.getOptions",url:h})}catch(n){t={displayInfobar:!0}}else t={displayInfobar:!0};t.displayInfobar&&await async function(t,i){let c=document.querySelector(n);if(!c){let s="";if(i.length){const t=i[0].split("saved date: ")[1];if(t&&i.shift(),i.length>1){let t=i[0].split("info: ")[1].trim();for(let n=1;n<i.length-1;n++)t+="\n"+i[n].trim();s=t.trim()}else s=t}s=s||"No info",c=d(n,document.body),c.className=A;const p=await async function(t){if(t.attachShadow)return t.attachShadow({mode:"open"});{a=!1;const n=d("iframe",t);return n.style.setProperty("background-color","transparent","important"),n.style.setProperty("position","fixed","important"),n.style.setProperty("top",0,"important"),n.style.setProperty("right",0,"important"),n.style.setProperty("width","44px","important"),n.style.setProperty("height","48px","important"),n.style.setProperty("z-index",2147483647,"important"),new Promise((t=>{n.contentDocument.body.style.setProperty("margin",0),n.onload=()=>t(n.contentDocument.body)}))}}(c),g=document.createElement("style");g.textContent=r,p.appendChild(g);const h=document.createElement("div");h.classList.add("infobar"),p.appendChild(h);const u=document.createElement("img");u.classList.add("infobar-close-button"),h.appendChild(u),u.src=o,u.onclick=t=>{0===t.button&&c.remove()};const m=document.createElement("span");h.appendChild(m),m.classList.add("infobar-content"),m.textContent=s;const f=document.createElement("a");f.classList.add("infobar-link"),h.appendChild(f),f.target="_blank",f.rel="noopener noreferrer",f.title="Open source URL: "+t,f.href=t;const b=document.createElement("img");b.classList.add("infobar-link-icon"),f.appendChild(b),b.src=e,l(h),document.addEventListener("click",(t=>{if(0===t.button){let n=t.target;for(;n&&n!=c;)n=n.parentElement;n!=c&&l(h)}}))}}(h,p)}}var p}function l(t){if(t.classList.remove("infobar-open"),t.onclick=e=>{if(0===e.button)return function(t){a||document.querySelector(n).childNodes[0].contentWindow.getSelection().removeAllRanges();if(t.classList.add("infobar-open"),t.onclick=null,t.onmouseout=null,!a){const e=document.querySelector(n).childNodes[0];e.style.setProperty("width","100vw","important"),e.style.setProperty("height","100vh","important"),e.style.setProperty("width",t.getBoundingClientRect().width+33+"px","important"),e.style.setProperty("height",t.getBoundingClientRect().height+21+"px","important")}}(t),!1},!a){const t=document.querySelector(n).childNodes[0];t.style.setProperty("width","44px","important"),t.style.setProperty("height","48px","important")}}function d(t,n){const e=document.createElement(t);return n.appendChild(e),Array.from(getComputedStyle(e)).forEach((t=>e.style.setProperty(t,"initial","important"))),e}t.window==t.top&&("loading"==document.readyState?document.addEventListener("DOMContentLoaded",s,!1):s())})("object"==typeof globalThis?globalThis:window)}();
</script>