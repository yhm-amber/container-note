[knowsby:lunatic]: https://lunatic.solutions/blog/writing-rust-the-elixir-way-1.5-years-later "The message passing and pattern matching works really well in Elixir because it's a dynamically typed language. Once I tried to translate this patterns to Rust, I couldn't figure out a way of fitting them into Rust's strict type system. I had a look at what other rust message passing libraries do or how the messages are handled in Go, Gleam and others. This lead me to try a channel based approach. Each process can capture a set of channels from its parent that are used to receive messages of a specific type. This sounded like a reasonable approach at first, but once I tried it out in a bigger project I realized that it's super easy to deadlock yourself while you wait on the wrong message type. It just didn't feel right. /// Solving this problem was my main focus over the last 18 months. That, and rewriting the whole VM from scratch for a more modular design, but this story is for another post. With the recent release of version 0.9, I finally arrived at a point where I feel like we found a great balance between Elixir's patterns and Rust's type safety. Check out the release notes for code examples. // 消息传递和模式匹配在 Elixir 中运行得非常好，因为它是动态的 键入的语言。 当我尝试将这种模式转换为 Rust 时，我找不到一种方法 将它们放入 Rust 严格的类型系统中。 我查看了其他 Rust 消息传递 库的作用或消息在 Go 、 Gleam 中的处理方式 和别的。 这促使我尝试 基于渠道 的方法。 每个进程可以捕获一组 来自其父级的通道，用于接收特定类型的消息。 这听起来像 起初这是一个合理的方法，但是当我在一个更大的项目中尝试它时，我意识到它是 当您等待错误的消息类型时，非常容易陷入僵局。只是没感觉到正确。 /// 解决这个问题是我过去 18 个月的主要关注点。那，然后重写从头开始整个虚拟机的模块化设计，但这个故事是另一篇文章的。最近发布的 0.9 版本 ，我终于到达了一个点，我觉得我们找到了一个 Elixir 的模式和 Rust 的类型安全之间取得了很好的平衡。查看发行说明代码示例。"

[knowsby:caramel]: https://caramel.run/manual/getting-started/first-steps.html "Caramel is a language that relies on the Erlang VM, just like Elixir or Gleam. This means that we need to compile our code, and run it from within Erlang."
