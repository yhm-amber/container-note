[src/gh]: https://github.com/gleam-lang/gleam.git "(Apache-2.0) (Languages: Rust 93.7%, Gleam 2.1%, JavaScript 1.5%, HTML 1.0%, CSS 0.8%, Erlang 0.3%, Other 0.6%) ⭐️ A friendly language for building type-safe, scalable systems!"
[tour/site]: https://tour.gleam.run/
[site]: https://gleam.run/ " Gleam makes it easy to use code written in other BEAM languages such as Erlang and Elixir, so there's a rich ecosystem of thousands of open source libraries for Gleam users to make use of. /// Gleam can additionally compile to JavaScript, enabling you to use your code in the browser, or anywhere else JavaScript can run. It also generates TypeScript definitions, so you can interact with your Gleam code confidently, even from the outside. // Gleam 可以轻松使用用其他 BEAM 语言编写的代码，例如 Erlang 和 Elixir，因此有数千个开放的丰富生态系统 供 Gleam 用户使用的源库。 /// Gleam 还可以编译为 JavaScript，使您能够使用 浏览器中的代码，或者 JavaScript 可以运行的任何其他地方。 它也是 生成 TypeScript 定义，以便您可以与 Gleam 交互 即使是从外部，也可以自信地编码。"


[knowsby:lunatic]: https://lunatic.solutions/blog/writing-rust-the-elixir-way-1.5-years-later "The message passing and pattern matching works really well in Elixir because it's a dynamically typed language. Once I tried to translate this patterns to Rust, I couldn't figure out a way of fitting them into Rust's strict type system. I had a look at what other rust message passing libraries do or how the messages are handled in Go, Gleam and others. This lead me to try a channel based approach. Each process can capture a set of channels from its parent that are used to receive messages of a specific type. This sounded like a reasonable approach at first, but once I tried it out in a bigger project I realized that it's super easy to deadlock yourself while you wait on the wrong message type. It just didn't feel right. /// Solving this problem was my main focus over the last 18 months. That, and rewriting the whole VM from scratch for a more modular design, but this story is for another post. With the recent release of version 0.9, I finally arrived at a point where I feel like we found a great balance between Elixir's patterns and Rust's type safety. Check out the release notes for code examples. // 消息传递和模式匹配在 Elixir 中运行得非常好，因为它是动态的 键入的语言。 当我尝试将这种模式转换为 Rust 时，我找不到一种方法 将它们放入 Rust 严格的类型系统中。 我查看了其他 Rust 消息传递 库的作用或消息在 Go 、 Gleam 中的处理方式 和别的。 这促使我尝试 基于渠道 的方法。 每个进程可以捕获一组 来自其父级的通道，用于接收特定类型的消息。 这听起来像 起初这是一个合理的方法，但是当我在一个更大的项目中尝试它时，我意识到它是 当您等待错误的消息类型时，非常容易陷入僵局。只是没感觉到正确。 /// 解决这个问题是我过去 18 个月的主要关注点。那，然后重写从头开始整个虚拟机的模块化设计，但这个故事是另一篇文章的。最近发布的 0.9 版本 ，我终于到达了一个点，我觉得我们找到了一个 Elixir 的模式和 Rust 的类型安全之间取得了很好的平衡。查看发行说明代码示例。"
[knowsby:caramel]: https://caramel.run/manual/getting-started/first-steps.html "Caramel is a language that relies on the Erlang VM, just like Elixir or Gleam. This means that we need to compile our code, and run it from within Erlang."
