[src/gh]: https://github.com/cordx56/rustowl.git "(MPL-2.0) (Languages: Rust 58.6%, Shell 29.0%, TypeScript 5.4%, Lua 4.9%, Emacs Lisp 1.5%, JavaScript 0.6%) Visualize Ownership and Lifetimes in Rust // 在 Rust 中可视化所有权和生命周期 /// RustOwl visualizes ownership movement and lifetimes of variables. When you save Rust source code, it is analyzed, and the ownership and lifetimes of variables are visualized when you hover over a variable or function call. /// RustOwl 可视化变量的所有权移动和生命周期。当您保存 Rust 源代码时，它会被分析，当您将鼠标悬停在变量或函数调用上时，变量的所有权和生命周期会被可视化。 /// RustOwl visualizes those by using underlines: // RustOwl 通过使用下划线来可视化这些内容： /// - 🟩 green: variable's actual lifetime // 🟩 绿色：变量的实际生命周期 /// - 🟦 blue: immutable borrowing // 🟦 蓝色：不可变借用 /// - 🟪 purple: mutable borrowing // 🟪 紫色：可变借用 /// - 🟧 orange: value moved / function call // 🟧 橙色：值移动 / 函数调用 /// - 🟥 red: lifetime error // 🟥 红色：生命周期错误 /// . - diff of lifetime between actual and expected, or // 实际生命周期与预期生命周期之间的差异，或者 /// . - invalid overlapped lifetime of mutable and shared (immutable) references // 不可变的可变引用与共享（不可变）引用的重叠生命周期无效 /// Detailed usage is described [here](docs/usage.md). // 详细用法请在此处查看。 /// Currently, we offer VSCode extension, Neovim plugin and Emacs package. For these editors, move the text cursor over the variable or function call you want to inspect and wait for 2 seconds to visualize the information. We implemented LSP server with an extended protocol. So, RustOwl can be used easily from other editor. // 目前，我们提供 VSCode 扩展、Neovim 插件和 Emacs 包。对于这些编辑器，将文本光标移动到您想要检查的变量或函数调用上，并等待 2 秒钟以可视化信息。我们实现了具有扩展协议的 LSP 服务器。因此，RustOwl 可以轻松地用于其他编辑器。"

[plg/visualstudio]: https://marketplace.visualstudio.com/items?itemName=cordx56.rustowl-vscode "RustOwl VS Code extension"
[plg/open-vsx]: https://open-vsx.org/extension/cordx56/rustowl-vscode "RustOwl Vscodium extension"
[app/winstall]: https://winstall.app/apps/Cordx56.Rustowl "(: winget install -- Cordx56.Rustowl)"
[app/crates]: https://crates.io/crates/rustowl "(: cargo install -- rustowl)"
