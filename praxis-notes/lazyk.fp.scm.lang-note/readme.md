[wiki/esolangs]： https://esolangs.org/wiki/Lazy_K "Lazy K, designed by Ben Rudiak-Gould, is a Turing tarpit based on combinatory logic. It is lazily evaluated and purely functional. // Lazy K 由 Ben Rudiak-Gould 设计，是一个基于组合逻辑的图灵陷阱 。它是惰性求值且纯函数式的。 /// Lazy K was designed to address a shortcoming of Unlambda; namely, its lack of functional purity. Lazy K's author felt that the functional programming paradigm needed an analog to the imperative paradigm's Brainfuck, and Unlambda was simply not it. // Lazy K 的设计初衷是为了解决 Unlambda 的一个缺陷：缺乏函数式纯粹性。Lazy K 的作者认为，函数式编程范式需要一个类似于命令式编程范式中 Brainfuck 的工具，而 Unlambda 显然不是。 /// Lazy K was submitted to the 2002 Esoteric Awards. // Lazy K 被提交参加 2002 年神秘学奖评选 。"
[cl.intro/ghio:tromp]: https://tromp.github.io/cl/lazy-k.html "Lazy K is a garbage-collected, referentially transparent functional programming language, with a simple stream-based I/O system. // Lazy K 是一种具有垃圾回收机制、引用透明的函数式编程语言，并具有简单的基于流的 I/O 系统。 /// What distinguishes Lazy K from other such languages is its almost total lack of other features. It does not, for example, offer an integrated Hindley-Milner polymorphic type system. It is not shipped with an extensive standard library with support for platform-independent GUI programming and bindings to other languages. Nor could any such library be written since, among other things, Lazy K does not provide any way to define or refer to any functions other than built-ins. This inability is complemented by a matching lack of support for numbers, strings, or any other data type. Nevertheless, Lazy K is Turing-complete. // Lazy K 与其他类似语言的区别在于它几乎完全缺乏其他特性。例如，它没有集成 Hindley-Milner 多态类型系统，也没有提供支持平台无关 GUI 编程和与其他语言绑定的完善标准库。事实上，由于 Lazy K 不允许定义或引用内置函数以外的任何函数，因此也无法编写这样的库。此外，它对数字、字符串或任何其他数据类型都缺乏支持。尽管如此，Lazy K 仍然是图灵完备的。 /// Here's a Lazy K program which prints out the prime numbers (all of them, if you wait long enough). It's based on an elegant implementation of the sieve of Eratosthenes using lazy lists, and it's surprisingly fast: about 80 primes in the first second of execution on my machine (of course it gets progressively slower). // 这是一个 Lazy K 程序，它可以打印出所有素数（如果你等待足够长的时间，就能打印出所有素数）。它基于使用惰性列表实现的埃拉托色尼筛法的巧妙方法，速度惊人：在我的机器上，运行的第一秒就能输出大约 80 个素数（当然，速度会逐渐变慢）。 /// (: (SII(S(K(S(S(K(SII(S(S(KS)(S(K(S(KS)))(S(K(S(S(KS)(SS(S(S(KS)K))(KK)))))(S(S(KS)(S(KK)(S(KS)(S(S(KS)(S(KK)(S(KS)(S(S(KS)(S(KK)(SII)))(K(SI(KK)))))))(K(S(K(S(S(KS)(S(K(SI))(S(KK)(S(K(S(S(KS)K)(S(S(KS)K)I)(S(SII)I(S(S(KS)K)I)(S(S(KS)K)))))(SI(K(KI)))))))))(S(KK)K)))))))(K(S(KK)(S(SI(K(S(S(S(S(SSK(SI(K(KI))))(K(S(S(KS)K)I(S(S(KS)K)(S(S(KS)K)I))(S(K(S(SI(K(KI)))))K)(KK))))(KK))(S(S(KS)(S(K(SI))(S(KK)(S(K(S(S(KS)K)))(SI(KK))))))(K(K(KI)))))(S(S(KS)(S(K(SI))(SS(SI)(KK))))(S(KK)(S(K(S(S(KS)K)))(SI(K(KI)))))))))(K(K(KI))))))))))(K(KI)))))(SI(KK)))))(S(K(S(K(S(K(S(SI(K(S(K(S(S(KS)K)I))(S(SII)I(S(S(KS)K)I)))))))K))))(S(S(KS)(S(KK)(SII)))(K(SI(K(KI)))))))(SII(S(K(S(S(KS)(S(K(S(S(SI(KK))(KI))))(SS(S(S(KS)(S(KK)(S(KS)(S(K(SI))K)))))(KK))))))(S(S(KS)(S(K(S(KS)))(S(K(S(KK)))(S(S(KS)(S(KK)(SII)))(K(S(S(KS)K)))))))(K(S(S(KS)(S(K(S(S(SI(KK))(KI))))(S(KK)(S(K(SII(S(K(S(S(KS)(S(K(S(K(S(S(KS)(S(KK)(S(KS)(S(K(SI))K))))(KK)))))(S(S(KS)(S(KK)(S(K(SI(KK)))(SI(KK)))))(K(SI(KK))))))))(S(S(KS)(S(K(S(KS)))(S(K(S(KK)))(S(S(KS)(S(KK)(SII)))(K(SI(K(KI))))))))(K(K(SI(K(KI)))))))))(S(K(SII))(S(K(S(K(SI(K(KI))))))(S(S(KS)(S(KK)(SI(K(S(K(S(SI(K(KI)))))K)))))(K(S(K(S(SI(KK))))(S(KK)(SII)))))))))))(K(SI(K(KI))))))))(S(S(KS)K)I)(SII(S(K(S(K(S(SI(K(KI)))))K))(SII)))))) /// Why the world needs Lazy K // 为什么世界需要 Lazy K /// ... or, in other words, what's wrong with Unlambda? // 换句话说， Unlambda 有什么问题？ /// Just as Brainfuck captures the distilled essence of (structured) imperative programming, so should there be a language which captures the essence of functional programming. Unlambda would seem to be the natural candidate for that position. But although it is a very pretty language, it just isn't functional enough for my taste. // 正如 Brainfuck 捕捉到了（结构化）命令式编程的精髓一样，也应该有一种语言能够捕捉到函数式编程的精髓。Unlambda 似乎是这个位置的理想之选。但尽管它是一种非常漂亮的语言，对我来说，它的函数式特性还不够。 /// The Unlambda page states that a functional programming language is one in which functions have first-class citizenship. But I think that this is incorrect: for one thing, by that definition almost any high-level language would qualify as functional, even Perl (and perhaps even C, which has qsort). More usually, “functional programming” is programming in which functions behave like real mathematical functions — that is, without side effects — and a pure functional language, then, is just one which requires this of all functions. In this sense, Unlambda isn't even close to being purely functional, because its I/O system depends crucially on side effects (or, equivalently, on the order of evaluation). The idea of side effects (or of meaning depending on evaluation order) is antithetical to the design of the combinator calculus, and there are strange interactions between them which make writing Unlambda programs a frustrating experience. This is, of course, deliberate: Unlambda is billed as “your functional programming language nightmares come true”, and the author credits Intercal as an inspiration. // Unlambda 的页面声称函数式编程语言是指函数拥有“一等公民”地位的语言。但我认为这种说法并不正确：首先，按照这个定义，几乎所有高级语言都可以算是函数式语言，甚至包括 Perl（或许还有 C，因为它有 qsort ）。更常见的定义是，“函数式编程”是指函数的行为像真正的数学函数一样——也就是说，没有副作用——而纯函数式语言则要求所有函数都必须如此。从这个意义上讲，Unlambda 远非纯函数式语言，因为它的 I/O 系统严重依赖于副作用（或者等价地，依赖于求值顺序）。副作用（或者说依赖于求值顺序）的概念与组合演算的设计理念背道而驰，它们之间存在着一些奇怪的相互作用，使得编写 Unlambda 程序成为一种令人沮丧的体验。当然，这并非偶然：Unlambda 的宣传语是“让你的函数式编程语言噩梦成真”，作者也承认 Intercal 是其灵感来源。 /// In designing Lazy K, I was interested only in elegance. Lazy K does not compromise the purity of the SKI combinator calculus in any way. There are no special combinators for I/O. There are no exceptions to the rules of abstraction elimination; the shortcuts are always valid. There are none of the evaluation-order games which permeate almost every other programming language, even most so-called functional languages: if there is any order in which a Lazy K program can be evaluated to work properly, the Lazy K interpreter will find it. There is no d operator, nor even any meaningful way to define one (except as equivalent to the identity function), and there's no need to add a dummy argument to argumentless functions, because the function and its value are interchangeable. // 在设计 Lazy K 时，我只关注其优雅性。Lazy K 丝毫不会损害 SKI 组合子演算的纯粹性。它没有用于 I/O 的特殊组合子，也没有抽象消除规则的例外；快捷方式始终有效。它不存在几乎所有其他编程语言（甚至包括大多数所谓的函数式语言）中普遍存在的求值顺序问题：只要 Lazy K 程序存在任何可以正确执行的求值顺序，Lazy K 解释器就能找到它。它没有 d 运算符，甚至没有任何有意义的方法来定义它（除了等价于恒等函数之外），也不需要为无参函数添加哑元，因为函数及其值是可以互换的。 /// Lazy K programs live in the same timeless Platonic realm as mathematical functions, what the Unlambda page calls “the blessed realm of the pure untyped lambda calculus”. Just as garbage collection hides the process of memory management from the programmer, so referential transparency hides the process of evaluation. The fact that some calculation is necessary in order to view a picture of the Mandelbrot set, or in order to “run” a Lazy K program, is an implementation detail. That's the essence of functional programming. // Lazy K 程序与数学函数一样，存在于永恒的柏拉图式领域，正如 Unlambda 页面所称的“纯粹无类型 lambda 演算的福地”。正如垃圾回收机制对程序员隐藏了内存管理过程一样，引用透明性也隐藏了求值过程。为了查看曼德勃罗集图像或“运行”Lazy K 程序，某些计算是必要的，但这仅仅是实现细节。这正是函数式编程的精髓所在。 /// I/O in Lazy K // Lazy K 中的 I/O /// How to handle input and output in a language without side effects? In a certain sense, input and output aren't side effects; they are, so to speak, front- and back-effects. So it is in Lazy K, where a program is simply treated as a function from the space of possible inputs to the space of possible outputs. // 如何在无副作用的语言中处理输入输出？从某种意义上说，输入输出并非副作用；它们更像是前端效应和后端效应。Lazy K 语言正是如此，它将程序简单地视为从可能的输入空间到可能的输出空间的函数。 /// Input and output streams are represented as lists of natural numbers from 0 to 255, each corresponding to one byte. End-of-file is represented by the value 256, not by end of list. (This is because it is often easier to deal with EOF as a character than as a special case. Nevertheless, I wonder if it wouldn't be better to use end-of-list.) // 输入和输出流都用 0 到 255 的自然数列表表示，每个自然数对应一个字节。文件结束符用值 256 表示，而不是列表结束符。（这是因为通常将文件结束符作为字符处理比作为特殊情况处理要容易得多。不过，我还是觉得使用列表结束符可能更好。） /// For the purpose of making these lists, pairs are represented in the usual way (that is, the pair (X . Y) is the function (lambda (f) (f X Y))) and natural numbers are represented as Church numerals (that is, the number n is represented by the operation of n-fold composition). // 为了制作这些列表，数对以通常的方式表示（即数对 (X . Y) 是函数 (lambda (f) (f X Y)) ），自然数以 Church 数表示（即数字 n 由 n 重合成运算表示）。 /// The input list is infinite in length, and all elements after the first occurrence of 256 are also 256. The output list is never examined beyond the first occurrence of 256; it doesn't matter what is in the cdr of that cell. In fact, since the car of each cell is examined by applying it to (lambda (x y) x), you can represent the end of your output simply by (k 256): for example, (lambda (input) (k 256)) is a valid program which ignores its input and prints nothing. // 输入列表长度无限，且除第一个出现 256 的元素外，其余元素均为 256。输出列表仅检查第一个出现 256 的元素；该单元格的 cdr 值是什么并不重要。实际上，由于每个单元格的 car 值都是通过将其应用于 (lambda (x y) x) 来检查的，因此您可以简单地用 (k 256) 表示输出的结束：例如， (lambda (input) (k 256)) 是一个有效的程序，它忽略输入且不输出任何内容。 /// (Incidentally, the Church numeral 256 has a very compact representation in lambdas or combinators: it is ((lambda (n) (n n)) ((lambda (n) (n n)) (lambda (f x) (f (f x))))), or SII(SII(S(S(KS)K)I)).) // （顺便一提，丘奇数 256 在 lambda 表达式或组合子中有一个非常简洁的表示：它是 ((lambda (n) (n n)) ((lambda (n) (n n)) (lambda (f x) (f (f x))))) ，或者 SII(SII(S(S(KS)K)I)) 。） /// The present interpreter actually accepts any value of 256 or greater as the end of the output, and its return code to the operating system is that value minus 256. // 当前解释器实际上接受任何大于等于 256 的值作为输出的结束值，并且它返回给操作系统的代码是该值减去 256。 /// Note that under these rules, the identity function is a program which copies its input to its output. Since Lazy K's syntax is such that the empty program is the identity function, the behavior of the UNIX cat utility (without arguments) can be expressed at least as compactly in Lazy K as in any other language. // 请注意，根据这些规则，恒等函数是一个将其输入复制到其输出的程序。由于 Lazy K 的语法使得空程序即为恒等函数，因此 UNIX cat 工具（不带参数）的行为至少可以用 Lazy K 像任何其他语言一样简洁地表达。 /// Lazy K syntax and semantics // 惰性 K 语法和语义 /// Lazy K's motto is “there's more than one way to do it”. In fact, there are exactly four ways to do it: combinator-calculus style, Unlambda style, Iota style, and Jot style. // Lazy K 的座右铭是“条条大路通罗马”。事实上，它有四种方法：组合演算风格、Unlambda 风格、Iota 风格和 Jot 风格。 /// - Combinator-calculus style: Lazy K programs can be written as expressions in the usual notation of the combinator calculus. The only predefined combinators you may use are S, K, and I, and there is no way to define your own (named) combinators. The prime-sieve example above uses this notation. // 组合演算风格 ：惰性 K 程序可以用组合演算的常用符号表示。你只能使用预定义的组合子 S 、 K 和 I ，无法定义自己的（命名）组合子。上面的素数筛示例就使用了这种表示法。 /// - Unlambda style: The Unlambda syntax is just another notation for combinator expressions, with a binary application operator ` and the combinators s, k, and i. Other Unlambda functions are useless or meaningless in Lazy K and are not supported. Unlambda notation is usually a bit more compact than CC notation (though not always: e.g. SII(SII) vs. ```sii``sii). Also, it looks nicer. // Unlambda 风格 ：Unlambda 语法只是组合子表达式的另一种表示法，它使用二元应用运算符 ` 和组合子 s 、 k 和 i 。其他 Unlambda 函数在 Lazy K 中无用或无意义，因此不受支持。Unlambda 表示法通常比 CC 表示法更简洁（尽管并非总是如此：例如 SII(SII) 与 ```sii``sii ）。此外，它看起来也更美观。 /// - Iota and Jot style: Iota and Jot are two languages created by Chris Barker, each of which is Turing-complete with only two symbols. Iota has a single named function and a binary application operator; Jot has two operators only (they act initially on the identity function). Exactly the same functions can be represented in Iota and Jot as in the usual combinator calculus, but Iota and Jot programs are several times larger than their counterparts using the S, K, and I combinators. The input-reversing example above is written in Jot. // Iota 和 Jot 风格 ： Iota 和 Jot 是 Chris Barker 创建的两种语言，它们都是图灵完备的，且都只有两个符号。Iota 只有一个命名函数和一个二元应用运算符；Jot 只有两个运算符（它们最初作用于恒等函数）。Iota 和 Jot 可以表示与通常的组合演算中完全相同的函数，但 Iota 和 Jot 程序比使用 S、K 和 I 组合子的程序要大好几倍。上面的输入反转示例是用 Jot 编写的。 /// The interpreter // 翻译 /// The Lazy K interpreter, cleverly named lazy, has the following command-line syntax: // Lazy K 解释器，巧妙地命名为 lazy ，具有以下命令行语法： /// (::: lazy [-b] { -e program-code | program-file.lazy } *) /// Arguments preceded by -e are interpreted as in-line Lazy K code (just as in Perl), and arguments not preceded by -e are interpreted as names of files containing Lazy K code. You can specify more than one chunk of code, in which case they are combined by backwards functional composition. Because of the way Lazy K's I/O model works, this is equivalent to piping the output of each program to the input of the next: i.e. lazy prog1 prog2 prog3 is equivalent to lazy prog1 | lazy prog2 | lazy prog3, except that it's more efficient (and the intermediate results needn't be byte streams). The first program's input always comes from standard input, and the last program's output always goes to standard output. // 以 -e 开头的参数会被解释为内联 Lazy K 代码（就像 Perl 一样），而未以 -e 开头的参数会被解释为包含 Lazy K 代码的文件名。您可以指定多个代码块，在这种情况下，它们会通过反向函数组合的方式进行合并。由于 Lazy K 的 I/O 模型的工作方式，这相当于将每个程序的输出通过管道传递给下一个程序的输入：例如， lazy prog1 prog2 prog3 等价于 lazy prog1 | lazy prog2 | lazy prog3 ，但效率更高（并且中间结果不必是字节流）。第一个程序的输入始终来自标准输入，最后一个程序的输出始终输出到标准输出。 /// If you don't specify any programs at all, you'll get an empty composition, which results in the identity function, which causes lazy to behave like cat (except much slower). If you want lazy to read source code from standard input, use lazy -. // 如果你完全不指定任何程序，就会得到一个空的组合，也就是恒等函数，这会导致 lazy 的行为类似于 cat （但速度慢得多）。如果你想让 lazy 从标准输入读取源代码，请使用 lazy - 。 /// The -b option puts standard input and standard output into binary mode on systems which care (i.e. Windows). If you have problems with any of the sample programs (particularly the Unlambda interpreter), try using this switch. // -b 选项会将标准输入和标准输出设置为二进制模式（适用于支持此功能的系统，例如 Windows）。如果您在使用任何示例程序（特别是 Unlambda 解释器）时遇到问题，请尝试使用此开关。 /// The compiler // 编译器 /// There is a Lazy K compiler, but it does not compile from Lazy K into machine code or C; rather, it compiles to Lazy K from a meta-language in which one actually has some hope of writing programs. Like Unlambda, Lazy K itself is better considered as bytecode for an unorthodox kind of virtual machine. The compiler is written in Scheme and is located in the file lazier.scm. // Lazy K 编译器确实存在，但它并非将 Lazy K 编译成机器码或 C 代码；而是将 Lazy K 代码从一种元语言编译成 Lazy K，而这种元语言本身确实有可能用于编写程序。与 Unlambda 类似，Lazy K 本身更应该被视为一种非传统虚拟机的字节码。该编译器使用 Scheme 语言编写，位于文件 lazier.scm 中。"
[cl.src/gh:tromp]: https://github.com/tromp/tromp.github.io.git "(Languages: HTML 85.9%, Roff 11.9%, Rust 1.1%, Haskell 0.4%, C 0.3%, PostScript 0.1%, Other 0.3%) John Tromp homepage /// The largest number representable in 64 bits // 64 位可表示的最大数字 /// Most people believe 18446744073709551615, or 0xFFFFFFFFFFFFFFFF in hexadecimal, to be the largest number representable in 64 bits. Which is indeed the case if we are talking about 64 bit unsigned integers such as represented by the datatype uint64_t in C or u64 in Rust. We can reach quite a bit further with floating point values. The 64-bit double floating point format finds its largest (finite) representable value in the 309 digit number 21024(1-2-53) = 17976931...24858368. // 大多数人认为 18446744073709551615（十六进制为 0xFFFFFFFFFFFFFFFF）是 64 位二进制数能表示的最大数字。如果指的是 64 位无符号整数，例如 C 语言中的 uint64_t 数据类型或 Rust 语言中的 u64 数据类型，那么这个数字确实如此。但对于浮点数来说，我们可以表示的范围要大得多。64 位双精度浮点数格式能表示的最大（有限）数字是 309 位数字 2¹⁰²⁴(1-2-5³) = 17976931...24858368。"
[dl/sange:essie2]: https://esoteric.sange.fi/essie2/download/ "Index of /essie2/download"
[designer.site/net]: https://neuron2.net/ "Must-Have Tools for AI Humanizing, Device Cleaning & Recovery // 人工智能人性化、设备清理和恢复的必备工具"
[kronosta-copy.src/gh]: https://github.com/kronosta/lazy-k.git "(Languages: Scheme 56.0%, HTML 29.3%, C++ 12.2%, C 2.5%) A copy of John Tromp's Lazy-K esolang taken from web:esoteric.sange.fi/essie2, in case that disappears // 一份来自 web:esoteric.sange.fi/essie2 的 John Tromp 的 Lazy-K esolang 副本，以防该链接失效。 /// This is Lazy K, which I am submitting to the Essies for consideration in the // category of “most entertaining new Turing-complete language”.// 这就是 Lazy K，我将其提交给 Essies 奖，以角逐“最具娱乐性的新图灵完备语言”的奖项。 /// Lazy K is, roughly speaking, a referentially-transparent Unlambda. For all the gory details (excuse me, all the clean and elegant details) please refer to lazy-k.html, which is a draft of a web page introducing the language. (It doesn't exist on the web yet.) Many of the source code files also contain semi-edifying comments. // 粗略地说，Lazy K 是一个引用透明的 Unlambda 函数。所有细节（或者说所有简洁优雅的细节）请参考 lazy-k.html，这是一个介绍该语言的网页草稿。（目前尚未发布。）许多源代码文件中也包含一些颇具启发性的注释。 /// One of the sample programs is a rather pretty implementation of mergesort, which I would like to submit for consideration under the “iron programmer” category, though whether it constitutes enough material to qualify is questionable. // 其中一个示例程序是归并排序的一个相当漂亮的实现，我想把它提交给“铁人程序员”类别考虑，尽管它是否构成足够的材料来获得资格还值得怀疑。 /// I would also like to submit my Unlambda, Brainfuck and Befunge interpreters for consideration under the category of “best language implementation in an esoteric language”, but unfortunately I can't because that category doesn't exist this time around. Oh well. // 我还想把我的 Unlambda、Brainfuck 和 Befunge 解释器提交到“最佳小众语言实现”类别中，可惜这次没有这个类别。唉。 /// Portability and build details: 便携性和构造细节： /// This archive contains files written in four languages: C, C++, Scheme, and Lazy K. The C, C++, and Scheme programs are standards-compliant to the best of my knowledge and should be quite portable. There are a couple of portability issues affecting Lazy K programs. One is that gcc likes to buffer output lines even when they're going to a console, which causes the prime-number printer to appear to hang for a while under a gcc-compiled interpreter. The other issue is the old newline versus CR-LF problem. The Lazy K interpreter has a -b flag which is intended for working around newline problems. In general, use it if omitting it causes problems and omit it if using it causes problems. // 此压缩包包含用四种语言编写的文件：C、C++、Scheme 和 Lazy K。据我所知，C、C++ 和 Scheme 程序均符合标准，并且应该具有良好的可移植性。Lazy K 程序存在一些可移植性问题。其一是 gcc 编译器即使在输出到控制台时也会缓存输出行，这会导致在 gcc 编译的解释器下，素数打印机出现短暂的卡顿现象。另一个问题是换行符与 CR-LF 之间的冲突。Lazy K 解释器提供了一个 -b 标志，用于解决换行符问题。一般来说，如果省略该标志会导致问题，则使用该标志；如果使用该标志会导致问题，则省略该标志。 /// No makefiles are provided for the C or C++ files; however, as there is only one of each, and they compile to separate executables, building them by hand with any compiler is straightforward. // C 或 C++ 文件没有提供 makefile；但是，由于每个文件只有一个，并且它们编译成单独的可执行文件，因此使用任何编译器手动构建它们都很简单。"
[irori-impl.src/gh]: https://github.com/irori/lazyk.git "(MIT) (Languages: C 96.4%, Makefile 2.0%, Shell 1.6%) Lazy K interpreter // 懒惰的 K 解释器 /// This is an interprefer of the Lazy K programming language. This implementation is 2-3 times faster than the C++ implementation included in the original Lazy K distribution. // 这是 Lazy K 的一个解释器 编程语言。这种实现方式比 C++ 快 2-3 倍。 原始 Lazy K 发行版中包含了该实现。 /// It fully supports all Lazy K syntaxes, combinator-calculus style, Unlambda style, Iota style, and Jot style (and mixture of them). // 它完全支持所有 Lazy K 语法、组合演算风格、Unlambda 风格、Iota 风格和 Jot 风格（以及它们的混合）。 /// Usage // 用法 /// (: $ lazyk [options] [program-file]) /// If program-file is not specified, program is read from the standard input. // 如果没有指定程序文件 ，则从标准输入读取程序。 /// Options: // 选项： /// - -h: Print help and exit. // -h ：打印帮助信息并退出。 /// - -u: Disable stdout buffering. // -u ：禁用标准输出缓冲。 /// - -v: Print version and exit. // -v ：打印版本信息并退出。 /// - -v0 (default): Do not print any debug information. // -v0 （默认值）：不打印任何调试信息。 /// - -v1: Print some statistics after execution. // -v1 ：执行后打印一些统计信息。 /// - -v2: Print logs for garbage collections. // -v2 ：打印垃圾回收日志。"
[msullivan-modified.src/gh]: https://github.com/msullivan/LazyK.git "(Languages: Scheme 39.3%, HTML 20.6%, C++ 20.2%, C 10.9%, Haskell 6.2%, Standard ML 2.8%) Updated LazyK source distribution // LazyK 源代码分发已更新 /// The Lazy K source distribution has gotten hard to find, so I am reposting my modified version. Below the line is the original README. // Lazy K 的源代码分发包现在很难找到，所以我重新发布我修改过的版本。下面是原始的 README 文件。 /// This source distribution is somewhat modified from the original: lazy.cpp has been substantially optimized. It now uses a copying garbage collector instead of reference counting. It has also been somewhat de-C++ified, due to personal preferences. // 此源代码分发包在原版基础上进行了一些修改：lazy.cpp 文件已大幅优化，现在使用复制垃圾回收器而非引用计数。此外，由于个人偏好，它也进行了一些去 C++ 化的处理。 /// lazy_orig.cpp is the original Lazy K interpreter. lazy2.c is my port of the C++ interpreter to C, as an intermediate step for my C0 port. lazy.c0 is a port to the L4 dialect of C0. C0 is a language used in CMU's intro programming courses, and the L4 dialect is used in the compiler design class. I made this port to be a test for student compilers. LazyK.hs is my haskell implementation of a Lazy K evaluator. It cheats. // lazy_orig.cpp 是原始的 Lazy K 解释器。lazy2.c 是我将 C++ 解释器移植到 C 语言的版本，作为我 C0 移植的中间步骤。lazy.c0 是移植到 C0 的 L4 方言的版本。C0 是卡内基梅隆大学 (CMU) 入门编程课程中使用的语言，而 L4 方言则用于编译器设计课程。我制作这个移植版本是为了测试学生的编译器。LazyK.hs 是我用 Haskell 实现的 Lazy K 求值器。它会作弊。 /// In eg/unlambda there are unlambda versions of all of the tests, since the C and C0 versions only support unlambda syntax. In test-data/ there are some word lists I used when benchmarking the sort test. // eg/unlambda 目录下包含了所有测试的 unlambda 版本，因为 C 和 C0 版本仅支持 unlambda 语法。test-data/ 目录下包含了一些我在对排序测试进行基准测试时使用的单词列表。 /// -Michael Sullivan // 迈克尔·沙利文"

