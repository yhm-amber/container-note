[src/gh]: https://github.com/sqlalchemy/sqlalchemy.git "(MIT) (Languages: Python 100.0%) The Database Toolkit for Python // Python 数据库工具包 /// The Python SQL Toolkit and Object Relational Mapper // Python SQL 工具包和对象关系映射器 /// SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. SQLAlchemy provides a full suite of well known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language. // SQLAlchemy 是一个给应用开发者提供完整 SQL 权力和灵活性的 Python SQL 工具包和对象关系映射器。SQLAlchemy 提供了一套成熟的、企业级持久化模式，专为高效和高性能的数据库访问而设计，并适配为一个简单且 Pythonic 的领域语言。 /// Major SQLAlchemy features include: // SQLAlchemy 的主要功能包括： /// - An industrial strength ORM, built from the core on the identity map, unit of work, and data mapper patterns. These patterns allow transparent persistence of objects using a declarative configuration system. Domain models can be constructed and manipulated naturally, and changes are synchronized with the current transaction automatically. // 一个工业级的 ORM，基于身份映射、工作单元和数据映射模式构建。这些模式允许使用声明式配置系统透明地持久化对象。领域模型可以自然地构建和操作，并且更改会自动与当前事务同步。 /// - A relationally-oriented query system, exposing the full range of SQL's capabilities explicitly, including joins, subqueries, correlation, and most everything else, in terms of the object model. Writing queries with the ORM uses the same techniques of relational composition you use when writing SQL. While you can drop into literal SQL at any time, it's virtually never needed. // 一个关系型查询系统，明确地暴露了 SQL 的全部功能，包括连接、子查询、关联以及几乎所有其他功能，这些功能都以对象模型的形式呈现。使用 ORM 编写查询与编写 SQL 时使用的关系组合技术相同。虽然你可以在任何时候切换到纯 SQL，但实际上几乎不需要这样做。 /// - A comprehensive and flexible system of eager loading for related collections and objects. Collections are cached within a session, and can be loaded on individual access, all at once using joins, or by query per collection across the full result set. // 一个全面且灵活的关联集合和对象即时加载系统。集合在会话中缓存，可以在单独访问时加载，也可以使用连接一次性加载，或者通过每个集合在整个结果集上进行查询来加载。 /// - A Core SQL construction system and DBAPI interaction layer. The SQLAlchemy Core is separate from the ORM and is a full database abstraction layer in its own right, and includes an extensible Python-based SQL expression language, schema metadata, connection pooling, type coercion, and custom types. // 一个核心 SQL 构造系统和 DBAPI 交互层。SQLAlchemy Core 与 ORM 分离，并且本身就是一个完整的数据库抽象层，包括可扩展的基于 Python 的 SQL 表达式语言、模式元数据、连接池、类型强制转换和自定义类型。 /// - All primary and foreign key constraints are assumed to be composite and natural. Surrogate integer primary keys are of course still the norm, but SQLAlchemy never assumes or hardcodes to this model. // 所有主键和外键约束都被假定为复合和自然的。当然，代理整数主键仍然是常态，但 SQLAlchemy 从不假设或硬编码这种模型。 /// - Database introspection and generation. Database schemas can be “reflected” in one step into Python structures representing database metadata; those same structures can then generate CREATE statements right back out - all within the Core, independent of the ORM. // 数据库内省和生成。数据库模式可以在一步之内被 “反射” 成表示数据库元数据的 Python 结构；这些相同的结构随后可以重新生成 CREATE 语句——所有这一切都在 Core 中完成，独立于 ORM。 /// SQLAlchemy's philosophy: // SQLAlchemy 的理念： /// - SQL databases behave less and less like object collections the more size and performance start to matter; object collections behave less and less like tables and rows the more abstraction starts to matter. SQLAlchemy aims to accommodate both of these principles. // 随着规模和性能开始变得重要，SQL 数据库表现得越来越不像对象集合；随着抽象开始变得重要，对象集合表现得越来越不像表和行。SQLAlchemy 致力于适应这两种原则。 /// - An ORM doesn't need to hide the “R”. A relational database provides rich, set-based functionality that should be fully exposed. SQLAlchemy's ORM provides an open-ended set of patterns that allow a developer to construct a custom mediation layer between a domain model and a relational schema, turning the so-called “object relational impedance” issue into a distant memory. // ORM 不需要隐藏 “R”。关系数据库提供了丰富、基于集合的功能，这些功能应该完全暴露。SQLAlchemy 的 ORM 提供了一套开放式的模式，允许开发者构造一个自定义的中间层，用于在领域模型和关系模式之间进行交互，将所谓的 “对象关系阻抗” 问题变成遥远的记忆。 /// - The developer, in all cases, makes all decisions regarding the design, structure, and naming conventions of both the object model as well as the relational schema. SQLAlchemy only provides the means to automate the execution of these decisions. // 开发者始终决定对象模型和关系模式的设计、结构和命名规范。SQLAlchemy 仅提供自动化执行这些决策的手段。 /// - With SQLAlchemy, there's no such thing as “the ORM generated a bad query” - you retain full control over the structure of queries, including how joins are organized, how subqueries and correlation is used, what columns are requested. Everything SQLAlchemy does is ultimately the result of a developer-initiated decision. // 使用 SQLAlchemy 时，不存在“ORM 生成了一个错误的查询”这种情况——你完全控制查询的结构，包括如何组织连接、如何使用子查询和关联、请求哪些列。SQLAlchemy 所做的一切最终都是开发者决策的结果。 /// - Don't use an ORM if the problem doesn't need one. SQLAlchemy consists of a Core and separate ORM component. The Core offers a full SQL expression language that allows Pythonic construction of SQL constructs that render directly to SQL strings for a target database, returning result sets that are essentially enhanced DBAPI cursors. // 如果问题不需要 ORM，就不要使用它。SQLAlchemy 由核心组件和独立的 ORM 组件组成。核心组件提供了一个完整的 SQL 表达式语言，允许以 Pythonic 方式构建 SQL 结构，这些结构直接渲染为目标数据库的 SQL 字符串，返回的结果集本质上是增强的 DBAPI 游标。 /// - Transactions should be the norm. With SQLAlchemy's ORM, nothing goes to permanent storage until commit() is called. SQLAlchemy encourages applications to create a consistent means of delineating the start and end of a series of operations. // 事务应该是常态。使用 SQLAlchemy 的 ORM，直到调用 commit()之前，没有任何内容被永久存储。SQLAlchemy 鼓励应用程序创建一种一致的方式来界定一系列操作的开始和结束。 /// - Never render a literal value in a SQL statement. Bound parameters are used to the greatest degree possible, allowing query optimizers to cache query plans effectively and making SQL injection attacks a non-issue. // 永远不要在 SQL 语句中渲染字面值。尽可能使用绑定参数，这允许查询优化器有效地缓存查询计划，并使 SQL 注入攻击成为一个非问题。"
[lib.pip/pypi]: https://pypi.org/project/SQLAlchemy/ "(: pip install -- SQLAlchemy) (License: MIT) (Requires: Python >=3.7) (Provides-Extra: [asyncio], [mypy], [mssql], [mssql-pymssql], [mssql-pyodbc], [mysql], [mysql-connector], [mariadb-connector], [oracle], [oracle-oracledb], [postgresql], [postgresql-pg8000], [postgresql-asyncpg], [postgresql-psycopg2binary], [postgresql-psycopg2cffi], [postgresql-psycopg], [postgresql-psycopgbinary], [pymysql], [aiomysql], [aioodbc], [asyncmy], [aiosqlite], [sqlcipher]) Database Abstraction Library // 数据库抽象库 (src: gh:sqlalchemy/sqlalchemy.git)"
[site/org]: https://sqlalchemy.org/ "The Python SQL Toolkit and Object Relational Mapper // Python SQL 工具和对象关系映射器 /// SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. // SQLAlchemy 是 Python SQL 工具包和对象关系映射器，为应用程序开发者提供了 SQL 的全部力量和灵活性。 /// It provides a full suite of well known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language. // 它提供了一套完整的、广为人知的企业级持久化模式，专为高效和高性能的数据库访问而设计，并适配为一个简单且 Python 风格的领域语言。"
[docs/.site]: https://docs.sqlalchemy.org/ "(: import sqlalchemy ;: engine = sqlalchemy.create_engine('sqlite+pysqlite:///:memory:', echo=True) # create an sqlalchemy 'engine' ;: with engine.connect() as conn: result = conn.execute(sqlalchemy.text(\"select 'hello world'\")) # execute a value-select in sqlite. ;: print(result.all()) #> [('hello world',)] # simple output query's result.)"
[knows_by]: https://posit-dev.github.io/querychat/py/data-sources.html "querychat supports many types of data sources, including: // querychat 支持多种类型的数据源，包括： /// - Any narwhals-compatible data frame. // 任何与 narwhals 兼容的数据帧。 /// - Any SQLAlchemy database. // 任何 SQLAlchemy 数据库。 /// - A custom DataSource interface/protocol. // 一个自定义的 DataSource 接口/协议。 /// (: engine = sqlalchemy.create_engine('sqlite:///:memory:') ;: qc = querychat.QueryChat(engine, '<a_table_name>'))"

