[site]: https://libera.chat "Providing a community platform for free and open-source software and peer directed projects."
[sable.src/gh]: https://github.com/Libera-Chat/sable.git "(AGPL-3.0) (Languages: Rust 99.9%, Other 0.1%) Sable, a chat server // Sable，一个聊天服务器 /// Sable is an experimental chat server designed to address many of the fundamental limitations of legacy IRC server software. In particular: // Sable 是一个实验性的聊天服务器，旨在解决传统 IRC 服务器软件的许多基本限制。具体来说： /// - Server linking and network state tracking are completely separated from client protocol mechanics. // 服务器连接和网络状态跟踪与客户端协议机制完全分离。 /// - Server nodes communicate using a Gossip-like protocol, removing the need for a spanning-tree routing and making netsplits, as they occur in legacy servers, a thing of the past. While a server may still become isolated from the network due to networking faults, the loss of a single connection will not disrupt the network. // 服务器节点使用类似 Gossip 的协议进行通信，无需使用生成树路由，从而消除了传统服务器中发生的网络分裂问题。虽然服务器可能由于网络故障而与网络隔离，但单个连接的丢失不会中断网络。 /// - All network state events are uniquely identified, and dependencies between them are tracked. Despite the arbitrarily-connected Gossip network, duplicate or out-of-order processing of events will not occur. // 所有网络状态事件都被唯一标识，并且它们之间的依赖关系被跟踪。尽管 Gossip 网络是任意连接的，但不会发生事件的重复处理或乱序处理。 /// - Complete network state history allows persistent user presence. Users can remain online when their clients disconnect, and can have multiple client connections, potentially on different servers, to a single user session. // 完整的网络状态历史记录允许用户持续在线。当用户客户端断开连接时，用户仍可以保持在线状态，并且可以拥有多个客户端连接，这些连接可能位于不同的服务器上，以支持单个用户会话。 /// - Instead of dynamic module loading and all the complications it can cause, server code upgrades are handled by re-executing the server in-place and resuming from saved state information. A further advantage is that there is no 'core' that cannot be upgraded without visible disruption. // 与动态模块加载及其可能引起的所有复杂问题相比，服务器代码升级是通过重新执行服务器并在保存的状态信息中恢复来处理的。一个进一步的优势是，没有无法在不引起明显中断的情况下升级的“核心”。 /// Architecture // 架构 /// Things are still changing too much to draw a diagram here. The foundational principles are: // 目前变化太多，无法在此绘制图表。基本原则是： /// - Every network object (user, channel, channel topic, channel ban, etc.) has a unique identifier. // 每个网络对象（用户、频道、频道主题、频道封禁等）都有一个唯一标识符。 /// - Every change to network state is represented by an Event. All events have a target object which they modify, a globally-unique event ID, an event clock containing its dependency information, other metadata, and a typed details structure describing the change being made. // 对网络状态的所有变更都由 Event 表示。所有事件都有一个被其修改的目标对象、一个全局唯一的事件 ID、一个包含其依赖信息的事件时钟、其他元数据，以及一个描述所做变更的类型化详细信息结构。 /// - Events are propagated between servers via a gossip protocol. // 事件通过一种 gossip 协议在服务器之间传播。 /// - Each server maintains an event log. An incoming event is added to the log only when all its dependencies have been added and processed. If an incoming event has missing dependencies, they are requested from the network. // 每台服务器都维护一个事件日志。只有当所有依赖项都已添加和处理时，传入的事件才会被添加到日志中。如果传入的事件缺少依赖项，则会从网络中请求这些依赖项。 /// - A server's view of network state is only ever updated by processing Events emitted by the event log. Event application is careful to ensure that any valid order of application for a set of events will eventually produce the same state. // 服务器的网络状态视图仅通过处理事件日志发出的 Event 更新。事件应用会小心确保任何一组事件的任何有效应用顺序最终都会产生相同的状态。 /// - All other code runs with a read-only view of network state. If updates need to be made, this is done by emitting an event for propagation and processing by the event log. // 其他所有代码都以只读视图运行网络状态。如果需要更新，这是通过发出事件进行传播和处理来完成的。 /// - There is no such thing as a netjoin. When a server starts up, it will not process any client connections until it has synced to a network, unless it has been specifically told to bootstrap a new network. If a server becomes completely detached from the network and cannot exchange events, it will be disconnected from the network permanently until it restarts. // 不存在所谓的 netjoin。当服务器启动时，除非被明确指示引导一个新网络，否则它不会处理任何客户端连接，直到它与网络同步。如果一个服务器完全与网络断开连接且无法交换事件，它将永久断开连接，直到重启。 /// Some other design decisions which are not as fundamental but are worth mentioning: // 还有一些其他设计决策，虽然不是那么根本，但值得提及： /// - Client listeners and DNS/identd connections are farmed out into a separate process to make seamless code upgrades easier. // 客户端监听器和 DNS/identd 连接被分配到单独的进程中，以便更容易地进行无缝代码升级。 /// - Server and network maintenance operations are performed via an out-of-band HTTP management service, not via IRC client connections. // 服务器和网络维护操作是通过一个带外 HTTP 管理服务执行的，而不是通过 IRC 客户端连接执行的。 /// Navigating the code // 代码导航 /// Currently, Sable is split into several crates: // 目前，Sable 被拆分成几个 crates： /// - sable_network contains all of the network data model and logic for running a network server. This includes state tracking but no client protocol logic. // sable_network 包含了运行网络服务器的所有网络数据模型和逻辑。这包括状态跟踪，但不包括客户端协议逻辑。 /// - - sable_network::network contains the Network type which represents network state and handles event application and conflict resolution, as well as the various state objects and convenience wrappers that make up a network. It also contains definitions of the event types. // sable_network::network 包含了 Network 类型，该类型表示网络状态并处理事件应用和冲突解决，以及构成网络的各个状态对象和便利包装器。它还包含事件类型的定义。 /// - - sable_network::history contains the NetworkHistoryLog type which represents the network history as it is visible to each user of the network // sable_network::history 包含了 NetworkHistoryLog 类型，该类型表示网络历史，即网络中每个用户可见的历史记录。 /// - - sable_network::sync contains the network synchronisation code // sable_network::sync 包含了网络同步代码 /// - - sable_network::node contains the NetworkNode struct which manages synchronisation and communication with the rest of the network // sable_network::node 包含了 NetworkNode 结构体，该结构体负责管理与网络其他部分的同步和通信 /// - sable_server contains generic code to run a network node and plug in node-specific functionality (such as a client server or services node) // sable_server 包含运行网络节点和插入节点特定功能（例如客户端服务器或服务节点）的通用代码 /// - sable_ircd contains the IRC client server // sable_ircd 包含 IRC 客户端服务器 /// - sable_services contains the special-purpose services node, which maintains a network-wide source of truth for account and registration data. // sable_services 包含特殊用途的服务节点，该节点维护着网络范围内的账户和注册数据的唯一真实来源。 /// - client_listener and auth_client contain split-out parts of the client server which run in their own processes. // client_listener 和 auth_client 包含从客户端服务器中分离出来的部分，它们在自己的进程中运行。 /// - sable_ipc contains IPC channel types used by the split-out processes to communicate with the main client server. // sable_ipc 包含 IPC 通道类型，这些通道类型被分离出来的进程用来与主要的客户端服务器进行通信。 /// - sable_macros contains procedural macros used by the other crates. // sable_macros 包含其他 crate 使用的程序化宏。"
[haematite.src/gh]: https://github.com/Libera-Chat/haematite.git "(MIT) (Languages: Rust 100.0%) IRC pseudoserver for exposing network state data elegantly // IRC 伪服务器，优雅地展示网络状态数据"
[gamja.src/gh]: https://github.com/Libera-Chat/gamja.git "(AGPL-3.0) (Languages: JavaScript 94.1%, CSS 5.7%, HTML 0.2%) A simple IRC web client. // 一个简单的 IRC 网络客户端。"
[ozone.src/gh]: https://github.com/Libera-Chat/ozone.git "(BSD-3-Clause) (Languages: Python 100.0%) Sigyn /// A Limnoria plugin to handle spam and abuse on a network level. // 一个用于在网络层面处理垃圾邮件和滥用的 Limnoria 插件。 /// Requesting ozone to your channel // 将 ozone 请求到你的频道 /// The best way is to discuss with a staffer, you could also ask for her presence temporary (duration varies), with an /invite ozone (reviewed by staff). // 最好的方式是与工作人员讨论，你也可以请求她暂时出现（持续时间不定），通过 /invite ozone （由工作人员审核）。 /// But as invite notification can be missed, feel free to join #libera-bots and ask in there. // 但由于邀请通知可能会被忽略，请随意加入 #libera-bots 并在那里提问。 /// If opped in your channel you can ask Sigyn to unkline an user, /msg ozone unkline <nick>, you have a dozen minutes to do so after the kill/kline, it only works if the user was banned due to abuse detected in your channel. // 如果在你的频道中被禁言，你可以要求 Sigyn 解除某个用户的禁言， /msg ozone unkline <nick> ，在禁言/kill 之后你有一打时间（12 分钟）来这样做，这只有在用户是因为在你的频道中滥用而被禁言时才有效。"
[curite.src/gh]: https://github.com/Libera-Chat/curite.git "(MIT) (Languages: Rust 60.5%, HTML 39.5%) nickserv account verification URL bot // nickserv 账户验证 URL 机器人 /// curite /// Email verification web server for Atheme IRC services // Atheme IRC 服务的邮箱验证 Web 服务器 /// curite allows users to verify their email addresses by clicking a link in the verification email. It accepts HTTP requests over a Unix socket (which requires a reverse proxy to sit between it and the internet) and processes them using Atheme's XMLRPC interface. // curite 允许用户通过点击验证邮件中的链接来验证他们的邮箱地址。它通过 Unix 套接字接受 HTTP 请求（这需要在它和互联网之间放置一个反向智能体），并使用 Atheme 的 XMLRPC 接口来处理这些请求。"
[site.src/gh]: https://github.com/Libera-Chat/libera-chat.github.io.git "(CC-BY-NC-SA-4.0) (Languages: CSS 41.9%, HTML 29.7%, JavaScript 22.2%, Ruby 6.2%) The website of Libera Chat, providing documentation and news // Libera Chat 的网站，提供文档和新闻 /// Style guide // 风格指南 /// Content // 内容 /// - Use British English. Exceptions apply to content: // 使用英式英语。以下内容除外： /// - - copied verbatim from external sources (notably the LICENSE files); or // 直接从外部来源复制的内容（尤其是 LICENSE 文件）；或 /// - - that must comply with technical standards // 必须符合技术标准的内容 /// - Channel names, nicknames, channel modes, user modes, IRC verbs, and IRC commands should be escaped (as code), for example: /join #libera // 频道名称、昵称、频道模式、用户模式、IRC 动词和 IRC 命令应转义（作为代码），例如： /join #libera /// - Filenames will be the URL slug; use lowercase alphanumeric characters and no underscores // 文件名将是 URL 斜杠；使用小写字母数字字符，不使用下划线 /// - In examples, mark required arguments with <>, and optional arguments with [] // 在示例中，用 <> 标记必需参数，用 [] 标记可选参数 /// - Lines should be no longer than 78 characters, so that people in 80-column terminals can edit the text without their editor “paging over” horizontally when their cursor reaches the end of the line // 行长度不应超过 78 个字符，以便在 80 列终端中编辑文本时，当光标到达行尾时，编辑器不会水平“翻页” /// - Internal links must be root-relative // 内部链接必须是根相对的 /// Code // 代码 /// - Use 2 spaces of indentation in code // 代码中缩进使用 2 个空格 /// - Be mindful about making the site accessible to all users, including those with screen readers or text-only web browsers // 注意确保网站对所有用户均可访问，包括使用屏幕阅读器或纯文本网页浏览器的用户 /// - For CSS // 对于 CSS /// - - Prefer logical properties (for example, margin-inline-start rather than margin-left) // 优先使用逻辑属性（例如， margin-inline-start 而不是 margin-left ） /// - - In general, lengths should be defined in rem units // 一般来说，长度应该用 rem 单位定义 /// - - CSS that is absolutely necessary to generate the layout should go in the appropriate inlined CSS; other CSS should be loaded separately // 绝对必要的用于生成布局的 CSS 应该放在相应的内联 CSS 中；其他 CSS 应该单独加载 /// - For JS // 对于 JS /// - - You probably don't need JavaScript // 你可能不需要 JavaScript /// - - Format JS with standard.js // 使用 standard.js 格式化 JS /// - For HTML // 对于 HTML /// - - Prefer elements with semantic meaning (for example, <main>, <article>) // 优先使用具有语义意义的元素（例如， <main> ， <article> ）"
[chatapp.wui/.site]: https://web.libera.chat/ "Libera.Chat is the IRC network for free & open-source software and peer directed projects. // Libera.Chat 是一个基于自由和开源软件及对等指导项目的 IRC 网络。"
[mastodon]: https://fosstodon.org/@liberachat
[bluesky]: https://bsky.app/profile/libera.chat
[irc/librachat]: https://web.libera.chat/#libera

