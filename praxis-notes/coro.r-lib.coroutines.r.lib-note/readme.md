[src/gh]: https://github.com/r-lib/coro.git "(MIT) (Languages: R 100.0%) Coroutines for R // R 中的协程 /// coro implements coroutines for R, i.e. functions that can be suspended and resumed later on. There are two kinds: // coro 为 R 提供了协程实现，即可以在后续继续挂起和恢复的函数。协程有两种类型： /// - Async functions, which make it straightforward to program concurrently // 异步函数，可以方便地编程并发 /// - Generators for iterating over complex sequences // 生成器，用于迭代复杂序列 /// Supported features: // 支持的功能： /// - Suspending within loops and if/else branches // 在循环和 if/else 分支中挂起 /// - Suspending within tryCatch() // 在 tryCatch() 中挂起 /// - on.exit() expressions and stack-based cleanup such as provided by local_ functions in the withr package // on.exit() 表达式和基于栈的清理，例如 withr 包中 local_ 函数提供的 /// - Step-debugging and browser() within coroutines // 协程中的步进调试和 browser() 功能 /// Compatibility with: // 兼容性： /// - Python iterators from the reticulate (. gh:rstudio/reticulate.git) package // reticulate 包中的 Python 迭代器 /// - Async operations from the promises (. gh:rstudio/promises.git) package // promises 包中的异步操作 /// - Parallel computations from the future (. gh:HenrikBengtsson/future.git) package // 未来包中的并行计算 /// Async/await functions // 异步/等待函数 /// Concurrent programming is made straightforward by async-await functions. Whenever you are waiting for a result that may take a while (downloading a file, computing a value in an external process), use await(). The argument to await() must return a promise from the promises package. // 异步编程通过 async-await 函数变得简单。当你等待一个可能需要较长时间的结果时（例如下载文件、在外部进程中计算一个值），请使用 await() 。 await() 的参数必须从 promises 包中返回一个 Promise。 /// Concurrent code based on promises can quickly become hard to write and follow. In the following artificial example, we wait for a download to complete, then decide to launch a computation in an external process depending on a property of the downloaded data. We also handle some errors specifically. // 基于 Promise 的并发代码可能会很快变得难以编写和跟随。在以下人为的示例中，我们等待下载完成，然后决定在外部进程中启动一个依赖于下载数据属性的运算。我们还专门处理了一些错误。 /// Generators // 生成器 /// Generators are based on a simple iteration protocol: // 生成器基于一个简单的迭代协议： /// - Iterators are functions. // 迭代器是函数。 /// - They can be advanced by calling the function. The new value is returned. // 它们可以通过调用函数来推进。新的值将被返回。 /// - An exhausted iterator returns the sentinel symbol exhausted. // 一个耗尽的迭代器返回哨兵符号 exhausted 。 /// Coroutines are an abstraction for state machines in languages that support them. Conversely, you can implement coroutines by rewriting the code source provided by the user as a state machine. Pass internals = TRUE to the print methods of coroutines to reveal the state machine that is running under the hood: // 协程是一种支持它们的语言中的状态机抽象。相反，你可以通过将用户提供的代码源重写为状态机来实现协程。将 internals = TRUE 传递给协程的打印方法，以揭示底层运行的状态机： /// (: print(generate_abc, internals = TRUE)) /// Despite this transformation of source code, browser() and step-debugging still work as you would expect. This is because coro keeps track of the source references from the original code. // 尽管源代码发生了这种转换， browser() 和 step-debugging 仍然按预期工作。这是因为 coro 会跟踪原始代码中的源引用。 /// Acknowledgements // 致谢 /// - The regenerator (. gh:facebook/regenerator.git) Javascript package which uses a similar transformation to implement generators and async functions in older versions of Javascript. // 再生器 JavaScript 包，它使用类似的转换在旧版本的 JavaScript 中实现生成器和异步函数。 /// - Gabor Csardi for many interesting discussions about concurrency and the design of coro. // Gabor Csardi 关于并发和 coro 设计的许多有趣讨论。"
[site/r-lib.org]: https://coro.r-lib.org/ "Iterators // 迭代器 /// Generators are a simple way of creating iterator functions, i.e. functions that you can call to return a new value. The iteration protocol is described in ?iterator. Here is a simple iterator that iterates over the elements of 1:3: // 生成器是一种创建迭代器函数的简单方法，即你可以调用它们来返回一个新值的函数。迭代协议在 ?iterator 中描述。这里是一个简单的迭代器，它遍历 1:3 中的元素： /// (: iterator <- coro::as_iterator(1:3) ;: iterator() #>> 1 ;: iterator() #>> 2 ;: iterator() #>> 3 ;: iterator() #>> coro::exhausted() #> .__exhausted__.) /// In R we normally don’t use this sort of iteration to work with vectors. Instead, we use the idiomatic techniques of vectorised programming. Iterator functions are useful for very specific tasks: // 在 R 中，我们通常不使用这种迭代方式来处理向量。相反，我们使用向量化编程的惯用技巧。迭代器函数适用于非常特定的任务： /// - Iterating over chunks of data when the whole data doesn’t fit in memory. // 迭代内存中无法一次性容纳的数块数据。 /// - Generating sequences when you don’t know in advance how many elements you will need. These sequences may be complex and even infinite. // 在事先不知道需要多少元素的情况下生成序列。这些序列可能是复杂的，甚至是无限的。 /// The iterator protocol is designed to be free of dependency. However, the easiest way to create an iterator is by using the generator factories provided in this package. // 迭代器协议设计为无依赖性。然而，创建迭代器最简单的方法是使用本包提供的生成器工厂。 /// Generators // 生成器 /// Generators create functions that can yield, i.e. suspend themselves. When a generator reaches a yield(value) statement it returns the value as if you called return(value). However, calling the generator again resumes the function right where it left off. Because they preserve their state between invokations, generators are ideal for creating iterator functions. // 生成器创建可以产生（yield）的函数，即可以自行暂停。当生成器遇到 yield(value) 语句时，它会像调用 return(value) 一样返回值。然而，再次调用生成器会从它暂停的地方继续执行函数。由于它们在调用之间保留状态，生成器非常适合创建迭代器函数。 /// (: generate_abc <- coro::generator(function () { for (x in letters[1:3]) { coro::yield(x) } }) ;: abc = generate_abc() # Create the iterator ;: abc() #>> 'a' ;: abc() #>> 'b' ;: abc() #>> 'c' ;: abc() #>> coro::exhausted() #> .__exhausted__. ;: abc() #>> coro::exhausted() #> .__exhausted__.)"
[package/cran]: https://cran.r-project.org/web/packages/coro/ "(Version: 	1.1.0) (Depends: 	R (≥ 3.5.0)) (Imports: 	rlang (≥ 0.4.12)) (Suggests: 	knitr, later (≥ 1.1.0), magrittr (≥ 2.0.0), promises, reticulate, rmarkdown, testthat (≥ 3.0.0)) (Published: 	2024-11-05) (DOI: 	10.32614/CRAN.package.coro) (Author: 	Lionel Henry [aut, cre], Posit Software, PBC [cph, fnd]) (Maintainer: 	Lionel Henry <lionel at posit.co>) (License: 	MIT + file LICENSE) (NeedsCompilation: 	no) coro: 'Coroutines' for R // coro: R 中的 '协程' /// Provides 'coroutines' for R, a family of functions that can be suspended and resumed later on. This includes 'async' functions (which await) and generators (which yield). 'Async' functions are based on the concurrency framework of the 'promises' package. Generators are based on a dependency free iteration protocol defined in 'coro' and are compatible with iterators from the 'reticulate' package. // 为 R 提供 '协程' ，这是一系列可以在稍后暂停和恢复的函数。这包括 'async' 函数（会等待）和生成器（会产出）。 'Async' 函数基于 'promises' 包的并发框架。生成器基于 'coro' 中定义的无依赖迭代协议，并与 'reticulate' 包的迭代器兼容。 (src: gh:r-lib/coro.git)"
[knows_by]: https://simonpcouch.github.io/streamy/reference/stream.html "Arguments /// - generator ///: A coro::generator() function."
