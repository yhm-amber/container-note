[src/gh]: https://github.com/rayon-rs/rayon.git "(Apache-2.0, MIT) (Languages: Rust 99.9%, Shell 0.1%) Rayon: A data parallelism library for Rust // 嫘萦： Rust 的数据并行库"
[lib/crates]: https://crates.io/crates/rayon "(: cargo add -- rayon)"
[api/docsrs]: https://docs.rs/rayon/

[blog:intro]: https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/ "(: xs.iter().map(...).sum() --> xs.par_iter().map(...).sum()) (: join (|| work_a(), || work_b(), || work_c(), ...) // the work a, b, c *may* run in parallel) This approach of “potential parallelism” is, in fact, the key point of difference between Rayon’s approach and crossbeam’s scoped threads. Whereas in crossbeam, when you put two bits of work onto scoped threads, they will always execute concurrently with one another, calling join in Rayon does not necessarily imply that the code will execute in parallel. This not only makes for a simpler API, it can make for more efficient execution. This is because knowing when parallelism is profitable is difficult to predict in advance, and always requires a certain amount of global context: for example, does the computer have idle cores? What other parallel operations are happening right now? In fact, one of the main points of this post is to advocate for *potential parallelism* as the basis for Rust data parallelism libraries, in contrast to the *guaranteed concurrency* that we have seen thus far. // 这种“潜在并行性”的方法实际上是 Rayon 与 crossbeam 作用域线程的重要区别。在 crossbeam 中，当您将两位工作放到作用域线程上时，它们将始终彼此并发执行，而在 Rayon 中调用 join 并不一定意味着代码将并行执行。这不仅可以使 API 变得更简单，还可以提高执行效率。这是因为知道并行何时有利可图是很难提前预测的，并且总是需要一定量的全局上下文：例如，计算机是否有空闲核心？目前正在进行哪些其他并行操作？事实上，这篇文章的要点之一是提倡 *潜在并行性* 作为 Rust 数据并行库的基础，这与我们迄今为止看到的 *保证并发性* 形成鲜明对比。"

[knows-by]: https://blog.logrocket.com/go-vs-rust-when-use-rust-when-use-go/ "Rust vs. Go: Scalability // Rust 与 Go：可扩展性 /// Both Rust and Go are good at scaling up to take advantage of many CPUs to process data in parallel. In Go, you can use a goroutine to process each piece of data, and a WaitGroup to wait for them all to finish. In Rust, rayon is a useful crate that makes it easy to iterate over a container in parallel. // Rust 和 Go 都擅长扩展以利用许多 CPU 并行处理数据。在 Go 中，您可以使用 goroutine 来处理每条数据，并使用WaitGroup来等待它们全部完成。在 Rust 中， rayon是一个有用的 crate，可以轻松并行迭代容器。"
