[core.src/gh]: https://github.com/cozodb/cozo.git "(MPL-2.0) (Languages: Rust 97.4%, C++ 0.7%, C 0.6%, Shell 0.5%, JavaScript 0.3%, Swift 0.3%, Other 0.2%) A transactional, relational-graph-vector database that uses Datalog for query. The hippocampus for AI! // 一个使用 Datalog 进行查询的、事务性的关系图向量数据库。AI 的海马体！ /// ## Introduction // 介绍 /// CozoDB is a general-purpose, transactional, relational database that uses Datalog for query, is embeddable but can also handle huge amounts of data and concurrency, and focuses on graph data and algorithms. It supports time travel and it is performant! // CozoDB 是一个通用型、支持事务的、关系型数据库，使用 Datalog 进行查询，可嵌入但也能处理大量数据和并发，专注于图数据与算法。它支持时间旅行，并且性能优异！ /// ### What does embeddable mean here? // 这里的 embeddable 是什么意思？ /// A database is almost surely embedded if you can use it on a phone which never connects to any network (this situation is not as unusual as you might think). SQLite is embedded. MySQL/Postgres/Oracle are client-server. // 如果你可以在一个永远不会连接到任何网络的手机上使用某个数据库，那么这个数据库几乎肯定是嵌入式数据库（这种情况比你想象的要常见）。SQLite 是嵌入式数据库。MySQL/Postgres/Oracle 是客户端-服务器架构。 ///> A database is embedded if it runs in the same process as your main program. This is in contradistinction to client-server databases, where your program connects to a database server (maybe running on a separate machine) via a client library. Embedded databases generally require no setup and can be used in a much wider range of environments. // 一个数据库如果与你的主程序运行在同一个进程中，则称为嵌入式数据库。这与客户端-服务器数据库形成对比，在客户端-服务器数据库中，你的程序通过客户端库连接到数据库服务器（可能运行在不同的机器上）。嵌入式数据库通常无需设置，并且可以在更广泛的范围内使用。 ///> We say CozoDB is embeddable instead of embedded since you can also use it in client-server mode, which can make better use of server resources and allow much more concurrency than in embedded mode. // 我们称 CozoDB 是可嵌入的而不是嵌入式，因为你也可以在客户端-服务器模式下使用它，这可以更好地利用服务器资源，并允许比嵌入式模式下更高的并发性。 /// ### Why graphs? // 为什么使用图？ /// Because data are inherently interconnected. Most insights about data can only be obtained if you take this interconnectedness into account. // 因为数据本质上就是相互关联的。大多数关于数据的洞察只有在考虑这种关联性时才能获得。 ///> Most existing graph databases start by requiring you to shoehorn your data into the labelled-property graph model. We don't go this route because we think the traditional relational model is much easier to work with for storing data, much more versatile, and can deal with graph data just fine. Even more importantly, the most piercing insights about data usually come from graph structures implicit several levels deep in your data. The relational model, being an algebra, can deal with it just fine. The property graph model, not so much, since that model is not very composable. // 大多数现有的图数据库一开始就要求你将数据强行塞进标记属性图模型中。我们不走这条路，因为我们认为传统的关系模型在存储数据方面要容易得多，功能更强大，并且完全可以处理图数据。更重要的是，关于数据的最大洞察通常来自于数据中隐含的、多级深度的图结构。关系模型作为一种代数，完全可以处理这种情况。而属性图模型则不然，因为该模型的可组合性较差。 /// ### What is so cool about Datalog? // Datalog 有什么如此酷炫的地方？ /// Datalog can express all relational queries. Recursion in Datalog is much easier to express, much more powerful, and usually runs faster than in SQL. Datalog is also extremely composable: you can build your queries piece by piece. // Datalog 可以表达所有关系查询。Datalog 中的递归表达起来更加容易，功能更强大，通常比 SQL 运行得更快。Datalog 还具有极高的可组合性：你可以逐步构建你的查询。 ///> Recursion is especially important for graph queries. CozoDB's dialect of Datalog supercharges it even further by allowing recursion through a safe subset of aggregations, and by providing extremely efficient canned algorithms (such as PageRank) for the kinds of recursions frequently required in graph analysis. // 递归对于图查询尤为重要。CozoDB 的 Datalog 方言通过允许通过安全的聚合子集进行递归，并通过为图分析中经常需要的递归类型提供极其高效的预定义算法（例如 PageRank），进一步增强了其功能。 ///> As you learn Datalog, you will discover that the rules of Datalog are like functions in a programming language. Rules are composable, and decomposing a query into rules can make it clearer and more maintainable, with no loss in efficiency. This is unlike the monolithic approach taken by the SQL select-from-where in nested forms, which can sometimes read like golfing. // 在学习 Datalog 的过程中，你会发现 Datalog 的规则就像编程语言中的函数一样。规则是可以组合的，将查询分解为规则可以使它更清晰、更易于维护，而且不会损失效率。这与 SQL select-from-where 在嵌套形式中采用的模块化方法不同，后者有时看起来像是在打高尔夫球。 /// ### Time travel? // 时间旅行？ /// Time travel in the database setting means tracking changes to data over time and allowing queries to be logically executed at a point in time to get a historical view of the data. // 在数据库设置中，时间旅行意味着跟踪数据随时间的变化，并允许在某个时间点逻辑地执行查询以获取数据的歷史视图。 ///> In a sense, this makes your database immutable, since nothing is really deleted from the database ever. // 在某种程度上，这使得您的数据库不可变，因为数据库中实际上从未真正删除任何内容。 ///> In Cozo, instead of having all data automatically support time travel, we let you decide if you want the capability for each of your relation. Every extra functionality comes with its cost, and you don't want to pay the price if you don't use it. // 在 Cozo 中，我们不是让所有数据自动支持时间旅行，而是让您决定是否希望每个关系都具有此功能。每项额外的功能都有其代价，如果您不使用它，就不想支付这个代价。 ///> For the reason why you might want time travel for your data, we have written a short story. // 关于您可能希望为数据启用时间旅行的原因，我们已经写了一个短篇故事。"
[site/org]: https://cozodb.org/ "CozoDB: /// Hippocampus for AI, with Embedded Datalog // CozoDB：AI 的 hippocampus，具有嵌入式 Datalog /// A FOSS embeddable, transactional, relational-graph-vector database, // 一个自由软件嵌入式、事务性、关系图-向量数据库， /// across platforms and languages, with time travelling capability, // 跨平台和语言，具有时间旅行功能， /// perfect as the long-term memory for LLMs and AI. // 完美作为 LLMs 和 AI 的长期记忆。 /// Features // 特性 /// - Graph Traversals // 图遍历 ///: Dynamic Datalog-Driven Graph Traversals, Unraveling Complex Relationships and Patterns // 动态 Datalog 驱动图遍历，揭示复杂关系和模式 /// - Vector search // 向量搜索 ///: Graph-Integrated HNSW Indexing, Enhancing Datalog with Semantic Nearest Neighbor Queries and Insights // 图集成 HNSW 索引，通过语义最近邻查询和洞察增强 Datalog /// - Whole-Graph Algorithms // 全图算法 ///: Comprehensive Graph Analysis, with Efficient Implementation of Prepackaged Graph Algorithms // 全面的图分析，高效实现预打包图算法 /// - Time travelling // 时间旅行 ///: Make your data immutable if needed, run historical queries against a point-in-time snapshot // 如需，使数据不可变，对某个时间点的快照运行历史查询 /// - Deduplication // 去重 ///: Streamlined MinHash-LSH Indexing, Enhancing Datalog with Robust Data Deduplication and Similarity Detection // 精简的 MinHash-LSH 索引，增强 Datalog，实现强大的数据去重和相似性检测 /// - Full-Text Search // 全文搜索 ///: Advanced FTS Integration, Empowering Datalog with High-Performance Text Retrieval and Analysis // 高级全文搜索集成，赋予 Datalog 高性能文本检索与分析能力 /// - Embeddable & Multilingual // 可嵌入与多语言 ///: Universal, Powering Projects Everywhere with Seamless Integration across Devices and Programming Languages // 通用型，通过跨设备与编程语言的无缝集成，赋能各类项目 /// - Pure performance // 纯粹性能 ///: 100K QPS for OLTP queries, or 30 seconds for the PageRank of 32M edges, on your average laptop // 平均笔记本电脑上，支持 OLTP 查询的 100K QPS，或 32M 条边的 PageRank 计算只需 30 秒 /// - Transactional // 事务性 ///: Enforces snapshot isolation for all reads and writes, and custom constraints set by triggers // 对所有读和写强制实现快照隔离，以及触发器设置的约束条件"
[demo-wasm.wui/.site]: https://cozodb.org/wasm-demo/ "Browser Demo"
[docs/.site]: https://docs.cozodb.org "Welcome to the documentation for CozoDB, a feature-rich, transactional, time-travel-enabled, relational-graph-vector database that uses Datalog for queries, while making no performance compromises. // 欢迎来到 CozoDB 的文档，CozoDB 是一个功能丰富、支持事务、支持时间旅行、关系图向量数据库，使用 Datalog 进行查询，同时不牺牲性能。"
[lib-rs.cargo/crates]: https://crates.io/crates/cozo "(: cargo add -- cozo) (MPL-2.0) (58K SLoC) (327 KiB) A general-purpose, transactional, relational database that uses Datalog and focuses on graph data and algorithms // 一个通用的事务性关系型数据库，使用 Datalog，专注于图数据与算法 /// This crate contains the implementation proper of CozoDB. // 这个包包含了 CozoDB 的实际实现。 (src: gh:cozodb/cozo.git)"
[lib-py.src/gh]: https://github.com/cozodb/pycozo.git "(MPL-2.0) (Languages: Python 100%) The Python client and Jupyter helper for CozoDB // CozoDB 的 Python 客户端和 Jupyter 辅助工具 /// (: from pycozo.client import Client ;: ...) (: client = Client() # In-memory database // 内存数据库) (: client = Client('sqlite','file.db') # SQLite-backed (lightweight persistent storage) // SQLite 后端（轻量级持久化存储）) (: client = Client('rocksdb','file.db') # RocksDB-backed (highly concurrent persistent storage) // RocksDB 后端（高度并发持久化存储）) (: client = Client('http', options={'host': 'http://127.0.0.1:9070'}) # Connecting to a standalone server // 连接到独立服务器) (: client = Client('http', options={'host': ..., 'auth': ...}) # If the address is not a loopback address, you also need to provide the auth string // 如果地址不是回环地址，您还需要提供认证字符串) (: ... ;: client.close() # After you are done with a client, you need to explicitly close it // 使用完客户端后，你需要显式地关闭它)"
[lib-py.pip/pypi]: https://pypi.org/project/pycozo/ "(: pip install -- pycozo[embedded,requests,pandas]) (License: MPL-2.0) Python client for the Cozo database // Cozo 数据库的 Python 客户端 /// To be useful, you must specify either the embedded option, which enables using CozoDB in the embedded mode, or the requests option, which enables using CozoDB through the HTTP API. The pandas option installs pandas as a dependency and allows optional auto-conversion of output relations to Pandas dataframes. You should specify pandas if you use the Jupyter helper. // 为了使其有用，你必须指定 embedded 选项，该选项启用嵌入式模式下的 CozoDB 使用，或者指定 requests 选项，该选项启用通过 HTTP API 使用 CozoDB。 pandas 选项将 pandas 作为依赖项安装，并允许输出关系到 Pandas 数据框的可选自动转换。如果你使用 Jupyter 辅助工具，你应该指定 pandas 。"
[lib-clj.src/gh]: https://github.com/cozodb/cozo-clj.git "(MIT) (Languages: Clojure 100.0%) Clojure bindings for CozoDb /// (: (in-ns 'cozo-clj.core) (def db (open-db)) (println (query db \"?[] <- [[1,2,3]]\")) (close db))"
[lib-clj.mvn/mvnrepository]: https://mvnrepository.com/artifact/io.github.cozodb/cozo-clj '(: [io.github.cozodb/cozo-clj "0.7.5"]) CozoDb Clojure bindings (src: gh:cozodb/cozo.git)'
[lib-nodejs.npm/npmjs]: https://npmjs.com/package/cozo-node "(: npm i --save -- cozo-node) (License: MIT) (Unpacked Size: 12.4 kB) (Total Files: 4) Embedded CozoDB for NodeJS (src: gh:cozodb/cozo.git@main/cozo-lib-nodejs)"

