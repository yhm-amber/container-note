
文件系统和数据库一样，都只是映射出了一些方便的接口，然后允许用户通过它们直接以规定好的信息存放形式来存放自己需要存放的数据。

你看到 PG 数据库不可读的数据文件，从架构层次来说，它应当是与硬盘上数据的实际形态出于同一个架构层次的，即便在这里它也已经是一个文件了。

题外话：有没有什么办法可以把 OCI 程序变为 NIF ？即为 NIF 增加 OCI 格式的支持？

# EatBox

标志：怪物箱

## DataBox

逻辑上的数据实体。

一个实体拥有其特定的切片规则和形态类型。


### 形态 (不同种类的对象)

一般数据对象：

- ByteStream (File) (由读取者决定如何解析内容的数据。可定义其格式规则从而能够在工作簿形态提供工作簿接口。
- StructsStream (Tables) (由元数据决定如何解析内容即其格式规则的数据。在字节流形态支持 xls 等格式的工作簿文件接口。底层可以基于 Lisp 的结构实现，也可以实现实时的 Lisp 格式的字节流接口。


这两种数据对象的形态默认不互通，可以指定互通方式。

它们的底层不同。工作簿是结构化数据，文件是非结构化，可以为文件定义结构化形态时的解析规则、也可以为工作簿指定文件就读取时的格式。

读取时会被告知它原本的形态，在文件形态视角下结构序列数据要被标识为特殊形态的文件、在结构序列形态视角下文件数据要被标志为非结构形态的工作簿。

还有一种：

- Rules (Formats) (定义规则的方式。

它是结构化的配置信息存储类型。比如能够用于规定上面两种形态的观察（访问）视角下如何决定另一种形态的被观察方式。

所有的代码意义的内容也都可以在该形态存储。如何解析代码的规则也可以在此处存储。

它在文件视角下，可以选择格式化的规则来显示为字符流。在工作簿视角下，可以以 AST 的形式来显示其有结构的数据。

也可以把合乎格式要求的文本或者工作簿，按照该格式要求映射为规则链接 (View) ，从而使得规则实际以另外两种形态被存储。

原初规则对象不可以删除，允许便捷地回退。其中记录了关于切片规则集合的目录位置的配置。

组织：

- NameSpace (Dir) (类似于数据库里的数据库或者文件系统里的目录内部记录特定对象名并对应其唯一的 BoxID 。它是一种特殊的 Tables 对象（或者基于它实现 ……）。一个 DataBox 允许被记录在多处。在文件视角下是目录，在工作簿视角下是库，在规则集视角下随便叫什么，总之这三个东西都叫命名空间或目录。
- Link (Softlink) (软链接。即文件下的软链接文件、工作簿下的 View 、规则视角下的规则链接。链接不根据其它访问方式访问其指向对象，而是根据对象 ID 。链接绑定规则，从而决定在以某种视角观察该链接时，按照何种规则来决定观察效果。

它们是特殊的数据对象，没有自己的视角。

从名称向唯一 ID 应当有直接的映射，从唯一 ID 到所有名称（即访问途径）也应当由直接的映射。这个需要考虑怎么实现。




### Splits

有默认切片规则集合。

也可自定义切片规则集合：通过各种接口导入。即不论通过各种方式，将 Rule 数据对象（或其链接）存入指定的切片规则路径。

每个切片都有基于 BoxID 的标识，它的每个副本也都有各自的标识。

（需要研究一下 MinIO 怎么存元数据从而可以无头即去中心化的。）




### Nodes

节点用 AteBox 程序实现，该程序初步支持用 Elixir/Erlang/Lunatic 实现。

这是个语言实体，要避免对特定语言的依赖。节点需要一些功能，而只要运行时或者需要具备该功能，就可以充当实现节点的方式。

