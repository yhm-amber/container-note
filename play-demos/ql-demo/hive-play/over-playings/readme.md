## 取得上一条的某字段

ref: https://www.cnblogs.com/erlou96/p/13590358.html  

使用 `LAG () OVER ()` 。

我们有这样一张表：

~~~
+--------------+------------+-------------+
| player_name  | point_get  |  play_time  |
+--------------+------------+-------------+
| a            | 1          | 1656604801  |
| b            | 4          | 1656604803  |
| c            | 1          | 1656604802  |
| a            | 3          | 1656604807  |
| a            | 2          | 1656604808  |
| c            | 3          | 1656604800  |
| b            | 7          | 1656604804  |
| a            | 1          | 1656604801  |
| b            | 9          | 1656604805  |
| c            | 2          | 1656604810  |
+--------------+------------+-------------+
~~~

生成产生它的代码的方式之一：

~~~ sh
echo '

    a 1 1656604801
    b 4 1656604803
    c 1 1656604802
    a 3 1656604807
    a 2 1656604808
    c 3 1656604800
    b 7 1656604804
    a 1 1656604801
    b 9 1656604805
    c 2 1656604810
    
    ' |
    
    xargs -i -- echo "'\"{}\"'" |
    tr ' ' '|' | xargs | tr ' ' ',' |
    
    awk '{print"    "$0}BEGIN{print"select explode (array ("}END{print") ) col"}' |
    awk '{print"    "$0}BEGIN{print"select split(x.col,\"\\\\|\") s from";print"("}END{print") x"}' |
    awk '{print"    "$0}BEGIN{print"select p.s[0] player_name, p.s[1] point_get, p.s[2] play_time from";print"("}END{print") p"}'
~~~

上面会给你打印一条 sql 。你可以在任何 hive 的 `beeline` 中执行（它是无状态的），你也可以把它作为子查询使用：

~~~~ sql
select player_name
, point_get, play_time
, lag
(
    array(point_get,play_time) ,
    1 , array(NULL,NULL) ) over
(
    partition by player_name
    order by point_get asc ) pre

from
(
    select p.s[0] player_name, p.s[1] point_get, p.s[2] play_time
    from
    (
        select split(x.col,"\\|") s
        from
        (
            select explode (array
            (
                "a|1|1656604801" ,
                "b|4|1656604803" ,
                "c|1|1656604802" ,
                "a|3|1656604807" ,
                "a|2|1656604808" ,
                "c|3|1656604800" ,
                "b|7|1656604804" ,
                "a|1|1656604801" ,
                "b|9|1656604805" ,
                "c|2|1656604810" ) ) col
        ) x
    ) p
) source ;
~~~~

执行结果：

~~~
+--------------+------------+-------------+---------------------+
| player_name  | point_get  |  play_time  |         pre         |
+--------------+------------+-------------+---------------------+
| a            | 1          | 1656604801  | [null,null]         |
| a            | 1          | 1656604801  | ["1","1656604801"]  |
| a            | 2          | 1656604808  | ["1","1656604801"]  |
| a            | 3          | 1656604807  | ["2","1656604808"]  |
| b            | 4          | 1656604803  | [null,null]         |
| b            | 7          | 1656604804  | ["4","1656604803"]  |
| b            | 9          | 1656604805  | ["7","1656604804"]  |
| c            | 1          | 1656604802  | [null,null]         |
| c            | 2          | 1656604810  | ["1","1656604802"]  |
| c            | 3          | 1656604800  | ["2","1656604810"]  |
+--------------+------------+-------------+---------------------+
~~~

逻辑：在按 `player_name` 分组时、取按照 `play_time` 正序排序时的 `本条的前一条` ，作为本条对应的字段 `pre` 中的内容。

关键的部位：

~~~ sql
, lag
(
    array(point_get,play_time) ,
    1,array(NULL,NULL) ) over
(
    partition by player_name
    order by point_get desc ) pre
~~~

这里：

- 在 `lag ()` 的括号中要指定的，有三方面的事：
  
  1. 最终会被填写在 `pre` 的值，要以什么样的表达式算出。
  2. 表示 `前几行` 的 `lag` ，这个位置写 `1` ，那就是取 `前一行` 的意思。
  3. 如果对当前行而言，被指定的 `前几行` 不存在，那么在当前行这个字段，填个啥。
  
  要取 `后几行` 则要用 `lead` ，参数位置和 `lag` 一样。
  
- 在 `over ()` 的括号中要指定的，在此处有两方面的事：上面的 `lag` 的 `前几行` ，究竟是在一个怎样的分组和排序前提下的 `前几行` 。

## 取得每个连续序列中的聚合值

聚合值可以是最大最小值。

比如：

- 有字段: 客户ID,登录日期
- 有需求: 统计客户连续登录天数和每次连续登录的最早日期

### 思路

- **什么是连续日期？**
- **就是说，这样的一组日期中每一个都是刚好差一天。**

那就简单了。只要能弄一个数字的递增序列字段，再用要作为评判连续与否所依据的那个日期字段、减去这个字段，得到的新字段就是分组依据。



问题就转变为了像这样用一次子查询来增加一个字段。它可以用开窗函数取得，以用户分区、以日期正序排序，来生成序号。最终，同分区内要有这样的对应关系：

~~~~
2020-01-01 对应新字段为 1
2020-01-02 对应新字段为 2
2020-01-04 对应新字段为 3
~~~~

如果是相同的日期应该对应相同的序号数字。

然后，用 `date_sub` 让当前日期减去序号（可以直接嵌套计算也可以多弄一个子查询），得到一个具有特殊意义的日期值，这个差出来的日期值如果相同，就说明是连续登录。

如果想求每次连续登录的最早日期，就用用户和这个差值结果分组（这需要把上面的结果当子查询），然后用求最小值的聚合函数作总于除了它俩外的剩下的字段（除了它俩应该只剩下从原始数据一直继承下来的那个日期字段了），那就是你要的结果。

那个 `date_sub` 出来的差值结果本身没有什么意义，它只是可以当做给每一坨连续打上的唯一标识，仅此而已。

### 代码

（暂略）


## 排序后有字段连续重复的条目之分组

### 描述

数据：有一个类型字段 T 一个数值字段 N 。  
目的：实现连续项去重，即每组中只取一条即可。  

思路：让每一预计只取一条的部分都能够有依据各自成为分区，然后就可以在每个分区中操作。  
需求：按照数值字段排序后，将类型字段中**连续**相同的条目归纳为一组。  

方案：很简单。先依据 N 排序，然后加一个字段：当 T 本条和上一条一样时设为 0 否则为 1 ，然后再用类似 scan 的逻辑得到该字段的聚合字段。那么，它就是分组依据了。  
关键： SQL 里的 scan 没有在 FP HOF 里那么优雅： `sum(laged_res) over (order by N rows between unbounded preceding and current row)` 。其中的 `rows between unbounded preceding and current row` 似乎是默认的所以可以不写，它用于指定开窗范围。

### 流程

`acc` :

| T | N |
| --- | --- |
| "A" | 101 |
| "B" | 102 |
| "A" | 104 |
| "B" | 106 |
| "A" | 110 |
| "A" | 111 |
| "B" | 112 |
| "B" | 114 |
| "B" | 115 |
| "A" | 120 |
| "A" | 121 |
| "B" | 122 |

~~~ sql
select T, N, IF( (T = lag(T) over (order by N) ), 0, 1) as pQ from acc;

-- （分组内）本条与（排序 N）的上条 T 相同则本条标记 0 否则 1
~~~

`acc` :

| T | N | pQ | 
| --- | --- | --- |
| "A" | 101 | 1 |
| "B" | 102 | 1 |
| "A" | 104 | 1 |
| "B" | 106 | 1 |
| "A" | 110 | 1 |
| "A" | 111 | 0 |
| "B" | 112 | 1 |
| "B" | 114 | 0 |
| "B" | 115 | 0 |
| "A" | 120 | 1 |
| "A" | 121 | 0 |
| "B" | 122 | 1 |

~~~ sql
select T, N, sum(pQ) over (order by N rows between unbounded preceding and current row) as Q from acc;

-- 以 scan 逻辑（开始行到本行的聚合）聚合 0 1 标记的字段得到应有行号 Q
~~~

`acc` :

| T | N | Q | 
| --- | --- | --- |
| "A" | 101 | 1 |
| "B" | 102 | 2 |
| "A" | 104 | 3 |
| "B" | 106 | 4 |
| "A" | 110 | 5 |
| "A" | 111 | 5 |
| "B" | 112 | 6 |
| "B" | 114 | 6 |
| "B" | 115 | 6 |
| "A" | 120 | 7 |
| "A" | 121 | 7 |
| "B" | 122 | 8 |

到这里，分区就得到了。

整理所有 SQL ：

~~~ sql
( select T, N, sum(pQ) over (order by N rows between unbounded preceding and current row) as Q from

( select T, N, IF( (T = lag(T) over (order by N) ), 0, 1) as pQ from table ) ) as t
~~~

即：

~~~ sql
( select T, N, sum(IF( (T = lag(T) over (order by N) ), 0, 1)) over (order by N rows between unbounded preceding and current row) as Q from table )
~~~

接下来就可以用来标记序号或者直接取出了。

可以在每 Q 组内按照 N 字段取最大或最小值。

简例：直接取得每个分区的最小值：

~~~ sql
select T, min(N) as N, Q from t group by T, Q order by N ;
~~~

| T | N | Q | 
| --- | --- | --- |
| "A" | 101 | 1 |
| "B" | 102 | 2 |
| "A" | 104 | 3 |
| "B" | 106 | 4 |
| "A" | 110 | 5 |
| "B" | 112 | 6 |
| "A" | 120 | 7 |
| "B" | 122 | 8 |

问题解决。

通用例：标记序号：

~~~ sql
select T, N, row_number() over (partition by T, Q order by N) as R from t ;
~~~

| T | N | R | 
| --- | --- | --- |
| "A" | 101 | 1 |
| "B" | 102 | 1 |
| "A" | 104 | 1 |
| "B" | 106 | 1 |
| "A" | 110 | 1 |
| "A" | 111 | 2 |
| "B" | 112 | 1 |
| "B" | 114 | 2 |
| "B" | 115 | 3 |
| "A" | 120 | 1 |
| "A" | 121 | 2 |
| "B" | 122 | 1 |

*这（只是比较明显一些地）意味着你可以比较随意地在去重中拿到你想要的那个而已。 :P*


